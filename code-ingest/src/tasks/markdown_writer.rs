//! Markdown task list writer for generating Kiro-compatible task files
//! 
//! This module provides functionality for writing hierarchical task structures
//! to markdown files with proper formatting, checkbox syntax, and content references.

use crate::error::{TaskError, TaskResult};
use crate::tasks::models::{ContentFileType, GenerationConfig};
use crate::tasks::task_structure_builder::{
    EnhancedTask, TaskStructure, PromptReference,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use tokio::fs;

/// Configuration for markdown generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarkdownConfig {
    /// Whether to include metadata section
    pub include_metadata: bool,
    /// Whether to include task overview
    pub include_overview: bool,
    /// Whether to include execution instructions
    pub include_instructions: bool,
    /// Indentation string for nested tasks
    pub indent_string: String,
    /// Maximum description length before truncation
    pub max_description_length: Option<usize>,
    /// Whether to include content file details
    pub include_content_details: bool,
    /// Whether to include prompt references
    pub include_prompt_references: bool,
    /// Custom header template
    pub header_template: Option<String>,
    /// Custom footer template
    pub footer_template: Option<String>,
}

impl Default for MarkdownConfig {
    fn default() -> Self {
        Self {
            include_metadata: true,
            include_overview: true,
            include_instructions: true,
            indent_string: "  ".to_string(), // 2 spaces
            max_description_length: None,
            include_content_details: true,
            include_prompt_references: true,
            header_template: None,
            footer_template: None,
        }
    }
}

impl MarkdownConfig {
    /// Create a minimal configuration for simple task lists
    pub fn minimal() -> Self {
        Self {
            include_metadata: false,
            include_overview: false,
            include_instructions: false,
            indent_string: "  ".to_string(),
            max_description_length: Some(100),
            include_content_details: false,
            include_prompt_references: false,
            header_template: None,
            footer_template: None,
        }
    }

    /// Create a detailed configuration for comprehensive task lists
    pub fn detailed() -> Self {
        Self {
            include_metadata: true,
            include_overview: true,
            include_instructions: true,
            indent_string: "  ".to_string(),
            max_description_length: None,
            include_content_details: true,
            include_prompt_references: true,
            header_template: Some("# {title}\n\nGenerated on {date}\n\n".to_string()),
            footer_template: Some("\n---\n\n*Generated by code-ingest task generator*\n".to_string()),
        }
    }
}

/// Markdown task list writer
pub struct MarkdownWriter {
    /// Configuration for markdown generation
    config: MarkdownConfig,
    /// Generation configuration from the task system
    generation_config: Option<GenerationConfig>,
}

impl MarkdownWriter {
    /// Create a new markdown writer with default configuration
    pub fn new() -> Self {
        Self {
            config: MarkdownConfig::default(),
            generation_config: None,
        }
    }

    /// Create a markdown writer with custom configuration
    pub fn with_config(config: MarkdownConfig) -> Self {
        Self {
            config,
            generation_config: None,
        }
    }

    /// Set the generation configuration
    pub fn with_generation_config(mut self, generation_config: GenerationConfig) -> Self {
        self.generation_config = Some(generation_config);
        self
    }

    /// Write a task structure to a markdown file
    pub async fn write_task_structure(
        &self,
        task_structure: &TaskStructure,
        output_path: &Path,
    ) -> TaskResult<()> {
        let markdown_content = self.generate_markdown(task_structure)?;
        
        // Ensure parent directory exists
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent).await.map_err(|e| {
                TaskError::TaskFileCreationFailed {
                    path: output_path.to_string_lossy().to_string(),
                    cause: format!("Failed to create parent directory: {}", e),
                    suggestion: "Check directory permissions and available disk space".to_string(),
                    source: Some(Box::new(e)),
                }
            })?;
        }

        // Write the markdown content to file
        fs::write(output_path, markdown_content).await.map_err(|e| {
            TaskError::TaskFileCreationFailed {
                path: output_path.to_string_lossy().to_string(),
                cause: e.to_string(),
                suggestion: "Check file permissions and available disk space".to_string(),
                source: Some(Box::new(e)),
            }
        })?;

        Ok(())
    }

    /// Generate markdown content from a task structure
    pub fn generate_markdown(&self, task_structure: &TaskStructure) -> TaskResult<String> {
        let mut markdown = String::new();

        // Add header
        self.add_header(&mut markdown, task_structure)?;

        // Add metadata section
        if self.config.include_metadata {
            self.add_metadata_section(&mut markdown, task_structure)?;
        }

        // Add task overview
        if self.config.include_overview {
            self.add_overview_section(&mut markdown, task_structure)?;
        }

        // Add main task content
        self.add_tasks_section(&mut markdown, task_structure)?;

        // Add execution instructions
        if self.config.include_instructions {
            self.add_instructions_section(&mut markdown, task_structure)?;
        }

        // Add footer
        self.add_footer(&mut markdown, task_structure)?;

        Ok(markdown)
    }

    /// Add header to the markdown
    fn add_header(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        if let Some(template) = &self.config.header_template {
            let header = self.apply_template(template, task_structure)?;
            markdown.push_str(&header);
        } else {
            // Default header
            markdown.push_str(&format!("# {} Task List\n\n", task_structure.table_name));
        }
        Ok(())
    }

    /// Add metadata section to the markdown
    fn add_metadata_section(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        markdown.push_str("## Metadata\n\n");
        
        markdown.push_str(&format!("- **Table Name**: `{}`\n", task_structure.table_name));
        markdown.push_str(&format!("- **Levels**: {}\n", task_structure.levels));
        markdown.push_str(&format!("- **Groups per Level**: {}\n", task_structure.groups_per_level));
        markdown.push_str(&format!("- **Generated**: {}\n", task_structure.metadata.created_at.format("%Y-%m-%d %H:%M:%S UTC")));
        
        if let Some(gen_config) = &task_structure.generation_config {
            if let Some(prompt_file) = &gen_config.prompt_file {
                markdown.push_str(&format!("- **Prompt File**: `{}`\n", prompt_file.display()));
            }
            markdown.push_str(&format!("- **Output Directory**: `{}`\n", gen_config.output_dir.display()));
            markdown.push_str(&format!("- **Work Area**: `{}`\n", gen_config.work_area_dir.display()));
        }
        
        markdown.push_str("\n");
        Ok(())
    }

    /// Add overview section to the markdown
    fn add_overview_section(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        let stats = task_structure.statistics();
        
        markdown.push_str("## Overview\n\n");
        markdown.push_str(&format!("This task list contains {} tasks organized in a hierarchical structure.\n\n", stats.total_tasks));
        
        markdown.push_str("### Task Distribution\n\n");
        markdown.push_str(&format!("- **Total Tasks**: {}\n", stats.total_tasks));
        markdown.push_str(&format!("- **Leaf Tasks**: {} (tasks with actual work)\n", stats.leaf_tasks));
        markdown.push_str(&format!("- **Branch Tasks**: {} (organizational tasks)\n", stats.branch_tasks));
        
        if stats.total_content_files > 0 {
            markdown.push_str(&format!("- **Content Files**: {}\n", stats.total_content_files));
        }
        
        if stats.tasks_with_prompts > 0 {
            markdown.push_str(&format!("- **Tasks with Prompts**: {}\n", stats.tasks_with_prompts));
        }
        
        markdown.push_str("\n");
        Ok(())
    }

    /// Add main tasks section to the markdown
    fn add_tasks_section(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        markdown.push_str("## Tasks\n\n");
        
        for root_task in &task_structure.root_tasks {
            self.add_task_to_markdown(markdown, root_task, 0)?;
        }
        
        Ok(())
    }

    /// Add a single task to the markdown with proper indentation and formatting
    fn add_task_to_markdown(&self, markdown: &mut String, task: &EnhancedTask, depth: usize) -> TaskResult<()> {
        let indent = self.config.indent_string.repeat(depth);
        
        // Task checkbox and description
        let description = if let Some(max_len) = self.config.max_description_length {
            if task.base_task.description.len() > max_len {
                format!("{}...", &task.base_task.description[..max_len])
            } else {
                task.base_task.description.clone()
            }
        } else {
            task.base_task.description.clone()
        };
        
        markdown.push_str(&format!("{}* [ ] {} {}\n", indent, task.base_task.task_number, description));
        
        // Add task details as sub-bullets
        self.add_task_details(markdown, task, depth + 1)?;
        
        // Add subtasks recursively
        for subtask in &task.enhanced_subtasks {
            self.add_task_to_markdown(markdown, subtask, depth + 1)?;
        }
        
        // Add spacing after root-level tasks
        if depth == 0 {
            markdown.push('\n');
        }
        
        Ok(())
    }

    /// Add task details as sub-bullets
    fn add_task_details(&self, markdown: &mut String, task: &EnhancedTask, depth: usize) -> TaskResult<()> {
        let indent = self.config.indent_string.repeat(depth);
        
        // Add content files if enabled and available
        if self.config.include_content_details && !task.content_files.is_empty() {
            self.add_content_files_details(markdown, task, &indent)?;
        }
        
        // Add prompt reference if enabled and available
        if self.config.include_prompt_references {
            if let Some(prompt_ref) = &task.prompt_reference {
                self.add_prompt_reference_details(markdown, prompt_ref, &indent)?;
            }
        }
        
        // Add output file if available
        if let Some(output_file) = &task.output_file {
            markdown.push_str(&format!("{}* **Output**: `{}`\n", indent, output_file.display()));
        }
        
        // Add metadata if available
        if !task.metadata.is_empty() {
            self.add_metadata_details(markdown, task, &indent)?;
        }
        
        Ok(())
    }

    /// Add content files details to the markdown
    fn add_content_files_details(&self, markdown: &mut String, task: &EnhancedTask, indent: &str) -> TaskResult<()> {
        // Group content files by type for better organization
        let content_files = task.get_content_files_by_type(&ContentFileType::Content);
        let l1_files = task.get_content_files_by_type(&ContentFileType::L1Context);
        let l2_files = task.get_content_files_by_type(&ContentFileType::L2Context);
        
        if !content_files.is_empty() || !l1_files.is_empty() || !l2_files.is_empty() {
            markdown.push_str(&format!("{}* **Content**:\n", indent));
            
            // Primary content files (A)
            for content_file in content_files {
                markdown.push_str(&format!("{}  * {} ({}): `{}`\n", 
                    indent, 
                    content_file.role, 
                    content_file.file_type.display_name(),
                    content_file.file_path.display()
                ));
            }
            
            // L1 context files (B)
            for l1_file in l1_files {
                markdown.push_str(&format!("{}  * {} ({}): `{}`\n", 
                    indent, 
                    l1_file.role, 
                    l1_file.file_type.display_name(),
                    l1_file.file_path.display()
                ));
            }
            
            // L2 context files (C)
            for l2_file in l2_files {
                markdown.push_str(&format!("{}  * {} ({}): `{}`\n", 
                    indent, 
                    l2_file.role, 
                    l2_file.file_type.display_name(),
                    l2_file.file_path.display()
                ));
            }
        }
        
        Ok(())
    }

    /// Add prompt reference details to the markdown
    fn add_prompt_reference_details(&self, markdown: &mut String, prompt_ref: &PromptReference, indent: &str) -> TaskResult<()> {
        markdown.push_str(&format!("{}* **Prompt**: `{}`\n", indent, prompt_ref.file_path.display()));
        
        if !prompt_ref.description.is_empty() {
            markdown.push_str(&format!("{}  * {}\n", indent, prompt_ref.description));
        }
        
        // Add prompt variables if any
        if !prompt_ref.variables.is_empty() {
            markdown.push_str(&format!("{}  * Variables:\n", indent));
            for (key, value) in &prompt_ref.variables {
                markdown.push_str(&format!("{}    * `{}`: {}\n", indent, key, value));
            }
        }
        
        Ok(())
    }

    /// Add metadata details to the markdown
    fn add_metadata_details(&self, markdown: &mut String, task: &EnhancedTask, indent: &str) -> TaskResult<()> {
        // Only show relevant metadata, not all internal details
        let relevant_keys = ["source_file", "file_extension", "line_count"];
        let relevant_metadata: HashMap<_, _> = task.metadata
            .iter()
            .filter(|(key, _)| relevant_keys.contains(&key.as_str()))
            .collect();
        
        if !relevant_metadata.is_empty() {
            for (key, value) in relevant_metadata {
                let display_key = match key.as_str() {
                    "source_file" => "File",
                    "file_extension" => "Type",
                    "line_count" => "Lines",
                    _ => key,
                };
                markdown.push_str(&format!("{}* **{}**: {}\n", indent, display_key, value));
            }
        }
        
        Ok(())
    }

    /// Add execution instructions section to the markdown
    fn add_instructions_section(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        markdown.push_str("## Execution Instructions\n\n");
        
        markdown.push_str("### How to Use This Task List\n\n");
        markdown.push_str("1. **Sequential Execution**: Work through tasks in the order they appear\n");
        markdown.push_str("2. **Hierarchical Structure**: Complete all subtasks before marking parent tasks as done\n");
        markdown.push_str("3. **Content Files**: Each task references specific content files (A, B, C) for analysis\n");
        markdown.push_str("4. **Output Files**: Results should be saved to the specified output paths\n\n");
        
        if let Some(gen_config) = &task_structure.generation_config {
            markdown.push_str("### File Locations\n\n");
            markdown.push_str(&format!("- **Content Files**: `{}`\n", gen_config.output_dir.display()));
            markdown.push_str(&format!("- **Output Files**: `{}`\n", gen_config.work_area_dir.display()));
            
            if let Some(prompt_file) = &gen_config.prompt_file {
                markdown.push_str(&format!("- **Analysis Prompt**: `{}`\n", prompt_file.display()));
            }
            
            markdown.push_str("\n");
        }
        
        markdown.push_str("### Analysis Workflow\n\n");
        markdown.push_str("For each task with content files:\n\n");
        markdown.push_str("1. Read the **A** file (primary content)\n");
        markdown.push_str("2. Review the **B** file (L1 context) for surrounding context\n");
        markdown.push_str("3. Examine the **C** file (L2 context) for broader context\n");
        markdown.push_str("4. Apply the analysis prompt to extract insights\n");
        markdown.push_str("5. Document findings in the specified output file\n\n");
        
        Ok(())
    }

    /// Add footer to the markdown
    fn add_footer(&self, markdown: &mut String, task_structure: &TaskStructure) -> TaskResult<()> {
        if let Some(template) = &self.config.footer_template {
            let footer = self.apply_template(template, task_structure)?;
            markdown.push_str(&footer);
        } else {
            // Default footer
            markdown.push_str("---\n\n");
            markdown.push_str(&format!("*Task list generated from table `{}` with {} total tasks*\n", 
                task_structure.table_name, 
                task_structure.statistics().total_tasks
            ));
        }
        Ok(())
    }

    /// Apply template variables to a template string
    fn apply_template(&self, template: &str, task_structure: &TaskStructure) -> TaskResult<String> {
        let mut result = template.to_string();
        
        // Replace common template variables
        result = result.replace("{title}", &format!("{} Tasks", task_structure.table_name));
        result = result.replace("{table_name}", &task_structure.table_name);
        result = result.replace("{date}", &chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string());
        result = result.replace("{total_tasks}", &task_structure.statistics().total_tasks.to_string());
        result = result.replace("{levels}", &task_structure.levels.to_string());
        result = result.replace("{groups}", &task_structure.groups_per_level.to_string());
        
        Ok(result)
    }
}

impl Default for MarkdownWriter {
    fn default() -> Self {
        Self::new()
    }
}

/// Utility functions for markdown formatting
pub struct MarkdownUtils;

impl MarkdownUtils {
    /// Escape markdown special characters in text
    pub fn escape_markdown(text: &str) -> String {
        text.replace('*', r"\*")
            .replace('_', r"\_")
            .replace('[', r"\[")
            .replace(']', r"\]")
            .replace('`', r"\`")
            .replace('#', r"\#")
    }

    /// Create a markdown link
    pub fn create_link(text: &str, url: &str) -> String {
        format!("[{}]({})", Self::escape_markdown(text), url)
    }

    /// Create a markdown code block
    pub fn create_code_block(code: &str, language: Option<&str>) -> String {
        if let Some(lang) = language {
            format!("```{}\n{}\n```", lang, code)
        } else {
            format!("```\n{}\n```", code)
        }
    }

    /// Create a markdown table from headers and rows
    pub fn create_table(headers: &[&str], rows: &[Vec<&str>]) -> String {
        let mut table = String::new();
        
        // Header row
        table.push_str("| ");
        table.push_str(&headers.join(" | "));
        table.push_str(" |\n");
        
        // Separator row
        table.push_str("| ");
        table.push_str(&vec!["---"; headers.len()].join(" | "));
        table.push_str(" |\n");
        
        // Data rows
        for row in rows {
            table.push_str("| ");
            table.push_str(&row.join(" | "));
            table.push_str(" |\n");
        }
        
        table
    }

    /// Validate markdown syntax (basic validation)
    pub fn validate_markdown(markdown: &str) -> Vec<String> {
        let mut issues = Vec::new();
        
        // Check for unmatched code blocks
        let code_block_count = markdown.matches("```").count();
        if code_block_count % 2 != 0 {
            issues.push("Unmatched code blocks detected".to_string());
        }
        
        // Check for unmatched brackets
        let open_brackets = markdown.matches('[').count();
        let close_brackets = markdown.matches(']').count();
        if open_brackets != close_brackets {
            issues.push("Unmatched square brackets detected".to_string());
        }
        
        issues
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tasks::models::{Task, ContentFileReference};
    use std::path::PathBuf;

    fn create_test_task_structure() -> TaskStructure {
        let mut structure = TaskStructure::new(
            "INGEST_20250928101039".to_string(),
            2,
            3,
        );
        
        // Create a root task with content files
        let mut root_task = EnhancedTask::from_task(Task::new(
            "task_1".to_string(),
            "Analyze main components".to_string(),
            "1".to_string(),
            0,
        ));
        
        // Add content files
        let content_file = ContentFileReference::new(
            PathBuf::from(".raw_data_202509/INGEST_20250928101039_1_Content.txt"),
            "A".to_string(),
            "Primary content".to_string(),
            ContentFileType::Content,
        );
        root_task.add_content_file(content_file);
        
        // Add a subtask
        let subtask = EnhancedTask::from_task(Task::new(
            "task_1_1".to_string(),
            "Analyze specific module".to_string(),
            "1.1".to_string(),
            1,
        ));
        root_task.add_enhanced_subtask(subtask);
        
        structure.add_root_task(root_task);
        structure
    }

    #[test]
    fn test_markdown_writer_creation() {
        let writer = MarkdownWriter::new();
        assert!(writer.config.include_metadata);
        assert!(writer.config.include_overview);
        assert_eq!(writer.config.indent_string, "  ");
    }

    #[test]
    fn test_markdown_config_variants() {
        let minimal = MarkdownConfig::minimal();
        assert!(!minimal.include_metadata);
        assert!(!minimal.include_overview);
        assert_eq!(minimal.max_description_length, Some(100));
        
        let detailed = MarkdownConfig::detailed();
        assert!(detailed.include_metadata);
        assert!(detailed.include_overview);
        assert!(detailed.header_template.is_some());
    }

    #[test]
    fn test_markdown_generation() {
        let writer = MarkdownWriter::new();
        let task_structure = create_test_task_structure();
        
        let markdown = writer.generate_markdown(&task_structure).unwrap();
        
        // Check that basic structure is present
        assert!(markdown.contains("# INGEST_20250928101039 Task List"));
        assert!(markdown.contains("## Metadata"));
        assert!(markdown.contains("## Overview"));
        assert!(markdown.contains("## Tasks"));
        assert!(markdown.contains("* [ ] 1 Analyze main components"));
        assert!(markdown.contains("* [ ] 1.1 Analyze specific module"));
    }

    #[test]
    fn test_template_application() {
        let writer = MarkdownWriter::new();
        let task_structure = create_test_task_structure();
        
        let template = "Title: {title}, Table: {table_name}, Tasks: {total_tasks}";
        let result = writer.apply_template(template, &task_structure).unwrap();
        
        assert!(result.contains("Title: INGEST_20250928101039 Tasks"));
        assert!(result.contains("Table: INGEST_20250928101039"));
        assert!(result.contains("Tasks: 2")); // Root task + 1 subtask
    }

    #[test]
    fn test_content_files_formatting() {
        let writer = MarkdownWriter::new();
        let task_structure = create_test_task_structure();
        
        let markdown = writer.generate_markdown(&task_structure).unwrap();
        
        // Check that content files are properly formatted
        assert!(markdown.contains("**Content**:"));
        assert!(markdown.contains("A (Content):"));
        assert!(markdown.contains("INGEST_20250928101039_1_Content.txt"));
    }

    #[test]
    fn test_markdown_utils_escape() {
        assert_eq!(MarkdownUtils::escape_markdown("test*bold*"), "test\\*bold\\*");
        assert_eq!(MarkdownUtils::escape_markdown("test_italic_"), "test\\_italic\\_");
        assert_eq!(MarkdownUtils::escape_markdown("test[link]"), "test\\[link\\]");
    }

    #[test]
    fn test_markdown_utils_link() {
        let link = MarkdownUtils::create_link("Test Link", "https://example.com");
        assert_eq!(link, "[Test Link](https://example.com)");
    }

    #[test]
    fn test_markdown_utils_code_block() {
        let code_block = MarkdownUtils::create_code_block("fn main() {}", Some("rust"));
        assert_eq!(code_block, "```rust\nfn main() {}\n```");
        
        let plain_block = MarkdownUtils::create_code_block("some code", None);
        assert_eq!(plain_block, "```\nsome code\n```");
    }

    #[test]
    fn test_markdown_utils_table() {
        let headers = vec!["Name", "Type", "Size"];
        let rows = vec![
            vec!["file1.rs", "Rust", "100"],
            vec!["file2.py", "Python", "200"],
        ];
        
        let table = MarkdownUtils::create_table(&headers, &rows);
        
        assert!(table.contains("| Name | Type | Size |"));
        assert!(table.contains("| --- | --- | --- |"));
        assert!(table.contains("| file1.rs | Rust | 100 |"));
        assert!(table.contains("| file2.py | Python | 200 |"));
    }

    #[test]
    fn test_markdown_validation() {
        // Valid markdown
        let valid_md = "# Title\n\nSome text with `code` and [link](url).\n\n```rust\ncode\n```";
        let issues = MarkdownUtils::validate_markdown(valid_md);
        assert!(issues.is_empty());
        
        // Invalid markdown with unmatched code blocks
        let invalid_md = "# Title\n\n```rust\ncode\n";
        let issues = MarkdownUtils::validate_markdown(invalid_md);
        assert!(!issues.is_empty());
        assert!(issues[0].contains("Unmatched code blocks"));
        
        // Invalid markdown with unmatched brackets
        let invalid_md2 = "# Title\n\n[link without closing";
        let issues2 = MarkdownUtils::validate_markdown(invalid_md2);
        assert!(!issues2.is_empty());
        assert!(issues2[0].contains("Unmatched square brackets"));
    }

    #[tokio::test]
    async fn test_write_task_structure() {
        let writer = MarkdownWriter::new();
        let task_structure = create_test_task_structure();
        
        // Create a temporary file path
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_tasks.md");
        
        // Write the task structure
        let result = writer.write_task_structure(&task_structure, &output_path).await;
        assert!(result.is_ok());
        
        // Verify the file was created and contains expected content
        let content = fs::read_to_string(&output_path).await.unwrap();
        assert!(content.contains("# INGEST_20250928101039 Task List"));
        assert!(content.contains("* [ ] 1 Analyze main components"));
        
        // Clean up
        let _ = fs::remove_file(&output_path).await;
    }

    #[test]
    fn test_minimal_config_generation() {
        let config = MarkdownConfig::minimal();
        let writer = MarkdownWriter::with_config(config);
        let task_structure = create_test_task_structure();
        
        let markdown = writer.generate_markdown(&task_structure).unwrap();
        
        // Should not include metadata or overview sections
        assert!(!markdown.contains("## Metadata"));
        assert!(!markdown.contains("## Overview"));
        assert!(!markdown.contains("## Execution Instructions"));
        
        // Should still include the main tasks
        assert!(markdown.contains("## Tasks"));
        assert!(markdown.contains("* [ ] 1 Analyze main components"));
    }
}