//! Integration tests for database export functionality
//!
//! These tests verify that the print-to-md export functionality works correctly
//! with real PostgreSQL databases.

use code_ingest::database::{Database, DatabaseExporter, ExportConfig, SchemaManager};
use std::env;
use std::collections::HashMap;
use tempfile::TempDir;
use tokio;

/// Helper function to create a test database connection
async fn create_test_database() -> Option<Database> {
    if let Ok(database_url) = env::var("DATABASE_URL") {
        Database::new(&database_url).await.ok()
    } else {
        None
    }
}

/// Helper function to set up test data for export
async fn setup_export_test_data(database: &Database) -> anyhow::Result<String> {
    let schema_manager = SchemaManager::new(database.pool().clone());
    
    // Initialize schema
    schema_manager.initialize_schema().await?;
    
    // Create a test ingestion table
    let table_name = schema_manager.create_ingestion_table(None).await?;
    
    // Insert diverse test data for export testing
    let insert_sql = format!(
        r#"
        INSERT INTO "{}" (
            ingestion_id, filepath, filename, extension, file_size_bytes,
            line_count, word_count, token_count, content_text, file_type,
            relative_path, absolute_path
        ) VALUES 
        (1, '/test/hello.rs', 'hello.rs', 'rs', 1024, 10, 25, 22, 
         'fn main() {{\n    println!("Hello, world!");\n}}', 'direct_text', 
         'hello.rs', '/test/hello.rs'),
        (1, '/test/utils.py', 'utils.py', 'py', 2048, 25, 80, 75, 
         'def greet(name):\n    return f"Hello, {{name}}!"', 'direct_text', 
         'utils.py', '/test/utils.py'),
        (1, '/test/config.json', 'config.json', 'json', 512, 8, 15, 18, 
         '{{\n  "name": "test-app",\n  "version": "1.0.0"\n}}', 'direct_text', 
         'config.json', '/test/config.json'),
        (1, '/test/large_file.txt', 'large_file.txt', 'txt', 8192, 100, 500, 450, 
         'This is a large text file with multiple lines.\nIt contains various content for testing export functionality.\nLine 3\nLine 4\nLine 5', 'direct_text', 
         'large_file.txt', '/test/large_file.txt'),
        (1, '/test/binary.exe', 'binary.exe', 'exe', 4096, NULL, NULL, NULL, 
         NULL, 'non_text', 'binary.exe', '/test/binary.exe')
        "#,
        table_name
    );
    
    sqlx::query(&insert_sql)
        .execute(database.pool())
        .await?;
    
    Ok(table_name)
}

#[tokio::test]
async fn test_basic_export_functionality() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // Configure export
        let config = ExportConfig {
            prefix: "test-export".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: None,
        };
        
        // Execute export
        let sql_query = format!("SELECT * FROM \"{}\" WHERE file_type = 'direct_text'", test_table);
        let result = exporter.export_to_markdown_files(&test_table, &sql_query, &config).await.unwrap();
        
        // Verify results
        assert_eq!(result.files_created, 4); // Should export 4 direct_text files
        assert_eq!(result.files_failed, 0);
        assert!(result.total_size_bytes > 0);
        assert_eq!(result.created_files.len(), 4);
        
        // Verify files were actually created
        for file_path in &result.created_files {
            assert!(file_path.exists(), "File should exist: {}", file_path.display());
            
            // Verify file content
            let content = tokio::fs::read_to_string(file_path).await.unwrap();
            assert!(content.contains("# Export Row"));
            assert!(content.contains("## File Information"));
            assert!(content.contains("Generated by code-ingest"));
        }
        
        // Verify file naming convention
        let expected_files = vec![
            "test-export-00001.md",
            "test-export-00002.md", 
            "test-export-00003.md",
            "test-export-00004.md",
        ];
        
        for expected_file in expected_files {
            let file_path = export_path.join(expected_file);
            assert!(file_path.exists(), "Expected file should exist: {}", expected_file);
        }
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Basic export functionality test passed");
        println!("   Files created: {}", result.files_created);
        println!("   Total size: {} bytes", result.total_size_bytes);
    } else {
        println!("⏭️  Skipping basic export test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_with_custom_query() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // Configure export
        let config = ExportConfig {
            prefix: "custom-query".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: None,
        };
        
        // Execute export with custom query (only Rust files)
        let sql_query = format!(
            "SELECT filepath, filename, extension, content_text FROM \"{}\" WHERE extension = 'rs'", 
            test_table
        );
        let result = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        
        // Verify results
        assert_eq!(result.files_created, 1); // Should export 1 Rust file
        assert_eq!(result.files_failed, 0);
        
        // Verify file content
        let rust_file = export_path.join("custom-query-00001.md");
        assert!(rust_file.exists());
        
        let content = tokio::fs::read_to_string(&rust_file).await.unwrap();
        assert!(content.contains("hello.rs"));
        assert!(content.contains("```rust"));
        assert!(content.contains("fn main()"));
        assert!(content.contains("Hello, world!"));
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Custom query export test passed");
        println!("   Rust files exported: {}", result.files_created);
    } else {
        println!("⏭️  Skipping custom query export test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_with_template() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // Custom template
        let template = r#"# File Analysis Report

**File**: {{FILEPATH}}
**Type**: {{FILE_TYPE}}
**Size**: {{FILE_SIZE_BYTES}} bytes

## Content Preview

{{CONTENT_TEXT}}

---
Report {{ROW_INDEX}} of {{TOTAL_ROWS}} generated at {{TIMESTAMP}}
"#;
        
        // Configure export with template
        let config = ExportConfig {
            prefix: "templated".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: Some(template.to_string()),
        };
        
        // Execute export
        let sql_query = format!("SELECT * FROM \"{}\" LIMIT 2", test_table);
        let result = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        
        // Verify results
        assert_eq!(result.files_created, 2);
        assert_eq!(result.files_failed, 0);
        
        // Verify template was applied
        let first_file = export_path.join("templated-00001.md");
        assert!(first_file.exists());
        
        let content = tokio::fs::read_to_string(&first_file).await.unwrap();
        assert!(content.contains("# File Analysis Report"));
        assert!(content.contains("Report 1 of 2 generated at"));
        assert!(content.contains("**File**: /test/"));
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Template export test passed");
        println!("   Templated files created: {}", result.files_created);
    } else {
        println!("⏭️  Skipping template export test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_error_handling() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // Test with invalid table name
        let config = ExportConfig {
            prefix: "error-test".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: None,
        };
        
        let result = exporter.export_to_markdown_files(
            "nonexistent_table", 
            "SELECT * FROM nonexistent_table", 
            &config
        ).await;
        
        assert!(result.is_err(), "Should fail for nonexistent table");
        
        // Test with invalid prefix
        let mut invalid_config = config.clone();
        invalid_config.prefix = "invalid@prefix".to_string();
        
        let result = exporter.export_query_to_markdown("SELECT 1", &invalid_config).await;
        assert!(result.is_err(), "Should fail for invalid prefix");
        
        // Test with empty query results
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.initialize_schema().await.unwrap();
        
        let empty_result = exporter.export_query_to_markdown(
            "SELECT * FROM ingestion_meta WHERE 1=0", 
            &config
        ).await.unwrap();
        
        assert_eq!(empty_result.files_created, 0);
        assert_eq!(empty_result.files_failed, 0);
        assert!(!empty_result.errors.is_empty());
        
        println!("✅ Error handling test passed");
    } else {
        println!("⏭️  Skipping error handling test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_overwrite_behavior() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // First export with overwrite disabled
        let config = ExportConfig {
            prefix: "overwrite-test".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: false,
            markdown_template: None,
        };
        
        let sql_query = format!("SELECT * FROM \"{}\" LIMIT 1", test_table);
        let result1 = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        
        assert_eq!(result1.files_created, 1);
        assert_eq!(result1.files_failed, 0);
        
        // Second export with same config (should fail due to existing files)
        let result2 = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        
        assert_eq!(result2.files_created, 0);
        assert_eq!(result2.files_failed, 1);
        assert!(!result2.errors.is_empty());
        
        // Third export with overwrite enabled
        let mut overwrite_config = config.clone();
        overwrite_config.overwrite_existing = true;
        
        let result3 = exporter.export_query_to_markdown(&sql_query, &overwrite_config).await.unwrap();
        
        assert_eq!(result3.files_created, 1);
        assert_eq!(result3.files_failed, 0);
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Overwrite behavior test passed");
    } else {
        println!("⏭️  Skipping overwrite test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_large_dataset() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        // Test safety limit
        let config = ExportConfig {
            prefix: "large-test".to_string(),
            location: export_path.clone(),
            max_files: Some(2), // Very low limit for testing
            overwrite_existing: true,
            markdown_template: None,
        };
        
        // This should fail due to safety limit
        let sql_query = format!("SELECT * FROM \"{}\"", test_table);
        let result = exporter.export_query_to_markdown(&sql_query, &config).await;
        
        assert!(result.is_err(), "Should fail due to safety limit");
        
        // Test with higher limit
        let mut safe_config = config.clone();
        safe_config.max_files = Some(10);
        
        let result = exporter.export_query_to_markdown(&sql_query, &safe_config).await.unwrap();
        assert!(result.files_created > 0);
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Large dataset test passed");
    } else {
        println!("⏭️  Skipping large dataset test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_formatting_quality() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        let config = ExportConfig {
            prefix: "format-test".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: None,
        };
        
        // Export different file types
        let sql_query = format!("SELECT * FROM \"{}\" ORDER BY extension", test_table);
        let result = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        
        assert!(result.files_created > 0);
        
        // Check specific formatting for different file types
        for file_path in &result.created_files {
            let content = tokio::fs::read_to_string(file_path).await.unwrap();
            
            // All files should have proper markdown structure
            assert!(content.contains("# Export Row"));
            assert!(content.contains("## Metadata"));
            assert!(content.contains("Generated by code-ingest"));
            
            // Check for proper syntax highlighting based on file extension
            if content.contains("hello.rs") {
                assert!(content.contains("```rust"));
            } else if content.contains("utils.py") {
                assert!(content.contains("```python"));
            } else if content.contains("config.json") {
                assert!(content.contains("```json"));
            }
            
            // Check for proper file information formatting
            if content.contains("## File Information") {
                assert!(content.contains("**File Path**:"));
                assert!(content.contains("**Filename**:"));
                assert!(content.contains("**Extension**:"));
            }
        }
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Formatting quality test passed");
        println!("   Files checked: {}", result.created_files.len());
    } else {
        println!("⏭️  Skipping formatting test (no DATABASE_URL)");
    }
}

#[tokio::test]
async fn test_export_performance() {
    if let Some(database) = create_test_database().await {
        let exporter = DatabaseExporter::new(database.pool().clone());
        
        // Set up test data
        let test_table = setup_export_test_data(&database).await.unwrap();
        
        // Create temporary directory for export
        let temp_dir = TempDir::new().unwrap();
        let export_path = temp_dir.path().to_path_buf();
        
        let config = ExportConfig {
            prefix: "perf-test".to_string(),
            location: export_path.clone(),
            max_files: Some(100),
            overwrite_existing: true,
            markdown_template: None,
        };
        
        // Measure export performance
        let start = std::time::Instant::now();
        let sql_query = format!("SELECT * FROM \"{}\"", test_table);
        let result = exporter.export_query_to_markdown(&sql_query, &config).await.unwrap();
        let duration = start.elapsed();
        
        // Performance assertions
        assert!(duration.as_secs() < 10, "Export should complete within 10 seconds");
        assert!(result.execution_time_ms < 10000, "Reported execution time should be reasonable");
        assert!(result.files_created > 0);
        
        // Check file sizes are reasonable
        assert!(result.total_size_bytes > 0);
        assert!(result.total_size_bytes < 10_000_000, "Total size should be reasonable for test data");
        
        // Clean up
        let schema_manager = SchemaManager::new(database.pool().clone());
        schema_manager.drop_table(&test_table).await.unwrap();
        
        println!("✅ Performance test passed");
        println!("   Export time: {}ms", duration.as_millis());
        println!("   Files created: {}", result.files_created);
        println!("   Total size: {} bytes", result.total_size_bytes);
    } else {
        println!("⏭️  Skipping performance test (no DATABASE_URL)");
    }
}