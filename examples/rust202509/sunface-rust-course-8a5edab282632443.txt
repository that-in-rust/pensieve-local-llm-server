Directory structure:
â””â”€â”€ sunface-rust-course/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ book.toml
    â”œâ”€â”€ deploy.sh
    â”œâ”€â”€ genpdf.sh
    â”œâ”€â”€ assets/
    â”‚   â”œâ”€â”€ bigPicture.js
    â”‚   â”œâ”€â”€ CNAME
    â”‚   â”œâ”€â”€ custom.js
    â”‚   â”œâ”€â”€ sitemap.xml
    â”‚   â”œâ”€â”€ rustlings-zh/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”œâ”€â”€ CHANGELOG.md
    â”‚   â”‚   â”œâ”€â”€ CONTRIBUTING.md
    â”‚   â”‚   â”œâ”€â”€ default_out.txt
    â”‚   â”‚   â”œâ”€â”€ info.toml
    â”‚   â”‚   â”œâ”€â”€ install.ps1
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ LICENSE
    â”‚   â”‚   â”œâ”€â”€ .all-contributorsrc
    â”‚   â”‚   â”œâ”€â”€ .clog.toml
    â”‚   â”‚   â”œâ”€â”€ .editorconfig
    â”‚   â”‚   â”œâ”€â”€ .gitpod.yml
    â”‚   â”‚   â”œâ”€â”€ .replit
    â”‚   â”‚   â”œâ”€â”€ exercises/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ quiz1.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ quiz2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ quiz3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ quiz4.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ advanced_errors/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ advanced_errs1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ advanced_errs2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ clippy/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ clippy1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ clippy2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ collections/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ hashmap1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ hashmap2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vec1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vec2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ conversions/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ as_ref_mut.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ from_into.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ from_str.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ try_from_into.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ using_as.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ enums/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ enums1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ enums2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ enums3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ error_handling/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ errors1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ errors2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ errors3.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ errors4.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ errors5.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ errors6.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ functions/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ functions1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ functions2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ functions3.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ functions4.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ functions5.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ generics/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generics1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generics2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ generics3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ if/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ if1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ if2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ macros/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ macros1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ macros2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ macros3.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ macros4.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ modules/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ modules1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ modules2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ modules3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ move_semantics/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ move_semantics1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ move_semantics2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ move_semantics3.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ move_semantics4.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ move_semantics5.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ option/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ option1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ option2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ option3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types3.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types4.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ primitive_types5.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ primitive_types6.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ standard_library_types/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ arc1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ box1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ iterators1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ iterators2.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ iterators3.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ iterators4.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ iterators5.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ strings/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ strings1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ strings2.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ structs/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ structs1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ structs2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ structs3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ tests/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tests1.rs
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tests2.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ tests3.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ threads/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ threads1.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ traits/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ traits1.rs
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ traits2.rs
    â”‚   â”‚   â”‚   â””â”€â”€ variables/
    â”‚   â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ variables1.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ variables2.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ variables3.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ variables4.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ variables5.rs
    â”‚   â”‚   â”‚       â””â”€â”€ variables6.rs
    â”‚   â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”‚   â”œâ”€â”€ exercise.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ main.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ run.rs
    â”‚   â”‚   â”‚   â”œâ”€â”€ ui.rs
    â”‚   â”‚   â”‚   â””â”€â”€ verify.rs
    â”‚   â”‚   â””â”€â”€ tests/
    â”‚   â”‚       â”œâ”€â”€ integration_tests.rs
    â”‚   â”‚       â””â”€â”€ fixture/
    â”‚   â”‚           â”œâ”€â”€ failure/
    â”‚   â”‚           â”‚   â”œâ”€â”€ compFailure.rs
    â”‚   â”‚           â”‚   â”œâ”€â”€ compNoExercise.rs
    â”‚   â”‚           â”‚   â”œâ”€â”€ info.toml
    â”‚   â”‚           â”‚   â”œâ”€â”€ testFailure.rs
    â”‚   â”‚           â”‚   â””â”€â”€ testNotPassed.rs
    â”‚   â”‚           â”œâ”€â”€ state/
    â”‚   â”‚           â”‚   â”œâ”€â”€ finished_exercise.rs
    â”‚   â”‚           â”‚   â”œâ”€â”€ info.toml
    â”‚   â”‚           â”‚   â”œâ”€â”€ pending_exercise.rs
    â”‚   â”‚           â”‚   â””â”€â”€ pending_test_exercise.rs
    â”‚   â”‚           â””â”€â”€ success/
    â”‚   â”‚               â”œâ”€â”€ compSuccess.rs
    â”‚   â”‚               â”œâ”€â”€ info.toml
    â”‚   â”‚               â””â”€â”€ testSuccess.rs
    â”‚   â””â”€â”€ writing-material/
    â”‚       â”œâ”€â”€ books.md
    â”‚       â”œâ”€â”€ courses.md
    â”‚       â”œâ”€â”€ demos_for_learning.md
    â”‚       â”œâ”€â”€ good-sourcecode.md
    â”‚       â”œâ”€â”€ è¯»è€…ç–‘æƒ‘çš„ç‚¹è®°å½•.md
    â”‚       â”œâ”€â”€ posts/
    â”‚       â”‚   â”œâ”€â”€ atomic.md
    â”‚       â”‚   â”œâ”€â”€ attributes.md
    â”‚       â”‚   â”œâ”€â”€ file.md
    â”‚       â”‚   â”œâ”€â”€ function_signature.md
    â”‚       â”‚   â”œâ”€â”€ generics.md
    â”‚       â”‚   â”œâ”€â”€ hashmap.md
    â”‚       â”‚   â”œâ”€â”€ identifier.md
    â”‚       â”‚   â”œâ”€â”€ images.md
    â”‚       â”‚   â”œâ”€â”€ interview.md
    â”‚       â”‚   â”œâ”€â”€ io.md
    â”‚       â”‚   â”œâ”€â”€ Iterator.md
    â”‚       â”‚   â”œâ”€â”€ lifetime.md
    â”‚       â”‚   â”œâ”€â”€ lifetime_elision_rules.md
    â”‚       â”‚   â”œâ”€â”€ non-lexical-lifetime.md
    â”‚       â”‚   â”œâ”€â”€ operators.md
    â”‚       â”‚   â”œâ”€â”€ package.md
    â”‚       â”‚   â”œâ”€â”€ performance.md
    â”‚       â”‚   â”œâ”€â”€ plugins.md
    â”‚       â”‚   â”œâ”€â”€ reference.md
    â”‚       â”‚   â”œâ”€â”€ rust-analyser.md
    â”‚       â”‚   â”œâ”€â”€ self-referential.md
    â”‚       â”‚   â”œâ”€â”€ SIMD.md
    â”‚       â”‚   â”œâ”€â”€ string.md
    â”‚       â”‚   â”œâ”€â”€ system_command.md
    â”‚       â”‚   â”œâ”€â”€ threads.md
    â”‚       â”‚   â”œâ”€â”€ to_resolved.md
    â”‚       â”‚   â”œâ”€â”€ tokio.md
    â”‚       â”‚   â”œâ”€â”€ trivia.md
    â”‚       â”‚   â”œâ”€â”€ wasm.md
    â”‚       â”‚   â”œâ”€â”€ fight-with-compiler-check/
    â”‚       â”‚   â”‚   â”œâ”€â”€ borrow.md
    â”‚       â”‚   â”‚   â””â”€â”€ generic.md
    â”‚       â”‚   â””â”€â”€ tests/
    â”‚       â”‚       â”œâ”€â”€ doc_test.md
    â”‚       â”‚       â”œâ”€â”€ integration_test.md
    â”‚       â”‚       â”œâ”€â”€ misc.md
    â”‚       â”‚       â””â”€â”€ unit_test.md
    â”‚       â””â”€â”€ style_guide/
    â”‚           â”œâ”€â”€ coding.md
    â”‚           â””â”€â”€ naming.md
    â”œâ”€â”€ ci/
    â”‚   â””â”€â”€ copy-assets.sh
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ about-book.md
    â”‚   â”œâ”€â”€ beat-ai.md
    â”‚   â”œâ”€â”€ community.md
    â”‚   â”œâ”€â”€ github.md
    â”‚   â”œâ”€â”€ index-list.md
    â”‚   â”œâ”€â”€ into-rust.md
    â”‚   â”œâ”€â”€ practice.md
    â”‚   â”œâ”€â”€ rust-weekly.md
    â”‚   â”œâ”€â”€ rustt.md
    â”‚   â”œâ”€â”€ rusty-book.md
    â”‚   â”œâ”€â”€ some-thoughts.md
    â”‚   â”œâ”€â”€ SUMMARY.md
    â”‚   â”œâ”€â”€ advance/
    â”‚   â”‚   â”œâ”€â”€ errors.md
    â”‚   â”‚   â”œâ”€â”€ global-variable.md
    â”‚   â”‚   â”œâ”€â”€ hrtb.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ macro.md
    â”‚   â”‚   â”œâ”€â”€ simd.md
    â”‚   â”‚   â”œâ”€â”€ async/
    â”‚   â”‚   â”‚   â”œâ”€â”€ async-await.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ future-excuting.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ getting-started.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ multi-futures-simultaneous.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ pain-points-and-workarounds.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ pin-unpin.md
    â”‚   â”‚   â”‚   â””â”€â”€ web-server.md
    â”‚   â”‚   â”œâ”€â”€ circle-self-ref/
    â”‚   â”‚   â”‚   â”œâ”€â”€ circle-reference.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ self-referential.md
    â”‚   â”‚   â”œâ”€â”€ concurrency-with-threads/
    â”‚   â”‚   â”‚   â”œâ”€â”€ concurrency-parallelism.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ message-passing.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ races.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ ref-counter-lock.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ send-sync.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ sync1.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ sync2.md
    â”‚   â”‚   â”‚   â””â”€â”€ thread.md
    â”‚   â”‚   â”œâ”€â”€ difficulties/
    â”‚   â”‚   â”‚   â””â”€â”€ pointer.md
    â”‚   â”‚   â”œâ”€â”€ functional-programing/
    â”‚   â”‚   â”‚   â”œâ”€â”€ closure.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ iterator.md
    â”‚   â”‚   â”œâ”€â”€ into-types/
    â”‚   â”‚   â”‚   â”œâ”€â”€ converse.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ custom-type.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ enum-int.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ sized.md
    â”‚   â”‚   â”œâ”€â”€ lifetime/
    â”‚   â”‚   â”‚   â”œâ”€â”€ advance.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ misconceptions.md
    â”‚   â”‚   â”‚   â””â”€â”€ static.md
    â”‚   â”‚   â”œâ”€â”€ smart-pointer/
    â”‚   â”‚   â”‚   â”œâ”€â”€ box.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ cell-refcell.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ deref.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ drop.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ rc-arc.md
    â”‚   â”‚   â””â”€â”€ unsafe/
    â”‚   â”‚       â”œâ”€â”€ inline-asm.md
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â”œâ”€â”€ superpowers.md
    â”‚   â”‚       â””â”€â”€ ub.md
    â”‚   â”œâ”€â”€ advance-practice/
    â”‚   â”‚   â”œâ”€â”€ async.md
    â”‚   â”‚   â”œâ”€â”€ bridging-with-sync.md
    â”‚   â”‚   â”œâ”€â”€ channels.md
    â”‚   â”‚   â”œâ”€â”€ design-pattern.md
    â”‚   â”‚   â”œâ”€â”€ frame.md
    â”‚   â”‚   â”œâ”€â”€ getting-startted.md
    â”‚   â”‚   â”œâ”€â”€ graceful-shutdown.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ io.md
    â”‚   â”‚   â”œâ”€â”€ overview.md
    â”‚   â”‚   â”œâ”€â”€ select.md
    â”‚   â”‚   â”œâ”€â”€ shared-state.md
    â”‚   â”‚   â”œâ”€â”€ spawning.md
    â”‚   â”‚   â””â”€â”€ stream.md
    â”‚   â”œâ”€â”€ advance-practice1/
    â”‚   â”‚   â”œâ”€â”€ graceful-shutdown.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ multi-threads.md
    â”‚   â”‚   â””â”€â”€ web-server.md
    â”‚   â”œâ”€â”€ appendix/
    â”‚   â”‚   â”œâ”€â”€ derive.md
    â”‚   â”‚   â”œâ”€â”€ difficulties.md
    â”‚   â”‚   â”œâ”€â”€ expressions.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ keywords.md
    â”‚   â”‚   â”œâ”€â”€ operators.md
    â”‚   â”‚   â”œâ”€â”€ prelude.md
    â”‚   â”‚   â”œâ”€â”€ rust-version.md
    â”‚   â”‚   â””â”€â”€ rust-versions/
    â”‚   â”‚       â”œâ”€â”€ 1.58.md
    â”‚   â”‚       â”œâ”€â”€ 1.59.md
    â”‚   â”‚       â”œâ”€â”€ 1.60.md
    â”‚   â”‚       â”œâ”€â”€ 1.61.md
    â”‚   â”‚       â”œâ”€â”€ 1.62.md
    â”‚   â”‚       â”œâ”€â”€ 1.63.md
    â”‚   â”‚       â”œâ”€â”€ 1.64.md
    â”‚   â”‚       â”œâ”€â”€ 1.65.md
    â”‚   â”‚       â”œâ”€â”€ 1.66.md
    â”‚   â”‚       â”œâ”€â”€ 1.67.md
    â”‚   â”‚       â”œâ”€â”€ 1.68.md
    â”‚   â”‚       â”œâ”€â”€ 1.69.md
    â”‚   â”‚       â”œâ”€â”€ 1.70.md
    â”‚   â”‚       â”œâ”€â”€ 1.71.md
    â”‚   â”‚       â”œâ”€â”€ 1.72.md
    â”‚   â”‚       â”œâ”€â”€ 1.73.md
    â”‚   â”‚       â”œâ”€â”€ 1.74.md
    â”‚   â”‚       â”œâ”€â”€ 1.75.md
    â”‚   â”‚       â”œâ”€â”€ 1.76.md
    â”‚   â”‚       â”œâ”€â”€ 1.77.md
    â”‚   â”‚       â”œâ”€â”€ 1.78.md
    â”‚   â”‚       â”œâ”€â”€ 1.79.md
    â”‚   â”‚       â”œâ”€â”€ 1.80.md
    â”‚   â”‚       â”œâ”€â”€ 1.81.md
    â”‚   â”‚       â”œâ”€â”€ 1.82.md
    â”‚   â”‚       â”œâ”€â”€ 1.83.md
    â”‚   â”‚       â”œâ”€â”€ 1.84.md
    â”‚   â”‚       â”œâ”€â”€ 1.85.md
    â”‚   â”‚       â”œâ”€â”€ 1.86.md
    â”‚   â”‚       â”œâ”€â”€ 1.87.md
    â”‚   â”‚       â”œâ”€â”€ 1.88.md
    â”‚   â”‚       â”œâ”€â”€ 1.89.md
    â”‚   â”‚       â””â”€â”€ intro.md
    â”‚   â”œâ”€â”€ basic/
    â”‚   â”‚   â”œâ”€â”€ comment.md
    â”‚   â”‚   â”œâ”€â”€ flow-control.md
    â”‚   â”‚   â”œâ”€â”€ formatted-output.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ lifetime.md
    â”‚   â”‚   â”œâ”€â”€ method.md
    â”‚   â”‚   â”œâ”€â”€ variable.md
    â”‚   â”‚   â”œâ”€â”€ base-type/
    â”‚   â”‚   â”‚   â”œâ”€â”€ char-bool.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ function.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ numbers.md
    â”‚   â”‚   â”‚   â””â”€â”€ statement-expression.md
    â”‚   â”‚   â”œâ”€â”€ collections/
    â”‚   â”‚   â”‚   â”œâ”€â”€ hashmap.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ vector.md
    â”‚   â”‚   â”œâ”€â”€ compound-type/
    â”‚   â”‚   â”‚   â”œâ”€â”€ array.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ enum.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ string-slice.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ struct.md
    â”‚   â”‚   â”‚   â””â”€â”€ tuple.md
    â”‚   â”‚   â”œâ”€â”€ crate-module/
    â”‚   â”‚   â”‚   â”œâ”€â”€ crate.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ module.md
    â”‚   â”‚   â”‚   â””â”€â”€ use.md
    â”‚   â”‚   â”œâ”€â”€ match-pattern/
    â”‚   â”‚   â”‚   â”œâ”€â”€ all-patterns.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ match-if-let.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ option.md
    â”‚   â”‚   â”‚   â””â”€â”€ pattern-match.md
    â”‚   â”‚   â”œâ”€â”€ ownership/
    â”‚   â”‚   â”‚   â”œâ”€â”€ borrowing.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.md
    â”‚   â”‚   â”‚   â””â”€â”€ ownership.md
    â”‚   â”‚   â”œâ”€â”€ result-error/
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ panic.md
    â”‚   â”‚   â”‚   â””â”€â”€ result.md
    â”‚   â”‚   â””â”€â”€ trait/
    â”‚   â”‚       â”œâ”€â”€ advance-trait.md
    â”‚   â”‚       â”œâ”€â”€ generic.md
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â”œâ”€â”€ trait-object.md
    â”‚   â”‚       â””â”€â”€ trait.md
    â”‚   â”œâ”€â”€ basic-practice/
    â”‚   â”‚   â”œâ”€â”€ base-features.md
    â”‚   â”‚   â”œâ”€â”€ envs.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ iterators.md
    â”‚   â”‚   â”œâ”€â”€ refactoring.md
    â”‚   â”‚   â”œâ”€â”€ stderr.md
    â”‚   â”‚   â””â”€â”€ tests.md
    â”‚   â”œâ”€â”€ cargo/
    â”‚   â”‚   â”œâ”€â”€ getting-started.md
    â”‚   â”‚   â”œâ”€â”€ git-auth.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ guide/
    â”‚   â”‚   â”‚   â”œâ”€â”€ build-cache.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ cargo-cache.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ cargo-toml-lock.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ dependencies.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ download-package.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ package-layout.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ tests-ci.md
    â”‚   â”‚   â”‚   â””â”€â”€ why-exist.md
    â”‚   â”‚   â””â”€â”€ reference/
    â”‚   â”‚       â”œâ”€â”€ cargo-target.md
    â”‚   â”‚       â”œâ”€â”€ configuration.md
    â”‚   â”‚       â”œâ”€â”€ deps-overriding.md
    â”‚   â”‚       â”œâ”€â”€ env.md
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â”œâ”€â”€ manifest.md
    â”‚   â”‚       â”œâ”€â”€ package-id.md
    â”‚   â”‚       â”œâ”€â”€ profile.md
    â”‚   â”‚       â”œâ”€â”€ profiles.md
    â”‚   â”‚       â”œâ”€â”€ publishing-on-crates.io.md
    â”‚   â”‚       â”œâ”€â”€ specify-deps.md
    â”‚   â”‚       â”œâ”€â”€ workspaces.md
    â”‚   â”‚       â”œâ”€â”€ build-script/
    â”‚   â”‚       â”‚   â”œâ”€â”€ examples.md
    â”‚   â”‚       â”‚   â””â”€â”€ intro.md
    â”‚   â”‚       â””â”€â”€ features/
    â”‚   â”‚           â”œâ”€â”€ examples.md
    â”‚   â”‚           â””â”€â”€ intro.md
    â”‚   â”œâ”€â”€ compiler/
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ fight-with-compiler/
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ phantom-data.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ unconstrained.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ borrowing/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ borrow-distinct-fields-of-struct.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ref-exist-in-out-fn.md
    â”‚   â”‚   â”‚   â””â”€â”€ lifetime/
    â”‚   â”‚   â”‚       â”œâ”€â”€ closure-with-static.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ loop.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ too-long1.md
    â”‚   â”‚   â”‚       â””â”€â”€ too-long2.md
    â”‚   â”‚   â””â”€â”€ pitfalls/
    â”‚   â”‚       â”œâ”€â”€ arithmetic-overflow.md
    â”‚   â”‚       â”œâ”€â”€ closure-with-lifetime.md
    â”‚   â”‚       â”œâ”€â”€ index.md
    â”‚   â”‚       â”œâ”€â”€ iterator-everywhere.md
    â”‚   â”‚       â”œâ”€â”€ lazy-iterators.md
    â”‚   â”‚       â”œâ”€â”€ main-with-channel-blocked.md
    â”‚   â”‚       â”œâ”€â”€ multiple-mutable-references.md
    â”‚   â”‚       â”œâ”€â”€ stack-overflow.md
    â”‚   â”‚       â”œâ”€â”€ the-disabled-mutability.md
    â”‚   â”‚       â”œâ”€â”€ use-vec-in-for.md
    â”‚   â”‚       â”œâ”€â”€ utf8-performance.md
    â”‚   â”‚       â””â”€â”€ weird-ranges.md
    â”‚   â”œâ”€â”€ difficulties/
    â”‚   â”‚   â”œâ”€â”€ cow.md
    â”‚   â”‚   â”œâ”€â”€ eq.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ lifetime.md
    â”‚   â”‚   â”œâ”€â”€ move-copy.md
    â”‚   â”‚   â”œâ”€â”€ pointer.md
    â”‚   â”‚   â”œâ”€â”€ slice.md
    â”‚   â”‚   â””â”€â”€ string.md
    â”‚   â”œâ”€â”€ first-try/
    â”‚   â”‚   â”œâ”€â”€ cargo.md
    â”‚   â”‚   â”œâ”€â”€ editor.md
    â”‚   â”‚   â”œâ”€â”€ hello-world.md
    â”‚   â”‚   â”œâ”€â”€ installation.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ slowly-downloading.md
    â”‚   â”‚   â””â”€â”€ sth-you-should-not-do.md
    â”‚   â”œâ”€â”€ libraries/
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ command/
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ structopt.md
    â”‚   â”‚   â”œâ”€â”€ http/
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ reqwest.md
    â”‚   â”‚   â””â”€â”€ json/
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â””â”€â”€ serde.md
    â”‚   â”œâ”€â”€ logs/
    â”‚   â”‚   â”œâ”€â”€ about-log.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ log.md
    â”‚   â”‚   â”œâ”€â”€ tracing-logger.md
    â”‚   â”‚   â”œâ”€â”€ tracing.md
    â”‚   â”‚   â””â”€â”€ observe/
    â”‚   â”‚       â”œâ”€â”€ about-observe.md
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â””â”€â”€ trace.md
    â”‚   â”œâ”€â”€ practice/
    â”‚   â”‚   â”œâ”€â”€ best-pratice.md
    â”‚   â”‚   â”œâ”€â”€ interview.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ naming.md
    â”‚   â”‚   â””â”€â”€ third-party-libs.md
    â”‚   â”œâ”€â”€ profiling/
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ compiler/
    â”‚   â”‚   â”‚   â”œâ”€â”€ attributes.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ llvm.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ phantom-data.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ speed-up.md
    â”‚   â”‚   â”‚   â””â”€â”€ optimization/
    â”‚   â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚       â””â”€â”€ option.md
    â”‚   â”‚   â”œâ”€â”€ memory/
    â”‚   â”‚   â”‚   â”œâ”€â”€ allocation.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ pointer-ref.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ uninit.md
    â”‚   â”‚   â”‚   â””â”€â”€ virtual.md
    â”‚   â”‚   â”œâ”€â”€ performance/
    â”‚   â”‚   â”‚   â”œâ”€â”€ allocator.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ calculate.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ clone-copy.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ cpu-cache.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ deep-into-move.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ early-optimise.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ enum.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ heap-stack.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ runtime-check.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ string.md
    â”‚   â”‚   â”‚   â””â”€â”€ tools.md
    â”‚   â”‚   â””â”€â”€ profiling/
    â”‚   â”‚       â””â”€â”€ performance/
    â”‚   â”‚           â””â”€â”€ benchmark.md
    â”‚   â”œâ”€â”€ std/
    â”‚   â”‚   â”œâ”€â”€ hashmap.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ iterator.md
    â”‚   â”‚   â”œâ”€â”€ search.md
    â”‚   â”‚   â””â”€â”€ vector.md
    â”‚   â”œâ”€â”€ templates/
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ files/
    â”‚   â”‚   â”‚   â”œâ”€â”€ dir.md
    â”‚   â”‚   â”‚   â””â”€â”€ intro.md
    â”‚   â”‚   â””â”€â”€ http/
    â”‚   â”‚       â””â”€â”€ intro.md
    â”‚   â”œâ”€â”€ test/
    â”‚   â”‚   â”œâ”€â”€ assertion.md
    â”‚   â”‚   â”œâ”€â”€ benchmark.md
    â”‚   â”‚   â”œâ”€â”€ ci.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ unit-integration-test.md
    â”‚   â”‚   â””â”€â”€ write-tests.md
    â”‚   â”œâ”€â”€ too-many-lists/
    â”‚   â”‚   â”œâ”€â”€ do-we-need-it.md
    â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”œâ”€â”€ advanced-lists/
    â”‚   â”‚   â”‚   â”œâ”€â”€ double-singly.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ stack-allocated.md
    â”‚   â”‚   â”‚   â””â”€â”€ unsafe-deque.md
    â”‚   â”‚   â”œâ”€â”€ bad-stack/
    â”‚   â”‚   â”‚   â”œâ”€â”€ basic-operations.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ final-code.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ layout.md
    â”‚   â”‚   â”œâ”€â”€ deque/
    â”‚   â”‚   â”‚   â”œâ”€â”€ final-code.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ iterator.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ peek.md
    â”‚   â”‚   â”‚   â””â”€â”€ symmetric.md
    â”‚   â”‚   â”œâ”€â”€ ok-stack/
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ iter.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ itermut.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ peek.md
    â”‚   â”‚   â”‚   â””â”€â”€ type-optimizing.md
    â”‚   â”‚   â”œâ”€â”€ persistent-stack/
    â”‚   â”‚   â”‚   â”œâ”€â”€ drop-arc.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â””â”€â”€ layout.md
    â”‚   â”‚   â”œâ”€â”€ production-unsafe-deque/
    â”‚   â”‚   â”‚   â”œâ”€â”€ basics.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ boring-combinatorics.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ drop-and-panic-safety.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ filling-in-random-bits.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ final-code.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ implementing-cursors.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ intro.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ send-sync-and-compile-tests.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ testing-cursors.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ testing.md
    â”‚   â”‚   â”‚   â””â”€â”€ variance-and-phantomData.md
    â”‚   â”‚   â””â”€â”€ unsafe-queue/
    â”‚   â”‚       â”œâ”€â”€ basics.md
    â”‚   â”‚       â”œâ”€â”€ extra-junk.md
    â”‚   â”‚       â”œâ”€â”€ final-code.md
    â”‚   â”‚       â”œâ”€â”€ intro.md
    â”‚   â”‚       â”œâ”€â”€ layout.md
    â”‚   â”‚       â”œâ”€â”€ layout2.md
    â”‚   â”‚       â”œâ”€â”€ miri.md
    â”‚   â”‚       â”œâ”€â”€ stacked-borrow.md
    â”‚   â”‚       â””â”€â”€ testing-stacked-borrow.md
    â”‚   â””â”€â”€ usecases/
    â”‚       â”œâ”€â”€ aws-rust.md
    â”‚       â””â”€â”€ intro.md
    â”œâ”€â”€ theme/
    â”‚   â”œâ”€â”€ index1.hbs
    â”‚   â””â”€â”€ style.css
    â””â”€â”€ .github/
        â””â”€â”€ workflows/
            â”œâ”€â”€ ci.yml
            â””â”€â”€ deploy.yml

================================================
FILE: README.md
================================================
<h1 align="center">Rustè¯­è¨€åœ£ç»</h1>

<div align="center">
    <img src="https://github.com/sunface/rust-course/blob/main/assets/banner.jpg?raw=true">
</div>
   
<div align="center">

[![studyrut](https://img.shields.io/badge/RustCnç¤¾åŒº-orange)](https://github.com/rustlang-cn) [![Stars Count](https://img.shields.io/github/stars/sunface/rust-course?style=flat)](https://github.com/sunface/rust-course/stargazers)
[![](https://img.shields.io/github/issues-pr-closed-raw/sunface/rust-course.svg?style=flat)](https://github.com/sunface/rust-course/issues)
[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/ines/spacy-course/master)

<!-- <a href="https://www.zhihu.com/column/c_1452781034895446017">
  <img alt="Sunface | çŸ¥ä¹" height="20px" width="20px" src="https://github.com/sunface/rust-course/blob/main/assets/zhihu.jpg">
</a> -->

</div>

**å·å¤–å·å¤–ï¼Œç‰¹å¤§æ–°é—»ï¼æœ¬ä¹¦è‹¦ä½œè€…ä¹…çŸ£ï¼Œå‡†å¤‡è‡ªæˆ‘é©å‘½äº†ï¼Œæ¬¢è¿å¤§å®¶è·Ÿé„™ä¹¦ä¸€èµ·å‘ä½œè€…æ‹ç –**: https://github.com/sunface/rust-course/issues/1563


## æ•™ç¨‹ç®€ä»‹

- åœ¨çº¿é˜…è¯»: https://course.rs

**`Rustè¯­è¨€åœ£ç»`**æ¶µç›–ä»**å…¥é—¨åˆ°ç²¾é€š**æ‰€éœ€çš„ Rust çŸ¥è¯†ï¼Œç›®å½•åŠå†…å®¹éƒ½ç»è¿‡æ·±æ€ç†Ÿè™‘çš„è®¾è®¡ï¼ŒåŒæ—¶è¯­è¨€ç”ŸåŠ¨å¹½é»˜ï¼Œè¡Œæ–‡æµç•…è‡ªå¦‚ï¼Œæ‘†è„±æŠ€æœ¯ä¹¦ç±å¸¸æœ‰çš„æœºå™¨å‘³å’Œæ™¦æ¶©æ„Ÿã€‚

- **æ·±å…¥åº¦**ï¼Œåœ¨åŸºç¡€æ•™å­¦çš„åŒæ—¶ï¼Œæä¾›äº†æ·±å…¥å‰–æã€‚æµ…å°è¾„æ­¢å¹¶ä¸èƒ½è®©æˆ‘ä»¬ç«™ä¸Šç´«ç¦ä¹‹å·…

- **ä¸“é¢˜å†…å®¹**ï¼Œå°† Rust é«˜çº§å†…å®¹é€šè¿‡ä¸“é¢˜çš„å½¢å¼ä¸€ä¸€å‘ˆç°ï¼Œå†…å®¹å†…èšæ€§æå¼ºï¼Œä¾‹å¦‚æ€§èƒ½ä¼˜åŒ–ã€æ‰‹æŠŠæ‰‹å®ç°é“¾è¡¨ã€Cargo å’Œ Tokio ä½¿ç”¨æŒ‡å—ã€async å¼‚æ­¥ç¼–ç¨‹ã€æ ‡å‡†åº“è§£æã€WASM ç­‰ç­‰

- **å†…å®¹ç´¢å¼•**ï¼Œä½œä¸ºä¸€æœ¬å·¥å…·ä¹¦ï¼Œä¼˜ç§€çš„ç´¢å¼•èƒ½åŠ›éå¸¸é‡è¦ï¼Œé—å¿˜ä¸å¯æ€•ï¼Œæ‰¾ä¸åˆ°æ‰å¯æ€•

- **è§„é¿é™·é˜±å’Œå¯¹æŠ—ç¼–è¯‘å™¨**ï¼Œåªæœ‰çœŸçš„ä¸Šæ‰‹å†™è¿‡ä¸€é•¿æ®µæ—¶é—´ Rust é¡¹ç›®ï¼Œæ‰çŸ¥é“è¯¥å¦‚ä½•è§„é¿å¸¸è§çš„é™·é˜±ä»¥åŠè§£å†³ä¸€äº›éš¾æçš„ç¼–è¯‘å™¨é”™è¯¯ï¼Œè€Œæœ¬ä¹¦å°†å¸®åŠ©ä½ å¤§å¤§ç¼©çŸ­è¿™ä¸ªè¿‡ç¨‹ï¼Œæå‰è§„é¿è¿™äº›é—®é¢˜

- **[Cookbook](https://rusty.course.rs)**ï¼Œæ¶µç›–å¤šä¸ªåº”ç”¨åœºæ™¯çš„å®æˆ˜ä»£ç ç‰‡æ®µï¼Œç¨‹åºå‘˜ä¸Šç½‘æŸ¥è¯¢æ–‡ä»¶æ“ä½œã€æ­£åˆ™è§£æã€æ•°æ®åº“æ“ä½œæ˜¯å¸¸äº‹ï¼Œæ²¡æœ‰äººèƒ½è®°ä½æ‰€æœ‰ä»£ç ï¼Œè€Œ Cookbook å¯è§£å›å¿§ï¼ŒCtrl + C/V èµ°å¤©ä¸‹

- **[é…å¥—ç»ƒä¹ é¢˜](https://github.com/sunface/rust-by-practice)**ï¼Œåƒå­¦ä¹ ä¸€é—¨å¤§å­¦è¯¾ç¨‹ä¸€æ ·å­¦ä¹  Rust æ˜¯ä¸€ç§ä»€ä¹ˆæ„Ÿè§‰ï¼Ÿ_Rust è¯­è¨€åœ£ç» + Rust è¯­è¨€å®æˆ˜_ åŒå‰‘åˆç’§ï¼Œç»™ä½ æœ€æè‡´çš„å­¦ä¹ ä½“éªŒ

æ€»ä¹‹åœ¨å†™ä½œè¿‡ç¨‹ä¸­æˆ‘ä»¬å§‹ç»ˆé“­è®°åˆå¿ƒï¼šä¸ºä¸­å›½ç”¨æˆ·æ‰“é€ ä¸€é—¨**å…¨é¢çš„ã€æ·±å…¥çš„ã€æŒç»­æ›´æ–°çš„** Rust æ•™ç¨‹ã€‚ æ–°æ‰‹ç”¨æ¥å…¥é—¨ï¼Œè€æ‰‹ç”¨æ¥æé«˜ï¼Œé«˜æ‰‹ç”¨æ¥æå‡ç”Ÿäº§åŠ›ã€‚

## ğŸ† è´¡çŒ®è€…

éå¸¸æ„Ÿè°¢æœ¬æ•™ç¨‹çš„[æ‰€æœ‰è´¡çŒ®è€…](https://github.com/sunface/rust-course/graphs/contributors)ï¼Œæ­£æ˜¯æœ‰äº†ä½ ä»¬ï¼Œæ‰æœ‰äº†ç°åœ¨çš„é«˜è´¨é‡ Rust æ•™ç¨‹!

<br />

ğŸ†

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/EluvK">
                <img src="https://avatars.githubusercontent.com/u/36977935?v=4" width="160px" alt=""/>
                <br />
                <sub><b>EluvK</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/AllanDowney">
                <img src="https://avatars.githubusercontent.com/u/82752697?v=4?s=100"  width="160px" alt=""/>
                <br />
                <sub><b>AllanDowney</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

<br />

ğŸ…

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/SUN-LG">
                <img src="https://avatars.githubusercontent.com/u/15073915?v=4" width="100px" alt=""/>
                <br />
                <sub><b>å­™ç«‹åˆš</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/JesseAtSZ">
                <img src="https://avatars.githubusercontent.com/u/35264598?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>JesseAtSZ</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/Rustln">
                <img src="https://avatars.githubusercontent.com/u/100085326?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>Rustln</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/1132719438">
                <img src="https://avatars.githubusercontent.com/u/10138791?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>1132719438</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

## åˆ›ä½œæ„Ÿæ‚Ÿ

æˆªè‡³ç›®å‰ï¼ŒRust è¯­è¨€åœ£ç»å·²å†™äº† 170 ä½™ç« ï¼Œ110 ä½™ä¸‡å­—ï¼Œå†ç» 800 å¤šä¸ªå°æ—¶ï¼Œæ¯ä¸€ä¸ªç« èŠ‚éƒ½æ˜¯æ‰‹åŠ¨å†™å°±ï¼Œæ²¡æœ‰ä»»ä½•æœºç¿»å’Œè´¨é‡ä¸Šçš„å¦¥å( ç›¸ä¿¡æ·±å…¥é˜…è¯»è¿‡çš„è¯»è€…éƒ½èƒ½ä½“ä¼šåˆ°è¿™ä¸€ç‚¹ )ã€‚

æ›¾ç»æœ‰è¯»è€…é—®è¿‡ "è¿™ä¹ˆå¥½çš„ä¹¦ä¸ºä½•è¦å¼€æºï¼Œè€Œä¸æ˜¯å‡ºç‰ˆ?"ï¼ŒåŸå› å¾ˆç®€å•ï¼š**åªæœ‰å®Œå…¨å¼€æºæ‰èƒ½å®Œç¾åœ°å‘ˆç°å‡ºæˆ‘æƒ³è¦çš„æ•™å­¦æ•ˆæœ**ã€‚

æ€»ä¹‹ï¼ŒRust è¦åœ¨å›½å†…çœŸæ­£å‘å±•èµ·æ¥ï¼Œå¿…é¡»å¾—æœ‰ä¸€äº›è¿½é€æ¢¦æƒ³çš„äººåœ¨åšç€ä¸è®¡ä»˜å‡ºçš„äº‹æƒ…ï¼Œè€Œæˆ‘å¸Œæœ›è‡ªå·±èƒ½è´¡çŒ®ä¸€ä»½å¾®è–„ä¹‹åŠ›ã€‚

ä½†æ˜¯è¦è¯´å®Œå…¨æ— æ¬²æ— æ±‚ï¼Œé‚£ä¹Ÿæ˜¯ä¸å¯èƒ½çš„ï¼Œçœ‹åˆ°é¡¹ç›®å¤šäº†ä¸€é¢— ğŸŒŸï¼Œé‚£æ„Ÿè§‰...æ£’æäº†ï¼Œå› ä¸ºå®ƒä»£è¡¨äº†è¯»è€…çš„è®¤å¯å’Œç§°èµã€‚

ä½ ä»¬ç”¨æŒ‡å°–ç»˜åˆ¶çš„æ˜Ÿç©ºï¼Œé‚£é‡Œç¹æ˜Ÿç‚¹ç‚¹ï¼Œæ¯ä¸€é¢—éƒ½åœ¨é¼“åŠ±ç€æ€€æ£ç€å¼€æºæ¢¦æƒ³çš„ç¨‹åºå‘˜æŠ«è†æ–©æ£˜ã€ä¸æ–­å‰è¡Œï¼Œä¸å¤¸å¼ çš„è¯´ï¼Œæ²¡æœ‰ä½ ä»¬ï¼Œå¼€æºä¸–ç•Œå°±æ²¡æœ‰æ˜Ÿå…‰ï¼Œè‡ªç„¶ä¹Ÿå°±ä¸ä¼šæœ‰ä»Šå¤©çš„å¼€æºç››ä¸–ã€‚

å› æ­¤ï¼Œ**æˆ‘æ³è¯·å¤§å®¶ï¼Œå¦‚æœè§‰å¾—ä¹¦è¿˜å¯ä»¥ï¼Œå°±åœ¨ä½ çš„æŒ‡å°–æ˜Ÿç©ºç»˜åˆ¶ä¸€é¢—æ–°çš„ ğŸŒŸï¼ŒæŒ‡å¼•æˆ‘ä»¬ç»§ç»­ç ¥ç ºå‰è¡Œ**ã€‚è¿™ä¸ªäººä¸–é—´ï¼Œå› å–„æ„è€Œç¾å¥½ã€‚

æœ€åï¼Œèƒ½é€šè¿‡å¼€æºåœ¨èŒ«èŒ«äººæµ·ä¸­ä¸å¤§å®¶ç›¸è¯†ï¼Œè¿™æ„Ÿè§‰çœŸå¥½ :D

## å¼€æºåè®®

åœ¨å¼€æºç‰ˆæƒä¸Šï¼Œæˆ‘ä»¬é€‰æ‹©äº† [No License](https://choosealicense.com/no-permission/)ï¼Œè¿™æ„å‘³ç€è¯»è€…å¯ä»¥éšæ„çš„ fork å’Œé˜…è¯»ï¼Œä½†æ˜¯**ä¸èƒ½ç§ä¸‹ä¿®æ”¹åå†åŒ…è£…åˆ†å‘**ï¼Œå¦‚æœæœ‰è¿™æ–¹é¢çš„éœ€æ±‚ï¼Œè¯·è”ç³»æˆ‘ä»¬ï¼Œæœ›ç†è§£ã€‚

## å€Ÿé‰´çš„ä¹¦ç±

ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼Œèƒ½å¸®æˆ‘ä»¬çœ‹çš„æ›´è¿œï¼Œç‰¹æ­¤æ„Ÿè°¢ä»¥ä¸‹å·¨äººï¼š

- [Rust Book](https://doc.rust-lang.org/book)
- [Rust nomicon](https://doc.rust-lang.org/nomicon/intro.html)
- [Async Rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)
- è¯¦ç»†æ¸…å•å‚è§ [è¿™é‡Œ](./assets/writing-material/books.md)

å› ä¸ºå®ƒä»¬ç»å¤§éƒ¨åˆ†æ˜¯æ”¯æŒ APACHE + MIT åŒåè®®çš„ï¼Œå› æ­¤æˆ‘ä»¬é€‰æ‹©äº†éµå¾ªå…¶ä¸­çš„ MIT åè®®ï¼Œå¹¶åœ¨è¿™é‡Œç»Ÿä¸€å¯¹å€Ÿé‰´çš„ä¹¦ç±è¿›è¡Œè¯´æ˜ã€‚

## ç¤¾åŒº & è¯»è€…äº¤æµ

- çŸ¥ä¹: [å­™é£ Sunface](https://www.zhihu.com/people/iSunface)
- RustCn å¾®ä¿¡äº¤æµ 2 ç¾¤ï¼š<img src="https://github.com/sunface/rust-course/assets/7036754/a84ec7e5-30b1-48da-9352-95503aa61a8f" width="200" /> 



- å¾®ä¿¡å…¬ä¼—å·: æ‰«æä¸‹é¢çš„äºŒç»´ç å…³æ³¨å…¬ä¼—å· `Rustè¯­è¨€ä¸­æ–‡ç½‘`

<img src="https://github.com/sunface/rust-course/blob/main/assets/studyrustå…¬ä¼—å·.png?raw=true" />



================================================
FILE: book.toml
================================================
[rust]
edition = "2021"   #åœ¨çº¿è¿è¡Œç”¨2021ç‰ˆæœ¬çš„

[book]
authors = ["sunface"]
language = "zh-CN"
title = "Rustè¯­è¨€åœ£ç»(Rust Course)"
src = "src"

[output.html]
additional-css = ["theme/style.css"]
additional-js = ["assets/custom.js", "assets/bigPicture.js"]
git-repository-url = "https://github.com/sunface/rust-course"
edit-url-template = "https://github.com/sunface/rust-course/edit/main/{path}"

[output.html.playground]
editable = true
copy-js = true
# line-numbers = true

[output.html.fold]
enable = true
level = 0



================================================
FILE: deploy.sh
================================================
## this script deploys the static website of course.rs to github pages

## build static website for book
mdbook build
## copy CNAME info to book dir
cp ./assets/CNAME ./book/
cp ./assets/*.html ./book/
cp ./assets/sitemap.xml ./book/

## init git repo
cd book
git init
git config user.name "sunface"
git config user.email "cto@188.com"
git add .
git commit -m 'deploy'
git branch -M gh-pages
git remote add origin https://github.com/sunface/rust-course

## push to github pages
git push -u -f origin gh-pages



================================================
FILE: genpdf.sh
================================================
#! /bin/sh

###########################################################
# Description:
#   This script write for mdbook project to generate pdf
###########################################################

cargo install mdbook mdbook-pdf
hasPdfSec=$(grep "output.pdf" ./book.toml)

if [ "$hasPdfSec" = "" ]; then
    echo "===>>> Backup book.toml file..."
    cp book.toml book.toml.bak
    cat >> book.toml << EOF

[output.pdf]
scale = 1
paper-width = 10
paper-height = 12
margin-top = 1
margin-bottom = 1
margin-left = 1
[output.pdf-outline]
EOF
fi
echo "===>>> Start build pdf..."
mdbook build
today=$(date +%Y%m%d)
echo "===>>> PDF rename to rust-curse-$today.pdf"
mv book/pdf/output.pdf rust-course.pdf
if [ -f book.toml.bak ]; then
    echo "===>>> Reverse book.toml file..."
    mv book.toml.bak book.toml
fi
exit 0



================================================
FILE: assets/bigPicture.js
================================================
var BigPicture=function(){var t,n,e,o,i,r,a,c,p,s,l,d,u,f,m,b,g,h,x,v,y,w,_,T,k,M,S,L,E,A,H,z,I,C=[],D={},O="appendChild",N="createElement",V="removeChild";function W(){var n=t.getBoundingClientRect();return"transform:translate3D("+(n.left-(e.clientWidth-n.width)/2)+"px, "+(n.top-(e.clientHeight-n.height)/2)+"px, 0) scale3D("+t.clientWidth/o.clientWidth+", "+t.clientHeight/o.clientHeight+", 0)"}function q(t){var n=A.length-1;if(!u){if(t>0&&E===n||t<0&&!E){if(!I.loop)return j(i,""),void setTimeout(j,9,i,"animation:"+(t>0?"bpl":"bpf")+" .3s;transition:transform .35s");E=t>0?-1:n+1}if([(E=Math.max(0,Math.min(E+t,n)))-1,E,E+1].forEach(function(t){if(t=Math.max(0,Math.min(t,n)),!D[t]){var e=A[t].src,o=document[N]("IMG");o.addEventListener("load",F.bind(null,e)),o.src=e,D[t]=o}}),D[E].complete)return B(t);u=1,j(m,"opacity:.4;"),e[O](m),D[E].onload=function(){y&&B(t)},D[E].onerror=function(){A[E]={error:"Error loading image"},y&&B(t)}}}function B(n){u&&(e[V](m),u=0);var r=A[E];if(r.error)alert(r.error);else{var a=e.querySelector("img:last-of-type");j(i=o=D[E],"animation:"+(n>0?"bpfl":"bpfr")+" .35s;transition:transform .35s"),j(a,"animation:"+(n>0?"bpfol":"bpfor")+" .35s both"),e[O](i),r.el&&(t=r.el)}H.innerHTML=E+1+"/"+A.length,X(A[E].caption),M&&M([i,A[E]])}function P(){var t,n,e=.95*window.innerHeight,o=.95*window.innerWidth,i=I.dimensions||[1920,1080],r=i[0],a=i[1],p=a/r;p>e/o?n=(t=Math.min(a,e))/p:t=(n=Math.min(r,o))*p,c.style.cssText+="width:"+n+"px;height:"+t+"px;"}function G(t){~[1,4].indexOf(o.readyState)?(U(),setTimeout(function(){o.play()},99)):o.error?U(t):f=setTimeout(G,35,t)}function R(n){I.noLoader||(n&&j(m,"top:"+t.offsetTop+"px;left:"+t.offsetLeft+"px;height:"+t.clientHeight+"px;width:"+t.clientWidth+"px"),t.parentElement[n?O:V](m),u=n)}function X(t){t&&(g.innerHTML=t),j(b,"opacity:"+(t?"1;pointer-events:auto":"0"))}function F(t){!~C.indexOf(t)&&C.push(t)}function U(t){if(u&&R(),T&&T(),"string"==typeof t)return $(),I.onError?I.onError():alert("Error: The requested "+t+" could not be loaded.");_&&F(s),o.style.cssText+=W(),j(e,"opacity:1;pointer-events:auto"),k=setTimeout(k,410),v=1,y=!!A,setTimeout(function(){o.style.cssText+="transition:transform .35s;transform:none",h&&setTimeout(X,250,h)},60)}function Y(t){var n=t?t.target:e,i=[b,x,r,a,g,L,S,m];n.blur(),w||~i.indexOf(n)||(o.style.cssText+=W(),j(e,"pointer-events:auto"),setTimeout($,350),clearTimeout(k),v=0,w=1)}function $(){if((o===c?p:o).removeAttribute("src"),document.body[V](e),e[V](o),j(e,""),j(o,""),X(0),y){for(var t=e.querySelectorAll("img"),n=0;n<t.length;n++)e[V](t[n]);u&&e[V](m),e[V](H),y=A=0,D={},z||e[V](S),z||e[V](L),i.onload=U,i.onerror=U.bind(null,"image")}I.onClose&&I.onClose(),w=u=0}function j(t,n){t.style.cssText=n}return function(w){var D;return n||function(){var t;function s(t){var n=document[N]("button");return n.className=t,n.innerHTML='<svg viewBox="0 0 48 48"><path d="M28 24L47 5a3 3 0 1 0-4-4L24 20 5 1a3 3 0 1 0-4 4l19 19L1 43a3 3 0 1 0 4 4l19-19 19 19a3 3 0 0 0 4 0v-4L28 24z"/></svg>',n}function d(t,n){var e=document[N]("button");return e.className="bp-lr",e.innerHTML='<svg viewBox="0 0 129 129" height="70" fill="#fff"><path d="M88.6 121.3c.8.8 1.8 1.2 2.9 1.2s2.1-.4 2.9-1.2a4.1 4.1 0 0 0 0-5.8l-51-51 51-51a4.1 4.1 0 0 0-5.8-5.8l-54 53.9a4.1 4.1 0 0 0 0 5.8l54 53.9z"/></svg>',j(e,n),e.onclick=function(n){n.stopPropagation(),q(t)},e}var f=document[N]("STYLE");f.innerHTML="#bp_caption,#bp_container{bottom:0;left:0;right:0;position:fixed;opacity:0}#bp_container>*,#bp_loader{position:absolute;right:0;z-index:10}#bp_container,#bp_caption,#bp_container svg{pointer-events:none}#bp_container{top:0;z-index:9999;background:rgba(0,0,0,.7);opacity:0;transition:opacity .35s}#bp_loader{top:0;left:0;bottom:0;display:flex;align-items:center;cursor:wait;background:0;z-index:9}#bp_loader svg{width:50%;max-width:300px;max-height:50%;margin:auto;animation:bpturn 1s infinite linear}#bp_aud,#bp_container img,#bp_sv,#bp_vid{user-select:none;max-height:96%;max-width:96%;top:0;bottom:0;left:0;margin:auto;box-shadow:0 0 3em rgba(0,0,0,.4);z-index:-1}#bp_sv{background:#111}#bp_sv svg{width:66px}#bp_caption{font-size:.9em;padding:1.3em;background:rgba(15,15,15,.94);color:#fff;text-align:center;transition:opacity .3s}#bp_aud{width:650px;top:calc(50% - 20px);bottom:auto;box-shadow:none}#bp_count{left:0;right:auto;padding:14px;color:rgba(255,255,255,.7);font-size:22px;cursor:default}#bp_container button{position:absolute;border:0;outline:0;background:0;cursor:pointer;transition:all .1s}#bp_container>.bp-x{padding:0;height:41px;width:41px;border-radius:100%;top:8px;right:14px;opacity:.8;line-height:1}#bp_container>.bp-x:focus,#bp_container>.bp-x:hover{background:rgba(255,255,255,.2)}.bp-x svg,.bp-xc svg{height:21px;width:20px;fill:#fff;vertical-align:top;}.bp-xc svg{width:16px}#bp_container .bp-xc{left:2%;bottom:100%;padding:9px 20px 7px;background:#d04444;border-radius:2px 2px 0 0;opacity:.85}#bp_container .bp-xc:focus,#bp_container .bp-xc:hover{opacity:1}.bp-lr{top:50%;top:calc(50% - 130px);padding:99px 0;width:6%;background:0;border:0;opacity:.4;transition:opacity .1s}.bp-lr:focus,.bp-lr:hover{opacity:.8}@keyframes bpf{50%{transform:translatex(15px)}100%{transform:none}}@keyframes bpl{50%{transform:translatex(-15px)}100%{transform:none}}@keyframes bpfl{0%{opacity:0;transform:translatex(70px)}100%{opacity:1;transform:none}}@keyframes bpfr{0%{opacity:0;transform:translatex(-70px)}100%{opacity:1;transform:none}}@keyframes bpfol{0%{opacity:1;transform:none}100%{opacity:0;transform:translatex(-70px)}}@keyframes bpfor{0%{opacity:1;transform:none}100%{opacity:0;transform:translatex(70px)}}@keyframes bpturn{0%{transform:none}100%{transform:rotate(360deg)}}@media (max-width:600px){.bp-lr{font-size:15vw}}",document.head[O](f),(e=document[N]("DIV")).id="bp_container",e.onclick=Y,l=s("bp-x"),e[O](l),"ontouchstart"in window&&(z=1,e.ontouchstart=function(n){var e=n.changedTouches;t=e[0].pageX},e.ontouchmove=function(t){t.preventDefault()},e.ontouchend=function(n){var e=n.changedTouches;if(y){var o=e[0].pageX-t;o<-30&&q(1),o>30&&q(-1)}}),i=document[N]("IMG"),(r=document[N]("VIDEO")).id="bp_vid",r.setAttribute("playsinline",1),r.controls=1,r.loop=1,(a=document[N]("audio")).id="bp_aud",a.controls=1,a.loop=1,(H=document[N]("span")).id="bp_count",(b=document[N]("DIV")).id="bp_caption",(x=s("bp-xc")).onclick=X.bind(null,0),b[O](x),g=document[N]("SPAN"),b[O](g),e[O](b),S=d(1,"transform:scalex(-1)"),L=d(-1,"left:0;right:auto"),(m=document[N]("DIV")).id="bp_loader",m.innerHTML='<svg viewbox="0 0 32 32" fill="#fff" opacity=".8"><path d="M16 0a16 16 0 0 0 0 32 16 16 0 0 0 0-32m0 4a12 12 0 0 1 0 24 12 12 0 0 1 0-24" fill="#000" opacity=".5"/><path d="M16 0a16 16 0 0 1 16 16h-4A12 12 0 0 0 16 4z"/></svg>',(c=document[N]("DIV")).id="bp_sv",(p=document[N]("IFRAME")).setAttribute("allowfullscreen",1),p.allow="autoplay; fullscreen",p.onload=function(){return c[V](m)},j(p,"border:0;position:absolute;height:100%;width:100%;left:0;top:0"),c[O](p),i.onload=U,i.onerror=U.bind(null,"image"),window.addEventListener("resize",function(){y||u&&R(1),o===c&&P()}),document.addEventListener("keyup",function(t){var n=t.keyCode;27===n&&v&&Y(),y&&(39===n&&q(1),37===n&&q(-1),38===n&&q(10),40===n&&q(-10))}),document.addEventListener("keydown",function(t){y&&~[37,38,39,40].indexOf(t.keyCode)&&t.preventDefault()}),document.addEventListener("focus",function(t){v&&!e.contains(t.target)&&(t.stopPropagation(),l.focus())},1),n=1}(),u&&(clearTimeout(f),$()),I=w,d=w.ytSrc||w.vimeoSrc,T=w.animationStart,k=w.animationEnd,M=w.onChangeImage,_=0,h=(t=w.el).getAttribute("data-caption"),w.gallery?function(n,r){var a=I.galleryAttribute||"data-bp";if(Array.isArray(n))A=n,h=n[E=r||0].caption;else{var c=(A=[].slice.call("string"==typeof n?document.querySelectorAll(n+" ["+a+"]"):n)).indexOf(t);E=0===r||r?r:-1!==c?c:0,A=A.map(function(t){return{el:t,src:t.getAttribute(a),caption:t.getAttribute("data-caption")}})}_=1,!~C.indexOf(s=A[E].src)&&R(1),A.length>1?(e[O](H),H.innerHTML=E+1+"/"+A.length,z||(e[O](S),e[O](L))):A=0,(o=i).src=s}(w.gallery,w.position):d||w.iframeSrc?(o=c,I.ytSrc?W="https://www.youtube.com/embed/"+d+"?html5=1&rel=0&playsinline=1&autoplay=1":I.vimeoSrc?W="https://player.vimeo.com/video/"+d+"?autoplay=1":I.iframeSrc&&(W=I.iframeSrc),j(m,""),c[O](m),p.src=W,P(),setTimeout(U,9)):w.imgSrc?(_=1,!~C.indexOf(s=w.imgSrc)&&R(1),(o=i).src=s):w.audio?(R(1),(o=a).src=w.audio,G("audio file")):w.vidSrc?(R(1),w.dimensions&&j(r,"width:"+w.dimensions[0]+"px"),D=w.vidSrc,Array.isArray(D)?(o=r.cloneNode(),D.forEach(function(t){var n=document[N]("SOURCE");n.src=t,n.type="video/"+t.match(/.(\w+)$/)[1],o[O](n)})):(o=r).src=D,G("video")):(o=i).src="IMG"===t.tagName?t.src:window.getComputedStyle(t).backgroundImage.replace(/^url|[(|)|'|"]/g,""),e[O](o),document.body[O](e),{close:Y,next:function(){return q(1)},prev:function(){return q(-1)}};var W}}();


================================================
FILE: assets/CNAME
================================================
course.rs


================================================
FILE: assets/custom.js
================================================
var initAll = function () {
    var path = window.location.pathname;
    if (path.endsWith("/print.html")) {
        return;
    }

    var images = document.querySelectorAll("main img")
    Array.prototype.forEach.call(images, function (img) {
        img.addEventListener("click", function () {
            BigPicture({
                el: img,
            });
        });
    });

    // Un-active everything when you click it
    Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
        el.addEventHandler("click", function () {
            Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
                el.classList.remove("active");
            });
            el.classList.add("active");
        });
    });

    var updateFunction = function () {
        var id = null;
        var elements = document.getElementsByClassName("header");
        Array.prototype.forEach.call(elements, function (el) {
            if (window.pageYOffset >= el.offsetTop) {
                id = el;
            }
        });

        Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
            el.classList.remove("active");
        });

        Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
            if (id == null) {
                return;
            }
            if (id.href.localeCompare(el.href) == 0) {
                el.classList.add("active");
            }
        });
    };

    var pagetoc = document.getElementsByClassName("pagetoc")[0];
    var elements = document.getElementsByClassName("header");
    Array.prototype.forEach.call(elements, function (el) {
        var link = document.createElement("a");

        // Indent shows hierarchy
        var indent = "";
        switch (el.parentElement.tagName) {
            case "H1":
                return;
            case "H3":
                indent = "20px";
                break;
            case "H4":
                indent = "40px";
                break;
            default:
                break;
        }

        link.appendChild(document.createTextNode(el.text));
        link.style.paddingLeft = indent;
        link.href = el.href;
        pagetoc.appendChild(link);
    });
    updateFunction.call();

    // Handle active elements on scroll
    window.addEventListener("scroll", updateFunction);

    document.getElementById("theme-list").addEventListener("click", function (e) {
        var iframe = document.querySelector('.giscus-frame');
        if (!iframe) return;
        var theme;
        if (e.target.className === "theme") {
            theme = e.target.id;
        } else {
            return;
        }

        // è‹¥å½“å‰ mdbook ä¸»é¢˜ä¸æ˜¯ Light æˆ– Rust ï¼Œåˆ™å°† giscuz ä¸»é¢˜è®¾ç½®ä¸º transparent_dark
        var giscusTheme = "light"
        if (theme != "light" && theme != "rust") {
            giscusTheme = "transparent_dark";
        }

        var msg = {
            setConfig: {
                theme: giscusTheme
            }
        };
        iframe.contentWindow.postMessage({ giscus: msg }, 'https://giscus.app');
    });
    
    pagePath = pagePath.replace("index.md", "");
    pagePath = pagePath.replace(".md", "");
    if (pagePath.length > 0) {
        if (pagePath.charAt(pagePath.length-1) == "/"){
            pagePath = pagePath.substring(0, pagePath.length-1)
        }
    }else {
        pagePath = "index"
    }

    // add visitors count
    var ele = document.createElement("div");
    ele.setAttribute("align","center");
    var count = document.createElement("img")
    count.setAttribute("src", "https://visitor-badge.glitch.me/badge?page_id=" + path);
    ele.appendChild(count);
    var divider =document.createElement("hr")

    document.getElementById("giscus-container").appendChild(ele);
    document.getElementById("giscus-container").appendChild(divider);

    // é€‰å–æµè§ˆå™¨é»˜è®¤ä½¿ç”¨çš„è¯­è¨€
    // const lang = navigator.language || navigator.userLanguage

    // è‹¥å½“å‰ mdbook ä¸»é¢˜ä¸º Light æˆ– Rust ï¼Œåˆ™å°† giscuz ä¸»é¢˜è®¾ç½®ä¸º light
    var theme = "transparent_dark";
    const themeClass = document.getElementsByTagName("html")[0].className;
    if (themeClass.indexOf("light") != -1 || themeClass.indexOf("rust") != -1) {
        theme = "light"
    }

    var script = document.createElement("script")
    script.type = "text/javascript";
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.crossOrigin = "anonymous";
    script.setAttribute("data-repo", "sunface/rust-course");
    script.setAttribute("data-repo-id", "MDEwOlJlcG9zaXRvcnkxNDM4MjIwNjk=");
    script.setAttribute("data-category", "ç« èŠ‚è¯„è®ºåŒº");
    script.setAttribute("data-category-id", "DIC_kwDOCJKM9c4COQcP");
    script.setAttribute("data-mapping", "specific");
    script.setAttribute("data-term", pagePath);
    script.setAttribute("data-reactions-enabled", "1");
    script.setAttribute("data-emit-metadata", "0");
    script.setAttribute("data-input-position", "top");
    script.setAttribute("data-theme", theme);
    // script.setAttribute("data-lang", lang);
    // é¢„å…ˆåŠ è½½è¯„è®ºä¼šæ›´å¥½ï¼Œè¿™æ ·ç”¨æˆ·è¯»åˆ°é‚£è¾¹æ—¶ï¼Œè¯„è®ºå°±åŠ è½½å¥½äº†
    // script.setAttribute("data-loading", "lazy");
    document.getElementById("giscus-container").appendChild(script);



};

window.addEventListener('load', initAll);


================================================
FILE: assets/sitemap.xml
================================================
ï»¿<?xml version='1.0' encoding='UTF-8'?>
<urlset>
<url>
<loc><![CDATA[http://course.rs]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/about-book.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/comment.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/crate.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/module.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/use.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/custom-type.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/formatted-output.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/closure.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/iterator.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/global-variable.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/hrtb.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/advance.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/basic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/message-passing.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/races.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/ref-counter-lock.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/send-sync.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/thread.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/box.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/cell.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/deref-drop.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/rc-refcell.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/self-referrence.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/derive.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/difficulties.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/expressions.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/keywords]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/keywords.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/operators.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/prelude.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/rust-version.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/char-bool.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/function.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/numbers]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/numbers.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/statement-expression.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/hashmap.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/vector.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/array]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/array.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/enum.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/string-slice]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/string-slice.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/struct.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/tuple.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/converse.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/errors/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/exception-error.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/first-try/cargo.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/flow-control.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/all-patterns.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/match-if-let]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/match-if-let.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/option.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/pattern-match.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/method.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/borrowing.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/ownership.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/panic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/result.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/advance-trait.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/generic]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/generic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait-object]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait-object.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/variable.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/build-js.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/cache.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/cargo-toml-lock.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/commands.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/dependency.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/feature.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/layout.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/manifest.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/profile.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/version.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/workspace.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/cdn-cgi/l/email-protection]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/attributes.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/speed-up.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/spped-up.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/core/ownership.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/panic-codes.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/panic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/pretty-format.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/simplify.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/user-define.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/loop.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/too-long1.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/too-long2.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/phantom-data.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/unconstrained.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/cargo.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/editor.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/hello-world.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/installation.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/into-rust.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/command/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/command/structopt.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/http/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/http/reqwest.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/json/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/json/serde.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/intro]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/procedure-macro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/allocation.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/layout.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/pointer-ref.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/uninit.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/virtual.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/apm.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/log.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/observability.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/async-await.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/future.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/into.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/multi-futures.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/system-io.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/task-excutor.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/task-schedule.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/workarounds.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/http.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/pin-unpin.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/basic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/stream.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/concurrency-parallelism.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/tcp.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/characteristics.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/design-pattern.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/trait-object.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/benchmark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/calculate.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/clone-copy.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/cpu-cache.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/deep-into-move.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/early-optimise.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/heap-stack.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/runtime-check.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/tools.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/arithmetic-overflow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/closure-with-lifetime.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/lazy-iterators.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/multiple-mutable-references.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/stack-overflow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/the-disabled-mutability.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/use-vec-in-for.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/weird-ranges.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/best-pratice.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/coding-tips.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/third-party-libs.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/print.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/hashmap.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/iterator.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/search.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/vector.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/clippy.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/code.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/mark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/naming.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/benchmark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/ci.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/intergration.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/unit.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/as-ref-as-mut.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/borrow-family.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/cow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/deref.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/eq.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/from-into.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/ffi.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/modify-global-var.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/raw-pointer.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/ub.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/web/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/web/serialization.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
</urlset>


================================================
FILE: assets/rustlings-zh/README.md
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/Cargo.toml
================================================
[package]
name = "rustlings"
version = "4.6.0"
authors = []
edition = "2021"

[dependencies]
argh = "0.1.4"
indicatif = "0.10.3"
console = "0.7.7"
notify = "4.0.15"
toml = "0.4.10"
regex = "1.5.5"
serde = {version = "1.0.10", features = ["derive"]}

[[bin]]
name = "rustlings"
path = "src/main.rs"

[dev-dependencies]
assert_cmd = "0.11.0"
predicates = "1.0.1"
glob = "0.3.0"



================================================
FILE: assets/rustlings-zh/CHANGELOG.md
================================================
<a name="4.6.0"></a>
## 4.6.0 (2021-09-25)


#### Features

*   add advanced_errs2 ([abd6b70c](https://github.com/rust-lang/rustlings/commit/abd6b70c72dc6426752ff41f09160b839e5c449e))
*   add advanced_errs1 ([882d535b](https://github.com/rust-lang/rustlings/commit/882d535ba8628d5e0b37e8664b3e2f26260b2671))
*   Add a farewell message when quitting `watch` ([1caef0b4](https://github.com/rust-lang/rustlings/commit/1caef0b43494c8b8cdd6c9260147e70d510f1aca))
*   add more watch commands ([a7dc080b](https://github.com/rust-lang/rustlings/commit/a7dc080b95e49146fbaafe6922a6de2f8cb1582a), closes [#842](https://github.com/rust-lang/rustlings/issues/842))
* **modules:**  update exercises, add modules3 (#822) ([dfd2fab4](https://github.com/rust-lang/rustlings/commit/dfd2fab4f33d1bf59e2e5ee03123c0c9a67a9481))
* **quiz1:**  add default function name in comment (#838) ([0a11bad7](https://github.com/rust-lang/rustlings/commit/0a11bad71402b5403143d642f439f57931278c07))

#### Bug Fixes

*   Correct small typo in exercises/conversions/from_str.rs ([86cc8529](https://github.com/rust-lang/rustlings/commit/86cc85295ae36948963ae52882e285d7e3e29323))
* **cli:**  typo in exercise.rs (#848) ([06d5c097](https://github.com/rust-lang/rustlings/commit/06d5c0973a3dffa3c6c6f70acb775d4c6630323c))
* **from_str, try_from_into:**  custom error types ([2dc93cad](https://github.com/rust-lang/rustlings/commit/2dc93caddad43821743e4903d89b355df58d7a49))
* **modules2:**  fix typo (#835) ([1c3beb0a](https://github.com/rust-lang/rustlings/commit/1c3beb0a59178c950dc05fe8ee2346b017429ae0))
* **move_semantics5:**
  *  change &mut *y to &mut x (#814) ([d75759e8](https://github.com/rust-lang/rustlings/commit/d75759e829fdcd64ef071cf4b6eae2a011a7718b))
  *  Clarify instructions ([df25684c](https://github.com/rust-lang/rustlings/commit/df25684cb79f8413915e00b5efef29369849cef1))
* **quiz1:**  Fix inconsistent wording (#826) ([03131a3d](https://github.com/rust-lang/rustlings/commit/03131a3d35d9842598150f9da817f7cc26e2669a))



<a name="4.5.0"></a>
## 4.5.0 (2021-07-07)


#### Features

*   Add move_semantics5 exercise. (#746) ([399ab328](https://github.com/rust-lang/rustlings/commit/399ab328d8d407265c09563aa4ef4534b2503ff2))
* **cli:**  Add "next" to run the next unsolved exercise. (#785) ([d20e413a](https://github.com/rust-lang/rustlings/commit/d20e413a68772cd493561f2651cf244e822b7ca5))

#### Bug Fixes

*   rename result1 to errors4 ([50ab289d](https://github.com/rust-lang/rustlings/commit/50ab289da6b9eb19a7486c341b00048c516b88c0))
*   move_semantics5 hints ([1b858285](https://github.com/rust-lang/rustlings/commit/1b85828548f46f58b622b5e0c00f8c989f928807))
*   remove trailing whitespaces from iterators1 ([4d4fa774](https://github.com/rust-lang/rustlings/commit/4d4fa77459392acd3581c6068aa8be9a02de12fc))
*   add hints to generics1 and generics2 exercises ([31457940](https://github.com/rust-lang/rustlings/commit/31457940846b3844d78d4a4d2b074bc8d6aaf1eb))
*   remove trailing whitespace ([d9b69bd1](https://github.com/rust-lang/rustlings/commit/d9b69bd1a0a7a99f2c0d80933ad2eea44c8c71b2))
* **installation:**  first PowerShell command ([aa9a943d](https://github.com/rust-lang/rustlings/commit/aa9a943ddf3ae260782e73c26bcc9db60e5894b6))
* **iterators5:**  derive Clone, Copy ([91fc9e31](https://github.com/rust-lang/rustlings/commit/91fc9e3118f4af603c9911698cc2a234725cb032))
* **quiz1:**  Updated question description (#794) ([d8766496](https://github.com/rust-lang/rustlings/commit/d876649616cc8a8dd5f539f8bc1a5434b960b1e9))
* **try_from_into, from_str:**  hints for dyn Error ([11d2cf0d](https://github.com/rust-lang/rustlings/commit/11d2cf0d604dee3f5023c17802d69438e69fa50e))
* **variables5:**  confine the answer further ([48ffcbd2](https://github.com/rust-lang/rustlings/commit/48ffcbd2c4cc4d936c2c7480019190f179813cc5))



<a name="4.4.0"></a>
## 4.4.0 (2021-04-24)


#### Bug Fixes

*   Fix spelling error in main.rs ([91ee27f2](https://github.com/rust-lang/rustlings/commit/91ee27f22bd3797a9db57e5fd430801c170c5db8))
*   typo in default out text ([644c49f1](https://github.com/rust-lang/rustlings/commit/644c49f1e04cbb24e95872b3a52b07d692ae3bc8))
* **collections:**  Naming exercises for vectors and hashmap ([bef39b12](https://github.com/rust-lang/rustlings/commit/bef39b125961310b34b34871e480a82e82af4678))
* **from_str:**
  *  Correct typos ([5f7c89f8](https://github.com/rust-lang/rustlings/commit/5f7c89f85db1f33da01911eaa479c3a2d4721678))
  *  test for error instead of unwrap/should_panic ([15e71535](https://github.com/rust-lang/rustlings/commit/15e71535f37cfaed36e22eb778728d186e2104ab))
  *   use trait objects for from_str ([c3e7b831](https://github.com/rust-lang/rustlings/commit/c3e7b831786c9172ed8bd5d150f3c432f242fba9))
* **functions3:**  improve function argument type (#687) ([a6509cc4](https://github.com/rust-lang/rustlings/commit/a6509cc4d545d8825f01ddf7ee37823b372154dd))
* **hashmap2:**  Update incorrect assertion (#660) ([72aaa15e](https://github.com/rust-lang/rustlings/commit/72aaa15e6ab4b72b3422f1c6356396e20a2a2bb8))
* **info:**  Fix typo (#635) ([cddc1e86](https://github.com/rust-lang/rustlings/commit/cddc1e86e7ec744ee644cc774a4887b1a0ded3e8))
* **iterators2:**  Moved errors out of tests. ([baf4ba17](https://github.com/rust-lang/rustlings/commit/baf4ba175ba6eb92989e3dd54ecbec4bedc9a863), closes [#359](https://github.com/rust-lang/rustlings/issues/359))
* **iterators3:**  Enabled iterators3.rs to run without commented out tests. ([c6712dfc](https://github.com/rust-lang/rustlings/commit/c6712dfccd1a093e590ad22bbc4f49edc417dac0))
* **main:**  Let find_exercise work with borrows ([347f30bd](https://github.com/rust-lang/rustlings/commit/347f30bd867343c5ace1097e085a1f7e356553f7))
* **move_semantics4:**
  *  Remove redundant "instead" (#640) ([cc266d7d](https://github.com/rust-lang/rustlings/commit/cc266d7d80b91e79df3f61984f231b7f1587218e))
  *  Small readbility improvement (#617) ([10965920](https://github.com/rust-lang/rustlings/commit/10965920fbdf8a1efc85bed869e55a1787006404))
* **option2:**  Rename uninformative variables (#675) ([b4de6594](https://github.com/rust-lang/rustlings/commit/b4de6594380636817d13c2677ec6f472a964cf43))
* **quiz3:**  Force an answer to Q2 (#672) ([0d894e6f](https://github.com/rust-lang/rustlings/commit/0d894e6ff739943901e1ae8c904582e5c2f843bd))
* **structs:**  Add 5.3 to structs/README (#652) ([6bd791f2](https://github.com/rust-lang/rustlings/commit/6bd791f2f44aa7f0ad926df767f6b1fa8f12a9a9))
* **structs2:**  correct grammar in hint (#663) ([ebdb66c7](https://github.com/rust-lang/rustlings/commit/ebdb66c7bfb6d687a14cc511a559a222e6fc5de4))
* **structs3:**
  * reword heading comment (#664) ([9f3e8c2d](https://github.com/rust-lang/rustlings/commit/9f3e8c2dde645e5264c2d2200e68842b5f47bfa3))
  *   add check to prevent naive implementation of is_international ([05a753fe](https://github.com/rust-lang/rustlings/commit/05a753fe6333d36dbee5f68c21dec04eacdc75df))
* **threads1:**  line number correction ([7857b0a6](https://github.com/rust-lang/rustlings/commit/7857b0a689b0847f48d8c14cbd1865e3b812d5ca))
* **try_from_into:**  use trait objects ([2e93a588](https://github.com/rust-lang/rustlings/commit/2e93a588e0abe8badb7eafafb9e7d073c2be5df8))

#### Features

*   Replace clap with argh ([7928122f](https://github.com/rust-lang/rustlings/commit/7928122fcef9ca7834d988b1ec8ca0687478beeb))
*   Replace emojis when NO_EMOJI env variable present ([8d62a996](https://github.com/rust-lang/rustlings/commit/8d62a9963708dbecd9312e8bcc4b47049c72d155))
*   Added iterators5.rs exercise. ([b29ea17e](https://github.com/rust-lang/rustlings/commit/b29ea17ea94d1862114af2cf5ced0e09c197dc35))
* **arc1:**  Add more details to description and hint (#710) ([81be4044](https://github.com/rust-lang/rustlings/commit/81be40448777fa338ebced3b0bfc1b32d6370313))
* **cli:**  Improve the list command with options, and then some ([8bbe4ff1](https://github.com/rust-lang/rustlings/commit/8bbe4ff1385c5c169c90cd3ff9253f9a91daaf8e))
* **list:**
  *  updated progress percentage ([1c6f7e4b](https://github.com/rust-lang/rustlings/commit/1c6f7e4b7b9b3bd36f4da2bb2b69c549cc8bd913))
  *  added progress info ([c0e3daac](https://github.com/rust-lang/rustlings/commit/c0e3daacaf6850811df5bc57fa43e0f249d5cfa4))



<a name="4.3.0"></a>
## 4.3.0 (2020-12-29)

#### Features

*   Rewrite default out text ([44d39112](https://github.com/rust-lang/rustlings/commit/44d39112ff122b29c9793fe52e605df1612c6490))
*   match exercise order to book chapters (#541) ([033bf119](https://github.com/rust-lang/rustlings/commit/033bf1198fc8bfce1b570e49da7cde010aa552e3))
*   Crab? (#586) ([fa9f522b](https://github.com/rust-lang/rustlings/commit/fa9f522b7f043d7ef73a39f003a9272dfe72c4f4))
*   add "rustlings list" command ([838f9f30](https://github.com/rust-lang/rustlings/commit/838f9f30083d0b23fd67503dcf0fbeca498e6647))
* **try_from_into:**  remove duplicate annotation ([04f1d079](https://github.com/rust-lang/rustlings/commit/04f1d079aa42a2f49af694bc92c67d731d31a53f))

#### Bug Fixes

*   update structs README ([bcf14cf6](https://github.com/rust-lang/rustlings/commit/bcf14cf677adb3a38a3ac3ca53f3c69f61153025))
*   added missing exercises to info.toml ([90cfb6ff](https://github.com/rust-lang/rustlings/commit/90cfb6ff28377531bfc34acb70547bdb13374f6b))
*   gives a bit more context to magic number ([30644c9a](https://github.com/rust-lang/rustlings/commit/30644c9a062b825c0ea89435dc59f0cad86b110e))
* **functions2:**  Change signature to trigger precise error message: (#605) ([0ef95947](https://github.com/rust-lang/rustlings/commit/0ef95947cc30482e63a7045be6cc2fb6f6dcb4cc))
* **structs1:**  Adjust wording (#573) ([9334783d](https://github.com/rust-lang/rustlings/commit/9334783da31d821cc59174fbe8320df95828926c))
* **try_from_into:**
  *  type error ([4f4cfcf3](https://github.com/rust-lang/rustlings/commit/4f4cfcf3c36c8718c7c170c9c3a6935e6ef0618c))
  *  Update description (#584) ([96347df9](https://github.com/rust-lang/rustlings/commit/96347df9df294f01153b29d9ad4ba361f665c755))
* **vec1:**  Have test compare every element in a and v ([9b6c6293](https://github.com/rust-lang/rustlings/commit/9b6c629397b24b944f484f5b2bbd8144266b5695))

<a name="4.2.0"></a>
## 4.2.0 (2020-11-07)

#### Features

*   Add HashMap exercises ([633c00cf](https://github.com/rust-lang/rustlings/commit/633c00cf8071e1e82959a3010452a32f34f29fc9))
*   Add Vec exercises ([0c12fa31](https://github.com/rust-lang/rustlings/commit/0c12fa31c57c03c6287458a0a8aca7afd057baf6))
* **primitive_types6:**  Add a test (#548) ([2b1fb2b7](https://github.com/rust-lang/rustlings/commit/2b1fb2b739bf9ad8d6b7b12af25fee173011bfc4))
* **try_from_into:**  Add tests (#571) ([95ccd926](https://github.com/rust-lang/rustlings/commit/95ccd92616ae79ba287cce221101e0bbe4f68cdc))

#### Bug Fixes

*   log error output when inotify limit is exceeded ([d61b4e5a](https://github.com/rust-lang/rustlings/commit/d61b4e5a13b44d72d004082f523fa1b6b24c1aca))
*   more unique temp_file ([5643ef05](https://github.com/rust-lang/rustlings/commit/5643ef05bc81e4a840e9456f4406a769abbe1392))
* **installation:**  Update the MinRustVersion ([21bfb2d4](https://github.com/rust-lang/rustlings/commit/21bfb2d4777429c87d8d3b5fbf0ce66006dcd034))
* **iterators2:**  Update description (#578) ([197d3a3d](https://github.com/rust-lang/rustlings/commit/197d3a3d8961b2465579218a6749b2b2cefa8ddd))
* **primitive_types6:**
  *  remove 'unused doc comment' warning ([472d8592](https://github.com/rust-lang/rustlings/commit/472d8592d65c8275332a20dfc269e7ac0d41bc88))
  *  missing comma in test ([4fb230da](https://github.com/rust-lang/rustlings/commit/4fb230daf1251444fcf29e085cee222a91f8a37e))
* **quiz3:**  Second test is for odd numbers, not even. (#553) ([18e0bfef](https://github.com/rust-lang/rustlings/commit/18e0bfef1de53071e353ba1ec5837002ff7290e6))

<a name="4.1.0"></a>
## 4.1.0 (2020-10-05)

#### Bug Fixes

*   Update rustlings version in Cargo.lock ([1cc40bc9](https://github.com/rust-lang/rustlings/commit/1cc40bc9ce95c23d56f6d91fa1c4deb646231fef))
* **arc1:**  index mod should equal thread count ([b4062ef6](https://github.com/rust-lang/rustlings/commit/b4062ef6993e80dac107c4093ea85166ad3ee0fa))
* **enums3:**  Update Message::ChangeColor to take a tuple. (#457) ([4b6540c7](https://github.com/rust-lang/rustlings/commit/4b6540c71adabad647de8a09e57295e7c7c7d794))
* **exercises:**  adding question mark to quiz2 ([101072ab](https://github.com/rust-lang/rustlings/commit/101072ab9f8c80b40b8b88cb06cbe38aca2481c5))
* **generics3:**  clarify grade change ([47f7672c](https://github.com/rust-lang/rustlings/commit/47f7672c0307732056e7426e81d351f0dd7e22e5))
* **structs3:**  Small adjustment of variable name ([114b54cb](https://github.com/rust-lang/rustlings/commit/114b54cbdb977234b39e5f180d937c14c78bb8b2))
* **using_as:**  Add test so that proper type is returned. (#512) ([3286c5ec](https://github.com/rust-lang/rustlings/commit/3286c5ec19ea5fb7ded81d047da5f8594108a490))

#### Features

*   Added iterators1.rs exercise ([9642f5a3](https://github.com/rust-lang/rustlings/commit/9642f5a3f686270a4f8f6ba969919ddbbc4f7fdd))
*   Add ability to run rustlings on repl.it (#471) ([8f7b5bd0](https://github.com/rust-lang/rustlings/commit/8f7b5bd00eb83542b959830ef55192d2d76db90a))
*   Add gitpod support (#473) ([4821a8be](https://github.com/rust-lang/rustlings/commit/4821a8be94af4f669042a06ab917934cfacd032f))
*   Remind the user of the hint option (#425) ([816b1f5e](https://github.com/rust-lang/rustlings/commit/816b1f5e85d6cc6e72673813a85d0ada2a8f84af))
*   Remind the user of the hint option (#425) ([9f61db5d](https://github.com/rust-lang/rustlings/commit/9f61db5dbe38538cf06571fcdd5f806e7901e83a))
* **cli:**  Added 'cls' command to 'watch' mode (#474) ([4f2468e1](https://github.com/rust-lang/rustlings/commit/4f2468e14f574a93a2e9b688367b5752ed96ae7b))
* **try_from_into:**  Add insufficient length test (#469) ([523d18b8](https://github.com/rust-lang/rustlings/commit/523d18b873a319f7c09262f44bd40e2fab1830e5))

<a name="4.0.0"></a>
## 4.0.0 (2020-07-08)

#### Breaking Changes

*   Add a --nocapture option to display test harnesses' outputs ([8ad5f9bf](https://github.com/rust-lang/rustlings/commit/8ad5f9bf531a4848b1104b7b389a20171624c82f))
*   Rename test to quiz, fixes #244 ([010a0456](https://github.com/rust-lang/rustlings/commit/010a04569282149cea7f7a76fc4d7f4c9f0f08dd))

#### Features

*   Add traits README ([173bb141](https://github.com/rust-lang/rustlings/commit/173bb14140c5530cbdb59e53ace3991a99d804af))
*   Add box1.rs exercise ([7479a473](https://github.com/rust-lang/rustlings/commit/7479a4737bdcac347322ad0883ca528c8675e720))
*   Rewrite try_from_into (#393) ([763aa6e3](https://github.com/rust-lang/rustlings/commit/763aa6e378a586caae2d8d63755a85eeba227933))
*   Add if2 exercise ([1da84b5f](https://github.com/rust-lang/rustlings/commit/1da84b5f7c489f65bd683c244f13c7d1ee812df0))
*   Added exercise structs3.rs ([b66e2e09](https://github.com/rust-lang/rustlings/commit/b66e2e09622243e086a0f1258dd27e1a2d61c891))
*   Add exercise variables6 covering const (#352) ([5999acd2](https://github.com/rust-lang/rustlings/commit/5999acd24a4f203292be36e0fd18d385887ec481))

#### Bug Fixes

*   Change then to than ([ddd98ad7](https://github.com/rust-lang/rustlings/commit/ddd98ad75d3668fbb10eff74374148aa5ed2344d))
*   rename quiz1 to tests1 in info (#420) ([0dd1c6ca](https://github.com/rust-lang/rustlings/commit/0dd1c6ca6b389789e0972aa955fe17aa15c95f29))
*   fix quiz naming inconsistency (#421) ([5563adbb](https://github.com/rust-lang/rustlings/commit/5563adbb890587fc48fbbc9c4028642687f1e85b))
*   confine the user further in variable exercises ([06ef4cc6](https://github.com/rust-lang/rustlings/commit/06ef4cc654e75d22a526812919ee49b8956280bf))
*   update iterator and macro text for typos and clarity ([95900828](https://github.com/rust-lang/rustlings/commit/959008284834bece0196a01e17ac69a7e3590116))
*   update generics2       closes #362 ([964c974a](https://github.com/rust-lang/rustlings/commit/964c974a0274199d755073b917c2bc5da0c9b4f1))
*   confusing comment in conversions/try_from_into.rs ([c9e4f2cf](https://github.com/rust-lang/rustlings/commit/c9e4f2cfb4c48d0b7451263cfb43b9426438122d))
* **arc1:**  Passively introduce attributes (#429) ([113cdae2](https://github.com/rust-lang/rustlings/commit/113cdae2d4e4c55905e8056ad326ede7fd7de356))
* **box1:**  fix comment typo (#426) ([bb2ca251](https://github.com/rust-lang/rustlings/commit/bb2ca251106b27a7272d9a30872904dd1376654c))
* **errorsn:**  Try harder to confine the user. (#388) ([2b20c8a0](https://github.com/rust-lang/rustlings/commit/2b20c8a0f5774d07c58d110d75879f33fc6273b5))
* **from_into.rs:**  typo ([a901499e](https://github.com/rust-lang/rustlings/commit/a901499ededd3ce1995164700514fe4e9a0373ea))
* **generics2:**  Guide students to the answer (#430) ([e6bd8021](https://github.com/rust-lang/rustlings/commit/e6bd8021d9a7dd06feebc30c9d5f953901d7b419))
* **installation:**
  *  Provide a backup git reference when tag can't be curl ([9e4fb100](https://github.com/rust-lang/rustlings/commit/9e4fb1009f1c9e3433915c03e22c2af422e5c5fe))
  *  Check if python is available while checking for git,rustc and cargo ([9cfb617d](https://github.com/rust-lang/rustlings/commit/9cfb617d5b0451b4b51644a1298965390cda9884))
* **option1:**
  *  Don't add only zeros to the numbers array ([cce6a442](https://github.com/rust-lang/rustlings/commit/cce6a4427718724a9096800754cd3abeca6a1580))
  *  Add cast to usize, as it is confusing in the context of an exercise about Option ([f6cffc7e](https://github.com/rust-lang/rustlings/commit/f6cffc7e487b42f15a6f958e49704c93a8d4465b))
* **option2:**  Add TODO to comments (#400) ([10967bce](https://github.com/rust-lang/rustlings/commit/10967bce57682812dc0891a9f9757da1a9d87404))
* **options1:**  Add hint about Array Initialization (#389) ([9f75554f](https://github.com/rust-lang/rustlings/commit/9f75554f2a30295996f03f0160b98c0458305502))
* **test2:**  name of type String and &str (#394) ([d6c0a688](https://github.com/rust-lang/rustlings/commit/d6c0a688e6a96f93ad60d540d4b326f342fc0d45))
* **variables6:**  minor typo (#419) ([524e17df](https://github.com/rust-lang/rustlings/commit/524e17df10db95f7b90a0f75cc8997182a8a4094))

<a name="3.0.0"></a>
## 3.0.0 (2020-04-11)

#### Breaking Changes

* make "compile" exercises print output (#278) ([3b6d5c](https://github.com/fmoko/rustlings/commit/3b6d5c3aaa27a242a832799eb66e96897d26fde3))

#### Bug Fixes

* **primitive_types:** revert primitive_types4 (#296) ([b3a3351e](https://github.com/rust-lang/rustlings/commit/b3a3351e8e6a0bdee07077d7b0382953821649ae))
* **run:**  compile clippy exercise files (#295) ([3ab084a4](https://github.com/rust-lang/rustlings/commit/3ab084a421c0f140ae83bf1fc3f47b39342e7373))
* **conversions:**
  * add additional test to meet exercise rules (#284) ([bc22ec3](https://github.com/fmoko/rustlings/commit/bc22ec382f843347333ef1301fc1bad773657f38))
  * remove duplicate not done comment (#292) ([dab90f](https://github.com/fmoko/rustlings/commit/dab90f7b91a6000fe874e3d664f244048e5fa342))
* don't hardcode documentation version for traits (#288) ([30e6af](https://github.com/fmoko/rustlings/commit/30e6af60690c326fb5d3a9b7335f35c69c09137d))

#### Features

*   add Option2 exercise (#290) ([86b5c08b](https://github.com/rust-lang/rustlings/commit/86b5c08b9bea1576127a7c5f599f5752072c087d))
*   add exercise for option (#282) ([135e5d47](https://github.com/rust-lang/rustlings/commit/135e5d47a7c395aece6f6022117fb20c82f2d3d4))
*   add new exercises for generics (#280) ([76be5e4e](https://github.com/rust-lang/rustlings/commit/76be5e4e991160f5fd9093f03ee2ba260e8f7229))
* **ci:**  add buildkite config ([b049fa2c](https://github.com/rust-lang/rustlings/commit/b049fa2c84dba0f0c8906ac44e28fd45fba51a71))

<a name="2.2.1"></a>
### 2.2.1 (2020-02-27)

#### Bug Fixes

*   Re-add cloning the repo to install scripts ([3d9b03c5](https://github.com/rust-lang/rustlings/commit/3d9b03c52b8dc51b140757f6fd25ad87b5782ef5))

#### Features

*   Add clippy lints (#269) ([1e2fd9c9](https://github.com/rust-lang/rustlings/commit/1e2fd9c92f8cd6e389525ca1a999fca4c90b5921))

<a name="2.2.0"></a>
## 2.2.0 (2020-02-25)


#### Bug Fixes

*   Update deps to version compatable with aarch64-pc-windows (#263) ([19a93428](https://github.com/rust-lang/rustlings/commit/19a93428b3c73d994292671f829bdc8e5b7b3401))
* **docs:**
  * Added a necessary step to Windows installation process (#242) ([3906efcd](https://github.com/rust-lang/rustlings/commit/3906efcd52a004047b460ed548037093de3f523f))
  * Fixed mangled sentence from book; edited for clarity (#266) ([ade52ff](https://github.com/rust-lang/rustlings/commit/ade52ffb739987287ddd5705944c8777705faed9))
  * Updated iterators readme to account for iterators4 exercise (#273) ([bec8e3a](https://github.com/rust-lang/rustlings/commit/bec8e3a644cbd88db1c73ea5f1d8a364f4a34016))
* **installation:**  make fatal errors more obvious (#272) ([17d0951e](https://github.com/rust-lang/rustlings/commit/17d0951e66fda8e11b204d5c4c41a0d5e22e78f7))
* **iterators2:**
  *  Remove reference to missing iterators2.rs (#245) ([419f7797](https://github.com/rust-lang/rustlings/commit/419f7797f294e4ce6a2b883199731b5bde77d262))
* **as_ref_mut:** Enable a test and improve per clippy's suggestion (#256) ([dfdf809](https://github.com/rust-lang/rustlings/commit/dfdf8093ebbd4145864995627b812780de52f902))
* **tests1:**
  * Change test command ([fe10e06c](https://github.com/rust-lang/rustlings/commit/fe10e06c3733ddb4a21e90d09bf79bfe618e97ce)
  * Correct test command in tests1.rs comment (#263) ([39fa7ae](https://github.com/rust-lang/rustlings/commit/39fa7ae8b70ad468da49b06f11b2383135a63bcf))

#### Features

*   Add variables5.rs exercise (#264) ([0c73609e](https://github.com/rust-lang/rustlings/commit/0c73609e6f2311295e95d6f96f8c747cfc4cba03))
*   Show a completion message when watching (#253) ([d25ee55a](https://github.com/rust-lang/rustlings/commit/d25ee55a3205882d35782e370af855051b39c58c))
*   Add type conversion and parsing exercises (#249) ([0c85dc11](https://github.com/rust-lang/rustlings/commit/0c85dc1193978b5165491b99cc4922caf8d14a65))
*   Created consistent money unit (#258) ([fd57f8f](https://github.com/rust-lang/rustlings/commit/fd57f8f2c1da2af8ddbebbccec214e6f40f4dbab))
*   Enable test for exercise test4 (#276) ([8b971ff](https://github.com/rust-lang/rustlings/commit/8b971ffab6079a706ac925f5917f987932b55c07))
*   Added traits exercises (#274 but specifically #216, which originally added
    this :heart:) ([b559cdd](https://github.com/rust-lang/rustlings/commit/b559cdd73f32c0d0cfc1feda39f82b3e3583df17))


<a name="2.1.0"></a>
## 2.1.0 (2019-11-27)

#### Bug Fixes

* add line numbers in several exercises and hints ([b565c4d3](https://github.com/rust-lang/rustlings/commit/b565c4d3e74e8e110bef201a082fa1302722a7c3))
* **arc1:**  Fix some words in the comment ([c42c3b21](https://github.com/rust-lang/rustlings/commit/c42c3b2101df9164c8cd7bb344def921e5ba3e61))
* **enums:**  Add link to chapter on pattern syntax (#242) ([615ce327](https://github.com/rust-lang/rustlings/commit/615ce3279800c56d89f19d218ccb7ef576624feb))
* **primitive_types4:**
  *  update outdated hint ([4c5189df](https://github.com/rust-lang/rustlings/commit/4c5189df2bdd9a231f6b2611919ba5aa14da0d3f))
  *  update outdated comment ([ded2c034](https://github.com/rust-lang/rustlings/commit/ded2c034ba93fa1e3c2c2ea16b83abc1a57265e8))
* **strings2:**  update line number in hint ([a09f684f](https://github.com/rust-lang/rustlings/commit/a09f684f05c58d239a6fc59ec5f81c2533e8b820))
* **variables1:**  Correct wrong word in comment ([fda5a470](https://github.com/rust-lang/rustlings/commit/fda5a47069e0954f16a04e8e50945e03becb71a5))

#### Features

* **watch:**  show hint while watching ([8143d57b](https://github.com/rust-lang/rustlings/commit/8143d57b4e88c51341dd4a18a14c536042cc009c))

<a name="2.0.0"></a>
## 2.0.0 (2019-11-12)

#### Bug Fixes

* **default:**  Clarify the installation procedure ([c371b853](https://github.com/rust-lang/rustlings/commit/c371b853afa08947ddeebec0edd074b171eeaae0))
* **info:**  Fix trailing newlines for hints ([795b6e34](https://github.com/rust-lang/rustlings/commit/795b6e348094a898e9227a14f6232f7bb94c8d31))
* **run:**  make `run` never prompt ([4b265465](https://github.com/rust-lang/rustlings/commit/4b26546589f7d2b50455429482cf1f386ceae8b3))

#### Breaking Changes

*   Refactor hint system ([9bdb0a12](https://github.com/rust-lang/rustlings/commit/9bdb0a12e45a8e9f9f6a4bd4a9c172c5376c7f60))
*   improve `watch` execution mode ([2cdd6129](https://github.com/rust-lang/rustlings/commit/2cdd61294f0d9a53775ee24ad76435bec8a21e60))
*   Index exercises by name ([627cdc07](https://github.com/rust-lang/rustlings/commit/627cdc07d07dfe6a740e885e0ddf6900e7ec336b))
* **run:**  makes `run` never prompt ([4b265465](https://github.com/rust-lang/rustlings/commit/4b26546589f7d2b50455429482cf1f386ceae8b3))

#### Features

* **cli:**  check for rustc before doing anything ([36a033b8](https://github.com/rust-lang/rustlings/commit/36a033b87a6549c1e5639c908bf7381c84f4f425))
* **hint:**  Add test for hint ([ce9fa6eb](https://github.com/rust-lang/rustlings/commit/ce9fa6ebbfdc3e7585d488d9409797285708316f))

<a name="1.5.1"></a>
### 1.5.1 (2019-11-11)

#### Bug Fixes

* **errors3:**  Update hint ([dcfb427b](https://github.com/rust-lang/rustlings/commit/dcfb427b09585f0193f0a294443fdf99f11c64cb), closes [#185](https://github.com/rust-lang/rustlings/issues/185))
* **if1:**  Remove `return` reference ([ad03d180](https://github.com/rust-lang/rustlings/commit/ad03d180c9311c0093e56a3531eec1a9a70cdb45))
* **strings:**  Move Strings before Structs ([6dcecb38](https://github.com/rust-lang/rustlings/commit/6dcecb38a4435593beb87c8e12d6314143631482), closes [#204](https://github.com/rust-lang/rustlings/issues/204))
* **structs1:**  Remove misleading comment ([f72e5a8f](https://github.com/rust-lang/rustlings/commit/f72e5a8f05568dde04eaeac10b9a69872f21cb37))
* **threads:**  Move Threads behind SLT ([fbe91a67](https://github.com/rust-lang/rustlings/commit/fbe91a67a482bfe64cbcdd58d06ba830a0f39da3), closes [#205](https://github.com/rust-lang/rustlings/issues/205))
* **watch:** clear screen before each `verify()`  ([3aff590](https://github.com/rust-lang/rustlings/commit/3aff59085586c24196a547c2693adbdcf4432648))

<a name="1.5.0"></a>
## 1.5.0 (2019-11-09)

#### Bug Fixes

* **test1:** Rewrite logic ([79a56942](https://github.com/rust-lang/rustlings/commit/79a569422c8309cfc9e4aed25bf4ab3b3859996b))
* **installation:**  Fix rustlings installation check ([7a252c47](https://github.com/rust-lang/rustlings/commit/7a252c475551486efb52f949b8af55803b700bc6))
* **iterators:**  Rename iterator3.rs ([433d2115](https://github.com/rust-lang/rustlings/commit/433d2115bc1c04b6d34a335a18c9a8f3e2672bc6))
* **iterators2:**  Remove syntax resulting in misleading error message ([4cde8664](https://github.com/rust-lang/rustlings/commit/4cde86643e12db162a66e62f23b78962986046ac))
* **option1:**
  *  Fix arguments passed to assert! macro (#222) ([4c2cf6da](https://github.com/rust-lang/rustlings/commit/4c2cf6da755efe02725e05ecc3a303304c10a6da))
  *  Fix arguments passed to assert! macro ([ead4f7af](https://github.com/rust-lang/rustlings/commit/ead4f7af9e10e53418efdde5c359159347282afd))
  *  Add test for prematurely passing exercise ([a750e4a1](https://github.com/rust-lang/rustlings/commit/a750e4a1a3006227292bb17d57d78ce84da6bfc6))
* **primitive_types4:**  Fail on a slice covering the wrong area ([5b1e673c](https://github.com/rust-lang/rustlings/commit/5b1e673cec1658afc4ebbbc800213847804facf5))
* **readme:**  http to https ([70946b85](https://github.com/rust-lang/rustlings/commit/70946b85e536e80e70ed9505cb650ca0a3a1fbb5))
* **test1:**
  *  Swap assertion parameter order ([4086d463](https://github.com/rust-lang/rustlings/commit/4086d463a981e81d97781851d17db2ced290f446))
  *  renamed function name to snake case closes #180 ([89d5186c](https://github.com/rust-lang/rustlings/commit/89d5186c0dae8135ecabf90ee8bb35949bc2d29b))

#### Features

*   Add enums exercises ([dc150321](https://github.com/rust-lang/rustlings/commit/dc15032112fc485226a573a18139e5ce928b1755))
*   Added exercise for struct update syntax ([1c4c8764](https://github.com/rust-lang/rustlings/commit/1c4c8764ed118740cd4cee73272ddc6cceb9d959))
* **iterators2:**  adds iterators2 exercise including config ([9288fccf](https://github.com/rust-lang/rustlings/commit/9288fccf07a2c5043b76d0fd6491e4cf72d76031))

<a name="1.4.1"></a>
### 1.4.1 (2019-08-13)


#### Bug Fixes

* **iterators2:**  Remove syntax resulting in misleading error message ([4cde8664](https://github.com/rust-lang/rustlings/commit/4cde86643e12db162a66e62f23b78962986046ac))
* **option1:**  Add test for prematurely passing exercise ([a750e4a1](https://github.com/rust-lang/rustlings/commit/a750e4a1a3006227292bb17d57d78ce84da6bfc6))
* **test1:**  Swap assertion parameter order ([4086d463](https://github.com/rust-lang/rustlings/commit/4086d463a981e81d97781851d17db2ced290f446))



<a name="1.4.0"></a>
## 1.4.0 (2019-07-13)

#### Bug Fixes

* **installation:**  Fix rustlings installation check ([7a252c47](https://github.com/rust-lang/rustlings/commit/7a252c475551486efb52f949b8af55803b700bc6))
* **iterators:**  Rename iterator3.rs ([433d2115](https://github.com/rust-lang/rustlings/commit/433d2115bc1c04b6d34a335a18c9a8f3e2672bc6))
* **readme:**  http to https ([70946b85](https://github.com/rust-lang/rustlings/commit/70946b85e536e80e70ed9505cb650ca0a3a1fbb5))
* **test1:**  renamed function name to snake case ([89d5186c](https://github.com/rust-lang/rustlings/commit/89d5186c0dae8135ecabf90ee8bb35949bc2d29b))
* **cli:** Check if changed exercise file exists before calling verify ([ba85ca3](https://github.com/rust-lang/rustlings/commit/ba85ca32c4cfc61de46851ab89f9c58a28f33c88))
* **structs1:** Fix the irrefutable let pattern warning ([cc6a141](https://github.com/rust-lang/rustlings/commit/cc6a14104d7c034eadc98297eaaa972d09c50b1f))

#### Features

* **changelog:**  Use clog for changelogs ([34e31232](https://github.com/rust-lang/rustlings/commit/34e31232dfddde284a341c9609b33cd27d9d5724))
* **iterators2:**  adds iterators2 exercise including config ([9288fccf](https://github.com/rust-lang/rustlings/commit/9288fccf07a2c5043b76d0fd6491e4cf72d76031))

<a name="1.3.0"></a>
### 1.3.0 (2019-06-05)

#### Features

- Adds a simple exercise for structures (#163, @briankung)

#### Bug Fixes

- Add Result type signature as it is difficult for new comers to understand Generics and Error all at once. (#157, @veggiemonk)
- Rustfmt and whitespace fixes (#161, @eddyp)
- errorsn.rs: Separate also the hints from each other to avoid accidental viewing (#162, @eddyp)
- fixed outdated links (#165, @gushroom)
- Fix broken link (#164, @HanKruiger)
- Remove highlighting and syntect (#167, @komaeda)

<a name="1.2.2"></a>
### 1.2.2 (2019-05-07)

#### Bug Fixes

- Reverted `--nocapture` flag since it was causing tests to pass unconditionally

<a name="1.2.1"></a>
### 1.2.1 (2019-04-22)

#### Bug Fixes

- Fix the `--nocapture` feature (@komaeda)
- Provide a nicer error message for when you're in the wrong directory

<a name="1.2.0"></a>
### 1.2.0 (2019-04-22)

#### Features

- Add errors to exercises that compile without user changes (@yvan-sraka)
- Use --nocapture when testing, enabling `println!` when running (@komaeda)

<a name="1.1.1"></a>
### 1.1.1 (2019-04-14)

#### Bug fixes

- Fix permissions on exercise files (@zacanger, #133)
- Make installation checks more thorough (@komaeda, 1b3469f236bc6979c27f6e1a04e4138a88e55de3)
- Fix order of true/false in tests for executables (@mgeier, #137)
- Stop run from panicking when compile fails (@cjpearce, #141)
- Fix intermittent test failure caused by race condition (@cjpearce, #140)
- Fix links by deleting book version (@diodfr, #142)
- Canonicalize paths to fix path matching (@cjpearce, #143)

<a name="1.1.0"></a>
### 1.1.0 (2019-03-20)

- errors2.rs: update link to Rust book (#124)
- Start verification at most recently modified file (#120)
- Watch for file creation events in watch mode (#117)
- Add standard library types to exercises suite (#119)
- Give a warning when Rustlings isn't run from the right directory (#123)
- Verify that rust version is recent enough to install Rustlings (#131)

<a name="1.0.1"></a>
### 1.0.1 (2019-03-06)

- Adds a way to install Rustlings in one command (`curl -L https://git.io/rustlings | bash`)
- Makes `rustlings watch` react to create file events (@shaunbennett, #117)
- Reworks the exercise management to use an external TOML file instead of just listing them in the code

<a name="1.0.0"></a>
### 1.0.0 (2019-03-06)

Initial release.



================================================
FILE: assets/rustlings-zh/CONTRIBUTING.md
================================================
## Contributing to Rustlings

First off, thanks for taking the time to contribute!! â¤ï¸

### Quick Reference

I want to...

_add an exercise! â¡ï¸ [read this](#addex) and then [open a Pull Request](#prs)_

_update an outdated exercise! â¡ï¸ [open a Pull Request](#prs)_

_report a bug! â¡ï¸ [open an Issue](#issues)_

_fix a bug! â¡ï¸ [open a Pull Request](#prs)_

_implement a new feature! â¡ï¸ [open an Issue to discuss it first, then a Pull Request](#issues)_

<a name="#src"></a>
### Working on the source code

`rustlings` is basically a glorified `rustc` wrapper. Therefore the source code
isn't really that complicated since the bulk of the work is done by `rustc`.
`src/main.rs` contains a simple `clap` CLI that loads from `src/verify.rs` and `src/run.rs`.

<a name="addex"></a>
### Adding an exercise

The first step is to add the exercise! Name the file `exercises/yourTopic/yourTopicN.rs`, make sure to
put in some helpful links, and link to sections of the book in `exercises/yourTopic/README.md`.

Next make sure it runs with `rustlings`. The exercise metadata is stored in `info.toml`, under the `exercises` array. The order of the `exercises` array determines the order the exercises are run by `rustlings verify`.

Add the metadata for your exercise in the correct order in the `exercises` array. If you are unsure of the correct ordering, add it at the bottom and ask in your pull request. The exercise metadata should contain the following:
```diff
  ...
+ [[exercises]]
+ name = "yourTopicN"
+ path = "exercises/yourTopic/yourTopicN.rs"
+ mode = "compile"
+ hint = """
+ Some kind of useful hint for your exercise."""
  ...
```

The `mode` attribute decides whether Rustlings will only compile your exercise, or compile and test it. If you have tests to verify in your exercise, choose `test`, otherwise `compile`.

That's all! Feel free to put up a pull request.

<a name="issues"></a>
### Issues

You can open an issue [here](https://github.com/rust-lang/rustlings/issues/new).
If you're reporting a bug, please include the output of the following commands:

- `rustc --version`
- `rustlings --version`
- `ls -la`
- Your OS name and version

<a name="prs"></a>
### Pull Requests

Opening a pull request is as easy as forking the repository and committing your
changes. There's a couple of things to watch out for:

#### Write correct commit messages

We follow the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0-beta.4/)
specification, because it makes it easier to generate changelogs automatically.
This means that you have to format your commit messages in a specific way. Say
you're working on adding a new exercise called `foobar1.rs`. You could write
the following commit message:

```
feat: Add foobar1.rs exercise
```

If you're just fixing a bug, please use the `fix` type:

```
fix(verify): Make sure verify doesn't self-destruct
```

The scope within the brackets is optional, but should be any of these:

- `installation` (for the installation script)
- `cli` (for general CLI changes)
- `verify` (for the verification source file)
- `watch` (for the watch functionality source)
- `run` (for the run functionality source)
- `EXERCISENAME` (if you're changing a specific exercise, or set of exercises,
  substitute them here)

When the commit also happens to close an existing issue, link it in the message
body:

```
fix: Update foobar

closes #101029908
```

If you're doing simple changes, like updating a book link, use `chore`:

```
chore: Update exercise1.rs book link
```

If you're updating documentation, use `docs`:

```
docs: Add more information to Readme
```

If, and only if, you're absolutely sure you want to make a breaking change
(please discuss this beforehand!), add an exclamation mark to the type and
explain the breaking change in the message body:

```
fix!: Completely change verification

BREAKING CHANGE: This has to be done because lorem ipsum dolor
```

#### Pull Request Workflow

Once you open a Pull Request, it may be reviewed or labeled (or both) until
the maintainers accept your change. Then, [bors](https://github.com/bors) will
run the test suite with your changes and if it's successful, automatically
merge it in!



================================================
FILE: assets/rustlings-zh/default_out.txt
================================================
æ„Ÿè°¢å®‰è£… Rustlings!

ä½ è¿˜æ²¡æœ‰ä»»ä½•ä½¿ç”¨ç»éªŒï¼Ÿä¸ç”¨æ‹…å¿ƒï¼ŒRustlings æ­£æ˜¯ä¸ºåˆå­¦è€…é‡èº«å®šåšï¼æˆ‘ä»¬å°†æ•™ä½ å¤§é‡
æœ‰å…³ Rust çš„çŸ¥è¯†, ä½†åœ¨æˆ‘ä»¬å¼€å§‹ä¹‹å‰ï¼Œä»¥ä¸‹æœ‰å‡ ä¸ªå…³äºå¦‚ä½•ä½¿ç”¨ Rustlings çš„è¯´æ˜ï¼š

1. Rustlings çš„æ ¸å¿ƒåœ¨äºä½ éœ€è¦å»è§£å†³ä¸€äº›ç»ƒä¹ ã€‚è¿™äº›ç»ƒä¹ é€šå¸¸æœ‰äº›è¯­æ³•ä¸Šçš„é”™è¯¯å¯¼è‡´äº†
   ä»–ä»¬æ— æ³•é€šè¿‡ç¼–è¯‘æˆ–æµ‹è¯•ã€‚æœ‰äº›åˆæ˜¯é€»è¾‘ä¸Šçš„é—®é¢˜ã€‚æ— è®ºæ˜¯ä»€ä¹ˆé”™è¯¯ï¼Œä½ çš„ç›®æ ‡å°±æ˜¯å»æ‰¾
   åˆ°å®ƒä»¬ç„¶åè§£å†³ï¼å½“ç»ƒä¹ ç¼–è¯‘é€šè¿‡ï¼Œè¿™æ„å‘³ç€ä½ æˆåŠŸè§£å†³äº†ï¼å¹¶ä¸” Rustlings ä¹Ÿå·²å‘ä½ 
   å‘èµ·äº†ä¸‹ä¸€é¢˜çš„æŒ‘æˆ˜ã€‚
2. å¦‚æœä½ ä»¥ watch æ¨¡å¼è¿è¡Œ Rustlings ï¼ˆæ¨èï¼‰ï¼Œå®ƒå°†è‡ªåŠ¨ä»ç¬¬ä¸€ä¸ªç»ƒä¹ å¼€å§‹ã€‚ä¸è¦
   ä¸ºè¿è¡Œ Rustlings æ—¶å¼¹å‡ºçš„é”™è¯¯ä¿¡æ¯è€Œæ„Ÿåˆ°å›°æƒ‘ã€‚å› ä¸ºä½ ä¸€è¿è¡Œ Rustlings å°±ä¼šå¼¹å‡º
   é”™è¯¯ä¿¡æ¯ï¼è¿™æ˜¯ç»ƒä¹ çš„ä¸€éƒ¨åˆ†ï¼Œæ‰€ä»¥å¿«ç”¨ç¼–è¾‘å™¨æ‰“å¼€ç»ƒä¹ æ–‡ä»¶ï¼Œç„¶ååƒä¾¦æ¢ä¸€æ ·å·¥ä½œ!
3. å¦‚æœä½ åœ¨ä¸€ä¸ªç»ƒä¹ ä¸­è¢«å¡ä½äº†ï¼Œå¯ä»¥é€šè¿‡é”®å…¥ 'hint'ï¼ˆåœ¨è§‚å¯Ÿæ¨¡å¼ä¸‹ï¼‰ï¼Œæˆ–è¿è¡Œ
   `rustex hint myexercise`æ¥æŸ¥çœ‹æç¤ºã€‚
4. å¦‚æœä½ è®¤ä¸ºæŸä¸ªç»ƒä¹ æ¯«æ— æ„ä¹‰ï¼Œè¯·éšæ—¶åœ¨ Github æ‰“å¼€ä¸€ä¸ª issue
   (https://github.com/rustcollege/rust-exercise/issues/new)ã€‚æˆ‘ä»¬ç§¯æåœ°å…³æ³¨ç€é¡¹ç›®çš„
   æ¯ä¸ªé—®é¢˜å’Œæ¯ä¸€ä»¶äº‹ã€‚å…¶ä»–å­¦ä¹ è€…ä¹Ÿè¿™æ ·åšçš„è¯ï¼Œè¿™æ ·ä½ ä»¬å°±å¯ä»¥äº’ç›¸å¸®åŠ©äº†

éƒ½æ˜ç™½äº†å—ï¼Ÿç‰›ğŸ‚ï¼å¯ä»¥è¿è¡Œ `rustex watch` å¼€å§‹ä½ çš„ç¬¬ä¸€ä¸ªç»ƒä¹ ã€‚æ³¨æ„ï¼Œç¡®ä¿æ‰“å¼€ä½ çš„ç¼–è¾‘å™¨!


================================================
FILE: assets/rustlings-zh/info.toml
================================================
# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
æç¤º: ç¬¬ 12 è¡Œçš„å˜é‡å£°æ˜ç¼ºå°‘äº†ä¸€ä¸ªå…³é”®å­—ï¼Œåœ¨ Rust ä¸­ï¼Œåˆ›å»ºä¸€ä¸ª
æ–°çš„å˜é‡ç»‘å®šå¿…é¡»ç”¨åˆ°è¿™ä¸ªå…³é”®å­—ã€‚"""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
ç¼–è¯‘å™¨åœ¨è¯´ï¼ŒRust æ— æ³•æ ¹æ®ç»™å®šå†…å®¹æ¨æ–­å‡ºå˜é‡ `x` çš„ç±»å‹.
å¦‚æœä½ å¯¹ç¬¬ 7 è¡Œæ ‡æ³¨ç±»å‹ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
å¦‚æœä½ å¯¹ x èµ‹äºˆä¸€ä¸ªå€¼å‘¢ï¼Ÿ
å¦‚æœä½ åŒæ—¶åšåˆ°äº†ä»¥ä¸Šä¸¤ç‚¹å‘¢ï¼Ÿ
 x åˆ°åº•æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ
å¦‚æœ x ä¸ 10 æ˜¯åŒä¸€ç±»å‹ï¼Œäº¦æˆ–è€…å®ƒæ˜¯ä¸åŒçš„ç±»å‹å‘¢ï¼Ÿ"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
åœ¨ Rustï¼Œå˜é‡ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ã€‚ä½†æˆ‘ä»¬æ­£è¯•å›¾é‡æ–°åˆ†é…
ä¸€ä¸ªä¸åŒçš„å€¼ç»™ x ï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå…³é”®å­—ä½¿å˜é‡å¯å˜ã€‚"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
ç³Ÿäº†ï¼åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬åœ¨ç¬¬ 7 è¡Œåˆ›å»ºäº†ä¸€ä¸ªå˜é‡ï¼Œç„¶åè¯•å›¾åœ¨ç¬¬ 8 è¡Œ
ä½¿ç”¨å®ƒï¼Œä½†æ˜¯å®ƒå¹¶æ²¡è¢«èµ‹å€¼ï¼æˆ‘ä»¬æ— æ³•æ‰“å°å‡ºä¸å­˜åœ¨çš„å†…å®¹ï¼Œæ‰€ä»¥å°è¯•èµ‹äºˆ x ä¸€ä¸ªå€¼ï¼
è¿™ä¸ªé”™è¯¯é€ æˆçš„ Bug åœ¨ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­éƒ½éå¸¸å®¹æ˜“å‘ç”Ÿâ€”â€”æ„Ÿè°¢ Rust ç¼–è¯‘å™¨æé†’äº†æˆ‘ä»¬"""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
åœ¨ variables3 ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„å…³é”®å­—ä½¿ä¸€ä¸ªä¸å¯å˜çš„å˜é‡å˜å¾—å¯å˜ã€‚
å¯æƒœçš„æ˜¯ï¼Œåœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œè¿™ä¸ªæ–¹æ³•å¹¶ä¸ç®¡ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ç»™ä¸€ä¸ªç°æœ‰çš„å˜é‡åˆ†é…ä¸€ä¸ªä¸
åŒç±»å‹çš„å€¼ã€‚æœ‰æ—¶ï¼Œä½ ä¼šæƒ³é‡å¤ä½¿ç”¨ç°æœ‰çš„å˜é‡åç§°ï¼Œå› ä¸ºä½ åªæ˜¯å°†æ•°å€¼è½¬æ¢ä¸ºä¸åŒçš„ç±»å‹ï¼Œå°±åƒ
æœ¬ç»ƒä¹ ä¸­ä¸€æ ·ã€‚å¹¸è¿çš„æ˜¯ï¼ŒRust æœ‰ä¸€ä¸ªå¼ºå¤§çš„æŠ€æœ¯å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šå˜é‡é®è”½ï¼ˆShadowingï¼‰ï¼
æœ‰å…³å˜é‡é®è”½çš„æ›´å¤šå†…å®¹å¯é€šè¿‡è¿™æœ¬ä¹¦çš„ 'Variables and Mutability'* ç« èŠ‚äº†è§£:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
å°è¯•ä½¿ç”¨æ­¤æŠ€æœ¯è§£å†³æ­¤ç»ƒä¹ ã€‚

è¯‘ï¼šVariables and Mutabilityï¼šå˜é‡ä¸å¯å˜æ€§"""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
æˆ‘ä»¬å·²ç»äº†è§£äº†å˜é‡ä¸å¯å˜æ€§ï¼Œä½†è¿˜æœ‰å¦ä¸€ç§é‡è¦çš„å˜é‡ç±»å‹ï¼›å¸¸é‡ï¼ˆConstantï¼‰ã€‚ 
å¸¸é‡æ°¸è¿œä¸å¯æ”¹å˜çš„ï¼Œå®ƒç”¨å…³é”®å­— 'const' è€Œéå…³é”®å­— 'let' å£°æ˜ï¼Œå¹¶ä¸”å…¶ç±»å‹ä¹Ÿå¿…é¡»è¢«æ ‡æ³¨ã€‚

æ›´å¤šå…³äºå¸¸é‡çš„ä¿¡æ¯ 'Differences Between Variables and Constants'* åœ¨è¿™æœ¬ä¹¦çš„ç« èŠ‚ 'Variables and Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants

è¯‘ï¼šDifferences Between Variables and Constantsï¼šå˜é‡ä¸å¸¸é‡çš„åŒºåˆ«
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
ä¸»å‡½æ•°ä¸­æ­£è¯•å›¾è°ƒç”¨ä¸€ä¸ªåä¸º `call_me` çš„å‡½æ•°ï¼Œå¯è¿™ä¸ªå‡½æ•°å¹¶ä¸å­˜åœ¨ã€‚
å®ƒå¸Œæœ›è¿™ä¸ªå‡½æ•°ä¸æ¥å—ä»»ä½•å‚æ•°ï¼ŒåŒæ—¶ä¹Ÿä¸è¿”å›å€¼ã€‚
å¬èµ·æ¥å¾ˆåƒ `main` å‡½æ•°ï¼Œä¸æ˜¯å—ï¼Ÿ"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
 Rust è¦æ±‚å‡½æ•°ç­¾åï¼ˆsignatureï¼‰æœ‰ç±»å‹æ ‡æ³¨ï¼Œä½†æ˜¯ `call_me` å‡½æ•°ç¼ºå°‘ `num` çš„ç±»å‹æ ‡æ³¨ã€‚"""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
æ­¤æ—¶, å‡½æ•° *å£°æ˜ï¼ˆdeclarationï¼‰* æ˜¯æ²¡é—®é¢˜çš„ï¼Œä½†å‡½æ•°è°ƒç”¨å‡ºäº†é—®é¢˜"""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
é”™è¯¯ä¿¡æ¯æŒ‡å‘ç¬¬ 15 è¡Œï¼Œè¯´å¸Œæœ›åœ¨`->`ä¹‹åæœ‰ä¸€ä¸ªç±»å‹ã€‚
é‚£ä¸ªåœ°æ–¹æ ‡æ³¨äº†å‡½æ•°çš„è¿”å›ç±»å‹â€”â€”çœ‹çœ‹ `is_even` å‡½æ•°çš„ç¤ºä¾‹å§"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
è¿™æ˜¯ä¸€ä¸ªéå¸¸å¸¸è§çš„é”™è¯¯ï¼Œå¯ä»¥é€šè¿‡åˆ é™¤ä¸€ä¸ªå­—ç¬¦æ¥è§£å†³ã€‚
å‘ç”Ÿçš„åŸå› æ˜¯ Rust åŒºåˆ†äº†è¡¨è¾¾å¼å’Œè¯­å¥ï¼šè¡¨è¾¾å¼æ ¹æ®å…¶è¿ç®—æ•°ï¼ˆoperandï¼‰è¿”å›ä¸€ä¸ªå€¼, 
è€Œè¯­å¥ä»…è¿”å›ä¸€ä¸ª `()` ç±»å‹ï¼Œå…¶è¡Œä¸ºå¥½æ¯” C/C++ ä¸­çš„ `void` ã€‚
æˆ‘ä»¬å¸Œæœ› `square` å‡½æ•°è¿”å›ä¸€ä¸ª `i32` ç±»å‹çš„å€¼ï¼Œä½†ç°åœ¨å®ƒè¿”å›çš„æ˜¯ `()` ç±»å‹...
å®ƒä»¬æ˜¾ç„¶æ˜¯ä¸ä¸€æ ·çš„ã€‚å¯¹æ­¤æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆã€‚
1. åœ¨ `num * num;` å‰é¢åŠ ä¸Š `return` å…³é”®å­—
2. ç§»é™¤ `;`ï¼Œè®©å®ƒå˜æˆ `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œä¹Ÿå¯ä»¥ç”¨ä¸€è¡Œæ¥åšè¿™ä»¶äº‹!
å…¶ä»–è¯­è¨€ä¸­çš„ä¸€äº›ç±»ä¼¼ä¾‹å­:
- åœ¨ C(++) ä¸­ä¼šæ˜¯: `a > b ? a : b`
- åœ¨ Python ä¸­ä¼šæ˜¯:  `a if a > b else b`
è¯·è®°ä½åœ¨ Rust ä¸­ï¼š
- `if` çš„æ¡ä»¶ä¸éœ€è¦ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥
- `if`/`else` çš„æ¡ä»¶æ˜¯è¡¨è¾¾å¼
- æ¯ä¸ªæ¡ä»¶åé¢éƒ½æœ‰ä¸€ä¸ª `{}` å—ã€‚"""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
å¯¹äºç¬¬ä¸€ä¸ªç¼–è¯‘é”™è¯¯ï¼Œåœ¨äº Rust ä¸­çš„é‡è¦ä¸€ç‚¹ï¼š
æ¯ä¸ªæ¡ä»¶å—ï¼ˆconditional blockï¼‰éƒ½å¿…é¡»è¿”å›ç›¸åŒçš„ç±»å‹ã€‚
ä¸ºäº†é€šè¿‡æµ‹è¯•ï¼Œä½ éœ€è¦å‡ ä¸ªæ¡ä»¶ç”¨æ¥åˆ¤æ–­ä¸åŒçš„è¾“å…¥"""

# TEST 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "No hints this time ;)"

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
åœ¨ç¬¬ 13 è¡Œæœ‰ä¸ª "cannot borrow immutable local variable `vec1` as mutable"* é”™è¯¯ï¼Œå¯¹å—ï¼Ÿ
ä¿®å¤é”™è¯¯çš„æ–¹æ³•æ˜¯æ·»åŠ ä¸€ä¸ªå…³é”®è¯ï¼Œå¹¶ä¸”æ·»åŠ çš„ä½ç½®ä¸åœ¨æŠ¥é”™çš„ç¬¬ 13 è¡Œä¸Šã€‚

è¯‘æ³¨ï¼šä¸èƒ½å°†ä¸å¯å˜çš„å±€éƒ¨å˜é‡ `vec1` å€Ÿç”¨ä¸ºå¯å˜å˜é‡"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
å½“æˆ‘ä»¬åœ¨ç¬¬ 10 è¡Œè°ƒç”¨ `fill_vec` æ—¶ï¼Œ`vec0' è¢« *ç§»åŠ¨ï¼ˆmovedï¼‰* åˆ°
å‡½æ•° `fill_vec` ä¸­ï¼Œè¿™æ„å‘³ç€å®ƒä¼šåœ¨ `fill_vec` å‡½æ•°çš„æœ«å°¾è¢«ä¸¢å¼ƒï¼ŒåŒæ—¶ä¹Ÿ
å¯¼è‡´äº†æˆ‘ä»¬ä¸èƒ½åœ¨ç¬¬ 13 è¡Œå†æ¬¡ä½¿ç”¨ `vec0`ï¼ˆæˆ–åœ¨ `main` ä¸­è°ƒç”¨ `fill_vec` åçš„ä»»ä½•åœ°æ–¹ï¼‰ã€‚
æˆ‘ä»¬å¯ä»¥ç”¨å‡ ç§æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéƒ½è¯•ä¸€è¯•å§ï¼
1. åšä¸€ä¸ª `vec0` æ•°æ®çš„æ‹·è´ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ `fill_vec` ã€‚
2. è®© `fill_vec` é€šè¿‡å€Ÿç”¨è€Œä¸æ˜¯è·å–æ‰€æœ‰æƒçš„æ–¹å¼è·å–å‚æ•°ï¼Œç„¶ååœ¨å‡½æ•°ä¸­å¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œä»¥ä¾¿è¿”å›
   ä¸€ä¸ªå…·æœ‰æ‰€æœ‰æƒçš„ `Vec<i32>` å˜é‡ã€‚
3. è®© `fill_vec` å€Ÿç”¨å¯å˜å‚æ•°ï¼ˆå‚æ•°ä¹Ÿéœ€è¦å¯å˜ï¼‰ï¼Œç›´æ¥è¿›è¡Œæ“ä½œï¼Œç„¶åä¸è¿”å›ä»»ä½•ä¸œè¥¿ã€‚æ¥ç€ä½ éœ€è¦
   å®Œå…¨åœ°å»æ‰ `vec1`â€”â€”ä½†æ³¨æ„ï¼Œè¿™ä¹Ÿå°†æ”¹å˜ç¬¬ä¸€ä¸ª `println!` æ‰“å°å‡ºå†…å®¹ã€‚"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
ä¸ä¹‹å‰ä¸åŒï¼š`fn fill_vec` ç¬¬ä¸€è¡Œçš„ `let mut vec = vec;` ç°åœ¨å·²ç»ä¸å­˜åœ¨äº†ã€‚ 
ä½ å¯ä»¥åœ¨æŸä¸ªåœ°æ–¹æ·»åŠ  `mut` ä»¥ä½¿ç°æœ‰çš„ä¸å¯å˜ç»‘å®šå˜å¾—å¯å˜ï¼Œè€ŒéæŠŠä¸åŒçš„é‚£ä¸€è¡ŒåŠ å›å» :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
åªè¦ä½ è§‰å¾—æœ‰ç¡®åˆ‡çš„ç›®æ ‡ï¼Œå°±å¯ä»¥åœæ­¢é˜…è¯» :) æˆ–è€…è¯•ç€åšä¸€ä¸ªæ­¥éª¤ï¼Œç„¶åä¿®å¤ç¼–è¯‘é”™è¯¯ã€‚
å› æ­¤ï¼Œç›®æ ‡æœ‰ï¼š
   - å»æ‰ main ä¸­åˆ›å»ºæ–° vector çš„ç¬¬ä¸€è¡Œ
   - æ‰€ä»¥ `vec0` å·²ä¸å­˜åœ¨äº†ï¼Œä¸èƒ½å†æŠŠå®ƒä¼ ç»™ `fill_vec` ã€‚
   - ç°å·²ä¸éœ€è¦å‘ `fill_vec` ä¼ é€’ä»»ä½•ä¸œè¥¿ï¼Œæ‰€ä»¥å®ƒçš„ï¼ˆå‡½æ•°ï¼‰ç­¾ååº”è¯¥åæ˜ å‡ºå®ƒä¸æ¥å—ä»»ä½•å‚æ•°*ã€‚
   - ç”±äºå·²ä¸åœ¨ `main` åˆ›å»º vector ï¼Œæ‰€ä»¥éœ€è¦åœ¨ `fill_vec` ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ vectorï¼Œ
     ç±»ä¼¼äº `main` ä¸­çš„åšæ³•ã€‚
     
è¯‘æ³¨ï¼šç»ƒä¹ ä¸­ fill_vec çš„å‡½æ•°ç­¾åå·²ç»æ²¡æœ‰æ¥å—å‚æ•°äº†ï¼Œæ‰€ä»¥ä¼°è®¡æ˜¯åœ¨è°ƒç”¨çš„åœ°æ–¹"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
ä»”ç»†æ¨æ•²æ¯ä¸ªå¯å˜å¼•ç”¨çš„ä½¿ç”¨èŒƒå›´ã€‚
åœ¨è·å–å¯å˜å¼•ç”¨åæ˜¯å¦èƒ½å¤Ÿç«‹å³æ›´æ–°å¼•ç”¨ï¼ˆxï¼‰çš„å€¼ï¼Ÿ 
åœ¨æœ¬ä¹¦çš„ 'References and Borrowing' éƒ¨åˆ†äº†è§£æ›´å¤šå…³äº 'Mutable References' çš„ä¿¡æ¯ã€‚
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
"""

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
æœ‰ä¸€ç§ç®€ä¾¿çš„æ–¹æ³•å¯ä»¥åˆå§‹åŒ–å…·æœ‰ä¸€å®šå¤§å°çš„æ•°ç»„ï¼Œè€Œä¸éœ€è¦ä½ è¾“å…¥ 100 ä¸ª
å…ƒç´ ï¼ˆä½†å¦‚æœä½ æƒ³çš„è¯ï¼Œé‚£å½“ç„¶å¯ä»¥ï¼ï¼‰ã€‚
ä¾‹å¦‚ï¼Œä½ å¯ä»¥è¿™æ ·åšï¼š
let array = ["Are we there yet?"; 10];

é¢å¤–ç›®æ ‡: è¿˜æœ‰å“ªäº›ä¸œè¥¿å¯ä»¥åœ¨ `a.len()>=100` æ—¶è¿”å› true """

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
çœ‹çœ‹è¿™æœ¬ä¹¦çš„ï¼šUnderstanding Ownership -> Slices -> Other Slices ç« èŠ‚å§ï¼š
https://doc.rust-lang.org/book/ch04-03-slices.htmlï¼Œ
ç„¶åæ‰¾å‡ºæ‰€éœ€åˆ‡ç‰‡å…ƒç´ å¯¹åº”æ•°ç»„é‡Œçš„èµ·å§‹å’Œæˆªæ­¢ä¸‹æ ‡ã€‚ 

å¦‚æœä½ å¥½å¥‡æ—¢ç„¶ `assert_eq!` çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯å¼•ç”¨ï¼Œä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªå‚æ•°
æ²¡æœ‰ä½¿ç”¨ & å·ç”¨æ¥è¡¨ç¤ºå¼•ç”¨ï¼Œå¯ä»¥çœ‹çœ‹è¿™æœ¬ä¹¦çš„ Deref å¼ºåˆ¶è½¬æ¢éƒ¨åˆ†ï¼š
https://doc.rust-lang.org/book/ch15-02-deref.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
çœ‹çœ‹è¿™æœ¬ä¹¦çš„ Data Types -> The Tuple Type ç±»å‹ç« èŠ‚ï¼š
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
ç‰¹åˆ«æ˜¯å…³äºè§£æ„çš„éƒ¨åˆ†ï¼ˆè¿™èŠ‚ä¸­å€’æ•°ç¬¬äºŒä¸ªä¾‹å­ï¼‰ã€‚
ä½ éœ€è¦ä¸€ä¸ªæ¨¡å¼å°† `name` å’Œ `age` ç»‘å®šåˆ°å…ƒç»„çš„é€‚å½“éƒ¨åˆ†ã€‚ä½ èƒ½å¤Ÿåšåˆ°çš„ï¼ï¼"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
è™½ç„¶ä½ å¯ä»¥ä½¿ç”¨ `let` å¯¹å…ƒç»„è¿›è¡Œè§£æ„ ï¼Œä½†ä¸å¦¨è¯•è¯•å¯¹å®ƒè¿›è¡Œç´¢å¼•ï¼Œ
æ­£å¦‚è¿™æœ¬ä¹¦çš„ Data Types -> The Tuple Type éƒ¨åˆ†çš„æœ€åä¸€ä¸ªä¾‹å­è¡¨ç¤ºçš„é‚£æ ·ã€‚
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
ç°åœ¨ï¼Œä½ çš„å·¥å…·ç®±é‡Œåˆå¤šäº†ä¸€ä¸ªå·¥å…·ï¼"""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust ä¸åªæœ‰ä¸€ç§ç»“æ„ã€‚å®é™…ä¸Šï¼Œæ‰€æœ‰çš„å˜ä½“éƒ½æ˜¯ç”¨æ¥ç»„åˆç›¸å…³çš„æ•°æ®ã€‚
é¦–å…ˆæ˜¯ä¸€èˆ¬çš„ï¼ˆæˆ–ç»å…¸çš„ï¼‰ç»“æ„ï¼Œä¸€å—ç›¸å…³çš„æ•°æ®è¢«å‘½åä¸ºä¸€ä¸ªå­—æ®µé›†åˆã€‚
å…ƒç»„ç»“æ„åŸºæœ¬ä¸Šå°±æ˜¯è¢«å‘½åçš„å…ƒç»„ã€‚
æœ€åçš„å•å…ƒç»“æ„æ²¡æœ‰ä»»ä½•å­—æ®µï¼Œå¯¹æ³›å‹å¾ˆæœ‰ç”¨ã€‚

åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ éœ€è¦å®Œæˆå¹¶å®ç°æ¯ä¸€ç§ç»“æ„ã€‚
æ›´å¤šå…³äºç»“æ„çš„å†…å®¹åœ¨è¿™ï¼šhttps://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
åˆ›å»ºç»“æ„ä½“çš„å®ä¾‹å¾ˆç®€å•ï¼Œä½ åªéœ€è¦ç»™å®ƒçš„å­—æ®µåˆ†é…ä¸€äº›å€¼ã€‚
ç„¶è€Œï¼Œåœ¨å®ä¾‹åŒ–ç»“æ„æ—¶ï¼Œè¿˜æœ‰äº›æ·å¾„ã€‚
çœ‹çœ‹è¿™æœ¬ä¹¦ï¼Œæ¥äº†è§£æ›´å¤šï¼šhttps://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
Package å®ç°çš„ new æ–¹æ³•åœ¨é‡é‡ï¼ˆweight_in_gramsï¼‰ä¸ç¬¦åˆç‰©ç†çš„æƒ…å†µä¸‹éœ€è¦ panic :)ï¼Œè¿™åœ¨ Rust éœ€è¦æ€ä¹ˆåšï¼Ÿ

å¯¹äº is_internationalï¼šä¸€ä¸ªåŒ…è£¹å…·æœ‰å›½é™…æ€§çš„æ¡ä»¶æœ‰å“ªäº›ï¼Ÿä¼¼ä¹ä¸å®ƒæ‰€ç»è¿‡çš„åœ°æ–¹æœ‰å…³å§ï¼Ÿ

å¯¹äº calculate_transport_feesï¼šæ›´å¤§çš„é€šå¸¸æ›´è´µï¼Œæˆ‘ä»¬çš„ Package æ²¡æœ‰å°ºå¯¸ï¼Œä½†æœ‰äº›ä¸œè¥¿å¯èƒ½åŒæ ·ç¬¦åˆéœ€è¦ :)

çœ‹çœ‹è¿™æœ¬ä¹¦ï¼Œäº†è§£æ›´å¤šå…³äºæ–¹æ³•å®ç°çš„ä¿¡æ¯ï¼šhttps://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = """
æç¤ºï¼šæšä¸¾ç±»å‹è¿˜æ²¡æœ‰è¢«å®šä¹‰ã€‚"""

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
æç¤ºï¼šä½ å¯ä»¥åˆ›å»ºå¤šç§ä¸åŒç±»å‹çš„æšä¸¾ï¼Œå¦‚ä¸åŒ…å«å€¼ã€åŒ¿åç»“æ„*ã€å­—ç¬¦ä¸²ã€å…ƒç»„ï¼Œç­‰ç­‰ã€‚

è¯‘ï¼šåŒ¿åç»“æ„å¯èƒ½æ˜¯ä¸å‘½åå­—æ®µåçš„ç»“æ„"""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = "è¿™æ¬¡æ²¡æœ‰æç¤º ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Rust ä¸­æ‰€æœ‰çš„ä¸œè¥¿é»˜è®¤éƒ½æ˜¯ç§æœ‰çš„ï¼ˆprivateï¼‰â€”â€”ä½†æ˜¯æœ‰ä¸ªå…³é”®å­—å¯ä»¥æ ‡æ˜æŸäº›ä¸œè¥¿ä¸ºå…¬å¼€çš„ï¼ˆpublicï¼‰ã€‚
è€Œç¼–è¯‘å™¨é”™è¯¯æ­£æŒ‡æ˜æŸäº›ä¸œè¥¿éœ€è¦èƒ½å¤Ÿè¢«å…¬å¼€è®¿é—®"""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
delicious_snacks æ¨¡å—è¯•å›¾æä¾›ä¸€ä¸ªåŒºåˆ«å…¶å†…éƒ¨ç»“æ„çš„å¤–éƒ¨æ¥å£ï¼ˆå¯¹äº `fruits` å’Œ `veggies` ä»¥åŠç›¸å…³çš„å¸¸æ•°ï¼‰ã€‚
å‚ç…§ main ä¸­çš„ä½¿ç”¨æƒ…å†µå®Œå–„ `use` è¯­å¥ï¼Œå¹¶æ‰¾åˆ°ä¸¤ä¸ªå¸¸é‡ä¸­ç¼ºå°‘çš„æŸä¸ªå…³é”®å­—ã€‚"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH å’Œ SystemTime å£°æ˜åœ¨ std::time æ¨¡å—ã€‚é€šè¿‡ `use` è¯­å¥
å°†å®ƒä»¬å¼•å…¥ä½œç”¨åŸŸã€‚ä½ å¯ä»¥ä½¿ç”¨åµŒå¥—è·¯å¾„ï¼ˆnested pathsï¼‰
æˆ–å…¨å±€æ“ä½œç¬¦ï¼ˆglob operatorï¼‰åªéœ€ä¸€è¡Œå°±èƒ½å¤Ÿå¼•å…¥å®ƒä»¬ã€‚

è¯‘ï¼šåµŒå¥—æ˜¯ {x,y,z} ï¼Œå…¨å±€æ˜¯ * """

# COLLECTIONS

[[exercises]]
name = "vec1"
path = "exercises/collections/vec1.rs"
mode = "test"
hint = """
Rust æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼å®šä¹‰ä¸€ä¸ª vector ã€‚
1. ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `Vec::new()` æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ vectorï¼Œç„¶å
   ä½¿ç”¨ `push()` æ–¹æ³•å¾€é‡Œé¢æ·»åŠ å…ƒç´ ã€‚
2. ç¬¬äºŒç§æ–¹æ³•æ›´ç®€å•ï¼Œé‚£å°±æ˜¯ä½¿ç”¨ `vec![]` å®ï¼Œæ¥ç€åœ¨å®çš„æ–¹æ‹¬å·å†…å®šä¹‰éœ€è¦çš„å…ƒç´ ã€‚
é˜…è¯»è¿™æœ¬ä¹¦çš„æ­¤ç« èŠ‚ï¼šhttps://doc.rust-lang.org/stable/book/ch08-01-vectors.html
æ¥äº†è§£æ›´å¤šã€‚
"""

[[exercises]]
name = "vec2"
path = "exercises/collections/vec2.rs"
mode = "test"
hint = """
æç¤º 1 ï¼š`i` æ˜¯ Vec ä¸­è¢«è¿­ä»£çš„æ¯ä¸ªå…ƒç´ ï¼Œä½ å¯ä»¥ä¹˜ä»¥å®ƒå—ï¼Ÿ
æç¤º 2 : ç ”ç©¶ä¸‹ç¼–è¯‘é”™è¯¯ç»™å‡ºçš„å»ºè®® ;)
"""

[[exercises]]
name = "hashmap1"
path = "exercises/collections/hashmap1.rs"
mode = "test"
hint = """
æç¤º 1 ï¼šçœ‹çœ‹å‡½æ•°çš„è¿”å›ç±»å‹ï¼Œæ¨æµ‹å‡º `basket` çš„ç±»å‹ã€‚
æç¤º 2 ï¼šæ°´æœçš„æ•°é‡åº”è¯¥ä¸å°‘äº 5 ä¸ªã€‚å¹¶ä¸”éœ€è¦ç¡®ä¿ç¯®å­é‡Œè‡³å°‘æœ‰ä¸‰ç§æ°´æœã€‚
"""

[[exercises]]
name = "hashmap2"
path = "exercises/collections/hashmap2.rs"
mode = "test"
hint = """
ä½¿ç”¨ `HashMap` ä¸­çš„ `entry()` å’Œ `or_insert()` æ¥å®Œæˆç›®æ ‡ã€‚
äº†è§£æ›´å¤šï¼šhttps://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value 
"""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
`current_favorite_color` å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸä¸º `'static` çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚
æˆ‘ä»¬çŸ¥é“è¿™ç‚¹æ˜¯å› ä¸ºå­—ç¬¦ä¸²ç›´æ¥å­˜å‚¨åœ¨äº†ä»£ç ä¸­â€”â€”å®ƒå¹¶ä¸æ¥è‡ªäºæ–‡ä»¶ã€ç”¨æˆ·è¾“å…¥æˆ–
å…¶ä»–ç¨‹åºâ€”â€”æ‰€ä»¥åªè¦ç¨‹åºè¿˜åœ¨è¿è¡Œï¼Œå®ƒå°±ä¼šä¸€ç›´å­˜åœ¨ã€‚ä½†å®ƒä»ç„¶æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚
æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥å°†å­—ç¬¦ä¸²åˆ‡ç‰‡è½¬æ¢ä¸º `String`ï¼Œè¿™åœ¨ä¹¦çš„ Strings ç« èŠ‚æœ‰æ‰€ä»‹ç»ï¼Œè¿˜æœ‰ä¸€ç§
æ–¹æ³•æ˜¯ä½¿ç”¨ `From` ç‰¹å¾"""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
æ˜¯çš„ï¼Œåªè¦æŠŠç»‘å®šåœ¨ `word` ä¸Šçš„å€¼æ”¹ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡è€Œé `String` å°±å¯ä»¥å¾ˆå®¹æ˜“åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸æ˜¯å—ï¼Ÿï¼Ÿ
æœ‰ä¸ªæ–¹æ³•æ˜¯åœ¨ç¬¬ 9 è¡Œæ·»ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™å°†å¼ºåˆ¶æŠŠ `String` è½¬ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚"""

# TEST 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "compile"
hint = "No hints this time ;)"

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Err` æ˜¯ `Result` çš„æˆå‘˜ä¹‹ä¸€ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªæµ‹è¯•çš„æ„æ€æ˜¯ `generate_nametag_text` 
åº”è¯¥è¿”å› `Result` è€Œä¸æ˜¯ `Option` ã€‚

è¦åšåˆ°è¿™äº›æ”¹å˜ï¼Œä½ éœ€è¦ï¼š
   - ä¿®æ”¹å‡½æ•°ç­¾åçš„è¿”å›ç±»å‹ä¸º Result<String, String>ï¼Œä»¥ä¾¿èƒ½è¿”å› `Ok(String)` å’Œ `Err(String)`ã€‚
   - æ›´æ”¹å‡½æ•°è¿”å›å€¼ `Some(stuff)` ä¸º `Ok(stuff)` ã€‚
   - æ›´æ”¹å‡½æ•°è¿”å›å€¼ `None` ä¸º `Err(error message)` ã€‚
   - å°†ç¬¬ä¸€ä¸ªæµ‹è¯•é¢„æœŸçš„å€¼ä» `Some(stuff)` æ”¹ä¸º `Ok(stuff)`ã€‚"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯å¯¹ `item_quantity.parse::<i32>()` ä½¿ç”¨ match è¯­å¥ï¼Œ
å…¶ä¸­æœ‰ä¸¤ç§æƒ…å†µéœ€è¦è¢«å¤„ç†ï¼Œåˆ†åˆ«æ˜¯ `Ok(something)` å’Œ `Err(something)`ã€‚
ä¸è¿‡è¿™ç§æ–¹æ³•åœ¨ Rust ä¸­å¾ˆå¸¸è§ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ª `?` æ“ä½œç¬¦ï¼Œä½œç”¨å‡ ä¹ç¬¦åˆä½ æƒ³è®©åŒ¹é…è¯­å¥åšçš„äº‹ï¼
çœ‹ä¸€ä¸‹ Error Handling ç« èŠ‚çš„è¿™éƒ¨åˆ†:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
ç„¶åè¯•ä¸€è¯•ï¼"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
å¦‚æœå…¶å®ƒå‡½æ•°å¯ä»¥è¿”å› `Result`ï¼Œä¸ºä»€ä¹ˆ `main` å‡½æ•°ä¸èƒ½ï¼Ÿ"""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` å°†åˆ›å»ºä¸€ä¸ªæ–°çš„å®ä¾‹ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Ok` ã€‚
å®ƒåº”è¯¥åšä¸€äº›æ£€æŸ¥ï¼Œå¦‚æœæ£€æŸ¥åˆ°å¤±è´¥ï¼Œåˆ™è¿”å› `Err` ï¼Œå¦‚æœç¡®å®šä¸€åˆ‡æ­£å¸¸ï¼Œåˆ™è¿”å› `Ok` :)ã€‚"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
æç¤ºï¼šåœ¨ `main()` ä¸­äº§ç”Ÿäº†ä¸¤ç§ `Result` ç±»å‹ï¼Œå®ƒä»¬æ˜¯é€šè¿‡ `?` è¿ç®—ç¬¦è¿”å›çš„ã€‚
é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•åœ¨ `main()` ä¸­å£°æ˜ä¸€ä¸ªå®¹çº³è¿™ä¸¤è€…çš„è¿”å›ç±»å‹ï¼Ÿ

é¢å¤–æç¤ºï¼š`?` æ“ä½œç¬¦çš„åº•å±‚å®ç°å®é™…ä¸Šæ˜¯å¯¹é”™è¯¯å€¼è°ƒç”¨äº† `From::from` ï¼Œå°†å…¶è½¬æ¢ä¸º
äº† `Box<dyn error::Error>` ç±»å‹ã€‚å®ƒæ˜¯å¤šæ€çš„â€”â€”è¿™æ„å‘³ç€ä¸åŒç±»å‹çš„é”™è¯¯å¯ä»¥ä»åŒä¸€ä¸ªå‡½æ•°è¿”å›ï¼Œ
å› ä¸ºå®ƒä»¬éƒ½å®ç°äº†`error::Error`ç‰¹å¾ï¼Œè¡Œä¸ºéƒ½æ˜¯ä¸€è‡´çš„ã€‚
è¯·çœ‹è¿™æœ¬ä¹¦çš„è¿™ä¸€éƒ¨åˆ†ï¼š
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

è¿™ä¸ªç»ƒä¹ ä½¿ç”¨äº†ä¸€äº›è¯¾ç¨‹åæœŸæ‰ä¼šä»‹ç»åˆ°çš„æ¦‚å¿µï¼Œå¦‚ `Box` æŒ‡é’ˆå’Œ `From` ç‰¹å¾ã€‚
ç°åœ¨è¯¦ç»†äº†è§£å®ƒä»¬å¹¶ä¸é‡è¦ï¼Œä½†å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œå¯ä»¥æå‰é˜…è¯»ã€‚

é˜…è¯»æ›´å¤šè£…ç®±é”™è¯¯ï¼ˆboxing errorsï¼‰çš„å†…å®¹ï¼š
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

é˜…è¯»æ›´å¤šå…³äºä½¿ç”¨ `?` æ“ä½œç¬¦å’Œè£…ç®±é”™è¯¯çš„å†…å®¹ã€‚
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
è¿™ä¸ªç»ƒä¹ ä½¿ç”¨çš„æ˜¯æ¥è‡ªäº error 4 çš„ `PositiveNonzeroInteger` å®Œæ•´ç‰ˆæœ¬ã€‚

åœ¨ TODO è¦æ±‚ä½ ä¿®æ”¹çš„é‚£ä¸€è¡Œä¸‹é¢ï¼Œæœ‰ä¸€ä¸ªåœ¨ `Result` ä¸Šä½¿ç”¨ `map_err()` æ–¹æ³•å°†
ä¸€ç§ç±»å‹çš„é”™è¯¯è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„ä¾‹å­ã€‚å°è¯•åœ¨ `parse()` çš„ `Result` ä¸Šä½¿ç”¨ç±»ä¼¼çš„ä¸œè¥¿ã€‚
ä½ å¯èƒ½ä½¿ç”¨ `?` æ“ä½œç¬¦åœ¨å‡½æ•°ä¸­æå‰è¿”å›ï¼Œæˆ–è€…ä½¿ç”¨ `match` è¡¨è¾¾å¼ï¼Œä»¥åŠç­‰ç­‰å…¶å®ƒæ–¹æ³•ã€‚

ä½ å¯ä»¥åœ¨ `impl ParsePosNonzeroError` å†…åˆ›å»ºå¦ä¸€ä¸ªæ–¹æ³•æ¥é…åˆ `map_err()` ä½¿ç”¨ã€‚

åœ¨ `std::result` æ–‡æ¡£äº†è§£æ›´å¤šå…³äº `map_err()` çš„ä¿¡æ¯ï¼š
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Rust ä¸­çš„ Vector é€šè¿‡æ³›å‹æ¥åˆ›å»ºä»»æ„ç±»å‹çš„åŠ¨æ€æ•°ç»„ã€‚
æ‰€ä»¥ä½ è¦å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬è¦æŠŠä»€ä¹ˆç±»å‹çš„å…ƒç´ æ¨å…¥åˆ°è¿™ä¸ªæ•°ç»„é‡Œã€‚"""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
ç›®å‰æˆ‘ä»¬åªåŒ…è£…äº† 'u32' ç±»å‹çš„å€¼ã€‚
æˆ–è®¸æˆ‘ä»¬å¯ä»¥é€šè¿‡æŸç§æ–¹å¼æ¥ä¿®æ”¹å¯¹ç±»å‹çš„æ˜¾å¼å¼•ç”¨ï¼Ÿ

å¦‚æœä½ è¿˜æ²¡æœ‰å¤´ç»ªï¼šhttps://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

[[exercises]]
name = "generics3"
path = "exercises/generics/generics3.rs"
mode = "test"
hint = """
ä¸ºäº†æ‰¾åˆ°è§£å†³è¿™ä¸ªéš¾é¢˜çš„æœ€ä½³æ–¹æ³•ï¼Œä½ éœ€è¦å›æƒ³ä¸€ä¸‹æœ‰å…³ trait çš„çŸ¥è¯†ï¼Œç‰¹åˆ«æ˜¯ trait çš„ç»‘å®šè¯­æ³•â€”â€”å¯èƒ½
è¿˜éœ€è¦è¿™ä¸ªï¼š"use std::fmt::Display;"

è¿™ç»å¯¹æ¯”å‰ä¸¤ä¸ªç»ƒä¹ æ›´éš¾ï¼ä½ éœ€è¦ä½¿ ReportCard ç»“æ„é€šç”¨ï¼Œå¹¶æ‹¥æœ‰æ­£ç¡®çš„å±æ€§ï¼ŒåŒæ—¶
ä½ ä¹Ÿéœ€è¦ç¨å¾®æ”¹å˜ä¸€ä¸‹ç»“æ„çš„å®ç°â€¦â€¦åŠ æ²¹ğŸ’ªï¼
"""

# OPTIONS

[[exercises]]
name = "option1"
path = "exercises/option/option1.rs"
mode = "compile"
hint = """
æç¤º 1ï¼šäº†è§£ Option çš„ä¸€äº›æ–¹æ³•ï¼š
is_some
is_none
unwrap

å’Œï¼š
æ¨¡å¼åŒ¹é…

æç¤º 2ï¼šæ•°ç»„æ²¡æœ‰åˆé€‚çš„é»˜è®¤å€¼ï¼›åœ¨ä½¿ç”¨å‰éœ€è¦æ·»åŠ è¿™äº›å€¼ã€‚
"""

[[exercises]]
name = "option2"
path = "exercises/option/option2.rs"
mode = "compile"
hint = """
æŸ¥çœ‹ï¼š
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

è®°ä½ï¼Œå¯ä»¥å¤šæ¬¡å±‚å åœ°å¯¹ Options ä½¿ç”¨ if let æˆ– while let ã€‚
ä¾‹å¦‚: Some(Some(variable)) = variable2
ä¹Ÿå¯ä»¥å‚è€ƒä¸‹ Option::flatten
"""

[[exercises]]
name = "option3"
path = "exercises/option/option3.rs"
mode = "compile"
hint = """
ç¼–è¯‘å™¨è¯´ `match` è¯­å¥ä¸­å‘ç”Ÿäº†éƒ¨åˆ†ç§»åŠ¨ã€‚
æ€æ ·é¿å…è¿™ç§æƒ…å†µï¼Ÿç¼–è¯‘å™¨ä¹Ÿå·²ç»™å‡ºäº†æ‰€éœ€çš„ä¿®æ­£ã€‚
æŒ‰ç…§ç¼–è¯‘å™¨çš„å»ºè®®è¿›è¡Œä¿®æ­£åï¼Œè¯·é˜…è¯»ï¼šhttps://doc.rust-lang.org/std/keyword.ref.html"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
ä¸‹é¢çš„ç½‘ç«™æ˜¯å…³äº Rust ä¸­ Traits çš„è®¨è®ºï¼š
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
æ³¨æ„ trait æ˜¯å¦‚ä½•å–å¾— 'self' çš„æ‰€æœ‰æƒï¼Œå¹¶è¿”å›ä¸€ä¸ª 'Self' çš„ã€‚
å°è¯•ä¿®æ”¹ä¼ å…¥çš„å­—ç¬¦ä¸² vectorã€‚ 

Vector å·²æä¾›äº†åœ¨å®ƒå°¾éƒ¨æ·»åŠ ä¸€ä¸ªå…ƒç´ çš„æ–¹æ³•ã€‚
å‚é˜…æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/std/vec/struct.Vec.html"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
ä½ ç”šè‡³ä¸éœ€è¦å†™ä»»ä½•ç”¨äºæµ‹è¯•çš„ä»£ç â€”â€”ç›´æ¥å¡«å…¥æŸä¸ªå€¼ç„¶åè¿è¡Œï¼Œå³ä½¿åœ¨ç°å®ä¸­è¿™æ ·åšæ²¡ä»€ä¹ˆæ„ä¹‰ :) 
`assert!` æ˜¯éœ€è¦ä¸€ä¸ªå‚æ•°çš„å®ã€‚æ ¹æ®å‚æ•°çš„å€¼ï¼Œ`assert!` å¯èƒ½ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼ˆè¿™æ„å‘³å°†é€š
è¿‡æµ‹è¯•ï¼‰æˆ–è€… `assert!` å¼•å‘äº† panic ï¼ˆæµ‹è¯•å¤±è´¥ï¼‰ã€‚æ‰€ä»¥è¯•ç€å»ç»™ `assert!` èµ‹äºˆä¸åŒçš„å€¼ï¼Œçœ‹
çœ‹å“ªäº›å¯ä»¥ç¼–è¯‘ï¼Œå“ªäº›èƒ½å¤Ÿé€šè¿‡ï¼Œå“ªäº›å°†é€ æˆå¤±è´¥ :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
å’Œå‰é¢çš„ç»ƒä¹ ä¸€æ ·ï¼Œä½ æ— éœ€ç¼–å†™ä»»ä½•ä»£ç å°±å¯ä»¥ç¼–è¯‘å’Œè¿è¡Œè¿™ä¸ªæµ‹è¯•ã€‚
`assert_eq!` æ˜¯ä¸€ä¸ªæ¥å—ä¸¤ä¸ªå‚æ•°å¹¶æ¯”è¾ƒä¸¤è€…çš„å®ã€‚å°è¯•ç»™å®ƒä¸¤ä¸ªç›¸ç­‰ã€ä¸¤ä¸ªä¸åŒçš„
å€¼å’Œä¸¤ä¸ªä¸åŒç±»å‹çš„å€¼ï¼ä¹Ÿä¸å¦¨è¯•è¯•è°ƒæ¢ä¸‹ä¸¤ä¸ªå‚æ•°çš„ä½ç½®"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
ä½ å¯ä»¥åœ¨ `assert!` æ¥å—å‚æ•°çš„ä½ç½®ç›´æ¥è°ƒç”¨ä¸€ä¸ªå‡½æ•°â€”â€”æ‰€ä»¥ä½ å¯ä»¥åšä¸€äº›ç±»ä¼¼äº
`assert!(having_fun())` çš„äº‹æƒ…ã€‚å¦‚æœä½ æƒ³æ£€æŸ¥å¾—åˆ°çš„å€¼æ˜¯ä¸æ˜¯ false ï¼Œå¯ä»¥
ç”¨ `!` æ¥å–åç»“æœï¼Œä¾‹å¦‚ `assert!(!having_fun())`ã€‚"""

# TEST 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = "No hints this time ;)"

# STANDARD LIBRARY TYPES

[[exercises]]
name = "box1"
path = "exercises/standard_library_types/box1.rs"
mode = "test"
hint = """
Step 1
The compiler's message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our `List` inside a `Box`. More details in the book here:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2
Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons "list builder".
Although the current list is one of integers (i32), feel free to change the definition
and try other types!
"""

[[exercises]]
name = "arc1"
path = "exercises/standard_library_types/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "iterators1"
path = "exercises/standard_library_types/iterators1.rs"
mode = "compile"
hint = """
Step 1:
We need to apply something to the collection `my_fav_fruits` before we start to go through
it. What could that be? Take a look at the struct definition for a vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html.
Step 2 & step 2.1:
Very similar to the lines above and below. You've got this!
Step 3:
An iterator goes through all elements in a collection, but what if we've run out of
elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/standard_library_types/iterators2.rs"
mode = "test"
hint = """
Step 1
The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.
The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.
The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2
Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to collect the iterator.

Step 3.
This is surprising similar to the previous solution. Collect is very powerful
and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/standard_library_types/iterators3.rs"
mode = "test"
hint = """
The divide function needs to return the correct error when even division is not
possible.

The division_results variable needs to be collected into a collection type.

The result_with_list function needs to return a single Result where the success
case is a vector of integers and the failure case is a DivisionError.

The list_of_results function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for how 
the `FromIterator` trait is used in `collect()`."""

[[exercises]]
name = "iterators4"
path = "exercises/standard_library_types/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a for loop that updates
a mutable variable. Or, you might write code utilizing recursion
and a match clause. In Rust you can take another functional
approach, computing the factorial elegantly with ranges and iterators."""

[[exercises]]
name = "iterators5"
path = "exercises/standard_library_types/iterators5.rs"
mode = "test"
hint = """
The documentation for the std::iter::Iterator trait contains numerous methods
that would be helpful here.

Return 0 from count_collection_iterator to make the code compile in order to
test count_iterator.

The collection variable in count_collection_iterator is a slice of HashMaps. It
needs to be converted into an iterator in order to use the iterator methods.

The fold method can be useful in the count_collection_iterator function.

For a further challenge, consult the documentation for Iterator to find
a different method that could make your code more compact than using fold."""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)


Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));`
Similar to the code in the example in the book that happens after the text
that says "We can use Arc<T> to fix this.". If not, give that a try! If you
do and would like more hints, keep reading!!


Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

Ok, so, real talk, this was actually tricky for *me* to do too. And
I could see a lot of different problems you might run into, so at this
point I'm not sure which one you've hit :)

Please open an issue if you're still running into a problem that
these hints are not helping you with, or if you've looked at the sample
answers and don't understand why they work and yours doesn't.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.
The way macros are written, it wants to see something between each
"macro arm", so it can separate them."""

# TEST 4

[[exercises]]
name = "quiz4"
path = "exercises/quiz4.rs"
mode = "test"
hint = "No hints this time ;)"

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Not every floating point value can be represented exactly in binary values in
memory. Take a look at the description of 
https://doc.rust-lang.org/stable/std/primitive.f32.html
When using the binary compare operators with floating points you won't compare
the floating point values but the binary representation in memory. This is 
usually not what you would like to do. 
See the suggestions of the clippy warning in compile output and use the
machine epsilon value...
https://doc.rust-lang.org/stable/std/primitive.f32.html#associatedconstant.EPSILON"""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over Option values are more clearly expressed as an `if let`"""

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Hint: Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Hint: Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add AsRef<str> as a trait bound to the functions."""

# ADVANCED ERRORS

[[exercises]]
name = "advanced_errs1"
path = "exercises/advanced_errors/advanced_errs1.rs"
mode = "test"
hint = """
This exercise uses an updated version of the code in errors6. The parsing
code is now in an implementation of the `FromStr` trait. Note that the
parsing code uses `?` directly, without any calls to `map_err()`. There is
one partial implementation of the `From` trait example that you should
complete.

Details: The `?` operator calls `From::from()` on the error type to convert
it to the error type of the return type of the surrounding function.

Hint: You will need to write another implementation of `From` that has a
different input type.
"""

[[exercises]]
name = "advanced_errs2"
path = "exercises/advanced_errors/advanced_errs2.rs"
mode = "test"
hint = """
This exercise demonstrates a few traits that are useful for custom error
types to implement. These traits make it easier for other code to consume
the custom error type.

Follow the steps in the comment near the top of the file. You will have to
supply a missing trait implementation, and complete a few incomplete ones.

You may find these pages to be helpful references:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/define_error_type.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/wrap_error.html

Hint: What trait must our error type have for `main()` to return the return
type that it returns?

Another hint: It's not necessary to implement any methods inside the missing
trait. (Some methods have default implementations that are supplied by the
trait.)

Another hint: Consult the tests to determine which error variants (and which
error message text) to produce for certain error conditions.

Challenge: There is one test that is marked `#[ignore]`. Can you supply the
missing code that will make it pass? You may want to consult the standard
library documentation for a certain trait for more hints.
"""



================================================
FILE: assets/rustlings-zh/install.ps1
================================================
#!/usr/bin/env pwsh

#Requires -Version 5
param($path = "$pwd/rustlings")

Write-Host "Let's get you set up with Rustlings!"

Write-Host "Checking requirements..."
if (Get-Command git -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS: Git is installed"
} else {
    Write-Host "WARNING: Git does not seem to be installed."
    Write-Host "Please download Git using your package manager or over https://git-scm.com/!"
    exit 1
}

if (Get-Command rustc -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS:  Rust is installed"
} else {
    Write-Host "WARNING: Rust does not seem to be installed."
    Write-Host "Please download Rust using https://rustup.rs!"
    exit 1
}

if (Get-Command cargo -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS: Cargo is installed"
} else {
    Write-Host "WARNING: Cargo does not seem to be installed."
    Write-Host "Please download Rust and Cargo using https://rustup.rs!"
    exit 1
}

# Function that compares two versions strings v1 and v2 given in arguments (e.g 1.31 and 1.33.0).
# Returns 1 if v1 > v2, 0 if v1 == v2, 2 if v1 < v2.
function vercomp($v1, $v2) {
    if ($v1 -eq $v2) {
       return 0
    }

    $v1 = $v1.Replace(".", "0")
    $v2 = $v2.Replace(".", "0")
    if ($v1.Length -gt $v2.Length) {
        $v2 = $v2.PadRight($v1.Length, "0")
    } else {
        $v1 = $v1.PadRight($v2.Length, "0")
    }

    if ($v1 -gt $v2) {
        return 1
    } else {
        return 2
    }
}

$rustVersion = $(rustc --version).Split(" ")[1]
$minRustVersion = "1.39"
if ((vercomp $rustVersion $minRustVersion) -eq 2) {
    Write-Host "WARNING: Rust version is too old: $rustVersion - needs at least $minRustVersion"
    Write-Host "Please update Rust with 'rustup update'"
    exit 1
} else {
    Write-Host "SUCCESS: Rust is up to date"
}

Write-Host "Cloning Rustlings at $path"
git clone -q https://github.com/rust-lang/rustlings $path
if (!($LASTEXITCODE -eq 0)) {
    exit 1
}

# UseBasicParsing is deprecated, pwsh 6 or above will automatically use it,
# but anyone running pwsh 5 will have to pass the argument.
$version = Invoke-WebRequest -UseBasicParsing https://api.github.com/repos/rust-lang/rustlings/releases/latest `
    | ConvertFrom-Json | Select-Object -ExpandProperty tag_name

Write-Host "Checking out version $version..."
Set-Location $path
git checkout -q tags/$version

Write-Host "Installing the 'rustlings' executable..."
cargo install --force --path .
if (!(Get-Command rustlings -ErrorAction SilentlyContinue)) {
    Write-Host "WARNING: Please check that you have '~/.cargo/bin' in your PATH environment variable!"
}

# Checking whether Clippy is installed.
# Due to a bug in Cargo, this must be done with Rustup: https://github.com/rust-lang/rustup/issues/1514
$clippy = (rustup component list | Select-String "clippy" | Select-String "installed") | Out-String
if (!$clippy) {
    Write-Host "Installing the 'cargo-clippy' executable..."
    rustup component add clippy
}

Write-Host "All done! Run 'rustlings' to get started."



================================================
FILE: assets/rustlings-zh/install.sh
================================================
#!/usr/bin/env bash

echo "Let's get you set up with Rustlings!"

echo "Checking requirements..."
if [ -x "$(command -v git)" ]
then
    echo "SUCCESS: Git is installed"
else
    echo "ERROR: Git does not seem to be installed."
    echo "Please download Git using your package manager or over https://git-scm.com/!"
    exit 1
fi

if [ -x "$(command -v rustc)" ]
then
    echo "SUCCESS: Rust is installed"
else
    echo "ERROR: Rust does not seem to be installed."
    echo "Please download Rust using https://rustup.rs!"
    exit 1
fi

if [ -x "$(command -v cargo)" ]
then
    echo "SUCCESS: Cargo is installed"
else
    echo "ERROR: Cargo does not seem to be installed."
    echo "Please download Rust and Cargo using https://rustup.rs!"
    exit 1
fi

# Look up python installations, starting with 3 with a fallback of 2
if [ -x "$(command -v python3)" ]
then
    PY="$(command -v python3)"
elif [ -x "$(command -v python)" ]
then
    PY="$(command -v python)"
elif [ -x "$(command -v python2)" ]
then
    PY="$(command -v python2)"
else
    echo "ERROR: No working python installation was found"
    echo "Please install python and add it to the PATH variable"
    exit 1
fi

# Function that compares two versions strings v1 and v2 given in arguments (e.g 1.31 and 1.33.0).
# Returns 1 if v1 > v2, 0 if v1 == v2, 2 if v1 < v2.
function vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    v1=( ${1//./ } )
    v2=( ${2//./ } )
    len1=${#v1[@]}
    len2=${#v2[@]}
    max_len=$len1
    if [[ $max_len -lt $len2 ]]
    then
        max_len=$len2
    fi
    for i in `seq 0 $max_len`
    do
        # Fill empty fields with zeros in v1
        if [ -z "${v1[$i]}" ]
        then
            v1[$i]=0
        fi
        # And in v2
        if [ -z "${v2[$i]}" ]
        then
            v2[$i]=0
        fi
        if [ ${v1[$i]} -gt ${v2[$i]} ]
        then
            return 1
        fi
        if [ ${v1[$i]} -lt ${v2[$i]} ]
        then
            return 2
        fi
    done
    return 0
}

RustVersion=$(rustc --version | cut -d " " -f 2)
MinRustVersion=1.39
vercomp $RustVersion $MinRustVersion
if [ $? -eq 2 ]
then
    echo "ERROR: Rust version is too old: $RustVersion - needs at least $MinRustVersion"
    echo "Please update Rust with 'rustup update'"
    exit 1
else
    echo "SUCCESS: Rust is up to date"
fi

Path=${1:-rustlings/}
echo "Cloning Rustlings at $Path..."
git clone -q https://github.com/rust-lang/rustlings $Path

cd $Path

Version=$(curl -s https://api.github.com/repos/rust-lang/rustlings/releases/latest | ${PY} -c "import json,sys;obj=json.load(sys.stdin);print(obj['tag_name']);")
CargoBin="${CARGO_HOME:-$HOME/.cargo}/bin"

if [[ -z ${Version} ]]
then
    echo "The latest tag version could not be fetched remotely."
    echo "Using the local git repository..."
    Version=$(ls -tr .git/refs/tags/ | tail -1)
    if [[ -z ${Version}  ]]
    then
        echo "No valid tag version found"
        echo "Rustlings will be installed using the main branch"
        Version="main"
    else
        Version="tags/${Version}"
    fi
else
    Version="tags/${Version}"
fi

echo "Checking out version $Version..."
git checkout -q ${Version}

echo "Installing the 'rustlings' executable..."
cargo install --force --path .

if ! [ -x "$(command -v rustlings)" ]
then
    echo "WARNING: Please check that you have '$CargoBin' in your PATH environment variable!"
fi

# Checking whether Clippy is installed.
# Due to a bug in Cargo, this must be done with Rustup: https://github.com/rust-lang/rustup/issues/1514
Clippy=$(rustup component list | grep "clippy" | grep "installed")
if [ -z "$Clippy" ]
then
    echo "Installing the 'cargo-clippy' executable..."
    rustup component add clippy
fi

echo "All done! Run 'rustlings' to get started."



================================================
FILE: assets/rustlings-zh/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2016 Carol (Nichols || Goulding)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: assets/rustlings-zh/.all-contributorsrc
================================================
{
  "files": [
    "README.md"
  ],
  "imageSize": 100,
  "commit": false,
  "contributors": [
    {
      "login": "carols10cents",
      "name": "Carol (Nichols || Goulding)",
      "avatar_url": "https://avatars2.githubusercontent.com/u/193874?v=4",
      "profile": "http://carol-nichols.com",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "QuietMisdreavus",
      "name": "QuietMisdreavus",
      "avatar_url": "https://avatars2.githubusercontent.com/u/5217170?v=4",
      "profile": "https://twitter.com/QuietMisdreavus",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "robertlugg",
      "name": "Robert M Lugg",
      "avatar_url": "https://avatars0.githubusercontent.com/u/6054540?v=4",
      "profile": "https://github.com/robertlugg",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hynek",
      "name": "Hynek Schlawack",
      "avatar_url": "https://avatars3.githubusercontent.com/u/41240?v=4",
      "profile": "https://hynek.me/about/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "spacekookie",
      "name": "Katharina Fey",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7669898?v=4",
      "profile": "https://spacekookie.de",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lukabavdaz",
      "name": "lukabavdaz",
      "avatar_url": "https://avatars0.githubusercontent.com/u/9624558?v=4",
      "profile": "https://github.com/lukabavdaz",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "evestera",
      "name": "Erik Vesteraas",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4187449?v=4",
      "profile": "http://vestera.as",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Delet0r",
      "name": "delet0r",
      "avatar_url": "https://avatars1.githubusercontent.com/u/23195618?v=4",
      "profile": "https://github.com/Delet0r",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "shaunbennett",
      "name": "Shaun Bennett",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10522375?v=4",
      "profile": "http://phinary.ca",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "abagshaw",
      "name": "Andrew Bagshaw",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8594541?v=4",
      "profile": "https://github.com/abagshaw",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kisom",
      "name": "Kyle Isom",
      "avatar_url": "https://avatars2.githubusercontent.com/u/175578?v=4",
      "profile": "https://ai6ua.net/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ColinPitrat",
      "name": "Colin Pitrat",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1541863?v=4",
      "profile": "https://github.com/ColinPitrat",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "zacanger",
      "name": "Zac Anger",
      "avatar_url": "https://avatars3.githubusercontent.com/u/12520493?v=4",
      "profile": "https://zacanger.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "mgeier",
      "name": "Matthias Geier",
      "avatar_url": "https://avatars1.githubusercontent.com/u/705404?v=4",
      "profile": "https://github.com/mgeier",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "cjpearce",
      "name": "Chris Pearce",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3453268?v=4",
      "profile": "https://github.com/cjpearce",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "yvan-sraka",
      "name": "Yvan Sraka",
      "avatar_url": "https://avatars2.githubusercontent.com/u/705213?v=4",
      "profile": "https://yvan-sraka.github.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "dendi239",
      "name": "Denys Smirnov",
      "avatar_url": "https://avatars3.githubusercontent.com/u/16478650?v=4",
      "profile": "https://github.com/dendi239",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "eddyp",
      "name": "eddyp",
      "avatar_url": "https://avatars2.githubusercontent.com/u/123772?v=4",
      "profile": "https://github.com/eddyp",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "briankung",
      "name": "Brian Kung",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2836167?v=4",
      "profile": "http://about.me/BrianKung",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "miller-time",
      "name": "Russell",
      "avatar_url": "https://avatars3.githubusercontent.com/u/281039?v=4",
      "profile": "https://rcousineau.gitlab.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "danwilhelm",
      "name": "Dan Wilhelm",
      "avatar_url": "https://avatars3.githubusercontent.com/u/6137185?v=4",
      "profile": "http://danwilhelm.com",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "Jesse-Cameron",
      "name": "Jesse",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3723654?v=4",
      "profile": "https://github.com/Jesse-Cameron",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "MrFroop",
      "name": "Fredrik JambrÃ©n",
      "avatar_url": "https://avatars3.githubusercontent.com/u/196700?v=4",
      "profile": "https://github.com/MrFroop",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "petemcfarlane",
      "name": "Pete McFarlane",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3472717?v=4",
      "profile": "https://github.com/petemcfarlane",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "nkanderson",
      "name": "nkanderson",
      "avatar_url": "https://avatars0.githubusercontent.com/u/4128825?v=4",
      "profile": "https://github.com/nkanderson",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "ajaxm",
      "name": "Ajax M",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13360138?v=4",
      "profile": "https://github.com/ajaxm",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "Dylnuge",
      "name": "Dylan Nugent",
      "avatar_url": "https://avatars2.githubusercontent.com/u/118624?v=4",
      "profile": "https://dylnuge.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "vyaslav",
      "name": "vyaslav",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1385427?v=4",
      "profile": "https://github.com/vyaslav",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "gdoenlen",
      "name": "George",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17297466?v=4",
      "profile": "https://join.sfxd.org",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "nyxtom",
      "name": "Thomas Holloway",
      "avatar_url": "https://avatars2.githubusercontent.com/u/222763?v=4",
      "profile": "https://github.com/nyxtom",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "workingjubilee",
      "name": "Jubilee",
      "avatar_url": "https://avatars1.githubusercontent.com/u/46493976?v=4",
      "profile": "https://github.com/workingjubilee",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "WofWca",
      "name": "WofWca",
      "avatar_url": "https://avatars1.githubusercontent.com/u/39462442?v=4",
      "profile": "https://github.com/WofWca",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "jrvidal",
      "name": "Roberto Vidal",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1636604?v=4",
      "profile": "https://github.com/jrvidal",
      "contributions": [
        "code",
        "doc",
        "ideas",
        "maintenance"
      ]
    },
    {
      "login": "jensim",
      "name": "Jens",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3663856?v=4",
      "profile": "https://github.com/jensim",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "rahatarmanahmed",
      "name": "Rahat Ahmed",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3174006?v=4",
      "profile": "http://rahatah.me/d",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "AbdouSeck",
      "name": "Abdou Seck",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6490055?v=4",
      "profile": "https://github.com/AbdouSeck",
      "contributions": [
        "code",
        "content",
        "review"
      ]
    },
    {
      "login": "codehearts",
      "name": "Katie",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2885412?v=4",
      "profile": "https://codehearts.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Socratides",
      "name": "Socrates",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27732983?v=4",
      "profile": "https://github.com/Socratides",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "gnodarse",
      "name": "gnodarse",
      "avatar_url": "https://avatars3.githubusercontent.com/u/46761795?v=4",
      "profile": "https://github.com/gnodarse",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "harrisonmetz",
      "name": "Harrison Metzger",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7883408?v=4",
      "profile": "https://github.com/harrisonmetz",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "TorbenJ",
      "name": "Torben Jonas",
      "avatar_url": "https://avatars2.githubusercontent.com/u/9077102?v=4",
      "profile": "https://github.com/TorbenJ",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "pbx",
      "name": "Paul Bissex",
      "avatar_url": "https://avatars0.githubusercontent.com/u/641?v=4",
      "profile": "http://paulbissex.com/",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "sjmann",
      "name": "Steven Mann",
      "avatar_url": "https://avatars0.githubusercontent.com/u/6589896?v=4",
      "profile": "https://github.com/sjmann",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "Tarnadas",
      "name": "Mario Reder",
      "avatar_url": "https://avatars2.githubusercontent.com/u/5855071?v=4",
      "profile": "https://smmdb.net/",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "sl4m",
      "name": "skim",
      "avatar_url": "https://avatars0.githubusercontent.com/u/47347?v=4",
      "profile": "https://keybase.io/skim",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "sanjaykdragon",
      "name": "Sanjay K",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10261698?v=4",
      "profile": "https://github.com/sanjaykdragon",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "crodjer",
      "name": "Rohan Jain",
      "avatar_url": "https://avatars1.githubusercontent.com/u/343499?v=4",
      "profile": "http://www.rohanjain.in",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "saidaspen",
      "name": "Said Aspen",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7727687?v=4",
      "profile": "https://www.saidaspen.se",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "uce",
      "name": "Ufuk Celebi",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1756620?v=4",
      "profile": "https://github.com/uce",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lebedevsergey",
      "name": "lebedevsergey",
      "avatar_url": "https://avatars2.githubusercontent.com/u/7325764?v=4",
      "profile": "https://github.com/lebedevsergey",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "avrong",
      "name": "Aleksei Trifonov",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6342851?v=4",
      "profile": "https://github.com/avrong",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Darrenmeehan",
      "name": "Darren Meehan",
      "avatar_url": "https://avatars2.githubusercontent.com/u/411136?v=4",
      "profile": "https://drn.ie",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jihchi",
      "name": "Jihchi Lee",
      "avatar_url": "https://avatars1.githubusercontent.com/u/87983?v=4",
      "profile": "https://github.com/jihchi",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "bertonha",
      "name": "Christofer Bertonha",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1225902?v=4",
      "profile": "https://github.com/bertonha",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "apatniv",
      "name": "Vivek Bharath Akupatni",
      "avatar_url": "https://avatars2.githubusercontent.com/u/22565917?v=4",
      "profile": "https://github.com/apatniv",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "DiD92",
      "name": "DÃ­dac SementÃ© FernÃ¡ndez",
      "avatar_url": "https://avatars3.githubusercontent.com/u/6002416?v=4",
      "profile": "https://github.com/DiD92",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "wrobstory",
      "name": "Rob Story",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2601457?v=4",
      "profile": "https://github.com/wrobstory",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "siobhanjacobson",
      "name": "Siobhan Jacobson",
      "avatar_url": "https://avatars2.githubusercontent.com/u/28983835?v=4",
      "profile": "https://github.com/siobhanjacobson",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "EvanCarroll",
      "name": "Evan Carroll",
      "avatar_url": "https://avatars2.githubusercontent.com/u/19922?v=4",
      "profile": "https://www.linkedin.com/in/evancarroll/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jmahmood",
      "name": "Jawaad Mahmood",
      "avatar_url": "https://avatars3.githubusercontent.com/u/95606?v=4",
      "profile": "http://www.jawaadmahmood.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "GaurangTandon",
      "name": "Gaurang Tandon",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6308683?v=4",
      "profile": "https://github.com/GaurangTandon",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "dev-cyprium",
      "name": "Stefan Kupresak",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6002628?v=4",
      "profile": "https://github.com/dev-cyprium",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "greg-el",
      "name": "Greg Leonard",
      "avatar_url": "https://avatars3.githubusercontent.com/u/45019882?v=4",
      "profile": "https://github.com/greg-el",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "ryanpcmcquen",
      "name": "Ryan McQuen",
      "avatar_url": "https://avatars3.githubusercontent.com/u/772937?v=4",
      "profile": "https://ryanpcmcquen.org",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "AnnikaCodes",
      "name": "Annika",
      "avatar_url": "https://avatars3.githubusercontent.com/u/56906084?v=4",
      "profile": "https://github.com/AnnikaCodes",
      "contributions": [
        "review"
      ]
    },
    {
      "login": "darnuria",
      "name": "Axel Viala",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2827553?v=4",
      "profile": "https://darnuria.eu",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "sazid",
      "name": "Mohammed Sazid Al Rashid",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2370167?v=4",
      "profile": "https://sazid.github.io",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "seeplusplus",
      "name": "Caleb Webber",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17479099?v=4",
      "profile": "https://codingthemsoftly.com",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "pcn",
      "name": "Peter N",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1056756?v=4",
      "profile": "https://github.com/pcn",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "seancad",
      "name": "seancad",
      "avatar_url": "https://avatars1.githubusercontent.com/u/47405611?v=4",
      "profile": "https://github.com/seancad",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "wsh",
      "name": "Will Hayworth",
      "avatar_url": "https://avatars3.githubusercontent.com/u/181174?v=4",
      "profile": "http://willhayworth.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "chrizel",
      "name": "Christian Zeller",
      "avatar_url": "https://avatars3.githubusercontent.com/u/20802?v=4",
      "profile": "https://github.com/chrizel",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jfchevrette",
      "name": "Jean-Francois Chevrette",
      "avatar_url": "https://avatars.githubusercontent.com/u/3001?v=4",
      "profile": "https://github.com/jfchevrette",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "jbaber",
      "name": "John Baber-Lucero",
      "avatar_url": "https://avatars.githubusercontent.com/u/1908117?v=4",
      "profile": "https://github.com/jbaber",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "tal-zvon",
      "name": "Tal",
      "avatar_url": "https://avatars.githubusercontent.com/u/3195851?v=4",
      "profile": "https://github.com/tal-zvon",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "apogeeoak",
      "name": "apogeeoak",
      "avatar_url": "https://avatars.githubusercontent.com/u/59737221?v=4",
      "profile": "https://github.com/apogeeoak",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "Crell",
      "name": "Larry Garfield",
      "avatar_url": "https://avatars.githubusercontent.com/u/254863?v=4",
      "profile": "http://www.garfieldtech.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "circumspect",
      "name": "circumspect",
      "avatar_url": "https://avatars.githubusercontent.com/u/40770208?v=4",
      "profile": "https://github.com/circumspect",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "cjwyett",
      "name": "Cyrus Wyett",
      "avatar_url": "https://avatars.githubusercontent.com/u/34195737?v=4",
      "profile": "https://github.com/cjwyett",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "cadolphs",
      "name": "cadolphs",
      "avatar_url": "https://avatars.githubusercontent.com/u/13894820?v=4",
      "profile": "https://github.com/cadolphs",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "hpwxf",
      "name": "Pascal H.",
      "avatar_url": "https://avatars.githubusercontent.com/u/26146722?v=4",
      "profile": "https://www.haveneer.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "chapeupreto",
      "name": "Rod Elias",
      "avatar_url": "https://avatars.githubusercontent.com/u/834048?v=4",
      "profile": "https://twitter.com/chapeupreto",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "blerchy",
      "name": "Matt Lebl",
      "avatar_url": "https://avatars.githubusercontent.com/u/2555355?v=4",
      "profile": "https://github.com/blerchy",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "flakolefluk",
      "name": "Ignacio Le Fluk",
      "avatar_url": "https://avatars.githubusercontent.com/u/11986564?v=4",
      "profile": "http://flakolefluk.dev",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "tlyu",
      "name": "Taylor Yu",
      "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4",
      "profile": "https://github.com/tlyu",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "Zerotask",
      "name": "Patrick Hintermayer",
      "avatar_url": "https://avatars.githubusercontent.com/u/20150243?v=4",
      "profile": "https://zerotask.github.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "arthas168",
      "name": "Pete Pavlovski",
      "avatar_url": "https://avatars.githubusercontent.com/u/32264020?v=4",
      "profile": "https://petkopavlovski.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "k12ish",
      "name": "k12ish",
      "avatar_url": "https://avatars.githubusercontent.com/u/45272873?v=4",
      "profile": "https://github.com/k12ish",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hongshaoyang",
      "name": "Shao Yang Hong",
      "avatar_url": "https://avatars.githubusercontent.com/u/19281800?v=4",
      "profile": "https://github.com/hongshaoyang",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "bmacer",
      "name": "Brandon Macer",
      "avatar_url": "https://avatars.githubusercontent.com/u/13931806?v=4",
      "profile": "https://github.com/bmacer",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "stoiandan",
      "name": "Stoian Dan",
      "avatar_url": "https://avatars.githubusercontent.com/u/10388612?v=4",
      "profile": "https://github.com/stoiandan",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "PiDelport",
      "name": "Pi Delport",
      "avatar_url": "https://avatars.githubusercontent.com/u/630271?v=4",
      "profile": "https://about.me/pjdelport",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "sateeshkumarb",
      "name": "Sateesh ",
      "avatar_url": "https://avatars.githubusercontent.com/u/429263?v=4",
      "profile": "https://github.com/sateeshkumarb",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "kayuapi",
      "name": "ZC",
      "avatar_url": "https://avatars.githubusercontent.com/u/10304328?v=4",
      "profile": "https://github.com/kayuapi",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hyperparabolic",
      "name": "hyperparabolic",
      "avatar_url": "https://avatars.githubusercontent.com/u/12348474?v=4",
      "profile": "https://github.com/hyperparabolic",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kolbma",
      "name": "arlecchino",
      "avatar_url": "https://avatars.githubusercontent.com/u/5228369?v=4",
      "profile": "https://www.net4visions.at",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "jazzplato",
      "name": "Richthofen",
      "avatar_url": "https://avatars.githubusercontent.com/u/7576730?v=4",
      "profile": "https://richthofen.io/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "cseltol",
      "name": "Ivan Nerazumov",
      "avatar_url": "https://avatars.githubusercontent.com/u/64264529?v=4",
      "profile": "https://github.com/cseltol",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "lauralindzey",
      "name": "lauralindzey",
      "avatar_url": "https://avatars.githubusercontent.com/u/65185744?v=4",
      "profile": "https://github.com/lauralindzey",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "sinharaksh1t",
      "name": "Rakshit Sinha",
      "avatar_url": "https://avatars.githubusercontent.com/u/28585848?v=4",
      "profile": "https://github.com/sinharaksh1t",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "dbednar230",
      "name": "Damian",
      "avatar_url": "https://avatars.githubusercontent.com/u/54457902?v=4",
      "profile": "https://github.com/dbednar230",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "benarmstead",
      "name": "Ben Armstead",
      "avatar_url": "https://avatars.githubusercontent.com/u/70973680?v=4",
      "profile": "https://benarmstead.co.uk",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "anuk909",
      "name": "anuk909",
      "avatar_url": "https://avatars.githubusercontent.com/u/34924662?v=4",
      "profile": "https://github.com/anuk909",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "granddaifuku",
      "name": "granddaifuku",
      "avatar_url": "https://avatars.githubusercontent.com/u/49578068?v=4",
      "profile": "https://granddaifuku.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Weilet",
      "name": "Weilet",
      "avatar_url": "https://avatars.githubusercontent.com/u/32561597?v=4",
      "profile": "https://weilet.me",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Millione",
      "name": "LIU JIE",
      "avatar_url": "https://avatars.githubusercontent.com/u/38575932?v=4",
      "profile": "https://github.com/Millione",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "abusch",
      "name": "Antoine BÃ¼sch",
      "avatar_url": "https://avatars.githubusercontent.com/u/506344?v=4",
      "profile": "https://github.com/abusch",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "frogtd",
      "name": "frogtd",
      "avatar_url": "https://avatars.githubusercontent.com/u/31412003?v=4",
      "profile": "https://frogtd.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "EmisonLu",
      "name": "Zhenghao Lu",
      "avatar_url": "https://avatars.githubusercontent.com/u/54395432?v=4",
      "profile": "https://github.com/EmisonLu",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "fredr",
      "name": "Fredrik Enestad",
      "avatar_url": "https://avatars.githubusercontent.com/u/762956?v=4",
      "profile": "https://soundtrackyourbrand.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "xuesongbj",
      "name": "xuesong",
      "avatar_url": "https://avatars.githubusercontent.com/u/18476085?v=4",
      "profile": "http://xuesong.pydevops.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "MpdWalsh",
      "name": "Michael Walsh",
      "avatar_url": "https://avatars.githubusercontent.com/u/48160144?v=4",
      "profile": "https://github.com/MpdWalsh",
      "contributions": [
        "code"
      ]
    }
  ],
  "contributorsPerLine": 8,
  "projectName": "rustlings",
  "projectOwner": "rust-lang",
  "repoType": "github",
  "repoHost": "https://github.com",
  "skipCi": true
}



================================================
FILE: assets/rustlings-zh/.clog.toml
================================================
[clog]

repository = "https://github.com/rust-lang/rustlings"
changelog = "CHANGELOG.md"


================================================
FILE: assets/rustlings-zh/.editorconfig
================================================
root = true

[*.rs]
end_of_line = lf
insert_final_newfile = true
indent_style = space
indent_size = 4



================================================
FILE: assets/rustlings-zh/.gitpod.yml
================================================
tasks:
  - init: /workspace/rustlings/install.sh
    command: /workspace/.cargo/bin/rustlings watch

vscode:
  extensions:
    - rust-lang.rust@0.7.8:CvNqMTgDdt3UXt+6BCDTVg==



================================================
FILE: assets/rustlings-zh/.replit
================================================
language = "rust"
run = "[ -x ~/.cargo/bin/rustlings ] && ~/.cargo/bin/rustlings watch || ./install.sh"



================================================
FILE: assets/rustlings-zh/exercises/README.md
================================================
# Exercise to Book Chapter mapping

| Exercise               | Book Chapter |
|------------------------|--------------|
| variables              | Â§3.1          |
| functions              | Â§3.3          |
| if                     | Â§3.5          |
| move_semantics         | Â§4.1          |
| primitive_types        | Â§4.3          |
| structs                | Â§5.1          |
| enums                  | Â§6            |
| modules                | Â§7            |
| collections            | Â§8.1, Â§8.3    |
| strings                | Â§8.2          |
| error_handling         | Â§9            |
| generics               | Â§10           |
| option                 | Â§10.1         |
| traits                 | Â§10.2         |
| tests                  | Â§11.1         |
| standard_library_types | Â§13.2         |
| threads                | Â§16.1         |
| macros                 | Â§19.6         |
| clippy                 | n/a           |
| conversions            | n/a           |



================================================
FILE: assets/rustlings-zh/exercises/quiz1.rs
================================================
// quiz1.rs
// This is a quiz for the following sections:
// - Variables
// - Functions

// Mary is buying apples. One apple usually costs 2 Rustbucks, but if you buy
// more than 40 at once, each apple only costs 1! Write a function that calculates
// the price of an order of apples given the quantity bought. No hints this time!

// I AM NOT DONE

// Put your function here!
// fn calculate_apple_price {

// Don't modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_apple_price(35);
    let price2 = calculate_apple_price(40);
    let price3 = calculate_apple_price(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(65, price3);
}



================================================
FILE: assets/rustlings-zh/exercises/quiz2.rs
================================================
// quiz2.rs
// This is a quiz for the following sections:
// - Strings

// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your
// task is to call one of these two functions on each value depending on what
// you think each value is. That is, add either `string_slice` or `string`
// before the parentheses on each line. If you're right, it will compile!

// I AM NOT DONE

fn string_slice(arg: &str) {
    println!("{}", arg);
}
fn string(arg: String) {
    println!("{}", arg);
}

fn main() {
    ???("blue");
    ???("red".to_string());
    ???(String::from("hi"));
    ???("rust is fun!".to_owned());
    ???("nice weather".into());
    ???(format!("Interpolation {}", "Station"));
    ???(&String::from("abc")[0..1]);
    ???("  hello there ".trim());
    ???("Happy Monday!".to_string().replace("Mon", "Tues"));
    ???("mY sHiFt KeY iS sTiCkY".to_lowercase());
}



================================================
FILE: assets/rustlings-zh/exercises/quiz3.rs
================================================
// quiz3.rs
// This is a quiz for the following sections:
// - Tests

// This quiz isn't testing our function -- make it do that in such a way that
// the test passes. Then write a second test that tests that we get the result
// we expect to get when we call `times_two` with a negative number.
// No hints, you can do this :)

// I AM NOT DONE

pub fn times_two(num: i32) -> i32 {
    num * 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_twice_of_positive_numbers() {
        assert_eq!(times_two(4), ???);
    }

    #[test]
    fn returns_twice_of_negative_numbers() {
        // TODO replace unimplemented!() with an assert for `times_two(-4)`
        unimplemented!()
    }
}



================================================
FILE: assets/rustlings-zh/exercises/quiz4.rs
================================================
// quiz4.rs
// This quiz covers the sections:
// - Modules
// - Macros

// Write a macro that passes the quiz! No hints this time, you can do it!

// I AM NOT DONE

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_macro_world() {
        assert_eq!(my_macro!("world!"), "Hello world!");
    }

    #[test]
    fn test_my_macro_goodbye() {
        assert_eq!(my_macro!("goodbye!"), "Hello goodbye!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/advanced_errors/advanced_errs1.rs
================================================
// advanced_errs1.rs

// Remember back in errors6, we had multiple mapping functions so that we
// could translate lower-level errors into our custom error type using
// `map_err()`? What if we could use the `?` operator directly instead?

// Make this code compile! Execute `rustlings hint advanced_errs1` for
// hints :)

// I AM NOT DONE

use std::num::ParseIntError;
use std::str::FromStr;

// This is a custom error type that we will be using in the `FromStr`
// implementation.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl From<CreationError> for ParsePosNonzeroError {
    fn from(e: CreationError) -> Self {
        // TODO: complete this implementation so that the `?` operator will
        // work for `CreationError`
    }
}

// TODO: implement another instance of the `From` trait here so that the
// `?` operator will work in the other place in the `FromStr`
// implementation below.

// Don't change anything below this line.

impl FromStr for PositiveNonzeroInteger {
    type Err = ParsePosNonzeroError;
    fn from_str(s: &str) -> Result<PositiveNonzeroInteger, Self::Err> {
        let x: i64 = s.parse()?;
        Ok(PositiveNonzeroInteger::new(x)?)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            PositiveNonzeroInteger::from_str("not a number"),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            PositiveNonzeroInteger::from_str("-555"),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            PositiveNonzeroInteger::from_str("0"),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(PositiveNonzeroInteger::from_str("42"), Ok(x.unwrap()));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/advanced_errors/advanced_errs2.rs
================================================
// advanced_errs2.rs

// This exercise demonstrates a few traits that are useful for custom error
// types to implement, especially so that other code can consume the custom
// error type more usefully.

// Make this compile, and make the tests pass!
// Execute `rustlings hint advanced_errs2` for hints.

// Steps:
// 1. Implement a missing trait so that `main()` will compile.
// 2. Complete the partial implementation of `From` for
//    `ParseClimateError`.
// 3. Handle the missing error cases in the `FromStr` implementation for
//    `Climate`.
// 4. Complete the partial implementation of `Display` for
//    `ParseClimateError`.

// I AM NOT DONE

use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::num::{ParseFloatError, ParseIntError};
use std::str::FromStr;

// This is the custom error type that we will be using for the parser for
// `Climate`.
#[derive(Debug, PartialEq)]
enum ParseClimateError {
    Empty,
    BadLen,
    NoCity,
    ParseInt(ParseIntError),
    ParseFloat(ParseFloatError),
}

// This `From` implementation allows the `?` operator to work on
// `ParseIntError` values.
impl From<ParseIntError> for ParseClimateError {
    fn from(e: ParseIntError) -> Self {
        Self::ParseInt(e)
    }
}

// This `From` implementation allows the `?` operator to work on
// `ParseFloatError` values.
impl From<ParseFloatError> for ParseClimateError {
    fn from(e: ParseFloatError) -> Self {
        // TODO: Complete this function
    }
}

// TODO: Implement a missing trait so that `main()` below will compile. It
// is not necessary to implement any methods inside the missing trait.

// The `Display` trait allows for other code to obtain the error formatted
// as a user-visible string.
impl Display for ParseClimateError {
    // TODO: Complete this function so that it produces the correct strings
    // for each error variant.
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // Imports the variants to make the following code more compact.
        use ParseClimateError::*;
        match self {
            NoCity => write!(f, "no city name"),
            ParseFloat(e) => write!(f, "error parsing temperature: {}", e),
        }
    }
}

#[derive(Debug, PartialEq)]
struct Climate {
    city: String,
    year: u32,
    temp: f32,
}

// Parser for `Climate`.
// 1. Split the input string into 3 fields: city, year, temp.
// 2. Return an error if the string is empty or has the wrong number of
//    fields.
// 3. Return an error if the city name is empty.
// 4. Parse the year as a `u32` and return an error if that fails.
// 5. Parse the temp as a `f32` and return an error if that fails.
// 6. Return an `Ok` value containing the completed `Climate` value.
impl FromStr for Climate {
    type Err = ParseClimateError;
    // TODO: Complete this function by making it handle the missing error
    // cases.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let v: Vec<_> = s.split(',').collect();
        let (city, year, temp) = match &v[..] {
            [city, year, temp] => (city.to_string(), year, temp),
            _ => return Err(ParseClimateError::BadLen),
        };
        let year: u32 = year.parse()?;
        let temp: f32 = temp.parse()?;
        Ok(Climate { city, year, temp })
    }
}

// Don't change anything below this line (other than to enable ignored
// tests).

fn main() -> Result<(), Box<dyn Error>> {
    println!("{:?}", "Hong Kong,1999,25.7".parse::<Climate>()?);
    println!("{:?}", "".parse::<Climate>()?);
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn test_empty() {
        let res = "".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::Empty));
        assert_eq!(res.unwrap_err().to_string(), "empty input");
    }
    #[test]
    fn test_short() {
        let res = "Boston,1991".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::BadLen));
        assert_eq!(res.unwrap_err().to_string(), "incorrect number of fields");
    }
    #[test]
    fn test_long() {
        let res = "Paris,1920,17.2,extra".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::BadLen));
        assert_eq!(res.unwrap_err().to_string(), "incorrect number of fields");
    }
    #[test]
    fn test_no_city() {
        let res = ",1997,20.5".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::NoCity));
        assert_eq!(res.unwrap_err().to_string(), "no city name");
    }
    #[test]
    fn test_parse_int_neg() {
        let res = "Barcelona,-25,22.3".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseInt(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing year: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_int_bad() {
        let res = "Beijing,foo,15.0".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseInt(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing year: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_float() {
        let res = "Manila,2001,bar".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseFloat(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseFloat(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing temperature: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_good() {
        let res = "Munich,2015,23.1".parse::<Climate>();
        assert_eq!(
            res,
            Ok(Climate {
                city: "Munich".to_string(),
                year: 2015,
                temp: 23.1,
            })
        );
    }
    #[test]
    #[ignore]
    fn test_downcast() {
        let res = "SÃ£o Paulo,-21,28.5".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        let inner: Option<&(dyn Error + 'static)> = err.source();
        assert!(inner.is_some());
        assert!(inner.unwrap().is::<ParseIntError>());
    }
}



================================================
FILE: assets/rustlings-zh/exercises/clippy/README.md
================================================
# Clippy

The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.

If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via `rustup component add clippy`.

## Further information

- [GitHub Repository](https://github.com/rust-lang/rust-clippy).



================================================
FILE: assets/rustlings-zh/exercises/clippy/clippy1.rs
================================================
// clippy1.rs
// The Clippy tool is a collection of lints to analyze your code
// so you can catch common mistakes and improve your Rust code.
//
// For these exercises the code will fail to compile when there are clippy warnings
// check clippy's suggestions from the output to solve the exercise.
// Execute `rustlings hint clippy1` for hints :)

// I AM NOT DONE

fn main() {
    let x = 1.2331f64;
    let y = 1.2332f64;
    if y != x {
        println!("Success!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/clippy/clippy2.rs
================================================
// clippy2.rs
// Make me compile! Execute `rustlings hint clippy2` for hints :)

// I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!("{}", res);
}



================================================
FILE: assets/rustlings-zh/exercises/collections/README.md
================================================
# é›†åˆï¼ˆCollectionsï¼‰

Rust çš„æ ‡å‡†åº“åŒ…å«äº†å¾ˆå¤šæœ‰ç”¨çš„æ•°æ®ç»“æ„ï¼Œå®ƒä»¬ç§°ä½œä¸ºé›†åˆã€‚
å¤§å¤šå…¶å®ƒçš„æ•°æ®ç±»å‹é€šå¸¸ä»…è¡¨ç¤ºä¸€ä¸ªç‰¹å®šçš„å€¼ï¼Œä½†é›†åˆå¯ä»¥åŒ…å«å¤šä¸ªå€¼ã€‚
å†…ç½®çš„æ•°ç»„å’Œå…ƒç»„ç±»å‹æŒ‡å‘çš„æ•°æ®å­˜å‚¨åœ¨å †ä¸Šï¼Œè¿™æ„å‘³ç€å­˜å‚¨çš„æ•°æ®ä¸å¿…åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œ
å¹¶å¯ä»¥æ ¹æ®ç¨‹åºçš„è¿è¡Œæ¥å¢åŠ æˆ–å‡å°‘ã€‚

æœ¬æ¬¡ç»ƒä¹ å°†å¸¦ä½ ç†Ÿæ‚‰ Rust ç¨‹åºä¸­ä¸¤ä¸ªç‰¹åˆ«å¸¸ç”¨çš„åŸºæœ¬æ•°æ®ç»“æ„ï¼š

* *vector* èƒ½å¤Ÿå­˜å‚¨ä¸€æ®µè¿ç»­ä¸”æ•°é‡ä¸å®šçš„å€¼ã€‚

* *æ•£åˆ—è¡¨ï¼ˆhash mapï¼‰* èƒ½å¤Ÿå°†æŸä¸ªå€¼ä¸ä¸€ä¸ªç‰¹å®šçš„é”®å…³è”èµ·æ¥ã€‚
  ä½ å¯èƒ½ä¹ŸçŸ¥é“å®ƒä»¬ï¼š[C++ ä¸­çš„ *unordered map*](https://en.cppreference.com/w/cpp/container/unordered_map)ã€[Python çš„ *dictionary*](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) æˆ–å…¶å®ƒè¯­è¨€ä¸­çš„ *associative arrayï¼ˆè¯‘ï¼šå…³è”æ•°ç»„ã€mapã€æ˜ å°„ï¼‰*ã€‚

## æ›´å¤šä¿¡æ¯

- [Storing Lists of Values with Vectors](https://doc.rust-lang.org/stable/book/ch08-01-vectors.html)
- [Storing Keys with Associated Values in Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)



================================================
FILE: assets/rustlings-zh/exercises/collections/hashmap1.rs
================================================
// hashmap1.rs

// ç”¨æ•£åˆ—è¡¨å®šä¹‰ä¸€ä¸ªæ°´æœç¯®ã€‚ä»¥é”®è¡¨ç¤ºæ°´æœçš„åç§°ï¼Œå€¼æ¥ä»£è¡¨ç¯®å­é‡Œå¯¹åº”æ°´æœçš„ä¸ªæ•°ã€‚
// è¦æ±‚å¿…é¡»åœ¨ç¯®å­é‡Œæ”¾è‡³å°‘ä¸‰ç§æ°´æœï¼ˆå¦‚è‹¹æœã€é¦™è•‰ã€èŠ’æœï¼‰ï¼Œæ¯ç§æ°´æœçš„æ€»æ•°ä¹Ÿåº”ä¸å°‘äºäº”ä¸ªã€‚
//
// è®©æˆ‘é€šè¿‡ç¼–è¯‘å’Œæµ‹è¯•ï¼
//
// å¦‚æœéœ€è¦æç¤ºï¼Œå¯ä»¥æ‰§è¡Œå‘½ä»¤ `rustlings hint hashmap1`ã€‚

// I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    let mut basket = // TODOï¼šåœ¨è¿™å£°æ˜ä¸ªæ•£åˆ—è¡¨

    // ç»™ä½ ä¸¤ä¸ªé¦™è•‰
    basket.insert(String::from("banana"), 2);

    // TODOï¼šåœ¨è¿™å¾€ç¯®å­é‡Œæ·»åŠ æ›´å¤šçš„æ°´æœ

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/hashmap2.rs
================================================
// hashmap2.rs
// ç»™ä½ ä¸€ä¸ªç”¨æ•£åˆ—è¡¨è¡¨ç¤ºçš„æ°´æœç¯®ï¼Œå®ƒçš„é”®è¡¨ç¤ºæ°´æœçš„åç§°ï¼Œå€¼è¡¨ç¤ºç¯®å­é‡Œå¯¹åº”æ°´æœçš„ä¸ªæ•°ã€‚
// ç°åœ¨éœ€è¦å¾€ç¯®å­æ·»åŠ è‡³å°‘ 11 ç§æ°´æœã€‚ç¯®å­é‡Œå·²æœ‰ - è‹¹æœ (4),
// èŠ’æœ (2) å’Œè”æ (5) ä¸‰ç§æ°´æœï¼Œä½ ä¸èƒ½å†æ·»åŠ è¿™äº›æ°´æœã€‚
//
// è®©æˆ‘é€šè¿‡æµ‹è¯•ï¼
//
// å¦‚æœéœ€è¦æç¤ºï¼Œå¯ä»¥æ‰§è¡Œå‘½ä»¤ `rustlings hint hashmap2`ã€‚

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODOï¼šå¦‚æœç¯®å­é‡Œæ²¡æœ‰æŸç§æ°´æœï¼Œå°±æŠŠå®ƒæ”¾å…¥ç¯®å­ã€‚
        // æ³¨æ„ï¼Œä½ ä¸èƒ½æ”¾å…¥ç¯®å­ä¸­ä»»ä½•å·²æœ‰çš„æ°´æœã€‚
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let mut basket = HashMap::<Fruit, u32>::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/vec1.rs
================================================
// vec1.rs
// ä½ çš„ä»»åŠ¡æ˜¯åˆ›å»ºä¸€ä¸ªä¸æ•°ç»„ `a` ä¸­çš„å…ƒç´ å®Œå…¨ç›¸åŒçš„ `Vec`ã€‚
// è®©æˆ‘é€šè¿‡ç¼–è¯‘å’Œæµ‹è¯•ï¼
// å¦‚æœéœ€è¦æç¤ºï¼Œå¯ä»¥æ‰§è¡Œå‘½ä»¤ `rustlings hint vec1`ã€‚

// I AM NOT DONE

fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // ä¸€ä¸ªæ™®é€šçš„æ•°ç»„
    let v = // TODOï¼šåœ¨è¿™é‡Œç”¨ vectors çš„å®æ¥å£°æ˜ä½ çš„ vector

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/vec2.rs
================================================
// vec2.rs
// ç»™å®šä¸€ä¸ªå…¨æ˜¯å¶æ•°çš„ Vec ã€‚ä½ çš„ä»»åŠ¡æ˜¯å®Œæˆä¸€ä¸ªå¾ªç¯ï¼Œåšåˆ°å°† Vec ä¸­çš„æ¯ä¸ªæ•°å­—éƒ½ä¹˜ä»¥ 2 ã€‚
//
// è®©æˆ‘é€šè¿‡ç¼–è¯‘å’Œæµ‹è¯•ï¼
//
// å¦‚æœéœ€è¦æç¤ºï¼Œå¯ä»¥æ‰§è¡Œå‘½ä»¤ `rustlings hint vec2`ã€‚

// I AM NOT DONE

fn vec_loop(mut v: Vec<i32>) -> Vec<i32> {
    for i in v.iter_mut() {
        // TODOï¼šå°† Vec `v` ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä¹˜ä»¥ 2 ã€‚
    }

    // æ­¤æ—¶ `v' åº”è¯¥ç­‰äº [4, 8, 12, 16, 20] ã€‚
    v
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/README.md
================================================
# Type conversions

Rust offers a multitude of ways to convert a value of a given type into another type.

The simplest form of type conversion is a type cast expression. It is denoted with the binary operator `as`. For instance, `println!("{}", 1 + 1.0);` would not compile, since `1` is an integer while `1.0` is a float. However, `println!("{}", 1 as f32 + 1.0)` should compile. The exercise [`using_as`](using_as.rs) tries to cover this.

Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the [`convert`](https://doc.rust-lang.org/std/convert/index.html) module.
The traits are the following:
- `From` and `Into` covered in [`from_into`](from_into.rs)
- `TryFrom` and `TryInto` covered in [`try_from_into`](try_from_into.rs)
- `AsRef` and `AsMut` covered in [`as_ref_mut`](as_ref_mut.rs)

Furthermore, the `std::str` module offers a trait called [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) which helps with converting strings into target types via the `parse` method on strings. If properly implemented for a given type `Person`, then `let p: Person = "Mark,20".parse().unwrap()` should both compile and run without panicking.

These should be the main ways ***within the standard library*** to convert data into your desired types.

## Further information

These are not directly covered in the book, but the standard library has a great documentation for it.
- [conversions](https://doc.rust-lang.org/std/convert/index.html)
- [`FromStr` trait](https://doc.rust-lang.org/std/str/trait.FromStr.html)


================================================
FILE: assets/rustlings-zh/exercises/conversions/as_ref_mut.rs
================================================
// AsRef and AsMut allow for cheap reference-to-reference conversions.
// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html
// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.

// I AM NOT DONE

// Obtain the number of bytes (not characters) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn byte_counter<T>(arg: T) -> usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn char_counter<T>(arg: T) -> usize {
    arg.as_ref().chars().count()
}

fn main() {
    let s = "CafÃ© au lait";
    println!("{}", char_counter(s));
    println!("{}", byte_counter(s));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = "CafÃ© au lait";
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = "Cafe au lait";
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from("CafÃ© au lait");
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from("Cafe au lait");
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/from_into.rs
================================================
// The From trait is used for value-to-value conversions.
// If From is implemented correctly for a type, the Into trait should work conversely.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html
#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

// We implement the Default trait to use it as a fallback
// when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -> Person {
        Person {
            name: String::from("John"),
            age: 30,
        }
    }
}

// Your task is to complete this implementation
// in order for the line `let p = Person::from("Mark,20")` to compile
// Please note that you'll need to parse the age component into a `usize`
// with something like `"4".parse::<usize>()`. The outcome of this needs to
// be handled appropriately.
//
// Steps:
// 1. If the length of the provided string is 0, then return the default of Person
// 2. Split the given string on the commas present in it
// 3. Extract the first element from the split operation and use it as the name
// 4. If the name is empty, then return the default of Person
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
// If while parsing the age, something goes wrong, then return the default of Person
// Otherwise, then return an instantiated Person object with the results

// I AM NOT DONE

impl From<&str> for Person {
    fn from(s: &str) -> Person {
    }
}

fn main() {
    // Use the `from` function
    let p1 = Person::from("Mark,20");
    // Since From is implemented for Person, we should be able to use Into
    let p2: Person = "Gerald,70".into();
    println!("{:?}", p1);
    println!("{:?}", p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        // Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, "John");
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        // Test that John is returned when bad string is provided
        let p = Person::from("");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        // Test that "Mark,20" works
        let p = Person::from("Mark,20");
        assert_eq!(p.name, "Mark");
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        // Test that "Mark,twenty" will return the default person due to an error in parsing age
        let p = Person::from("Mark,twenty");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from("Mark");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from("Mark,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(",1");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(",");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(",one");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from("Mike,32,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from("Mike,32,man");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/from_str.rs
================================================
// from_str.rs
// This is similar to from_into.rs, but this time we'll implement `FromStr`
// and return errors instead of falling back to a default value.
// Additionally, upon implementing FromStr, you can use the `parse` method
// on strings to generate an object of the implementor type.
// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html
use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Empty input string
    Empty,
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::<usize>()
    ParseInt(ParseIntError),
}

// I AM NOT DONE

// Steps:
// 1. If the length of the provided string is 0, an error should be returned
// 2. Split the given string on the commas present in it
// 3. Only 2 elements should be returned from the split, otherwise return an error
// 4. Extract the first element from the split operation and use it as the name
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
//    with something like `"4".parse::<usize>()`
// 6. If while extracting the name and the age something goes wrong, an error should be returned
// If everything goes well, then return a Result of a Person object

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &str) -> Result<Person, Self::Err> {
    }
}

fn main() {
    let p = "Mark,20".parse::<Person>().unwrap();
    println!("{:?}", p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!("".parse::<Person>(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = "John,32".parse::<Person>();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            "John,".parse::<Person>(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            "John,twenty".parse::<Person>(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!("John".parse::<Person>(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(",1".parse::<Person>(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            ",".parse::<Person>(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            ",one".parse::<Person>(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!("John,32,".parse::<Person>(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            "John,32,man".parse::<Person>(),
            Err(ParsePersonError::BadLen)
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/try_from_into.rs
================================================
// try_from_into.rs
// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
// Basically, this is the same as From. The main difference is that this should return a Result type
// instead of the target type itself.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html
use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// I AM NOT DONE

// Your task is to complete this implementation
// and return an Ok result of inner type Color.
// You need to create an implementation for a tuple of three integers,
// an array of three integers, and a slice of integers.
//
// Note that the implementation for tuple and array will be checked at compile time,
// but the slice implementation needs to check the slice length!
// Also note that correct RGB color values must be integers in the 0..=255 range.

// Tuple implementation
impl TryFrom<(i16, i16, i16)> for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {
    }
}

// Array implementation
impl TryFrom<[i16; 3]> for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {
    }
}

// Slice implementation
impl TryFrom<&[i16]> for Color {
    type Error = IntoColorError;
    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {
    }
}

fn main() {
    // Use the `from` function
    let c1 = Color::try_from((183, 65, 14));
    println!("{:?}", c1);

    // Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result<Color, _> = [183, 65, 14].try_into();
    println!("{:?}", c2);

    let v = vec![183, 65, 14];
    // With slice we should use `try_from` function
    let c3 = Color::try_from(&v[..]);
    println!("{:?}", c3);
    // or take slice within round brackets and use TryInto
    let c4: Result<Color, _> = (&v[..]).try_into();
    println!("{:?}", c4);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result<Color, _> = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result<Color, _> = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result<Color, _> = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result<Color, _> = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result<Color, _> = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result<Color, _> = Color::try_from(&v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/using_as.rs
================================================
// Type casting in Rust is done via the usage of the `as` operator.
// Please note that the `as` operator is not only used when type casting.
// It also helps with renaming imports.
//
// The goal is to make sure that the division does not fail to compile
// and returns the proper type.

// I AM NOT DONE

fn average(values: &[f64]) -> f64 {
    let total = values.iter().fold(0.0, |a, b| a + b);
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!("{}", average(&values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/enums/README.md
================================================
# æšä¸¾ï¼ˆenumsï¼‰

Rust æœ‰ä¸€ç§å«åšâ€œæšä¸¾â€çš„ç±»å‹ï¼Œè¿™ç§ç±»å‹åˆ—ä¸¾å‡ºäº†æŸç§é›†åˆä¸­æ‰€æœ‰å¯èƒ½çš„å€¼ã€‚
æšä¸¾æ˜¯è®¸å¤šè¯­è¨€å…±æœ‰çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œä½†å®ƒçš„ä½œç”¨åœ¨æ¯ç§è¯­è¨€ä¸­éƒ½æœ‰æ‰€ä¸åŒã€‚
å¦‚ F#ã€OCaml å’Œ Haskell ä¹‹ç±»çš„å‡½æ•°å¼è¯­è¨€ä¸­çš„ä»£æ•°æ•°æ®ç±»å‹ï¼ˆalgebraic data typesï¼‰å’Œ Rust çš„æšä¸¾å¾ˆç›¸ä¼¼ã€‚
Rust çš„â€œæ¨¡å¼åŒ¹é…â€åŠŸèƒ½ä¸æšä¸¾ç»“åˆèµ·éå¸¸å¼ºå¤§ï¼Œåˆ©ç”¨å®ƒæˆ‘ä»¬å¾ˆå®¹æ˜“å°±èƒ½é’ˆå¯¹æšä¸¾çš„ä¸åŒç±»å‹è¿è¡Œä¸åŒçš„ä»£ç ã€‚

## æ›´å¤šä¿¡æ¯

- [Enums](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [Pattern syntax](https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html)



================================================
FILE: assets/rustlings-zh/exercises/enums/enums1.rs
================================================
// enums1.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint enums1` è·å–æç¤º :)

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODOï¼šéµç…§ä¸‹é¢çš„ä½¿ç”¨æ–¹å¼æ¥å®šä¹‰å‡ ç§ Message çš„ç±»å‹
}

fn main() {
    println!("{:?}", Message::Quit);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::ChangeColor);
}



================================================
FILE: assets/rustlings-zh/exercises/enums/enums2.rs
================================================
// enums2.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint enums2` è·å–æç¤ºï¼

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODOï¼šå®šä¹‰ä¸‹é¢ä½¿ç”¨åˆ°çš„å¤šç§ Message ç±»å‹
}

impl Message {
    fn call(&self) {
        println!("{:?}", &self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/enums/enums3.rs
================================================
// enums3.rs
// è§£å†³æ‰€æœ‰çš„ TODO ï¼Œé€šè¿‡æµ‹è¯•ï¼

// I AM NOT DONE

enum Message {
    // TODOï¼šæ ¹æ®ä»¥ä¸‹çš„ä½¿ç”¨æ–¹å¼ï¼Œå®ç° Message çš„ä¸åŒç±»å‹
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn echo(&self, s: String) {
        println!("{}", s);
    }

    fn move_position(&mut self, p: Point) {
        self.position = p;
    }

    fn process(&mut self, message: Message) {
        // TODOï¼šä½¿ç”¨ match è¡¨è¾¾å¼æ¥å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor((255, 0, 255)));
        state.process(Message::Echo(String::from("hello world")));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/README.md
================================================
# é”™è¯¯å¤„ç†
å¤§å¤šæ•°çš„é”™è¯¯å¹¶æ²¡æœ‰ä¸¥é‡åˆ°éœ€è¦è®©ç¨‹åºå®Œå…¨åœæ­¢è¿è¡Œçš„ç¨‹åº¦ã€‚
æœ‰æ—¶ä¸€ä¸ªå‡½æ•°æ‰§è¡Œå¤±è´¥æ—¶ï¼Œä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°å¯¹é€ æˆå¤±è´¥çš„åŸå› è¿›è¡Œè§£é‡Šå¹¶é‡‡å–å¯¹åº”æªæ–½çš„ã€‚
ä¾‹å¦‚ï¼Œä½ æ­£è¯•å›¾æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œä½†ç”±äºè¯¥æ–‡ä»¶ä¸å­˜åœ¨å¯¼è‡´äº†æ“ä½œå¤±è´¥ï¼Œè¿™æ—¶ä½ å¯èƒ½æƒ³åˆ›å»º
è¯¥æ–‡ä»¶è€Œä¸æ˜¯ç›´æ¥ç»ˆæ­¢ç¨‹åºã€‚

## æ›´å¤šä¿¡æ¯

- [Error Handling](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)
- [Generics](https://doc.rust-lang.org/book/ch10-01-syntax.html)
- [Result](https://doc.rust-lang.org/rust-by-example/error/result.html)
- [Boxing errors](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html)



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors1.rs
================================================
// errors1.rs
// å‡ä½¿ä½ ä¼ ç»™è¿™ä¸ªå‡½æ•°ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå®ƒå°†æ‹’ç»ç”Ÿæˆä¸€æ®µä¸ªæ€§ç­¾åï¼ˆnametageï¼‰ã€‚
// å¦‚æœå®ƒèƒ½è§£é‡Šæ‹’ç»çš„åŸå› æ˜¯ä»€ä¹ˆï¼Œè€Œä¸æ˜¯ç²—æš´è¿”å› `None` é‚£å°±æ›´å®Œç¾äº†ã€‚
// ç¬¬ 2 ä¸ªæµ‹è¯•ç›®å‰è¿˜æ²¡é€šè¿‡å¹¶æœªèƒ½ç¼–è¯‘ï¼Œä½†å®ƒè¯´æ˜äº†æˆ‘ä»¬å¸Œæœ›è¿™ä¸ªå‡½æ•°å…·æœ‰çš„è¡Œä¸ºã€‚
// æ‰§è¡Œ `rustlings hint errors1` è·å–æç¤ºï¼

// I AM NOT DONE

pub fn generate_nametag_text(name: String) -> Option<String> {// è¯‘ï¼šç”Ÿæˆä¸ªæ€§ç­¾å
    if name.len() > 0 {
        Some(format!("Hi! My name is {}", name))// è¯‘ï¼š"å—¨ï¼æˆ‘çš„åå­—æ˜¯ {}"
    } else {
        // ä¸å…è®¸ä½¿ç”¨ç©ºçš„åå­—ã€‚
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ä½ å¯ä»¥æ³¨é‡Šæ‰ç¬¬ 2 ä¸ªæµ‹è¯•ï¼Œé‚£ä¹ˆè¿™ä¸ªæµ‹è¯•å°±èƒ½åˆæ­¥é€šè¿‡ã€‚
    // å½“ä½ æ›´æ”¹äº†æµ‹è¯•çš„å‡½æ•°æ—¶ï¼Œä¹Ÿéœ€è¦ä¿®æ”¹ä¸‹æµ‹è¯•ä»£ç ä»¥ä½¿æµ‹è¯•æ­£ç¡®ï¼
    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {// è¯‘ï¼šç”¨ä¸€ä¸ªéç©ºåç§°ç”Ÿæˆä¸€æ®µä¸ªæ€§ç­¾å
        assert_eq!(
            generate_nametag_text("BeyoncÃ©".into()),
            Some("Hi! My name is BeyoncÃ©".into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {// è¯‘ï¼šè¯´æ˜ä¸ºä»€ä¹ˆä¸ªæ€§ç­¾åç”Ÿæˆå¤±è´¥äº†
        assert_eq!(
            generate_nametag_text("".into()),
            Err("`name` was empty; it must be nonempty.".into())
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors2.rs
================================================
// errors2.rs
// å‡è®¾æˆ‘ä»¬æ­£åœ¨ç¼–å†™ä¸€ä¸ªæ¸¸æˆï¼Œä½ å¯ä»¥ç”¨ä»£å¸è´­ä¹°ç‰©å“ã€‚
// æ‰€æœ‰ç‰©å“çš„ä»·æ ¼éƒ½æ˜¯ 5 ä¸ªä»£å¸ï¼Œæ¯å½“ä½ è´­ä¹°ç‰©å“æ—¶ï¼Œéƒ½éœ€è¦ 1 ä¸ªä»£å¸çš„å°è´¹ã€‚
// æ¸¸æˆç©å®¶å°†è¾“å…¥ä»–ä»¬æƒ³è¦è´­ä¹°çš„ç‰©å“æ•°é‡ï¼Œ`total_cost` å‡½æ•°èƒ½å¤Ÿè®¡ç®—å‡ºæ‰€éœ€çš„ä»£å¸æ•°é‡ã€‚
// è™½ç„¶ç©å®¶è¾“å…¥çš„æ˜¯æ•°é‡ï¼Œä½†æˆ‘ä»¬å¾—åˆ°çš„å´æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²â€”â€”ä»–ä»¬å¯èƒ½è¾“å…¥äº†ä»»ä½•ä¸œè¥¿ï¼Œè€Œä¸ä»…ä»…æ˜¯æ•°å­—ï¼

// ç›®å‰è¿™ä¸ªå‡½æ•°æ²¡æœ‰å¤„ç†ä»»ä½•é”™è¯¯çš„æƒ…å†µï¼ˆä¹Ÿæ²¡æœ‰å¤„ç†æˆåŠŸçš„æƒ…å†µï¼‰ã€‚
// æˆ‘ä»¬è¦åšçš„æ˜¯ï¼š
// å¦‚æœæˆ‘ä»¬åœ¨éæ•°å­—çš„å­—ç¬¦ä¸²ä¸Šè°ƒç”¨ `parse` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†è¿”å› `ParseIntError`ï¼Œ
// åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¦ç«‹åˆ»ä»å‡½æ•°è¿”å›è¿™ä¸ªé”™è¯¯ï¼Œè€Œä¸æ˜¯ç»§ç»­è¿›è¡Œç›¸å…³è®¡ç®—ã€‚

// è‡³å°‘æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ç‚¹ï¼Œå®ƒä»¬éƒ½æ˜¯æ­£ç¡®çš„â€”â€”ä½†å…¶ä¸­ä¸€ç§ç®€çŸ­å¾—å¤š! 
// æ‰§è¡Œ `rustlings hint errors2` ä»¥è·å¾—å…³äºè¿™ä¸¤ç§æ–¹å¼çš„æç¤ºã€‚

// I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>();

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost("34"), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost("beep boop").unwrap_err().to_string(),
            "invalid digit found in string"
        );// è¯‘ï¼šå­—ç¬¦ä¸²ä¸­åŒ…å«æ— æ•ˆçš„æ•°å­—
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors3.rs
================================================
// errors3.rs
// è¿™æ˜¯ä¸€ä¸ªè¯•å›¾ä½¿ç”¨å‰é¢ç»ƒä¹ ä¸­ `total_cost` å‡½æ•°å®Œæ•´ç‰ˆçš„ç¨‹åºã€‚
// ä½†å‡ºäº†äº›é—®é¢˜ï¼ä¸ºä»€ä¹ˆä¸è¡Œï¼Ÿæˆ‘ä»¬éœ€è¦æ€æ ·åšæ‰èƒ½è§£å†³é—®é¢˜ï¼Ÿ
// æ‰§è¡Œ `rustlings hint errors3` è·å–æç¤ºï¼

// I AM NOT DONE

use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = "8";

    let cost = total_cost(pretend_user_input)?;

    if cost > tokens {
        println!("You can't afford that many!");// è¯‘ï¼šä½ çš„ä»£å¸ä¸è¶³ä»¥å®Œæˆæ”¯ä»˜ï¼
    } else {
        tokens -= cost;
        println!("You now have {} tokens.", tokens);// è¯‘ï¼šç°åœ¨ä½ æœ‰ {} ä¸ªä»£å¸"
    }
}

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors4.rs
================================================
// errors4.rs
// é€šè¿‡æµ‹è¯•ï¼æ‰§è¡Œ `rustlings hint errors4` è·å–æç¤º :)

// I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors5.rs
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors6.rs
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/exercises/functions/README.md
================================================
# å‡½æ•°ï¼ˆFunctionsï¼‰

åœ¨æœ¬ç»ƒä¹ ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä»¥åŠ Rust ç¼–è¯‘å™¨æ€æ ·å¯ä»¥å¯¹äº‹ç‰©è¿›è¡Œè¿½æº¯ï¼ˆtrace things way backï¼‰ã€‚

è¯‘ï¼šä¾æ®ç»ƒä¹ çš„å†…å®¹ï¼Œè¿½æº¯çš„æ„æ€å¯èƒ½æ˜¯ç±»å‹æ¨å¯¼ä¹‹ç±»çš„äº‹ã€‚

## æ›´å¤šä¿¡æ¯

- [How Functions Work](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)



================================================
FILE: assets/rustlings-zh/exercises/functions/functions1.rs
================================================
// functions1.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint functions1` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me();
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions2.rs
================================================
// functions2.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint functions2` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);// è¯‘ï¼š"å®ï¼å‘¼å«å·ç  {}"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions3.rs
================================================
// functions3.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint functions3` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions4.rs
================================================
// functions4.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint functions4` è·å–æç¤º :)

// å•†åº—æ­£åœ¨è¿›è¡Œä¿ƒé”€ï¼Œå¦‚æœä»·æ ¼æ˜¯å¶æ•°ï¼Œå¯ä»¥ä¼˜æƒ  10 Rustbucksï¼Œå¦‚æœæ˜¯å¥‡æ•°ï¼Œåˆ™ä¼˜æƒ  3 Rustbucksã€‚
// è¯‘ï¼šRustbucks å¯èƒ½æƒ³è¡¨è¾¾ Rustå…ƒ çš„æ„æ€ï¼Œå¥½æ¯” ç¾å…ƒ ã€‚

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let original_price = 51;
    println!("Your sale price is {}", sale_price(original_price));// è¯‘ï¼š"ä½ éœ€æ”¯ä»˜ {}"
}

fn sale_price(price: i32) -> {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -> bool {
    num % 2 == 0
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions5.rs
================================================
// functions5.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint functions5` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let answer = square(3);
    println!("The answer is {}", answer);// è¯‘ï¼š"ç­”æ¡ˆæ˜¯ {}"
}

fn square(num: i32) -> i32 {
    num * num;
}



================================================
FILE: assets/rustlings-zh/exercises/generics/README.md
================================================
# æ³›å‹

æ³›å‹çš„ä¸»æ—¨æ˜¯æŠŠç±»å‹å’Œå‡½æ•°æ³›åŒ–åˆ°å¤šç§æƒ…å†µã€‚
è¿™åœ¨å¾ˆå¤šæ–¹é¢æœ‰åŠ©äºå‡å°‘é‡å¤ä»£ç ï¼Œä½†ä¹Ÿå¯èƒ½éœ€è¦ä¸ºæ­¤ä½¿ç”¨ç›¸å½“å¤šçš„è¯­æ³•ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œä½¿ç”¨æ³›å‹çš„è¯åˆ™éœ€è¦å°å¿ƒè°¨æ…åœ°æ ‡æ˜æ³›å‹é€‚ç”¨äºå“ªäº›ç±»å‹ã€‚

## æ›´å¤šä¿¡æ¯

- [Generic Data Types](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html)
- [Bounds](https://doc.rust-lang.org/rust-by-example/generics/bounds.html)



================================================
FILE: assets/rustlings-zh/exercises/generics/generics1.rs
================================================
// è¿™ä¸ªè´­ç‰©æ¸…å•ç¨‹åºæ— æ³•ç¼–è¯‘ï¼
// ç”¨ä½ å¯¹æ³›å‹çš„äº†è§£æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

// æ‰§è¡Œ `rustlings hint generics1` è·å–æç¤ºï¼

// I AM NOT DONE

fn main() {
    let mut shopping_list: Vec<?> = Vec::new();
    shopping_list.push("milk");
}



================================================
FILE: assets/rustlings-zh/exercises/generics/generics2.rs
================================================
// è¿™ä¸ªå¼ºå¤§çš„ Wrapper æ‹¥æœ‰å­˜å‚¨ä¸€ä¸ªæ­£æ•´æ•°å€¼çš„èƒ½åŠ›ã€‚
// åˆ©ç”¨æ³›å‹é‡å†™å®ƒï¼Œä½¿å®ƒæ”¯æŒåŒ…è£…ï¼ˆwrappingï¼‰ä»»ä½•ç±»å‹çš„å€¼ã€‚

// æ‰§è¡Œ `rustlings hint generics2` è·å–æç¤ºï¼

// I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -> Self {
        Wrapper { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new("Foo").value, "Foo");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/generics/generics3.rs
================================================
// ä¸€æ‰€æƒ³è±¡çš„é­”æ³•å­¦é™¢æœ‰ä¸€ä¸ªé‡‡ç”¨ Rust ç¼–å†™çš„æ–°ç‰ˆæˆç»©å•ç”Ÿæˆç³»ç»Ÿï¼
// ç›®å‰è¯¥ç³»ç»Ÿä»…æ”¯æŒåˆ›å»ºä»¥æ•°å­—è¡¨ç¤ºçš„æˆç»©å•ï¼ˆå¦‚ 1.0 -> 5.5ï¼‰ã€‚
// ç„¶è€Œï¼Œå­¦æ ¡ä¹Ÿå‘å¸ƒç”¨å­—æ¯è¡¨ç¤ºçš„æˆç»©ï¼ˆA+ -> F-ï¼‰ï¼Œæ‰€ä»¥éœ€è¦èƒ½å¤Ÿæ‰“å°ä¸¤ç§æˆç»©å•ã€‚

// åœ¨ ReportCard ç»“æ„å®šä¹‰å’Œ impl å—ä¸­è¿›è¡Œå¿…è¦çš„ä»£ç ä¿®æ”¹ï¼Œä»¥æ”¯æŒç”¨å­—æ¯è¡¨ç¤ºçš„æˆç»©å•ã€‚
// å°†ç¬¬äºŒä¸ªæµ‹è¯•çš„ grade æ”¹ä¸º "A+"ï¼Œç”¨æ¥è¡¨æ˜ä»£ç å·²å…è®¸æŒ‰å­—æ¯è¡¨ç¤ºæˆç»©ã€‚

// æ‰§è¡Œ 'rustlings hint generics3' è·å–æç¤ºï¼

// I AM NOT DONE

pub struct ReportCard {
    pub grade: f32,
    pub student_name: String,
    pub student_age: u8,
}

impl ReportCard {
    pub fn print(&self) -> String {
        format!("{} ({}) - achieved a grade of {}",// è¯‘ï¼š{} ({}) - æˆç»©ä¸º {}"
            &self.student_name, &self.student_age, &self.grade)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Tom Wriggle".to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            "Tom Wriggle (12) - achieved a grade of 2.1"
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {
        // TODOï¼šå®Œæˆç»ƒä¹ åï¼Œåœ¨è¿™é‡Œæ›´æ”¹ grade çš„å€¼ã€‚
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Gary Plotter".to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            "Gary Plotter (11) - achieved a grade of A+"
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/if/README.md
================================================
# If

ä½ å°†åœ¨è¿™å­¦ä¹ æœ€åŸºæœ¬çš„æ§åˆ¶æµï¼ˆcontrol flowï¼‰â€”â€”`if`

## æ›´å¤šä¿¡æ¯

- [Control Flow - if expressions](https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions)



================================================
FILE: assets/rustlings-zh/exercises/if/if1.rs
================================================
// if1.rs

// I AM NOT DONE

pub fn bigger(a: i32, b: i32) -> i32 {
    // å®Œæˆè¿™ä¸ªè¿”å›æ›´å¤§æ•°å­—çš„å‡½æ•°ï¼
    // ä½†ä¸å…è®¸ä»¥ä¸‹æ–¹å¼ï¼š
    // - è°ƒç”¨å…¶å®ƒå‡½æ•°
    // - é¢å¤–å˜é‡
    // æ‰§è¡Œ `rustex hint if1` è·å–æç¤º
}

// æš‚æ—¶ä¸è¦åœ¨æ„å®ƒ :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/if/if2.rs
================================================
// if2.rs

// ç¬¬ä¸€æ­¥ï¼šè®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼
// ç¬¬äºŒæ­¥ï¼šbar_for_fuzz å’Œ default_to_baz å¯ä»¥é€šè¿‡æµ‹è¯•ï¼
// æ‰§è¡Œ `rustex hint if2` è·å–æç¤º :)

// I AM NOT DONE

pub fn fizz_if_foo(fizzish: &str) -> &str {
    if fizzish == "fizz" {
        "foo"
    } else {
        1
    }
}

// æµ‹è¯•ä¸éœ€è¦æ›´æ”¹ã€‚
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(fizz_if_foo("fizz"), "foo")
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(fizz_if_foo("fuzz"), "bar")
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(fizz_if_foo("literally anything"), "baz")
    }
}



================================================
FILE: assets/rustlings-zh/exercises/macros/README.md
================================================
# Macros

Rust's macro system is very powerful, but also kind of difficult to wrap your
head around. We're not going to teach you how to write your own fully-featured
macros. Instead, we'll show you how to use and create them.

## Further information

- [Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html)



================================================
FILE: assets/rustlings-zh/exercises/macros/macros1.rs
================================================
// macros1.rs
// Make me compile! Execute `rustlings hint macros1` for hints :)

// I AM NOT DONE

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    my_macro();
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros2.rs
================================================
// macros2.rs
// Make me compile! Execute `rustlings hint macros2` for hints :)

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros3.rs
================================================
// macros3.rs
// Make me compile, without taking the macro out of the module!
// Execute `rustlings hint macros3` for hints :)

// I AM NOT DONE

mod macros {
    macro_rules! my_macro {
        () => {
            println!("Check out my macro!");
        };
    }
}

fn main() {
    my_macro!();
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros4.rs
================================================
// macros4.rs
// Make me compile! Execute `rustlings hint macros4` for hints :)

// I AM NOT DONE

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    }
    ($val:expr) => {
        println!("Look at this other macro: {}", $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}



================================================
FILE: assets/rustlings-zh/exercises/modules/README.md
================================================
# æ¨¡å—ï¼ˆModulesï¼‰

è¿™éƒ¨åˆ†æˆ‘ä»¬å°†å‘ä½ ä»‹ç» Rust çš„æ¨¡å—ç³»ç»Ÿã€‚

## æ›´å¤šä¿¡æ¯

- [The Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)



================================================
FILE: assets/rustlings-zh/exercises/modules/modules1.rs
================================================
// modules1.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint modules1` è·å–æç¤º :)

// I AM NOT DONE

mod sausage_factory {
    // ç¡®ä¿å®ƒä»…åœ¨å½“å‰æ¨¡å—å¯è§ã€‚
    fn get_secret_recipe() -> String {
        String::from("Ginger")
    }

    fn make_sausage() {
        get_secret_recipe();
        println!("sausage!");
    }
}

fn main() {
    sausage_factory::make_sausage();
}



================================================
FILE: assets/rustlings-zh/exercises/modules/modules2.rs
================================================
// modules2.rs
// ä½ å¯ä»¥æŠŠæ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼Œå¹¶ä½¿ç”¨ 'use' å’Œ 'as' å…³é”®å­—ç»™å®ƒä»¬å–ä¸ªåˆ«ç§°.
// ä¿®å¤ 'use' è¯­å¥çš„ç›¸å…³ä»£ç ä»¥é€šè¿‡ç¼–è¯‘ã€‚
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint modules2` è·å–æç¤º :)

// I AM NOT DONE

mod delicious_snacks {

    // TODO: ä¿®å¤è¿™äº› 'use' è¯­å¥
    use self::fruits::PEAR as ???
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &'static str = "Pear";
        pub const APPLE: &'static str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &'static str = "Cucumber";
        pub const CARROT: &'static str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}



================================================
FILE: assets/rustlings-zh/exercises/modules/modules3.rs
================================================
// modules3.rs
// ä½ å¯ä»¥ä½¿ç”¨ 'use' å…³é”®å­—å°†ä»»ä½•ä½ç½®çš„æ¨¡å—ï¼ˆç‰¹åˆ«æ˜¯ Rust æ ‡å‡†åº“ä¸­çš„æ¨¡å—ï¼‰å¼•å…¥ä½œç”¨åŸŸã€‚
// ä» std::time æ¨¡å—å¼•å…¥ SystemTime å’Œ UNIX_EPOCHã€‚å¦‚æœä½ èƒ½ç”¨ä¸€è¡Œä»£ç è§£å†³ï¼Œå°±èƒ½è·å¾—é¢å¤–å¾—åˆ†ã€‚
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint modules3` è·å–æç¤º :)

// I AM NOT DONE

// TODO: å®Œæˆè¿™ä¸ª `use` è¯­å¥
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) => println!("1970-01-01 00:00:00 UTC was {} seconds ago!", n.as_secs()),
        Err(_) => panic!("SystemTime before UNIX EPOCH!"),
    }
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/README.md
================================================
# ç§»åŠ¨è¯­ä¹‰ï¼ˆMove Semanticsï¼‰

è¿™äº›ç»ƒä¹ æ”¹ç¼–è‡ª [pnkfelix](https://github.com/pnkfelix) çš„ [Rust Tutorial](https://pnkfelix.github.io/rust-examples-icfp2014/) -- è°¢è°¢ Felix !!!

## æ›´å¤šä¿¡æ¯

ä»¥ä¸‹ä¹¦ç±ä¸­çš„å†…å®¹å¯¹äºå½“å‰çš„å­¦ä¹ å°¤å…¶é‡è¦ã€‚

- [Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
- [Reference and borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics1.rs
================================================
// move_semantics1.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint move_semantics1` è·å–æç¤º :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);// è¯‘ï¼š"{} é•¿åº¦ä¸º {} å†…å®¹æ˜¯ `{:?}`"

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics2.rs
================================================
// move_semantics2.rs
// åœ¨ä¸æ›´æ”¹ç¬¬ 13 è¡Œçš„è¦æ±‚ä¸‹é€šè¿‡ç¼–è¯‘ï¼
// æ‰§è¡Œ `rustex hint move_semantics2` è·å–æç¤º :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    // ä¸è¦æ›´æ”¹ä¸‹é¢é‚£è¡Œï¼
    println!("{} has length {} content `{:?}`", "vec0", vec0.len(), vec0);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics3.rs
================================================
// move_semantics3.rs
// åœ¨ä¸æ·»åŠ æ–°è¡Œä»…æ”¹å˜å·²æœ‰è¡Œçš„è¦æ±‚ä¸‹é€šè¿‡ç¼–è¯‘ï¼
// ï¼ˆä¹Ÿä¸å…è®¸æœ‰å¤šä¸ªåˆ†å·çš„è¡Œï¼ï¼‰
// æ‰§è¡Œ `rustex hint move_semantics3` è·å–æç¤º :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics4.rs
================================================
// move_semantics4.rs
// é‡æ„è¿™æ®µä»£ç ï¼Œåšåˆ°åˆ é™¤ `vec0` ï¼Œå¹¶åœ¨ `fn fill_vec` è€Œé `fn main` ä¸­åˆ›å»º vector ï¼Œ
// ç„¶åå°†æ–°åˆ›å»ºçš„ vector ä» `fill_vec` è½¬ç§»åˆ°å…¶è°ƒç”¨è€…ã€‚
// æ‰§è¡Œ `rustex hint move_semantics4` è·å–æç¤º :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

// `fill_vec()` ä¸å†è·å– `vec: Vec<i32>` å‚æ•°
fn fill_vec() -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics5.rs
================================================
// move_semantics5.rs
// åªé€šè¿‡é‡æ–°æ’åˆ— `main()` ä¸­çš„å·²æœ‰è¡Œæ¥å®Œæˆç¼–è¯‘ï¼Œå¹¶ä¸”ä¸èƒ½å¢åŠ ã€æ›´æ”¹æˆ–åˆ é™¤ä»»ä½•è¡Œ
// æ‰§è¡Œ `rustex hint move_semantics5` è·å–æç¤º :)

// I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &mut x;
    let z = &mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}



================================================
FILE: assets/rustlings-zh/exercises/option/README.md
================================================
# Option

Option ç±»å‹ä»£è¡¨å¯é€‰çš„å€¼ï¼šæ¯ä¸ª Option è¦ä¹ˆæ˜¯ Some ï¼ŒåŒ…å«ä¸€ä¸ªå€¼ï¼›è¦ä¹ˆæ˜¯ None ï¼Œè¡¨ç¤ºç©ºå€¼ã€‚
Option åœ¨ Rust ä»£ç ä¸­ååˆ†å¸¸è§ï¼Œå› ä¸ºå®ƒæœ‰è®¸å¤šç”¨é€”ï¼š
- åˆå§‹å€¼
- è¾“å…¥å€¼ä¸ç¬¦åˆå®šä¹‰çš„æƒ…å†µä¸‹ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼ï¼ˆéƒ¨åˆ†å‡½æ•°ï¼‰ã€‚
- è¿”å› None ä½œä¸ºç®€å•é”™è¯¯çš„è¿”å›å€¼
- å¯é€‰çš„ç»“æ„å­—æ®µ
- å¯ä»¥å€Ÿç”¨æˆ– "å–èµ°" çš„ç»“æ„å­—æ®µï¼ˆçš„å€¼ï¼‰
- å¯é€‰çš„å‡½æ•°å‚æ•°
- ç©ºæŒ‡é’ˆ
- åœ¨æŸäº›æƒ…å†µä¸‹äº¤æ¢å€¼*

è¯‘æ³¨ï¼šâ€œåœ¨æŸäº›æƒ…å†µä¸‹äº¤æ¢å€¼â€å¯ä»¥å‡è®¾æœ‰ä¸ªå¯å˜æ•°ç»„ï¼Œç°åœ¨è¦é€šè¿‡ä¸¤ä¸ªå¯å˜å¼•ç”¨æ¥äº¤æ¢å…¶ä¸­ä¸¤ä¸ªå…ƒç´ çš„å€¼ã€‚ä½† Rust æ˜¾ç„¶ä¸å…è®¸æœ‰ä¸¤ä¸ªå¯¹æ•°ç»„çš„å¯å˜å¼•ç”¨ï¼Œè¿™æ—¶å€™å¯ä»¥ç”¨ Option åŒ…è£…ä¸‹å…ƒç´ å€¼ï¼Œæ¯”å¦‚ï¼š

``` rust
fn main() {
    let mut array = vec![Some(1), Some(2)];
    let a = array.get_mut(0).unwrap().take().unwrap();
    let b = array.get_mut(1).unwrap().replace(a);
    *array.get_mut(0).unwrap() = b;
    println!("{:?}", array);// [Some(2), Some(1)]
}
```

å˜¿å˜¿ï¼Œæœ‰ç‚¹å¼ºè¡Œäº†ã€‚
[ç¤ºä¾‹å‚è€ƒ](https://zulip-archive.rust-lang.org/stream/122651-general/topic/.60Option.60.20.22swapping.20things.20out.20of.20difficult.20situations.22.3F.html)
[å…³äº Option çš„æè¿°æ¥è‡ªäº](https://doc.rust-lang.org/std/option/)

## æ›´å¤šä¿¡æ¯

- [Option Enum Format](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-enum-definitions)
- [Option Module Documentation](https://doc.rust-lang.org/std/option/)
- [Option Enum Documentation](https://doc.rust-lang.org/std/option/enum.Option.html)



================================================
FILE: assets/rustlings-zh/exercises/option/option1.rs
================================================
// option1.rs
// è®©æˆ‘é€šè¿‡ç¼–è¯‘ï¼æ‰§è¡Œ `rustlings hint option1` è·å–æç¤ºï¼

// I AM NOT DONE

// ä½ å¯ä»¥è‡ªç”±ä¿®æ”¹ä»£ç ï¼Œä½†è¿™ä¸ªå‡½æ•°ç­¾åé™¤å¤–ã€‚
fn print_number(maybe_number: Option<u16>) {
    println!("printing: {}", maybe_number.unwrap());
}

fn main() {
    print_number(13);
    print_number(99);

    let mut numbers: [Option<u16>; 5];
    for iter in 0..5 {
        let number_to_add: u16 = {
            ((iter * 1235) + 2) / (4 * 16)
        };

        numbers[iter as usize] = number_to_add;
    }
}



================================================
FILE: assets/rustlings-zh/exercises/option/option2.rs
================================================
// option2.rs
// è®©æˆ‘é€šè¿‡ç¼–è¯‘ï¼æ‰§è¡Œ `rustlings hint option2` è·å–æç¤ºï¼

// I AM NOT DONE

fn main() {
    let optional_word = Some(String::from("rustlings"));
    // TODOï¼šæ”¹æˆé€‚ç”¨äºå€¼ä¸º "Some" ç±»å‹çš„ if let è¯­å¥ï¼Œ
    word = optional_word {
        println!("The word is: {}", word);
    } else {
        println!("The optional word doesn't contain anything");
    }

    let mut optional_integers_vec: Vec<Option<i8>> = Vec::new();
    for x in 1..10 {
        optional_integers_vec.push(Some(x));
    }

    // TODOï¼šæ”¹æˆ while let è¯­å¥â€”â€”è®°ä½ï¼Œvector.pop çš„è¿”å›ç±»å‹ä¸º Option<T>ã€‚
    // ä½ å¯ä»¥å¤šæ¬¡å±‚å åœ°å¯¹ `Option<T>` ä½¿ç”¨ while let æˆ– if let
    integer = optional_integers_vec.pop() {
        println!("current value: {}", integer);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/option/option3.rs
================================================
// option3.rs
// è®©æˆ‘é€šè¿‡ç¼–è¯‘ï¼æ‰§è¡Œ `rustlings hint option3` è·å–æç¤º

// I AM NOT DONE

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let y: Option<Point> = Some(Point { x: 100, y: 200 });

    match y {
        Some(p) => println!("Co-ordinates are {},{} ", p.x, p.y),
        _ => println!("no match"),
    }
    y; // æ— éœ€åˆ é™¤è¿™è¡Œå°±å¯ä»¥è§£å†³ã€‚
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/README.md
================================================
# åŸºæœ¬ç±»å‹ï¼ˆPrimitive Typesï¼‰

Rust æœ‰å‡ ä¸ªç›´æ¥åœ¨ç¼–è¯‘å™¨ä¸­å®ç°åŸºæœ¬ç±»å‹ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹æœ€é‡è¦çš„å‡ ä¸ªã€‚

## æ›´å¤šä¿¡æ¯

- [Data Types](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html)
- [The Slice Type](https://doc.rust-lang.org/stable/book/ch04-03-slices.html)



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types1.rs
================================================
// primitive_types1.rs
// è¡¥å……ä¸å®Œæ•´ä»£ç è¡Œçš„ç¼ºå¤±éƒ¨åˆ†ï¼
// æ²¡æœ‰æç¤ºï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆè¯€çªï¼Œåªè¦ä¹ æƒ¯äºé”®å…¥è¿™äº›å†…å®¹å°±å¯ä»¥äº† :)

// I AM NOT DONE

fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!("Good morning!");// è¯‘ï¼š"æ—©ä¸Šå¥½"
    }

    let // å‚ç…§ä¸Šé¢çš„ç¤ºä¾‹æ¥è¡¥å……è¿™ä¸€è¡Œçš„ç¼ºå¤±éƒ¨åˆ†ï¼æˆ–è€…è®©å®ƒå€¼ä¸º false ï¼
    if is_evening {
        println!("Good evening!");// è¯‘ï¼š"æ™šä¸Šå¥½"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types2.rs
================================================
// primitive_types2.rs
// è¡¥å……ä¸å®Œæ•´ä»£ç è¡Œçš„ç¼ºå¤±éƒ¨åˆ†ï¼
// æ²¡æœ‰æç¤ºï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆè¯€çªï¼Œåªè¦ä¹ æƒ¯äºé”®å…¥è¿™äº›å†…å®¹å°±å¯ä»¥äº† :)

// I AM NOT DONE

fn main() {
    // Characters (`char`)

    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!("Alphabetical!");// è¯‘ï¼š"å­—æ¯ï¼"
    } else if my_first_initial.is_numeric() {
        println!("Numerical!");// è¯‘ï¼š"æ•°å­—ï¼"
    } else {
        println!("Neither alphabetic nor numeric!");// è¯‘ï¼š"æ—¢ä¸æ˜¯å­—æ¯ä¹Ÿä¸æ˜¯æ•°å­—ï¼"
    }

    let // åƒä¸Šé¢çš„ç¤ºä¾‹ä¸€æ ·å®Œæˆè¿™è¡Œä»£ç ï¼ä½ æœ€å–œæ¬¢çš„è§’è‰²æ˜¯ä»€ä¹ˆï¼Ÿ
    // è¯•è¯•ä¸€ä¸ªå­—æ¯ï¼Œæˆ–è€…ä¸€ä¸ªæ•°å­—ï¼Œä¹Ÿå¯ä»¥ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ï¼Œåˆæˆ–è€…ä¸€ä¸ªä¸å±äº
    // ä½ æ¯è¯­çš„å­—ç¬¦ï¼Œä¸€ä¸ªè¡¨æƒ…ç¬¦å·çœ‹èµ·æ¥ä¹Ÿä¸é”™ã€‚
    if your_character.is_alphabetic() {
        println!("Alphabetical!");
    } else if your_character.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types3.rs
================================================
// primitive_types3.rs
// åœ¨ ??? å¤„åˆ›å»ºä¸€ä¸ªä¸å°‘äº 100 ä¸ªå…ƒç´ çš„æ•°ç»„ã€‚
// æ‰§è¡Œ `rustex hint primitive_types3` è·å–æç¤ºï¼

// I AM NOT DONE

fn main() {
    let a = ???

    if a.len() >= 100 {
        println!("Wow, that's a big array!");// è¯‘ï¼š"å“‡ï¼é‚£æ•°ç»„å¯çœŸå¤§ï¼"
    } else {
        println!("Meh, I eat arrays like that for breakfast.");// è¯‘ï¼š"å—¯ï¼Œæˆ‘æŠŠè¿™æ ·çš„æ•°ç»„å½“æ—©é¤åƒã€‚"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types4.rs
================================================
// primitive_types4.rs
// åœ¨ ??? å¤„è·å–æ•°ç»„ a çš„ä¸€ä¸ªåˆ‡ç‰‡ï¼ˆsliceï¼‰ï¼Œä»¥é€šè¿‡æµ‹è¯•ã€‚
// æ‰§è¡Œ `rustex hint primitive_types4` è·å–æç¤ºï¼!

// I AM NOT DONE

#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types5.rs
================================================
// primitive_types5.rs
// å¯¹ `cat` å…ƒç»„è¿›è¡Œè§£æ„ï¼ˆDestructureï¼‰ï¼Œä½¿ println èƒ½å¤Ÿè¿è¡Œã€‚
// æ‰§è¡Œ `rustex hint primitive_types5` è·å–æç¤ºï¼

// I AM NOT DONE

fn main() {
    let cat = ("Furry McFurson", 3.5);
    let /* your pattern here */ = cat;// è¯‘ï¼šæ¨¡å¼å†™åœ¨è¿™

    println!("{} is {} years old.", name, age);
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types6.rs
================================================
// primitive_types6.rs
// ä½¿ç”¨å…ƒç»„ç´¢å¼•ï¼ˆtuple indexï¼‰æ¥è®¿é—® `numbers` çš„ç¬¬äºŒä¸ªå…ƒç´ ã€‚
// ä½ å¯ä»¥æŠŠç¬¬äºŒä¸ªå…ƒç´ çš„è¡¨è¾¾å¼æ”¾åœ¨ ??? å¤„ï¼Œè¿™æ ·æµ‹è¯•å°±ä¼šé€šè¿‡ã€‚
// æ‰§è¡Œ `rustex hint primitive_types6` è·å–æç¤ºï¼

// I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // ç”¨å…ƒç»„ç´¢å¼•çš„è¯­æ³•æ›¿æ¢ä¸‹é¢çš„ ???
    let second = ???;

    assert_eq!(2, second,
        "This is not the 2nd number in the tuple!")// è¯‘ï¼šè¿™ä¸æ˜¯å…ƒç»„ä¸­çš„ç¬¬äºŒä¸ªæ•°å­—!
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/README.md
================================================
# Standard library types

This section will teach you about Box, Shared-State Concurrency and Iterators.

## Further information

- [Using Box to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html)
- [Shared-State Concurrency](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
- [Iterator](https://doc.rust-lang.org/book/ch13-02-iterators.html)
- [Iterator documentation](https://doc.rust-lang.org/stable/std/iter/)



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/arc1.rs
================================================
// arc1.rs
// In this exercise, we are given a Vec of u32 called "numbers" with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` for hints :)

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let mut i = offset;
            let mut sum = 0;
            while i < child_numbers.len() {
                sum += child_numbers[i];
                i += 8;
            }
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/box1.rs
================================================
// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `unimplemented!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` for hints :)

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list()
    );
}

pub fn create_empty_list() -> List {
    unimplemented!()
}

pub fn create_non_empty_list() -> List {
    unimplemented!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators1.rs
================================================
// iterators1.rs
//
//  Make me compile by filling in the `???`s
//
// When performing operations on elements within a collection, iterators are essential.
// This module helps you get familiar with the structure of using an iterator and
// how to go through elements within an iterable collection.
//
// Execute `rustlings hint iterators1` for hints :D

// I AM NOT DONE

fn main () {
    let my_fav_fruits = vec!["banana", "custard apple", "avocado", "peach", "raspberry"];

    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&"banana"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&"avocado"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2.1
    assert_eq!(my_iterable_fav_fruits.next(), Some(&"raspberry"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators2.rs
================================================
// iterators2.rs
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer. Follow the steps to complete the exercise.
// As always, there are hints if you execute `rustlings hint iterators2`!

// I AM NOT DONE

// Step 1.
// Complete the `capitalize_first` function.
// "hello" -> "Hello"
pub fn capitalize_first(input: &str) -> String {
    let mut c = input.chars();
    match c.next() {
        None => String::new(),
        Some(first) => ???,
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// ["hello", "world"] -> ["Hello", "World"]
pub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {
    vec![]
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// ["hello", " ", "world"] -> "Hello World"
pub fn capitalize_words_string(words: &[&str]) -> String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first("hello"), "Hello");
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(""), "");
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec!["hello", "world"];
        assert_eq!(capitalize_words_vector(&words), ["Hello", "World"]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec!["hello", " ", "world"];
        assert_eq!(capitalize_words_string(&words), "Hello World");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators3.rs
================================================
// iterators3.rs
// This is a bigger exercise than most of the others! You can do it!
// Here is your mission, should you choose to accept it:
// 1. Complete the divide function to get the first four tests to pass.
// 2. Get the remaining tests to pass by completing the result_with_list and
//    list_of_results functions.
// Execute `rustlings hint iterators3` to get some hints!

// I AM NOT DONE

#[derive(Debug, PartialEq, Eq)]
pub enum DivisionError {
    NotDivisible(NotDivisibleError),
    DivideByZero,
}

#[derive(Debug, PartialEq, Eq)]
pub struct NotDivisibleError {
    dividend: i32,
    divisor: i32,
}

// Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
// Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -> Result<i32, DivisionError> {}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -> () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -> () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(
            divide(81, 6),
            Err(DivisionError::NotDivisible(NotDivisibleError {
                dividend: 81,
                divisor: 6
            }))
        );
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(format!("{:?}", result_with_list()), "Ok([1, 11, 1426, 3])");
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(
            format!("{:?}", list_of_results()),
            "[Ok(1), Ok(11), Ok(1426), Ok(3)]"
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators4.rs
================================================
// iterators4.rs

// I AM NOT DONE

pub fn factorial(num: u64) -> u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_1() {
        assert_eq!(1, factorial(1));
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(2, factorial(2));
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(24, factorial(4));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators5.rs
================================================
// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` for hints.
//
// Make the code compile and the tests pass.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &HashMap<String, Progress>, value: Progress) -> usize {
    let mut count = 0;
    for val in map.values() {
        if val == &value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // map is a hashmap with String keys and Progress values.
    // map = { "variables1": Complete, "from_str": None, ... }
}

fn count_collection_for(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if val == &value {
                count += 1;
            }
        }
    }
    count
}

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // collection is a slice of hashmaps.
    // collection = [{ "variables1": Complete, "from_str": None, ... },
    //     { "variables2": Complete, ... }, ... ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(3, count_iterator(&map, Progress::Complete));
    }

    #[test]
    fn count_equals_for() {
        let map = get_map();
        assert_eq!(
            count_for(&map, Progress::Complete),
            count_iterator(&map, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(
            6,
            count_collection_iterator(&collection, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        assert_eq!(
            count_collection_for(&collection, Progress::Complete),
            count_collection_iterator(&collection, Progress::Complete)
        );
    }

    fn get_map() -> HashMap<String, Progress> {
        use Progress::*;

        let mut map = HashMap::new();
        map.insert(String::from("variables1"), Complete);
        map.insert(String::from("functions1"), Complete);
        map.insert(String::from("hashmap1"), Complete);
        map.insert(String::from("arc1"), Some);
        map.insert(String::from("as_ref_mut"), None);
        map.insert(String::from("from_str"), None);

        map
    }

    fn get_vec_map() -> Vec<HashMap<String, Progress>> {
        use Progress::*;

        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from("variables2"), Complete);
        other.insert(String::from("functions2"), Complete);
        other.insert(String::from("if1"), Complete);
        other.insert(String::from("from_into"), None);
        other.insert(String::from("try_from_into"), None);

        vec![map, other]
    }
}



================================================
FILE: assets/rustlings-zh/exercises/strings/README.md
================================================
# å­—ç¬¦ä¸²

Rust æœ‰ä¸¤ç§å­—ç¬¦ä¸²ç±»å‹ï¼Œä¸€ç§æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆ`&str`ï¼‰ï¼Œå¦ä¸€ç§æ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²ï¼ˆ`String`ï¼‰ã€‚æˆ‘ä»¬ä¸æ‰“ç®—å‘ä½ è¯´æ˜ä½•æ—¶ä½¿ç”¨å…¶ä¸­å“ªä¸€ç§ï¼Œä½†æˆ‘ä»¬å°†ä¸ºä½ è®²è§£å¦‚ä½•åŒºåˆ†å’Œåˆ›å»ºå®ƒä»¬ï¼Œå¹¶çµæ´»ä½¿ç”¨ã€‚

## æ›´å¤šä¿¡æ¯

- [Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)



================================================
FILE: assets/rustlings-zh/exercises/strings/strings1.rs
================================================
// strings1.rs
// åœ¨ä¸æ”¹å˜å‡½æ•°ç­¾åçš„è¦æ±‚ä¸‹é€šè¿‡ç¼–è¯‘ï¼
// æ‰§è¡Œ `rustlings hint strings1` è·å–æç¤º ;)

// I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {}", answer);// è¯‘ï¼š"å½“å‰æˆ‘æœ€å–œçˆ±çš„é¢œè‰²æ˜¯ {}"
}

// è¯‘ï¼šå½“å‰æœ€å–œçˆ±çš„é¢œè‰²
fn current_favorite_color() -> String {
    "blue"
}



================================================
FILE: assets/rustlings-zh/exercises/strings/strings2.rs
================================================
// strings2.rs
// åœ¨ä¸æ”¹å˜å‡½æ•°ç­¾åçš„è¦æ±‚ä¸‹é€šè¿‡ç¼–è¯‘ï¼
// æ‰§è¡Œ `rustlings hint strings2` è·å–æç¤º ;)

// I AM NOT DONE

fn main() {
    let word = String::from("green"); // å°è¯•ä¸æ›´æ”¹è¿™ä¸€è¡Œ :)
    if is_a_color_word(word) {
        println!("That is a color word I know!");// è¯‘ï¼šæˆ‘çŸ¥é“è¿™ä¸ªé¢œè‰²è¯
    } else {
        println!("That is not a color word I know.");// è¯‘ï¼šæˆ‘ä¸çŸ¥é“è¿™ä¸ªé¢œè‰²è¯
    }
}

// è¯‘ï¼šæ˜¯å¦æ˜¯é¢œè‰²è¯
fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}



================================================
FILE: assets/rustlings-zh/exercises/structs/README.md
================================================
# ç»“æ„ï¼ˆStructsï¼‰

Rust æœ‰ä¸‰ç§ç»“æ„ç±»å‹ï¼šç»å…¸çš„ C ç»“æ„ã€å…ƒç»„ç»“æ„å’Œå•å…ƒç»“æ„ã€‚

## æ›´å¤šä¿¡æ¯

- [Structures](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)
- [Method Syntax](https://doc.rust-lang.org/book/ch05-03-method-syntax.html)



================================================
FILE: assets/rustlings-zh/exercises/structs/structs1.rs
================================================
// structs1.rs
// è§£å†³æ‰€æœ‰çš„ TODO ï¼Œé€šè¿‡æµ‹è¯•ï¼

// I AM NOT DONE

struct ColorClassicStruct {
    // TODO: ä¸€äº›ä¸œè¥¿éœ€è¦åœ¨è¿™é‡Œ
}

struct ColorTupleStruct(/* TODO: ä¸€äº›ä¸œè¥¿éœ€è¦åœ¨è¿™é‡Œ */);

#[derive(Debug)]
struct UnitStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: å®ä¾‹åŒ–ä¸€ä¸ªç»å…¸çš„ C ç»“æ„ä½“ï¼
        // let green =

        assert_eq!(green.name, "green");
        assert_eq!(green.hex, "#00FF00");
    }

    #[test]
    fn tuple_structs() {
        // TODO: å®ä¾‹åŒ–ä¸€ä¸ªå…ƒç»„ç»“æ„ï¼
        // let green =

        assert_eq!(green.0, "green");
        assert_eq!(green.1, "#00FF00");
    }

    #[test]
    fn unit_structs() {
        // TODO: å®ä¾‹åŒ–ä¸€ä¸ªå•å…ƒç»“æ„ï¼
        // let unit_struct =
        let message = format!("{:?}s are fun!", unit_struct);

        assert_eq!(message, "UnitStructs are fun!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/structs/structs2.rs
================================================
// structs2.rs
// è§£å†³æ‰€æœ‰çš„ TODO ï¼Œé€šè¿‡æµ‹è¯•ï¼

// I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: åˆ©ç”¨ä¸Šé¢çš„æ¨¡æ¿ï¼ˆtemplate æ˜¯æ¨¡æ¿çš„æ„æ€ï¼‰ç„¶åæ”¹å˜å…¶ä¸­çš„ä¸€äº›å€¼æ¥åˆ›å»ºå±äºä½ çš„è®¢å•ï¼
        // let your_order =
        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/structs/structs3.rs
================================================
// structs3.rs
// æ¥å£æ—¢å¯ä»¥åŒ…å«æ•°æ®ä¹Ÿå¯ä»¥å¤„ç†é€»è¾‘ã€‚
// åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬å·²ç»å®šä¹‰äº† Package ç»“æ„ï¼Œä½†æˆ‘ä»¬æƒ³æµ‹è¯•ä¸€äº›æ ¹æ®å®ƒå®ç°çš„é€»è¾‘ã€‚
// è®©ä»£ç é€šè¿‡ç¼–è¯‘å’Œæµ‹è¯•ï¼
// å¦‚æœä½ æœ‰é—®é¢˜ï¼Œå¯ä»¥æ‰§è¡Œ `rustlings hint structs3` æŸ¥çœ‹æç¤º

// I AM NOT DONE

#[derive(Debug)]
struct Package {// è¯‘ï¼šåŒ…è£¹
    sender_country: String,// è¯‘ï¼šå¯„ä»¶äººå›½å®¶
    recipient_country: String,// è¯‘ï¼šæ”¶ä»¶äººå›½å®¶
    weight_in_grams: i32,// è¯‘ï¼šé‡é‡ï¼ˆå…‹ï¼‰
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {
        if weight_in_grams <= 0 {
            // è¿™é‡Œéœ€è¦å®Œæˆä¸€äº›ä¸œè¥¿â€¦â€¦
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&self) -> ??? {// è¯‘ï¼šæ˜¯å¦æ˜¯å›½é™…ä¸Šçš„
        // è¿™é‡Œéœ€è¦å®Œæˆä¸€äº›ä¸œè¥¿â€¦â€¦
    }

    fn get_fees(&self, cents_per_gram: i32) -> ??? {// è¯‘ï¼šè·å–æ‰€éœ€è´¹ç”¨
        // è¿™é‡Œéœ€è¦å®Œæˆä¸€äº›ä¸œè¥¿â€¦â€¦
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {// è¯‘ï¼šå¤±è´¥åœ°åˆ›å»ºæ²¡æœ‰é‡é‡çš„åŒ…è£¹
        let sender_country = String::from("Spain");// è¯‘ï¼šè¥¿ç­ç‰™
        let recipient_country = String::from("Austria");// è¯‘ï¼šå¥¥åœ°åˆ©

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {// è¯‘ï¼šåˆ›å»ºå›½é™…ä¸Šçš„åŒ…è£¹
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {// è¯‘ï¼šè®¡ç®—è¿è¾“è´¹
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;// è¯‘ï¼šåˆ†/å…‹ï¼ˆä¸€å…‹éœ€è¦å¤šå°‘åˆ†é’±ï¼‰

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/README.md
================================================
# æµ‹è¯•

è¿™æ¬¡ä¸æŒ‰ä¹¦æœ¬ä¸Šçš„é¡ºåºä»‹ç»æµ‹è¯•â€”â€”æ¥ä¸‹æ¥çš„å¾ˆå¤šç»ƒä¹ éƒ½ä¼šè¦æ±‚ä½ é€šè¿‡æµ‹è¯•ï¼

## æ›´å¤šä¿¡æ¯

- [Writing Tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)



================================================
FILE: assets/rustlings-zh/exercises/tests/tests1.rs
================================================
// tests1.rs
// æµ‹è¯•å¯¹äºç¡®ä¿ä»£ç å®ç°äº†é¢„æœŸåŠŸèƒ½éå¸¸é‡è¦ã€‚
// å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤å¯¹å½“å‰æ–‡ä»¶ä¸­çš„ä»£ç è¿›è¡Œæµ‹è¯•ï¼š
// rustlings run tests1

// å…³äºæµ‹è¯•è¿˜æœ‰ä¸ªé—®é¢˜â€”â€”å¦‚ä½•æˆåŠŸç¼–è¯‘æµ‹è¯•ã€é€šè¿‡æµ‹è¯•æˆ–è€…ä½¿æµ‹è¯•å¤±è´¥ï¼Ÿ
// æ‰§è¡Œ `rustlings hint tests1` è·å–æç¤º :)

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert() {
        assert!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/tests2.rs
================================================
// tests2.rs
// è®©æµ‹è¯•èƒ½å¤Ÿç¼–è¯‘ç„¶åé€šè¿‡æµ‹è¯•å’Œä½¿æµ‹è¯•å¤±è´¥ï¼
// æ‰§è¡Œ `rustlings hint tests2` è·å–æç¤º :)

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert_eq() {
        assert_eq!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/tests3.rs
================================================
// tests3.rs
// è¿™ä¸ªæµ‹è¯•ä¸æ˜¯åœ¨æµ‹è¯•æˆ‘ä»¬çš„å‡½æ•°â€”â€”æƒ³äº›æ–¹æ³•è®©å®ƒçš„è¿”å›å€¼å¯ä»¥é€šè¿‡æµ‹è¯•ã€‚
// åœ¨ç¬¬äºŒä¸ªæµ‹è¯•åˆ¤æ–­è°ƒç”¨ `is_even(5)` æ˜¯å¦å¾—åˆ°äº†é¢„æœŸçš„ç»“æœã€‚
// æ‰§è¡Œ `rustlings hint tests3` è·å–æç¤º :)

// I AM NOT DONE

pub fn is_even(num: i32) -> bool {
    num % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_true_when_even() {// å¶æ•°å°†è¿”å› true
        assert!();
    }

    #[test]
    fn is_false_when_odd() {// å¥‡æ•°å°†è¿”å› false
        assert!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/threads/README.md
================================================
# Threads

In most current operating systems, an executed programâ€™s code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.

## Further information

- [Dining Philosophers example](https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html)
- [Using Threads to Run Code Simultaneously](https://doc.rust-lang.org/book/ch16-01-threads.html)



================================================
FILE: assets/rustlings-zh/exercises/threads/threads1.rs
================================================
// threads1.rs
// Make this compile! Execute `rustlings hint threads1` for hints :)
// The idea is the thread spawned on line 22 is completing jobs while the main thread is
// monitoring progress until 10 jobs are completed. Because of the difference between the
// spawned threads' sleep time, and the waiting threads sleep time, when you see 6 lines
// of "waiting..." and the program ends without timing out when running,
// you've got it :)

// I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let status_shared = status.clone();
    thread::spawn(move || {
        for _ in 0..10 {
            thread::sleep(Duration::from_millis(250));
            status_shared.jobs_completed += 1;
        }
    });
    while status.jobs_completed < 10 {
        println!("waiting... ");
        thread::sleep(Duration::from_millis(500));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/traits/README.md
================================================
# Traits

Trait æ˜¯ä¸€ç³»åˆ—æ–¹æ³•çš„é›†åˆã€‚

æ•°æ®ç±»å‹å¯ä»¥å®ç° traitã€‚ä¸ºæ­¤éœ€è¦å¸®æ•°æ®ç±»å‹å®šä¹‰å¥½æ„æˆ trait çš„æ–¹æ³•ã€‚ 
ä¾‹å¦‚ï¼Œ`String` ç±»å‹å®ç°äº† `From<&str>` traitã€‚å®ƒèµ‹äºˆæˆ‘ä»¬èƒ½åŠ›å†™å‡º `String::from("hello")`ã€‚

å¦‚æ­¤ä¸€æ¥ï¼Œtrait å°±æœ‰ç‚¹ç±»ä¼¼äº Java çš„æ¥å£å’Œ C++ çš„æŠ½è±¡ç±»ã€‚

å¦å¤–ä¸€äº›å¸¸è§çš„ Rust trait åŒ…æ‹¬ï¼š
- `Clone` ï¼ˆ`clone` æ–¹æ³•ï¼‰
- `Display` (å®ç°é€šè¿‡ `{}` è¿›è¡Œæ ¼å¼åŒ–æ˜¾ç¤º)
- `Debug` (å®ç°é€šè¿‡ `{:?}` è¿›è¡Œæ ¼å¼åŒ–æ˜¾ç¤º )

å› ä¸º trait æ ‡æ˜äº†æ•°æ®ç±»å‹ä¹‹é—´çš„å…±æœ‰è¡Œä¸ºï¼Œæ‰€ä»¥å®ƒåœ¨ç¼–å†™æ³›å‹æ—¶éå¸¸æœ‰ç”¨ã€‚

## æ›´å¤šä¿¡æ¯

- [Traits](https://doc.rust-lang.org/book/ch10-02-traits.html)



================================================
FILE: assets/rustlings-zh/exercises/traits/traits1.rs
================================================
// traits1.rs
// æ˜¯æ—¶å€™æ¥å®ç°äº› trait äº†ï¼
//
// ä½ çš„ä»»åŠ¡æ˜¯ä¸º `String` å®ç° `AppendBar` traitã€‚
//
// `AppendBar` åªæœ‰ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°† "Bar" è¿½åŠ åˆ°ä»»ä½•å®ç°è¯¥ trait çš„å¯¹è±¡ä¸Šã€‚
// è¯‘ï¼šAppend æœ‰è¿½åŠ ã€é™„åŠ çš„æ„æ€ï¼Œæ‰€ä»¥â€œè¿½åŠ /é™„åŠ  Barâ€ã€‚

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -> Self;
}

impl AppendBar for String {
    // åœ¨è¿™é‡Œç¼–å†™ä»£ç 
}

fn main() {
    let s = String::from("Foo");
    let s = s.append_bar();
    println!("s: {}", s);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from("Foo").append_bar(), String::from("FooBar"));
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(
            String::from("").append_bar().append_bar(),
            String::from("BarBar")
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/traits/traits2.rs
================================================
// traits2.rs
//
// ä½ çš„ä»»åŠ¡æ˜¯ä¸ºä¸€ä¸ªå­—ç¬¦ä¸² vector å®ç° `AppendBar` traitã€‚
//
// ä¸ºäº†å®ç°è¯¥ traitï¼Œè¯·æ€è€ƒä¸‹å°† "Bar" è¿½åŠ åˆ°å­—ç¬¦ä¸² vector çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ 
//
// è¿™æ¬¡æ²¡æœ‰æ ·æ¿ä»£ç ï¼Œç›¸ä¿¡è‡ªå·±ï¼ 

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -> Self;
}

//TODOï¼šåœ¨è¿™ç¼–å†™ä»£ç 

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from("Foo")].append_bar();
        assert_eq!(foo.pop().unwrap(), String::from("Bar"));
        assert_eq!(foo.pop().unwrap(), String::from("Foo"));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/variables/README.md
================================================
# å˜é‡ï¼ˆVariablesï¼‰

åœ¨ Rustï¼Œå˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„.
ä¸å¯å˜æ„å‘³ç€å½“ä¸€ä¸ªå€¼è¢«ç»‘å®šåˆ°æŸä¸ªåå­—ä¸Šï¼Œä½ å°±ä¸èƒ½å†å¯¹è¿™ä¸ªå€¼åšå‡ºæ›´æ”¹ã€‚
å½“ç„¶ï¼Œä½ å¯ä»¥é€šè¿‡åœ¨å˜é‡åå‰æ·»åŠ  mut æ¥ä½¿å®ƒä»¬å˜å¾—å¯å˜ã€‚

## æ›´å¤šä¿¡æ¯

- [Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)



================================================
FILE: assets/rustlings-zh/exercises/variables/variables1.rs
================================================
// variables1.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables1` è·å–æç¤º :)

// å…³äº `I AM NOT DONE`ï¼š
// å³ä½¿ä½ å·²ç»æƒ³åˆ°äº†è§£å†³æ–¹æ¡ˆï¼Œæˆ‘ä»¬æœ‰æ—¶ä¹Ÿä¼šé¼“åŠ±ä½ åœ¨ç‰¹å®šçš„ç»ƒä¹ 
// ç»§ç»­å»å°è¯•åšåˆ°æ›´å¥½ã€‚å¦‚æœä½ å·²ç»é€šè¿‡ç»ƒä¹ å¹¶åšå¥½äº†åº”å¯¹ä¸‹ä¸€é¢˜
// çš„å‡†å¤‡, è¯·åˆ é™¤ä¸‹é¢çš„ `I AM NOT DONE` æ³¨é‡Šã€‚

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
/// åŠ æ²¹ ğŸ’ª
fn main() {
    x = 5;
    println!("x has the value {}", x);// è¯‘ï¼šx çš„å€¼æ˜¯
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables2.rs
================================================
// variables2.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables2` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x;
    if x == 10 {
        println!("Ten!");// è¯‘ï¼šåï¼
    } else {
        println!("Not ten!");// è¯‘ï¼šä¸æ˜¯åï¼
    }
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables3.rs
================================================
// variables3.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables3` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x = 3;
    println!("Number {}", x);// è¯‘ï¼š"æ•°å­— {}"
    x = 5; // don't change this lineï¼ˆè¯‘ï¼šä¸è¦æ›´æ”¹è¿™ä¸€è¡Œï¼‰
    println!("Number {}", x);
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables4.rs
================================================
// variables4.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables4` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x: i32;
    println!("Number {}", x);
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables5.rs
================================================
// variables5.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables5` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
fn main() {
    let number = "T-H-R-E-E"; // don't change this line
    println!("Spell a Number : {}", number);// è¯‘ï¼š"æ‹¼æ¥çš„æ•°å­—ï¼š{}"
    number = 3;
    println!("Number plus two is : {}", number + 2);// è¯‘ï¼š"æ•°å­—åŠ ä¸ŠäºŒæ˜¯ï¼š{}"
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables6.rs
================================================
// variables6.rs
// è®©æˆ‘èƒ½å¤Ÿç¼–è¯‘ï¼æ‰§è¡Œ `rustex hint variables6` è·å–æç¤º :)

// I AM NOT DONE

/// ç¿»è¯‘: [mg-chao](https://github.com/mg-chao)
const NUMBER = 3;
fn main() {
    println!("Number {}", NUMBER);
}



================================================
FILE: assets/rustlings-zh/src/exercise.rs
================================================
use regex::Regex;
use serde::Deserialize;
use std::env;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, remove_file, File};
use std::io::Read;
use std::path::PathBuf;
use std::process::{self, Command};

const RUSTC_COLOR_ARGS: &[&str] = &["--color", "always"];
const I_AM_DONE_REGEX: &str = r"(?m)^\s*///?\s*I\s+AM\s+NOT\s+DONE";
const CONTEXT: usize = 2;
const CLIPPY_CARGO_TOML_PATH: &str = "./exercises/clippy/Cargo.toml";

// Get a temporary file name that is hopefully unique
#[inline]
fn temp_file() -> String {
    let thread_id: String = format!("{:?}", std::thread::current().id())
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();

    format!("./temp_{}_{}", process::id(), thread_id)
}

// The mode of the exercise.
#[derive(Deserialize, Copy, Clone, Debug)]
#[serde(rename_all = "lowercase")]
pub enum Mode {
    // Indicates that the exercise should be compiled as a binary
    Compile,
    // Indicates that the exercise should be compiled as a test harness
    Test,
    // Indicates that the exercise should be linted with clippy
    Clippy,
}

#[derive(Deserialize)]
pub struct ExerciseList {
    pub exercises: Vec<Exercise>,
}

// A representation of a rustlings exercise.
// This is deserialized from the accompanying info.toml file
#[derive(Deserialize, Debug)]
pub struct Exercise {
    // Name of the exercise
    pub name: String,
    // The path to the file containing the exercise's source code
    pub path: PathBuf,
    // The mode of the exercise (Test, Compile, or Clippy)
    pub mode: Mode,
    // The hint text associated with the exercise
    pub hint: String,
}

// An enum to track of the state of an Exercise.
// An Exercise can be either Done or Pending
#[derive(PartialEq, Debug)]
pub enum State {
    // The state of the exercise once it's been completed
    Done,
    // The state of the exercise while it's not completed yet
    Pending(Vec<ContextLine>),
}

// The context information of a pending exercise
#[derive(PartialEq, Debug)]
pub struct ContextLine {
    // The source code that is still pending completion
    pub line: String,
    // The line number of the source code still pending completion
    pub number: usize,
    // Whether or not this is important
    pub important: bool,
}

// The result of compiling an exercise
pub struct CompiledExercise<'a> {
    exercise: &'a Exercise,
    _handle: FileHandle,
}

impl<'a> CompiledExercise<'a> {
    // Run the compiled exercise
    pub fn run(&self) -> Result<ExerciseOutput, ExerciseOutput> {
        self.exercise.run()
    }
}

// A representation of an already executed binary
#[derive(Debug)]
pub struct ExerciseOutput {
    // The textual contents of the standard output of the binary
    pub stdout: String,
    // The textual contents of the standard error of the binary
    pub stderr: String,
}

struct FileHandle;

impl Drop for FileHandle {
    fn drop(&mut self) {
        clean();
    }
}

impl Exercise {
    pub fn compile(&self) -> Result<CompiledExercise, ExerciseOutput> {
        let cmd = match self.mode {
            Mode::Compile => Command::new("rustc")
                .args(&[self.path.to_str().unwrap(), "-o", &temp_file()])
                .args(RUSTC_COLOR_ARGS)
                .output(),
            Mode::Test => Command::new("rustc")
                .args(&["--test", self.path.to_str().unwrap(), "-o", &temp_file()])
                .args(RUSTC_COLOR_ARGS)
                .output(),
            Mode::Clippy => {
                let cargo_toml = format!(
                    r#"[package]
name = "{}"
version = "0.0.1"
edition = "2018"
[[bin]]
name = "{}"
path = "{}.rs""#,
                    self.name, self.name, self.name
                );
                let cargo_toml_error_msg = if env::var("NO_EMOJI").is_ok() {
                    "Failed to write Clippy Cargo.toml file."
                } else {
                    "Failed to write ğŸ“ Clippy ğŸ“ Cargo.toml file."
                };
                fs::write(CLIPPY_CARGO_TOML_PATH, cargo_toml).expect(cargo_toml_error_msg);
                // To support the ability to run the clippy exercises, build
                // an executable, in addition to running clippy. With a
                // compilation failure, this would silently fail. But we expect
                // clippy to reflect the same failure while compiling later.
                Command::new("rustc")
                    .args(&[self.path.to_str().unwrap(), "-o", &temp_file()])
                    .args(RUSTC_COLOR_ARGS)
                    .output()
                    .expect("Failed to compile!");
                // Due to an issue with Clippy, a cargo clean is required to catch all lints.
                // See https://github.com/rust-lang/rust-clippy/issues/2604
                // This is already fixed on Clippy's master branch. See this issue to track merging into Cargo:
                // https://github.com/rust-lang/rust-clippy/issues/3837
                Command::new("cargo")
                    .args(&["clean", "--manifest-path", CLIPPY_CARGO_TOML_PATH])
                    .args(RUSTC_COLOR_ARGS)
                    .output()
                    .expect("Failed to run 'cargo clean'");
                Command::new("cargo")
                    .args(&["clippy", "--manifest-path", CLIPPY_CARGO_TOML_PATH])
                    .args(RUSTC_COLOR_ARGS)
                    .args(&["--", "-D", "warnings"])
                    .output()
            }
        }
        .expect("Failed to run 'compile' command.");

        if cmd.status.success() {
            Ok(CompiledExercise {
                exercise: self,
                _handle: FileHandle,
            })
        } else {
            clean();
            Err(ExerciseOutput {
                stdout: String::from_utf8_lossy(&cmd.stdout).to_string(),
                stderr: String::from_utf8_lossy(&cmd.stderr).to_string(),
            })
        }
    }

    fn run(&self) -> Result<ExerciseOutput, ExerciseOutput> {
        let arg = match self.mode {
            Mode::Test => "--show-output",
            _ => "",
        };
        let cmd = Command::new(&temp_file())
            .arg(arg)
            .output()
            .expect("Failed to run 'run' command");

        let output = ExerciseOutput {
            stdout: String::from_utf8_lossy(&cmd.stdout).to_string(),
            stderr: String::from_utf8_lossy(&cmd.stderr).to_string(),
        };

        if cmd.status.success() {
            Ok(output)
        } else {
            Err(output)
        }
    }

    pub fn state(&self) -> State {
        let mut source_file =
            File::open(&self.path).expect("We were unable to open the exercise file!");

        let source = {
            let mut s = String::new();
            source_file
                .read_to_string(&mut s)
                .expect("We were unable to read the exercise file!");
            s
        };

        let re = Regex::new(I_AM_DONE_REGEX).unwrap();

        if !re.is_match(&source) {
            return State::Done;
        }

        let matched_line_index = source
            .lines()
            .enumerate()
            .filter_map(|(i, line)| if re.is_match(line) { Some(i) } else { None })
            .next()
            .expect("This should not happen at all");

        let min_line = ((matched_line_index as i32) - (CONTEXT as i32)).max(0) as usize;
        let max_line = matched_line_index + CONTEXT;

        let context = source
            .lines()
            .enumerate()
            .filter(|&(i, _)| i >= min_line && i <= max_line)
            .map(|(i, line)| ContextLine {
                line: line.to_string(),
                number: i + 1,
                important: i == matched_line_index,
            })
            .collect();

        State::Pending(context)
    }

    // Check that the exercise looks to be solved using self.state()
    // This is not the best way to check since
    // the user can just remove the "I AM NOT DONE" string from the file
    // without actually having solved anything.
    // The only other way to truly check this would to compile and run
    // the exercise; which would be both costly and counterintuitive
    pub fn looks_done(&self) -> bool {
        self.state() == State::Done
    }
}

impl Display for Exercise {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", self.path.to_str().unwrap())
    }
}

#[inline]
fn clean() {
    let _ignored = remove_file(&temp_file());
}

#[cfg(test)]
mod test {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_clean() {
        File::create(&temp_file()).unwrap();
        let exercise = Exercise {
            name: String::from("example"),
            path: PathBuf::from("tests/fixture/state/pending_exercise.rs"),
            mode: Mode::Compile,
            hint: String::from(""),
        };
        let compiled = exercise.compile().unwrap();
        drop(compiled);
        assert!(!Path::new(&temp_file()).exists());
    }

    #[test]
    fn test_pending_state() {
        let exercise = Exercise {
            name: "pending_exercise".into(),
            path: PathBuf::from("tests/fixture/state/pending_exercise.rs"),
            mode: Mode::Compile,
            hint: String::new(),
        };

        let state = exercise.state();
        let expected = vec![
            ContextLine {
                line: "// fake_exercise".to_string(),
                number: 1,
                important: false,
            },
            ContextLine {
                line: "".to_string(),
                number: 2,
                important: false,
            },
            ContextLine {
                line: "// I AM NOT DONE".to_string(),
                number: 3,
                important: true,
            },
            ContextLine {
                line: "".to_string(),
                number: 4,
                important: false,
            },
            ContextLine {
                line: "fn main() {".to_string(),
                number: 5,
                important: false,
            },
        ];

        assert_eq!(state, State::Pending(expected));
    }

    #[test]
    fn test_finished_exercise() {
        let exercise = Exercise {
            name: "finished_exercise".into(),
            path: PathBuf::from("tests/fixture/state/finished_exercise.rs"),
            mode: Mode::Compile,
            hint: String::new(),
        };

        assert_eq!(exercise.state(), State::Done);
    }

    #[test]
    fn test_exercise_with_output() {
        let exercise = Exercise {
            name: "exercise_with_output".into(),
            path: PathBuf::from("tests/fixture/success/testSuccess.rs"),
            mode: Mode::Test,
            hint: String::new(),
        };
        let out = exercise.compile().unwrap().run().unwrap();
        assert!(out.stdout.contains("THIS TEST TOO SHALL PASS"));
    }
}



================================================
FILE: assets/rustlings-zh/src/main.rs
================================================
use crate::exercise::{Exercise, ExerciseList};
use crate::run::run;
use crate::verify::verify;
use argh::FromArgs;
use console::Emoji;
use notify::DebouncedEvent;
use notify::{RecommendedWatcher, RecursiveMode, Watcher};
use std::ffi::OsStr;
use std::fs;
use std::io::{self, prelude::*};
use std::path::Path;
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::mpsc::{channel, RecvTimeoutError};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

#[macro_use]
mod ui;

mod exercise;
mod run;
mod verify;

// In sync with crate version
const VERSION: &str = "4.6.0";

#[derive(FromArgs, PartialEq, Debug)]
/// Rustlings is a collection of small exercises to get you used to writing and reading Rust code
struct Args {
    /// show outputs from the test exercises
    #[argh(switch)]
    nocapture: bool,
    /// show the executable version
    #[argh(switch, short = 'v')]
    version: bool,
    #[argh(subcommand)]
    nested: Option<Subcommands>,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand)]
enum Subcommands {
    Verify(VerifyArgs),
    Watch(WatchArgs),
    Run(RunArgs),
    Hint(HintArgs),
    List(ListArgs),
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "verify")]
/// Verifies all exercises according to the recommended order
struct VerifyArgs {}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "watch")]
/// Reruns `verify` when files were edited
struct WatchArgs {}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "run")]
/// Runs/Tests a single exercise
struct RunArgs {
    #[argh(positional)]
    /// the name of the exercise
    name: String,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "hint")]
/// Returns a hint for the given exercise
struct HintArgs {
    #[argh(positional)]
    /// the name of the exercise
    name: String,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "list")]
/// Lists the exercises available in Rustlings
struct ListArgs {
    #[argh(switch, short = 'p')]
    /// show only the paths of the exercises
    paths: bool,
    #[argh(switch, short = 'n')]
    /// show only the names of the exercises
    names: bool,
    #[argh(option, short = 'f')]
    /// provide a string to match exercise names
    /// comma separated patterns are acceptable
    filter: Option<String>,
    #[argh(switch, short = 'u')]
    /// display only exercises not yet solved
    unsolved: bool,
    #[argh(switch, short = 's')]
    /// display only exercises that have been solved
    solved: bool,
}

fn main() {
    let args: Args = argh::from_env();

    if args.version {
        println!("v{}", VERSION);
        std::process::exit(0);
    }

    if args.nested.is_none() {
        println!();
        println!(r#"       æ¬¢è¿æ¥åˆ°...                        "#);
        println!(r#"                 _   _ _                  "#);
        println!(r#"  _ __ _   _ ___| |_| (_)_ __   __ _ ___  "#);
        println!(r#" | '__| | | / __| __| | | '_ \ / _` / __| "#);
        println!(r#" | |  | |_| \__ \ |_| | | | | | (_| \__ \ "#);
        println!(r#" |_|   \__,_|___/\__|_|_|_| |_|\__, |___/ "#);
        println!(r#"                               |___/      "#);
        println!();
    }

    if !Path::new("info.toml").exists() {
        println!(
            "{} must be run from the rustlings directory",
            std::env::current_exe().unwrap().to_str().unwrap()
        );
        println!("Try `cd rustlings/`!");
        std::process::exit(1);
    }

    if !rustc_exists() {
        println!("We cannot find `rustc`.");
        println!("Try running `rustc --version` to diagnose your problem.");
        println!("For instructions on how to install Rust, check the README.");
        std::process::exit(1);
    }

    let toml_str = &fs::read_to_string("info.toml").unwrap();
    let exercises = toml::from_str::<ExerciseList>(toml_str).unwrap().exercises;
    let verbose = args.nocapture;

    let command = args.nested.unwrap_or_else(|| {
        let text = fs::read_to_string("default_out.txt").unwrap();
        println!("{}", text);
        std::process::exit(0);
    });
    match command {
        Subcommands::List(subargs) => {
            if !subargs.paths && !subargs.names {
                println!("{:<17}\t{:<46}\t{:<7}", "Name", "Path", "Status");
            }
            let mut exercises_done: u16 = 0;
            let filters = subargs.filter.clone().unwrap_or_default().to_lowercase();
            exercises.iter().for_each(|e| {
                let fname = format!("{}", e.path.display());
                let filter_cond = filters
                    .split(',')
                    .filter(|f| !f.trim().is_empty())
                    .any(|f| e.name.contains(&f) || fname.contains(&f));
                let status = if e.looks_done() {
                    exercises_done += 1;
                    "Done"
                } else {
                    "Pending"
                };
                let solve_cond = {
                    (e.looks_done() && subargs.solved)
                        || (!e.looks_done() && subargs.unsolved)
                        || (!subargs.solved && !subargs.unsolved)
                };
                if solve_cond && (filter_cond || subargs.filter.is_none()) {
                    let line = if subargs.paths {
                        format!("{}\n", fname)
                    } else if subargs.names {
                        format!("{}\n", e.name)
                    } else {
                        format!("{:<17}\t{:<46}\t{:<7}\n", e.name, fname, status)
                    };
                    // Somehow using println! leads to the binary panicking
                    // when its output is piped.
                    // So, we're handling a Broken Pipe error and exiting with 0 anyway
                    let stdout = std::io::stdout();
                    {
                        let mut handle = stdout.lock();
                        handle.write_all(line.as_bytes()).unwrap_or_else(|e| {
                            match e.kind() {
                                std::io::ErrorKind::BrokenPipe => std::process::exit(0),
                                _ => std::process::exit(1),
                            };
                        });
                    }
                }
            });
            let percentage_progress = exercises_done as f32 / exercises.len() as f32 * 100.0;
            println!(
                "Progress: You completed {} / {} exercises ({:.2} %).",
                exercises_done,
                exercises.len(),
                percentage_progress
            );
            std::process::exit(0);
        }

        Subcommands::Run(subargs) => {
            let exercise = find_exercise(&subargs.name, &exercises);

            run(exercise, verbose).unwrap_or_else(|_| std::process::exit(1));
        }

        Subcommands::Hint(subargs) => {
            let exercise = find_exercise(&subargs.name, &exercises);

            println!("{}", exercise.hint);
        }

        Subcommands::Verify(_subargs) => {
            verify(&exercises, verbose).unwrap_or_else(|_| std::process::exit(1));
        }

        Subcommands::Watch(_subargs) => match watch(&exercises, verbose) {
            Err(e) => {
                println!(
                    "Error: Could not watch your progress. Error message was {:?}.",
                    e
                );
                println!("Most likely you've run out of disk space or your 'inotify limit' has been reached.");
                std::process::exit(1);
            }
            Ok(WatchStatus::Finished) => {
                println!(
                    "{emoji} All exercises completed! {emoji}",
                    emoji = Emoji("ğŸ‰", "â˜…")
                );
                println!();
                println!("+----------------------------------------------------+");
                println!("|          You made it to the Fe-nish line!          |");
                println!("+--------------------------  ------------------------+");
                println!("                          \\/                         ");
                println!("     â–’â–’          â–’â–’â–’â–’â–’â–’â–’â–’      â–’â–’â–’â–’â–’â–’â–’â–’          â–’â–’   ");
                println!("   â–’â–’â–’â–’  â–’â–’    â–’â–’        â–’â–’  â–’â–’        â–’â–’    â–’â–’  â–’â–’â–’â–’ ");
                println!("   â–’â–’â–’â–’  â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’  â–’â–’â–’â–’ ");
                println!(" â–‘â–‘â–’â–’â–’â–’â–‘â–‘â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’â–‘â–‘â–’â–’â–’â–’ ");
                println!("   â–“â–“â–“â–“â–“â–“â–“â–“  â–“â–“      â–“â–“â–ˆâ–ˆ  â–“â–“  â–“â–“â–ˆâ–ˆ      â–“â–“  â–“â–“â–“â–“â–“â–“â–“â–“ ");
                println!("     â–’â–’â–’â–’    â–’â–’      â–ˆâ–ˆâ–ˆâ–ˆ  â–’â–’  â–ˆâ–ˆâ–ˆâ–ˆ      â–’â–’â–‘â–‘  â–’â–’â–’â–’   ");
                println!("       â–’â–’  â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’  â–’â–’     ");
                println!("         â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–’â–’â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’       ");
                println!("           â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’         ");
                println!("             â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’           ");
                println!("           â–’â–’  â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’  â–’â–’         ");
                println!("         â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’       ");
                println!("       â–’â–’    â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’    â–’â–’     ");
                println!("       â–’â–’  â–’â–’    â–’â–’                  â–’â–’    â–’â–’  â–’â–’     ");
                println!("           â–’â–’  â–’â–’                      â–’â–’  â–’â–’         ");
                println!();
                println!("We hope you enjoyed learning about the various aspects of Rust!");
                println!(
                    "If you noticed any issues, please don't hesitate to report them to our repo."
                );
                println!(
                    "You can also contribute your own exercises to help the greater community!"
                );
                println!();
                println!("Before reporting an issue or contributing, please read our guidelines:");
                println!("https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md");
            }
            Ok(WatchStatus::Unfinished) => {
                println!("We hope you're enjoying learning about Rust!");
                println!("If you want to continue working on the exercises at a later point, you can simply run `rustlings watch` again");
            }
        },
    }
}

fn spawn_watch_shell(
    failed_exercise_hint: &Arc<Mutex<Option<String>>>,
    should_quit: Arc<AtomicBool>,
) {
    let failed_exercise_hint = Arc::clone(failed_exercise_hint);
    println!("æ¬¢è¿ä½¿ç”¨ watch æ¨¡å¼ï¼ä½ å¯ä»¥è¾“å…¥ 'help' ä»¥æŸ¥çœ‹ä½ åœ¨è¿™èƒ½å¤Ÿä½¿ç”¨çš„å‘½ä»¤æ¦‚è§ˆ");
    thread::spawn(move || loop {
        let mut input = String::new();
        match io::stdin().read_line(&mut input) {
            Ok(_) => {
                let input = input.trim();
                if input == "hint" {
                    if let Some(hint) = &*failed_exercise_hint.lock().unwrap() {
                        println!("{}", hint);
                    }
                } else if input == "clear" {
                    println!("\x1B[2J\x1B[1;1H");
                } else if input.eq("quit") {
                    should_quit.store(true, Ordering::SeqCst);
                    println!("å†è§ğŸ˜Šï¼");
                } else if input.eq("help") {
                    println!("åœ¨ watch æ¨¡å¼ä¸‹å¯ä½¿ç”¨çš„å‘½ä»¤:");
                    println!("  hint  - æ˜¾ç¤ºå½“å‰ç»ƒä¹ çš„æç¤º");
                    println!("  clear - æ¸…ç†å±å¹•");
                    println!("  quit  - é€€å‡º watch æ¨¡å¼");
                    println!("  help  - æ˜¾ç¤ºè¿™äº›å¸®åŠ©ä¿¡æ¯");
                    println!();
                    println!("å½“ä½ ç¼–è¾‘äº†ç»ƒä¹ æ–‡ä»¶çš„å†…å®¹ï¼Œwatch æ¨¡å¼å°†è‡ªåŠ¨é‡æ–°è¯„ä¼°å½“å‰ç»ƒä¹ ");
                } else {
                    println!("æœªçŸ¥çš„å‘½ä»¤: {}", input);
                }
            }
            Err(error) => println!("å‘½ä»¤è¯»å–é”™è¯¯: {}", error),
        }
    });
}

fn find_exercise<'a>(name: &str, exercises: &'a [Exercise]) -> &'a Exercise {
    if name.eq("next") {
        exercises
            .iter()
            .find(|e| !e.looks_done())
            .unwrap_or_else(|| {
                println!("ğŸ‰ Congratulations! You have done all the exercises!");
                println!("ğŸ”š There are no more exercises to do next!");
                std::process::exit(1)
            })
    } else {
        exercises
            .iter()
            .find(|e| e.name == name)
            .unwrap_or_else(|| {
                println!("No exercise found for '{}'!", name);
                std::process::exit(1)
            })
    }
}

enum WatchStatus {
    Finished,
    Unfinished,
}

fn watch(exercises: &[Exercise], verbose: bool) -> notify::Result<WatchStatus> {
    /* Clears the terminal with an ANSI escape code.
    Works in UNIX and newer Windows terminals. */
    fn clear_screen() {
        println!("\x1Bc");
    }

    let (tx, rx) = channel();
    let should_quit = Arc::new(AtomicBool::new(false));

    let mut watcher: RecommendedWatcher = Watcher::new(tx, Duration::from_secs(2))?;
    watcher.watch(Path::new("./exercises"), RecursiveMode::Recursive)?;

    clear_screen();

    let to_owned_hint = |t: &Exercise| t.hint.to_owned();
    let failed_exercise_hint = match verify(exercises.iter(), verbose) {
        Ok(_) => return Ok(WatchStatus::Finished),
        Err(exercise) => Arc::new(Mutex::new(Some(to_owned_hint(exercise)))),
    };
    spawn_watch_shell(&failed_exercise_hint, Arc::clone(&should_quit));
    loop {
        match rx.recv_timeout(Duration::from_secs(1)) {
            Ok(event) => match event {
                DebouncedEvent::Create(b) | DebouncedEvent::Chmod(b) | DebouncedEvent::Write(b) => {
                    if b.extension() == Some(OsStr::new("rs")) && b.exists() {
                        let filepath = b.as_path().canonicalize().unwrap();
                        let pending_exercises = exercises
                            .iter()
                            .skip_while(|e| !filepath.ends_with(&e.path))
                            // .filter(|e| filepath.ends_with(&e.path))
                            .chain(
                                exercises
                                    .iter()
                                    .filter(|e| !e.looks_done() && !filepath.ends_with(&e.path)),
                            );
                        clear_screen();
                        match verify(pending_exercises, verbose) {
                            Ok(_) => return Ok(WatchStatus::Finished),
                            Err(exercise) => {
                                let mut failed_exercise_hint = failed_exercise_hint.lock().unwrap();
                                *failed_exercise_hint = Some(to_owned_hint(exercise));
                            }
                        }
                    }
                }
                _ => {}
            },
            Err(RecvTimeoutError::Timeout) => {
                // the timeout expired, just check the `should_quit` variable below then loop again
            }
            Err(e) => println!("watch error: {:?}", e),
        }
        // Check if we need to exit
        if should_quit.load(Ordering::SeqCst) {
            return Ok(WatchStatus::Unfinished);
        }
    }
}

fn rustc_exists() -> bool {
    Command::new("rustc")
        .args(&["--version"])
        .stdout(Stdio::null())
        .spawn()
        .and_then(|mut child| child.wait())
        .map(|status| status.success())
        .unwrap_or(false)
}



================================================
FILE: assets/rustlings-zh/src/run.rs
================================================
use crate::exercise::{Exercise, Mode};
use crate::verify::test;
use indicatif::ProgressBar;

// Invoke the rust compiler on the path of the given exercise,
// and run the ensuing binary.
// The verbose argument helps determine whether or not to show
// the output from the test harnesses (if the mode of the exercise is test)
pub fn run(exercise: &Exercise, verbose: bool) -> Result<(), ()> {
    match exercise.mode {
        Mode::Test => test(exercise, verbose)?,
        Mode::Compile => compile_and_run(exercise)?,
        Mode::Clippy => compile_and_run(exercise)?,
    }
    Ok(())
}

// Invoke the rust compiler on the path of the given exercise
// and run the ensuing binary.
// This is strictly for non-test binaries, so output is displayed
fn compile_and_run(exercise: &Exercise) -> Result<(), ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation_result = exercise.compile();
    let compilation = match compilation_result {
        Ok(compilation) => compilation,
        Err(output) => {
            progress_bar.finish_and_clear();
            warn!(
                "Compilation of {} failed!, Compiler error message:\n",
                exercise
            );
            println!("{}", output.stderr);
            return Err(());
        }
    };

    progress_bar.set_message(format!("Running {}...", exercise).as_str());
    let result = compilation.run();
    progress_bar.finish_and_clear();

    match result {
        Ok(output) => {
            println!("{}", output.stdout);
            success!("Successfully ran {}", exercise);
            Ok(())
        }
        Err(output) => {
            println!("{}", output.stdout);
            println!("{}", output.stderr);

            warn!("Ran {} with errors", exercise);
            Err(())
        }
    }
}



================================================
FILE: assets/rustlings-zh/src/ui.rs
================================================
macro_rules! warn {
    ($fmt:literal, $ex:expr) => {{
        use console::{style, Emoji};
        use std::env;
        let formatstr = format!($fmt, $ex);
        if env::var("NO_EMOJI").is_ok() {
            println!("{} {}", style("!").red(), style(formatstr).red());
        } else {
            println!(
                "{} {}",
                style(Emoji("âš ï¸ ", "!")).red(),
                style(formatstr).red()
            );
        }
    }};
}

macro_rules! success {
    ($fmt:literal, $ex:expr) => {{
        use console::{style, Emoji};
        use std::env;
        let formatstr = format!($fmt, $ex);
        if env::var("NO_EMOJI").is_ok() {
            println!("{} {}", style("âœ“").green(), style(formatstr).green());
        } else {
            println!(
                "{} {}",
                style(Emoji("âœ…", "âœ“")).green(),
                style(formatstr).green()
            );
        }
    }};
}



================================================
FILE: assets/rustlings-zh/src/verify.rs
================================================
use crate::exercise::{CompiledExercise, Exercise, Mode, State};
use console::style;
use indicatif::ProgressBar;
use std::env;

// Verify that the provided container of Exercise objects
// can be compiled and run without any failures.
// Any such failures will be reported to the end user.
// If the Exercise being verified is a test, the verbose boolean
// determines whether or not the test harness outputs are displayed.
pub fn verify<'a>(
    start_at: impl IntoIterator<Item = &'a Exercise>,
    verbose: bool,
) -> Result<(), &'a Exercise> {
    for exercise in start_at {
        let compile_result = match exercise.mode {
            Mode::Test => compile_and_test(exercise, RunMode::Interactive, verbose),
            Mode::Compile => compile_and_run_interactively(exercise),
            Mode::Clippy => compile_only(exercise),
        };
        if !compile_result.unwrap_or(false) {
            return Err(exercise);
        }
    }
    Ok(())
}

enum RunMode {
    Interactive,
    NonInteractive,
}

// Compile and run the resulting test harness of the given Exercise
pub fn test(exercise: &Exercise, verbose: bool) -> Result<(), ()> {
    compile_and_test(exercise, RunMode::NonInteractive, verbose)?;
    Ok(())
}

// Invoke the rust compiler without running the resulting binary
fn compile_only(exercise: &Exercise) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let _ = compile(exercise, &progress_bar)?;
    progress_bar.finish_and_clear();

    success!("Successfully compiled {}!", exercise);
    Ok(prompt_for_completion(exercise, None))
}

// Compile the given Exercise and run the resulting binary in an interactive mode
fn compile_and_run_interactively(exercise: &Exercise) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation = compile(exercise, &progress_bar)?;

    progress_bar.set_message(format!("Running {}...", exercise).as_str());
    let result = compilation.run();
    progress_bar.finish_and_clear();

    let output = match result {
        Ok(output) => output,
        Err(output) => {
            warn!("Ran {} with errors", exercise);
            println!("{}", output.stdout);
            println!("{}", output.stderr);
            return Err(());
        }
    };

    success!("Successfully ran {}!", exercise);

    Ok(prompt_for_completion(exercise, Some(output.stdout)))
}

// Compile the given Exercise as a test harness and display
// the output if verbose is set to true
fn compile_and_test(exercise: &Exercise, run_mode: RunMode, verbose: bool) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Testing {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation = compile(exercise, &progress_bar)?;
    let result = compilation.run();
    progress_bar.finish_and_clear();

    match result {
        Ok(output) => {
            if verbose {
                println!("{}", output.stdout);
            }
            success!("Successfully tested {}", &exercise);
            if let RunMode::Interactive = run_mode {
                Ok(prompt_for_completion(exercise, None))
            } else {
                Ok(true)
            }
        }
        Err(output) => {
            warn!(
                "Testing of {} failed! Please try again. Here's the output:",
                exercise
            );
            println!("{}", output.stdout);
            Err(())
        }
    }
}

// Compile the given Exercise and return an object with information
// about the state of the compilation
fn compile<'a, 'b>(
    exercise: &'a Exercise,
    progress_bar: &'b ProgressBar,
) -> Result<CompiledExercise<'a>, ()> {
    let compilation_result = exercise.compile();

    match compilation_result {
        Ok(compilation) => Ok(compilation),
        Err(output) => {
            progress_bar.finish_and_clear();
            warn!(
                "Compiling of {} failed! Please try again. Here's the output:",
                exercise
            );
            println!("{}", output.stderr);
            Err(())
        }
    }
}

fn prompt_for_completion(exercise: &Exercise, prompt_output: Option<String>) -> bool {
    let context = match exercise.state() {
        State::Done => return true,
        State::Pending(context) => context,
    };

    let no_emoji = env::var("NO_EMOJI").is_ok();

    let clippy_success_msg = if no_emoji {
        "The code is compiling, and Clippy is happy!"
    } else {
        "The code is compiling, and ğŸ“ Clippy ğŸ“ is happy!"
    };

    let success_msg = match exercise.mode {
        Mode::Compile => "The code is compiling!",
        Mode::Test => "The code is compiling, and the tests pass!",
        Mode::Clippy => clippy_success_msg,
    };

    println!();
    if no_emoji {
        println!("~*~ {} ~*~", success_msg)
    } else {
        println!("ğŸ‰ ğŸ‰  {} ğŸ‰ ğŸ‰", success_msg)
    }
    println!();

    if let Some(output) = prompt_output {
        println!("Output:");
        println!("{}", separator());
        println!("{}", output);
        println!("{}", separator());
        println!();
    }

    println!("You can keep working on this exercise,");
    println!(
        "or jump into the next one by removing the {} comment:",
        style("`I AM NOT DONE`").bold()
    );
    println!();
    for context_line in context {
        let formatted_line = if context_line.important {
            format!("{}", style(context_line.line).bold())
        } else {
            context_line.line.to_string()
        };

        println!(
            "{:>2} {}  {}",
            style(context_line.number).blue().bold(),
            style("|").blue(),
            formatted_line
        );
    }

    false
}

fn separator() -> console::StyledObject<&'static str> {
    style("====================").bold()
}



================================================
FILE: assets/rustlings-zh/tests/integration_tests.rs
================================================
use assert_cmd::prelude::*;
use glob::glob;
use predicates::boolean::PredicateBooleanExt;
use std::fs::File;
use std::io::Read;
use std::process::Command;

#[test]
fn runs_without_arguments() {
    let mut cmd = Command::cargo_bin("rustlings").unwrap();
    cmd.assert().success();
}

#[test]
fn fails_when_in_wrong_dir() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .current_dir("tests/")
        .assert()
        .code(1);
}

#[test]
fn verify_all_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("verify")
        .current_dir("tests/fixture/success")
        .assert()
        .success();
}

#[test]
fn verify_fails_if_some_fails() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("verify")
        .current_dir("tests/fixture/failure")
        .assert()
        .code(1);
}

#[test]
fn run_single_compile_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .success();
}

#[test]
fn run_single_compile_failure() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compFailure"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .success();
}

#[test]
fn run_single_test_failure() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testFailure"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_not_passed() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testNotPassed.rs"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_no_filename() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("run")
        .current_dir("tests/fixture/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_no_exercise() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compNoExercise.rs"])
        .current_dir("tests/fixture/failure")
        .assert()
        .code(1);
}

#[test]
fn get_hint_for_single_test() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["hint", "testFailure"])
        .current_dir("tests/fixture/failure")
        .assert()
        .code(0)
        .stdout("Hello!\n");
}

#[test]
fn all_exercises_require_confirmation() {
    for exercise in glob("exercises/**/*.rs").unwrap() {
        let path = exercise.unwrap();
        let source = {
            let mut file = File::open(&path).unwrap();
            let mut s = String::new();
            file.read_to_string(&mut s).unwrap();
            s
        };
        source
            .matches("// I AM NOT DONE")
            .next()
            .unwrap_or_else(|| {
                panic!(
                    "There should be an `I AM NOT DONE` annotation in {:?}",
                    path
                )
            });
    }
}

#[test]
fn run_compile_exercise_does_not_prompt() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "pending_exercise"])
        .current_dir("tests/fixture/state")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("I AM NOT DONE").not());
}

#[test]
fn run_test_exercise_does_not_prompt() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "pending_test_exercise"])
        .current_dir("tests/fixture/state")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("I AM NOT DONE").not());
}

#[test]
fn run_single_test_success_with_output() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["--nocapture", "run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("THIS TEST TOO SHALL PAS"));
}

#[test]
fn run_single_test_success_without_output() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("THIS TEST TOO SHALL PAS").not());
}

#[test]
fn run_rustlings_list() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/success")
        .assert()
        .success();
}

#[test]
fn run_rustlings_list_no_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/success")
        .assert()
        .success()
        .stdout(predicates::str::contains("Pending").not());
}

#[test]
fn run_rustlings_list_both_done_and_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Done").and(predicates::str::contains("Pending")));
}

#[test]
fn run_rustlings_list_without_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list", "--solved"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Pending").not());
}

#[test]
fn run_rustlings_list_without_done() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list", "--unsolved"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Done").not());
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/compFailure.rs
================================================
fn main() {
    let
}


================================================
FILE: assets/rustlings-zh/tests/fixture/failure/compNoExercise.rs
================================================
fn main() {
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/info.toml
================================================
[[exercises]]
name = "compFailure"
path = "compFailure.rs"
mode = "compile"
hint = ""

[[exercises]]
name = "testFailure"
path = "testFailure.rs"
mode = "test"
hint = "Hello!"



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/testFailure.rs
================================================
#[test]
fn passing() {
    asset!(true);
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/testNotPassed.rs
================================================
#[test]
fn not_passing() {
    assert!(false);
}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/finished_exercise.rs
================================================
// fake_exercise

fn main() {

}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/info.toml
================================================
[[exercises]]
name = "pending_exercise"
path = "pending_exercise.rs"
mode = "compile"
hint = """"""

[[exercises]]
name = "pending_test_exercise"
path = "pending_test_exercise.rs"
mode = "test"
hint = """"""

[[exercises]]
name = "finished_exercise"
path = "finished_exercise.rs"
mode = "compile"
hint = """"""




================================================
FILE: assets/rustlings-zh/tests/fixture/state/pending_exercise.rs
================================================
// fake_exercise

// I AM NOT DONE

fn main() {

}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/pending_test_exercise.rs
================================================
// I AM NOT DONE

#[test]
fn it_works() {}



================================================
FILE: assets/rustlings-zh/tests/fixture/success/compSuccess.rs
================================================
fn main() {
}



================================================
FILE: assets/rustlings-zh/tests/fixture/success/info.toml
================================================
[[exercises]]
name = "compSuccess"
path = "compSuccess.rs"
mode = "compile"
hint = """"""

[[exercises]]
name = "testSuccess"
path = "testSuccess.rs"
mode = "test"
hint = """"""



================================================
FILE: assets/rustlings-zh/tests/fixture/success/testSuccess.rs
================================================
#[test]
fn passing() {
    println!("THIS TEST TOO SHALL PASS");
    assert!(true);
}



================================================
FILE: assets/writing-material/books.md
================================================
## æœ¬ä¹¦å‚è€ƒçš„ä¹¦ç±

1. [Rustè¯­è¨€](https://doc.rust-lang.org/book)

3. [Cargoæ•™å­¦](https://doc.rust-lang.org/cargo/index.html)

4. [Rustæ€§èƒ½ä¹‹ä¹¦](https://nnethercote.github.io/perf-book/title-page.html)

5. [Rustå¼‚æ­¥ç¼–ç¨‹](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)

6. [Rust API Guidlines](https://rust-lang.github.io/api-guidelines/naming.html)

7. [Rust in action](https://livebook.manning.com/book/rust-in-action/chapter-5/)
    - [ç¤ºä¾‹](https://github.com/barabadzhi/rust-in-action)

8. [Rust nomicon](https://doc.rust-lang.org/nomicon/dot-operator.html)
    
9. [Rust Forge](https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods)

10. [rustcå¼€å‘è€…ä¹‹ä¹¦](https://rustc-dev-guide.rust-lang.org/method-lookup.html)

11. [Rust Style](https://doc.rust-lang.org/1.6.0/style/README.html)

12. [Learning Rust](https://learning-rust.github.io/docs/a1.why_rust.html)

13. [Rust doc](https://doc.rust-lang.org/rustdoc/the-doc-attribute.html)

14. [Unstable Rust](https://doc.rust-lang.org/stable/unstable-book/)

15. [Rust Fuzz Book](https://rust-fuzz.github.io/book/)


## å¯å‚è€ƒçš„æ•™ç¨‹
1. https://github.com/ferrous-systems/teaching-material#core-topics


================================================
FILE: assets/writing-material/courses.md
================================================
## å¯å€Ÿé‰´çš„è¯¾ç¨‹å½¢å¼
https://www.reddit.com/r/rust/comments/rwp8mo/teaching_rust_at_the_university_of_warsaw/

## ç»ƒä¹ é¢˜




================================================
FILE: assets/writing-material/demos_for_learning.md
================================================
æ•´ç†å‡ ä¸ªå¯ä»¥ä½œä¸ºå­¦ä¹ demoçš„é¡¹ç›®ï¼Œéœ€è¦å°†æ³¨é‡Šå’Œç›¸å…³æ–‡æ¡£ç¿»è¯‘æˆä¸­æ–‡

1. [mini-redis](https://github.com/tokio-rs/mini-redis)


================================================
FILE: assets/writing-material/good-sourcecode.md
================================================
# å€¼å¾—å­¦ä¹ çš„æºä»£ç 

https://www.reddit.com/r/rust/comments/rxfx85/good_rust_source_code/

https://www.reddit.com/r/rust/comments/rx8rom/rust_projects_where_you_learnt_a_ton_of_stuff/


================================================
FILE: assets/writing-material/è¯»è€…ç–‘æƒ‘çš„ç‚¹è®°å½•.md
================================================
# è¯»è€…ç–‘æƒ‘çš„ç‚¹
è¿™é‡Œè®°å½•ä¸€äº›è¯»è€…åé¦ˆçš„åœ¨é˜…è¯»è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç–‘æƒ‘æˆ–è€…å›°æƒ‘çš„ç‚¹ï¼Œåç»­é’ˆå¯¹è¿™äº›åœ°æ–¹ï¼Œå¯ä»¥è¿›è¡Œç›¸åº”çš„å†…å®¹ä¼˜åŒ–ã€‚

1. å¼•ç”¨å’Œåˆ‡ç‰‡çš„åŒºåˆ«



================================================
FILE: assets/writing-material/posts/atomic.md
================================================
https://www.reddit.com/r/rust/comments/rtqrx4/introducing_atomicstory/


================================================
FILE: assets/writing-material/posts/attributes.md
================================================
## #[derive(Default)]
```rust
#[derive(Default)]
struct NotSend(Rc<()>);

fn require_send(_: impl Send) {}

async fn bar() {}
async fn foo() {
    //Returns the "default value" for a type.
    NotSend::default();
}
```


================================================
FILE: assets/writing-material/posts/file.md
================================================
## è¯»å–å…¨éƒ¨å†…å®¹

```rust
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new("hello.txt");
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result<File>`
    let mut file = match File::open(&path) {
        Err(why) => panic!("couldn't open {}: {}", display, why),
        Ok(file) => file,
    };

    // Read the file contents into a string, returns `io::Result<usize>`
    let mut s = String::new();
    match file.read_to_string(&mut s) {
        Err(why) => panic!("couldn't read {}: {}", display, why),
        Ok(_) => print!("{} contains:\n{}", display, s),
    }

    // `file` goes out of scope, and the "hello.txt" file gets closed
}
```

## è¯»å–å…¨éƒ¨è¡Œ
This process is more efficient than creating a String in memory especially working with larger files.

```rust
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines("./hosts") {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!("{}", ip);
            }
        }
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where P: AsRef<Path>, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
```

## ä¸€äº›å¸¸ç”¨çš„æ–‡ä»¶æ“ä½œ
```rust
use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

fn cat(path: &Path) -> io::Result<String> {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

// A simple implementation of `% echo s > path`
fn echo(s: &str, path: &Path) -> io::Result<()> {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &Path) -> io::Result<()> {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

fn main() {
    println!("`mkdir a`");
    // Create a directory, returns `io::Result<()>`
    match fs::create_dir("a") {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(_) => {},
    }

    println!("`echo hello > a/b.txt`");
    // The previous match can be simplified using the `unwrap_or_else` method
    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`mkdir -p a/c/d`");
    // Recursively create a directory, returns `io::Result<()>`
    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`touch a/c/e.txt`");
    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`ln -s ../b.txt a/c/b.txt`");
    // Create a symbolic link, returns `io::Result<()>`
    if cfg!(target_family = "unix") {
        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
        });
    }

    println!("`cat a/c/b.txt`");
    match cat(&Path::new("a/c/b.txt")) {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(s) => println!("> {}", s),
    }

    println!("`ls a`");
    // Read the contents of a directory, returns `io::Result<Vec<Path>>`
    match fs::read_dir("a") {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(paths) => for path in paths {
            println!("> {:?}", path.unwrap().path());
        },
    }

    println!("`rm a/c/e.txt`");
    // Remove a file, returns `io::Result<()>`
    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`rmdir a/c/d`");
    // Remove an empty directory, returns `io::Result<()>`
    fs::remove_dir("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    }
}
```



================================================
FILE: assets/writing-material/posts/function_signature.md
================================================
## å‡½æ•°çš„å…¥å‚æ˜¯ä¸€ä¸ªasync function
å› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº†trait boundï¼Œæ‰€ä»¥ä¸èƒ½ç”¨`Fn() -> impl Future<Output=Result<Return, sql::Error>>`çš„æ–¹å¼.

```rust
use core::future::Future;

pub async fn on_tran<F, Fut>(f: F) -> usize 
    where F: Fn() -> Fut, Fut: Future<Output=usize> {
    f().await
}


#[tokio::main]
async fn main() {
    let foo = || {
        async {
            8 as usize
        }
    };
    
    println!("{}", on_tran(foo).await);
}
```



================================================
FILE: assets/writing-material/posts/generics.md
================================================
https://stackoverflow.com/questions/37606035/pass-generic-function-as-argument


================================================
FILE: assets/writing-material/posts/hashmap.md
================================================
## Key of hashmap
Any type that implements the Eq and Hash traits can be a key in HashMap.

Note that f32 and f64 do not implement Hash, likely because floating-point precision errors would make using them as hashmap keys horribly error-prone.

All collection classes implement Eq and Hash if their contained type also respectively implements Eq and Hash. For example, `Vec<T>` will implement Hash if T implements Hash.



================================================
FILE: assets/writing-material/posts/identifier.md
================================================
## Raw identifiers
Rustå› ä¸ºç‰ˆæœ¬æ›´è¿­åŸå› ï¼Œå¯èƒ½ä¼šæ–°å¢ä¸€äº›`å…³é”®å­—`,è¿™äº›æ–°å¢å…³é”®å­—å¯èƒ½ä¼šå¯¼è‡´æ—§çš„å‡½æ•°åè°ƒç”¨ä¸å†é€šè¿‡ç¼–è¯‘ï¼Œä¾‹å¦‚åœ¨Rust Edition 2015ä¸­ï¼Œå¼•å…¥äº†æ–°çš„å…³é”®å­—`try`.

è¿è¡Œä»¥ä¸‹ä»£ç :
```rust
extern crate foo;

fn main() {
    foo::try();
}
```

å°†è·å¾—ä¸‹é¢çš„é”™è¯¯
```rust
error: expected identifier, found keyword `try`
 --> src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
```

å¯ä»¥ç”¨Raw identifieræ¥è§£å†³:
```rust
extern crate foo;

fn main() {
    foo::r#try();
}
```


================================================
FILE: assets/writing-material/posts/images.md
================================================
## å®¹å™¨ç±»å‹è¯´æ˜å›¾
https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p


================================================
FILE: assets/writing-material/posts/interview.md
================================================
https://www.reddit.com/r/rust/comments/si0j6v/im_preparing_for_a_rust_interview/


================================================
FILE: assets/writing-material/posts/io.md
================================================

## Reading input as Raw Bytes
The built-in String type uses UTF-8 internally, which adds a small, but nonzero overhead caused by UTF-8 validation when you read input into it. If you just want to process input bytes without worrying about UTF-8 (for example if you handle ASCII text), you can use `BufRead::read_until`.




================================================
FILE: assets/writing-material/posts/Iterator.md
================================================
åŒ…å«äº†ä¸€äº›Iteratorçš„å¸¸ç”¨å¤„ç†æ–¹æ³•
## éå†åŒæ—¶è·å–å…ƒç´ çš„ç´¢å¼•
```rust
    let mut xs = vec![1i32, 2, 3];
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }
```

## å‡ ç§ä»Vecç”ŸæˆIteratorçš„æ–¹å¼
1. iterè¿”å›çš„æ˜¯å€¼çš„ä¸å¯å˜å¼•ç”¨ï¼Œå³&T
2. iter_mutè¿”å›çš„æ˜¯å¯å˜å¼•ç”¨ï¼Œå³&mut T
3. into_iterè¿”å›çš„æ˜¯Tç±»å‹çš„å€¼

```rust
  let mut v = [String::from("a"), String::from("a"), String::from("a")];
    // - move occurs because `v` has type `Vec<String>`, which does not implement the `Copy
    //`v` moved due to this method call
    for x in v.into_iter() {
        println!("{:?}", x)
    }

    // Error: borrow of moved value: `v`
    println!("{:?}", v)
```
## å¿½ç•¥Vecä¸­å¤±è´¥çš„Result
`filter_map` calls a function and filters out the results that are `None`

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!("Results: {:?}", numbers);
}
```

## éå†Vecæ—¶ï¼Œå¤±è´¥ç›´æ¥è¿”å›
`Result` implements `FromIter` so that a vector of results (`Vec<Result<T, E>>`) can be turned into a result with a vector (`Result<Vec<T>, E>`). Once an `Result::Err` is found, the iteration will terminate

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!("Results: {:?}", numbers);
}
```

This same technique can be used with `Option`.

## éå†Vecæ—¶ï¼Œæ”¶é›†æ‰€æœ‰çš„æ­£ç¡®å€¼å’Œé”™è¯¯å€¼

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
```


================================================
FILE: assets/writing-material/posts/lifetime.md
================================================
## for<'a>

https://www.reddit.com/r/rust/comments/rq43c6/generic_fn_impl_for_iterating_over_mut_items_twice/

https://www.reddit.com/r/rust/comments/6uobit/fora_lifetime_syntax/



================================================
FILE: assets/writing-material/posts/lifetime_elision_rules.md
================================================
ä¸€äº›lifetimeæ¶ˆé™¤è§„åˆ™


### 1
Let's talk about a feature that's available in both editions: we've added some additional elision rules for `impl` blocks and function definitions. Code like this:

```rust
impl<'a> Reader for BufReader<'a> {
    // methods go here
}
```

can now be written like this:
```rust
impl Reader for BufReader<'_> {
    // methods go here
}
```

The `'_` lifetime still shows that `BufReader` takes a parameter, but we don't need to create a name for it anymore.

### 2
Lifetimes are still required to be defined in structs. However, we no longer require as much boilerplate as before:

```rust
// Rust 2015
struct Ref<'a, T: 'a> {
    field: &'a T
}

// Rust 2018
struct Ref<'a, T> {
    field: &'a T
}
```

The `: 'a` is inferred. You can still be explicit if you prefer. We're considering some more options for elision here in the future, but have no concrete plans yet.




================================================
FILE: assets/writing-material/posts/non-lexical-lifetime.md
================================================
https://stackoverflow.com/questions/50251487/what-are-non-lexical-lifetimes




================================================
FILE: assets/writing-material/posts/operators.md
================================================
## Operators and Symbols

This appendix contains a glossary of Rustâ€™s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.

### Operators

Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.

<span class="caption">Table B-1: Operators</span>

| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Short-circuiting logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | `Deref` |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | `PartialOrd` |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | `PartialOrd` |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | â€œAnd the restâ€ pattern binding | |
| `...` | `expr...expr` | (Deprecated, use `..=` instead) In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | |
| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |
| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |
| `?` | `expr?` | Error propagation | |

### Non-operator Symbols

The following list contains all non-letters that donâ€™t function as operators;
that is, they donâ€™t behave like a function or method call.

Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.

<span class="caption">Table B-2: Stand-Alone Syntax</span>

| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>&vert;...&vert; expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | â€œIgnoredâ€ pattern binding; also used to make integer literals readable |

Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.

<span class="caption">Table B-3: Path-Related Syntax</span>

| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which itâ€™s defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |

Table B-4 shows symbols that appear in the context of using generic type
parameters.

<span class="caption">Table B-4: Generics</span>

| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |

Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.

<span class="caption">Table B-5: Trait Bound Constraints</span>

| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T: 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |

Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.

<span class="caption">Table B-6: Macros and Attributes</span>

| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(â€¦)â€¦` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |

Table B-7 shows symbols that create comments.

<span class="caption">Table B-7: Comments</span>

| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |

Table B-8 shows symbols that appear in the context of using tuples.

<span class="caption">Table B-8: Tuples</span>

| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |

Table B-9 shows the contexts in which curly braces are used.

<span class="caption">Table B-9: Curly Brackets</span>

| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |

Table B-10 shows the contexts in which square brackets are used.

<span class="caption">Table B-10: Square Brackets</span>

| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the â€œindexâ€ |



================================================
FILE: assets/writing-material/posts/package.md
================================================
## layout
```go
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ bin/
â”‚       â”œâ”€â”€ named-executable.rs
â”‚       â”œâ”€â”€ another-executable.rs
â”‚       â””â”€â”€ multi-file-executable/
â”‚           â”œâ”€â”€ main.rs
â”‚           â””â”€â”€ some_module.rs
â”œâ”€â”€ benches/
â”‚   â”œâ”€â”€ large-input.rs
â”‚   â””â”€â”€ multi-file-bench/
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ bench_module.rs
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ simple.rs
â”‚   â””â”€â”€ multi-file-example/
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ ex_module.rs
â””â”€â”€ tests/
    â”œâ”€â”€ some-integration-tests.rs
    â””â”€â”€ multi-file-test/
        â”œâ”€â”€ main.rs
        â””â”€â”€ test_module.rs
```




================================================
FILE: assets/writing-material/posts/performance.md
================================================
## books
1. [Rustæ€§èƒ½ä¹‹ä¹¦](https://nnethercote.github.io/perf-book/title-page.html)
2. [How to write fast rust code](https://likebike.com/posts/How_To_Write_Fast_Rust_Code.html#emit-asm)


## crates
1. [é«˜æ€§èƒ½Mutexåº“](https://github.com/Amanieu/parking_lot)

## ä¸è¦é€šè¿‡ç¯å¢ƒå˜é‡æ¥æ§åˆ¶åœ¨ä¸åŒç¯å¢ƒä¸‹çš„tracingè¡Œä¸º

è¿™ç§æ§åˆ¶æ¶ˆè€—å¾ˆå¤§ï¼Œéšç€rust 1.57.0ç‰ˆæœ¬å‘å¸ƒï¼Œå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰cargo profileçš„æ–¹å¼æ¥å®ç°

cargo profileå¯ä»¥åšï¼š
Enable costlier tracing/logging/debug on staging builds, or force LTO only for production builds.


ä¸ºä½•ä¸è¦ç”¨ç¯å¢ƒå˜é‡æ¥æ§åˆ¶tracingåº“çš„è¡Œä¸º:
If your app is in any way performance sensitive you are carrying a significant cost for that.


================================================
FILE: assets/writing-material/posts/plugins.md
================================================

https://www.reddit.com/r/rust/comments/sboyb2/designing_a_rust_rust_plugin_system/


================================================
FILE: assets/writing-material/posts/reference.md
================================================
## structä¸­çš„ä¸€ä¸ªå­—æ®µæ˜¯å¦å¤–ä¸€ä¸ªå­—æ®µçš„æŒ‡é’ˆ
```rust
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Test provides methods to get a reference to the value of the fields a and b. Since b is a reference to a we store it as a pointer since the borrowing rules of Rust doesn't allow us to define this lifetime. We now have what we call a self-referential struct.




================================================
FILE: assets/writing-material/posts/rust-analyser.md
================================================
## å¯ä»¥ä¸ºrust-analyzeræŒ‡å®šä¸€ä¸ªcheckæ–‡ä»¶å¤¹ï¼Œé¿å…æ„å»ºçš„cacheè¢«lockä½

You can already setup rust-analyzer to use different folder. I set `Check On Save` to `check` and in `Check On Save: Extra Args` to `--target-dir target/rust-analyzer-target`.


================================================
FILE: assets/writing-material/posts/self-referential.md
================================================
## code snippets
1. https://stackoverflow.com/questions/67823680/open-a-single-file-from-a-zip-archive-and-pass-on-as-read-instance/67828823#67828823


## crates
1. https://github.com/Kimundi/owning-ref-rs
2. https://github.com/joshua-maros/ouroboros

https://www.reddit.com/r/learnrust/comments/rf4qdz/is_it_possible_to_hold_an_arena_and_references/


================================================
FILE: assets/writing-material/posts/SIMD.md
================================================

https://www.reddit.com/r/rust/comments/rqgwaz/why_is_my_simd_code_slower_than_the_naive_one/


================================================
FILE: assets/writing-material/posts/string.md
================================================
## å­—ç¬¦ä¸²å¸¸é‡

```rust
fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!("Unicode character {} (U+211D) is called {}",
                unicode_codepoint, character_name );


    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and indentation here ->\
                        <- can be escaped too!";
    println!("{}", long_string);
}
```

```rust
fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // If you need "# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```

## Bytes string
Want a string that's not UTF-8? (Remember, `str` and `String` must be valid UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!

```rust
use std::str;

fn main() {
    // Note that this is not actually a `&str`
    let bytestring: &[u8; 21] = b"this is a byte string";

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!("A byte string: {:?}", bytestring);

    // Byte strings can have byte escapes...
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...but no unicode escapes
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ã‚ˆã†ã“ã" in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successful: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
```


================================================
FILE: assets/writing-material/posts/system_command.md
================================================
å…³äºè°ƒç”¨osçš„å‘½ä»¤

```rust
use std::process::Command;

fn main() {
    let output = Command::new("rustc")
        .arg("--versn")
        .output().unwrap_or_else(|e| {
            panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&output.stdout);

        print!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&output.stderr);

        print!("rustc failed and stderr was:\n{}", s);
    }
}
```

## Pipes
The std::Child struct represents a running child process, and exposes the stdin, stdout and stderr handles for interaction with the underlying process via pipes.

```rust
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &'static str =
"the quick brown fox jumped over the lazy dog\n";

fn main() {
    // Spawn the `wc` command
    let process = match Command::new("wc")
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) => panic!("couldn't spawn wc: {}", why),
        Ok(process) => process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option<ChildStdin>`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) => panic!("couldn't write to wc stdin: {}", why),
        Ok(_) => println!("sent pangram to wc"),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option<ChildStdout>` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Err(why) => panic!("couldn't read wc stdout: {}", why),
        Ok(_) => print!("wc responded with:\n{}", s),
    }
}

```


## è°ƒç”¨å‘½ä»¤ï¼Œä½¿ç”¨ç”¨æˆ·çš„è¾“å…¥ä½œä¸ºå‚æ•°

```rust
let cmd = Command::new("rev")
    .stdin(Stdio::inherit())
    .stdout(Stdio::inherit())
    .output()?;
```

https://www.reddit.com/r/learnrust/comments/r5wwkz/what_the_relationship_between_processstdio_and/



================================================
FILE: assets/writing-material/posts/threads.md
================================================
## Arcå’ŒMutexç»“åˆå®ç°å¤šçº¿ç¨‹æ•°æ®ä¿®æ”¹å’Œæ±‡æ€»
```rust
use std::sync::{Arc,Mutex};
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
    let status_shared = Arc::clone(&status);
    thread::spawn(move || {
        for _ in 0..10 {
            thread::sleep(Duration::from_millis(250));
            let mut s = status_shared.lock().unwrap();
            s.jobs_completed += 1;
        }
    });

    while status.lock().unwrap().jobs_completed < 10 {
        println!("waiting... ");
        thread::sleep(Duration::from_millis(500));
    }
}
```

## å¤šä¸ªçº¿ç¨‹åŒæ—¶æ— é”çš„å¯¹ä¸€ä¸ªæ•°ç»„è¿›è¡Œä¿®æ”¹
https://www.reddit.com/r/rust/comments/rtutr0/lockless_threads_for_mutable_operations/


================================================
FILE: assets/writing-material/posts/to_resolved.md
================================================
## unknown `into` behavior

```rust
 let s: Box<dyn Error + Send + Sync> = "connection reset by peer".into();
 ```

this works because:
```rust
impl From<&'_ str> for Box<dyn Error>
```


================================================
FILE: assets/writing-material/posts/tokio.md
================================================
## æ€§èƒ½

https://www.reddit.com/r/rust/comments/lg0a7b/benchmarking_tokio_tasks_and_goroutines/


================================================
FILE: assets/writing-material/posts/trivia.md
================================================
## Rustå†·çŸ¥è¯†

https://www.reddit.com/r/rust/comments/rwufz4/borrow_checker_allows_borrow_of_mutably_borrowed/


================================================
FILE: assets/writing-material/posts/wasm.md
================================================
https://www.reddit.com/r/rust/comments/s9yugv/compile_rust_to_wasm_and_import_as_typescript/


================================================
FILE: assets/writing-material/posts/fight-with-compiler-check/borrow.md
================================================
## å¯ä»¥é€šè¿‡move structä¸­çš„å­—æ®µï¼Œæ¥è§£å†³borrowå’Œmut borrowæ— æ³•å…±å­˜çš„é—®é¢˜

```rust
struct Foo {
    bar: Bar
}

let bar: &Bar = &foo.bar;
let foo_mut: &mut Foo = &mut foo; // Canâ€™t do it.
println!("{}{}", foo_mut, bar);
```

If you no longer need Bar as a field of Foo, you can move it out instead of borrowing. This way you will be able to obtain Bar and still be able to mutate Foo.

```rust
struct Foo {
    bar: Option<Bar>
}

let bar: Bar = foo.bar.take(); // sets option to None
let foo_mut: &mut Foo = &mut foo;

println!("{}{}", foo_mut, bar);
```




================================================
FILE: assets/writing-material/posts/fight-with-compiler-check/generic.md
================================================
## the type parameter `T` is not constrained by the impl trait

```rust
use std::default::Default;

trait Maker {
    type Item;

    fn make(&mut self) -> Self::Item;
}

struct Foo<T> {
    a: T,
}

struct Bar;

impl<T> Maker for Bar
    where T: Default  {
    type Item = Foo<T>;

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

ä¸Šé¢çš„ä»£ç ä¼šå¯¼è‡´ä»¥ä¸‹ç¼–è¯‘é”™è¯¯:
```bash
tests/lang.rs:1000:10: 1000:11 error: the type parameter `T` is not constrained by the impl trait, self type, or predicates [E0207]
tests/lang.rs:1000     impl<T> Maker for Bar
```

å¯ä»¥ä½¿ç”¨[å¹½çµæ•°æ®]()æ¥åˆæ­¥è§£å†³

```rust
use std::marker::PhantomData;
struct Bar<T> {
    _m: PhantomData<T>
}

impl<T> Maker for Bar<T>
    where T: Default  {
    type Item = Foo<T>;

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

å…³äºè¿™ä¸ªé—®é¢˜ï¼Œä¸»è¦æ˜¯å› ä¸ºåœ¨`impl`ä»£ç å—ä¸­ï¼Œå…³è”ç±»å‹æ˜¯ç”±`Self`å’Œæ‰€æœ‰è¾“å…¥ç±»å‹å‚æ•°ä¸€åŒå†³å®šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´`å…³è”ç±»å‹`ä¸­å‡ºç°çš„æ³›å‹å‚æ•°ï¼Œå¿…é¡»åœ¨`impl`ä¸­æœ‰æ‰€å®šä¹‰ï¼Œè¦ä¹ˆä¸º`Maker`å¢åŠ æ³›å‹å˜é‡ï¼Œè¦ä¹ˆä¸º`Bar`å¢åŠ ã€‚

å¦‚æœä½ æƒ³è¦è®©Selfæ‹¥æœ‰å¤šç§å¯èƒ½çš„ç±»å‹ï¼Œå°±å¾—ä½¿ç”¨å¤–éƒ¨è¾“å…¥çš„ç±»å‹å‚æ•°ï¼Œè€Œä¸æ˜¯å…³è”ç±»å‹ï¼š
```rust
use std::default::Default;

trait Maker<Item> {
    fn make(&mut self) -> Item;
}

struct Foo<T> {
    a: T,
}

struct Bar;

impl<T> Maker<Foo<T>> for Bar
    where T: Default  
{

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

ç±»ä¼¼çš„ä¾‹å­è¿˜æœ‰è¿™ä¸ªï¼šhttps://www.reddit.com/r/rust/comments/r61l29/generic_impl_doesnt_work_while_generic_function/




================================================
FILE: assets/writing-material/posts/tests/doc_test.md
================================================
## Documentation testing
The primary way of documenting a Rust project is through annotating the source code. Documentation comments are written in markdown and support code blocks in them. Rust takes care about correctness, so these code blocks are compiled and used as tests.

```rust
/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate <cratename>`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Usually doc comments may include sections "Examples", "Panics" and "Failures".
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}

/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -> Result<(), String> { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}
```

```bash
$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

## æœ€æ–°è¿›å±•
æ ¹æ®twitterä¸Šçš„æ¶ˆæ¯ï¼Œrustå³å°†æ”¯æŒä»æµ‹è¯•æ–‡ä»¶ä¸­ï¼Œè‡ªåŠ¨è·å–æ–‡æ¡£æ³¨é‡Šçš„åŠŸèƒ½ï¼Œè¿™æ ·å°±èƒ½ä¿æŒæµ‹è¯•æ–‡ä»¶å’Œæ–‡æ¡£çš„ä¸€è‡´æ€§ï¼Œæ— éœ€åœ¨å¤šä¸ªåœ°æ–¹ç»´æŠ¤å¤šå¥—æµ‹è¯•ä»£ç 


================================================
FILE: assets/writing-material/posts/tests/integration_test.md
================================================
Cargo looks for integration tests in `tests` directory next to `src`.

File `src/lib.rs`:

```rust
// Define this in a crate called `adder`.
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

File with `test: tests/integration_test.rs`:

```rust
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
```


================================================
FILE: assets/writing-material/posts/tests/misc.md
================================================
## Development dependencies
Sometimes there is a need to have dependencies for tests (or examples, or benchmarks) only. Such dependencies are added to Cargo.toml in the [dev-dependencies] section. These dependencies are not propagated to other packages which depend on this package.

One such example is using a crate that extends standard assert! macros.
File Cargo.toml:

```toml
# standard crate data is left out
[dev-dependencies]
pretty_assertions = "0.4.0"
```

File `src/lib.rs`:

```toml
// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```


================================================
FILE: assets/writing-material/posts/tests/unit_test.md
================================================
## Tests and ?
in Rust 2018, your unit tests can return Result<()>, which lets you use ? in them! This can make them much more concise.

```rust
fn sqrt(number: f64) -> Result<f64, String> {
    if number >= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err("negative floats don't have square roots".to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -> Result<(), String> {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}
```

## Testing panics
To check functions that should panic under certain circumstances, use attribute #[should_panic]. This attribute accepts optional parameter expected = with the text of the panic message. If your function can panic in multiple ways, it helps make sure your test is testing the correct panic.

```rust
pub fn divide_non_zero_result(a: u32, b: u32) -> u32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    } else if a < b {
        panic!("Divide result is zero");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}

```

## Ignoring tests
Tests can be marked with the #[ignore] attribute to exclude some tests. Or to run them with command cargo test -- --ignored

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
```


================================================
FILE: assets/writing-material/style_guide/coding.md
================================================
# ä»£ç é£æ ¼

## ä½¿ç”¨[tap](https://github.com/myrrlyn/tap)åº“æ¥å®ç°`point-free`ç¼–ç¨‹é£æ ¼
```rust
use tap::{Tap, TapFallible};

type SomeValue = String;
type SomeOtherValue = String;
type SomeError = String;

fn foo() -> Result<SomeValue, SomeError> {
    Ok("foo".into())
}

fn bar(input: &str) -> Result<SomeOtherValue, SomeError> {
    if input == "bar" {
        Ok("Success".into())
    } else {
        Err("This is a failure message".into())
    }
}

fn my_fun() -> Result<SomeOtherValue, SomeError> {
    foo()
        .tap_err(|err| println!("foo() failed with error: {}", err))
        .and_then(|foo_val| bar(&foo_val))
        .tap(|res| println!("bar() returned result: {:?}", res))
}

fn main() {
    let result = my_fun();
    println!("{:?}", result);
}
```


================================================
FILE: assets/writing-material/style_guide/naming.md
================================================
# å‘½åè§„èŒƒ

åŸºæœ¬çš„Rustå‘½åè§„èŒƒåœ¨[RFC 430]ä¸­æœ‰æè¿°.

é€šå¸¸ï¼Œå¯¹äº"type-level"çš„æ„é€ Rustå€¾å‘äºä½¿ç”¨é©¼å³°å‘½å,è€Œå¯¹äº'value-level'çš„æ„é€ ä½¿ç”¨è›‡å½¢å‘½åã€‚è¯¦æƒ…å¦‚ä¸‹:

| æ¡ç›® | æƒ¯ä¾‹ |
| ---- | ---------- |
| åŒ…Crates | [unclear](https://github.com/rust-lang/api-guidelines/issues/29) |
| æ¨¡å—Modules | `snake_case` |
| ç±»å‹Types | `UpperCamelCase` |
| ç‰¹å¾Traits | `UpperCamelCase` |
| æšä¸¾é¡¹ | `UpperCamelCase` |
| å‡½æ•°Functions | `snake_case` |
| æ–¹æ³•Methods | `snake_case` |
| é€šç”¨æ„é€ å™¨General constructors | `new` or `with_more_details` |
| è½¬æ¢æ„é€ å™¨Conversion constructors | `from_some_other_type` |
| å®Macros | `snake_case!` |
| å±€éƒ¨å˜é‡Local variables | `snake_case` |
| é™æ€ç±»å‹Statics | `SCREAMING_SNAKE_CASE` |
| å¸¸é‡Constants | `SCREAMING_SNAKE_CASE` |
| ç±»å‹å‚æ•°Type parameters | `UpperCamelCase`, é€šå¸¸ä½¿ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯: `T` |
| ç”Ÿå‘½å‘¨æœŸLifetimes | é€šå¸¸ä½¿ç”¨å°å†™å­—æ¯: `'a`, `'de`, `'src` |
| Features | [unclear](https://github.com/rust-lang/api-guidelines/issues/101) but see [C-FEATURE] |

å¯¹äºé©¼å³°å‘½åæ³•, å¤åˆè¯çš„ç¼©ç•¥å½¢å¼æˆ‘ä»¬è®¤ä¸ºæ˜¯ä¸€ä¸ªå•ç‹¬çš„è¯è¯­ï¼Œæ‰€ä»¥åªå¯¹é¦–å­—æ¯è¿›è¡Œå¤§å†™: ä½¿ç”¨`Uuid`è€Œä¸æ˜¯`UUID`, `Usize`è€Œä¸æ˜¯`USize`, `Stdin`è€Œä¸æ˜¯`StdIn`.å¯¹äºè›‡å½¢å‘½åæ³•ï¼Œç¼©ç•¥è¯ç”¨å…¨å°å†™: `is_xid_start`.

å¯¹äºè›‡å½¢å‘½å(åŒ…æ‹¬å…¨å¤§å†™çš„`SCREAMING_SNAKE_CASE`), é™¤äº†æœ€åä¸€éƒ¨åˆ†ï¼Œå…¶å®ƒéƒ¨åˆ†çš„è¯è¯­éƒ½ä¸èƒ½ç”±å•ä¸ªå­—æ¯ç»„æˆï¼š
`btree_map`è€Œä¸æ˜¯`b_tree_map`, `PI_2`è€Œä¸æ˜¯`PI2`.

åŒ…åä¸åº”è¯¥ä½¿ç”¨`-rs`æˆ–è€…`-rust`ä½œä¸ºåç¼€ï¼Œå› ä¸ºæ¯ä¸€ä¸ªåŒ…éƒ½æ˜¯Rustå†™çš„ï¼Œå› æ­¤è¿™ç§å¤šä½™çš„æ³¨é‡Šå…¶å®æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚

[RFC 430]: https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md
[C-FEATURE]: #c-feature


##  ç±»å‹è½¬æ¢è¦éµå®ˆ`as_`, `to_`, `into_`å‘½åæƒ¯ä¾‹(C-CONV)
ç±»å‹è½¬æ¢åº”è¯¥é€šè¿‡æ–¹æ³•è°ƒç”¨çš„æ–¹å¼å®ç°ï¼Œå…¶ä¸­çš„å‰ç¼€è§„åˆ™å¦‚ä¸‹ï¼š

| æ–¹æ³•å‰ç¼€ | æ€§èƒ½å¼€é”€ | æ‰€æœ‰æƒæ”¹å˜ |
| ------ | ---- | --------- |
| `as_` | Free | borrowed -\> borrowed |
| `to_` | Expensive | borrowed -\> borrowed<br>borrowed -\> owned (non-Copy types)<br>owned -\> owned (Copy types) |
| `into_` | Variable | owned -\> owned (non-Copy types) |

For example:

- [`str::as_bytes()`] æŠŠ`str`å˜æˆUTF-8å­—èŠ‚æ•°ç»„, æ€§èƒ½å¼€é”€æ˜¯0. å…¶ä¸­è¾“å…¥æ˜¯ä¸€ä¸ªå€Ÿç”¨çš„`&str`ï¼Œè¾“å‡ºä¹Ÿæ˜¯ä¸€ä¸ªå€Ÿç”¨çš„`&str`.
- [`Path::to_str`] ä¼šæ‰§è¡Œä¸€æ¬¡æ˜‚è´µçš„UTF-8å­—èŠ‚æ•°ç»„æ£€æŸ¥ï¼Œè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯å€Ÿç”¨çš„ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œå¦‚æœæŠŠæ–¹æ³•å‘½åä¸º`as_str`æ˜¯ä¸æ­£ç¡®çš„ï¼Œå› ä¸ºè¿™ä¸ªæ–¹æ³•çš„å¼€é”€è¿˜æŒºå¤§.
- [`str::to_lowercase()`]åœ¨è°ƒç”¨è¿‡ç¨‹ä¸­ä¼šéå†å­—ç¬¦ä¸²çš„å­—ç¬¦ï¼Œä¸”å¯èƒ½ä¼šåˆ†é…æ–°çš„å†…å­˜å¯¹è±¡.è¾“å…¥æ˜¯ä¸€ä¸ªå€Ÿç”¨çš„`str`ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ªæœ‰ç‹¬ç«‹æ‰€æœ‰æƒçš„`String`
- [`String::into_bytes()`]è¿”å›`String`åº•å±‚çš„`Vec<u8>`æ•°ç»„ï¼Œè½¬æ¢æœ¬èº«æ˜¯é›¶æ¶ˆè€—çš„ã€‚è¯¥æ–¹æ³•è·å–`String`çš„æ‰€æœ‰æƒï¼Œç„¶åè¿”å›ä¸€ä¸ªæ–°çš„æœ‰ç‹¬ç«‹æ‰€æœ‰æƒçš„`Vec<u8>`


[`str::as_bytes()`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes
[`Path::to_str`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str
[`str::to_lowercase()`]: https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase
[`f64::to_radians()`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians
[`String::into_bytes()`]: https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes
[`BufReader::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`BufWriter::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner


å½“ä¸€ä¸ªå•ç‹¬çš„å€¼è¢«æŸä¸ªç±»å‹æ‰€åŒ…è£…æ—¶ï¼Œè®¿é—®è¯¥ç±»å‹çš„å†…éƒ¨å€¼åº”é€šè¿‡`into_inner()`æ–¹æ³•æ¥è®¿é—®ã€‚ä¾‹å¦‚å°†ä¸€ä¸ªç¼“å†²åŒºå€¼åŒ…è£…ä¸º[`BufReader`]ç±»å‹ï¼Œè¿˜æœ‰[`GzDecoder`]ã€[`AtomicBool`]ç­‰ï¼Œéƒ½æ˜¯è¿™ç§ç±»å‹ã€‚


[`BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`GzDecoder`]: https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner
[`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner

å¦‚æœ`mut`é™å®šç¬¦åœ¨è¿”å›ç±»å‹ä¸­å‡ºç°ï¼Œé‚£ä¹ˆåœ¨å‘½åä¸Šä¹Ÿåº”è¯¥ä½“ç°å‡ºæ¥ã€‚ä¾‹å¦‚ï¼Œ[`Vec::as_mut_slice`] å°±è¯´æ˜å®ƒè¿”å›äº†ä¸€ä¸ªmutåˆ‡ç‰‡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹`as_mut_slice`æ¯”`as_slice_mut`æ›´é€‚åˆã€‚

[`Vec::as_mut_slice`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice

```rust
// è¿”å›ç±»å‹æ˜¯ä¸€ä¸ªmutåˆ‡ç‰‡.
fn as_mut_slice(&mut self) -> &mut [T];
```

##### æ ‡å‡†åº“ä¸­çš„ä¸€äº›ä¾‹å­

- [`Result::as_ref`](https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref)
- [`RefCell::as_ptr`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr)
- [`slice::to_vec`](https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec)
- [`Option::into_iter`](https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter)


##  è¯»è®¿é—®å™¨(Getter)çš„åç§°éµå¾ªRustçš„å‘½åè§„èŒƒ(C-GETTER)

é™¤äº†å°‘æ•°ä¾‹å¤–ï¼Œåœ¨Rustä»£ç ä¸­`get`å‰ç¼€ä¸ç”¨äºgetterã€‚

```rust
pub struct S {
    first: First,
    second: Second,
}

impl S {
    // è€Œä¸æ˜¯get_first
    pub fn first(&self) -> &First {
        &self.first
    }

    // è€Œä¸æ˜¯get_first_mut, get_mut_first, or mut_first.
    pub fn first_mut(&mut self) -> &mut First {
        &mut self.first
    }
}
```
è‡³äºä¸Šæ–‡æåˆ°çš„å°‘æ•°ä¾‹å¤–ï¼Œå¦‚ä¸‹ï¼šå½“æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå€¼èƒ½è¢«getteræ‰€è·å–æ—¶ï¼Œæ‰ä½¿ç”¨`get`å‰ç¼€ã€‚ä¾‹å¦‚ï¼Œ
[`Cell::get`]èƒ½ç›´æ¥è®¿é—®åˆ°`Cell`ä¸­çš„å†…å®¹ã€‚

[`Cell::get`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get

æœ‰äº›getterä¼šåœ¨è¿‡ç¨‹ä¸­æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘æ·»åŠ `_unchecked`getterå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è™½ç„¶ä¸å®‰å…¨ï¼Œä½†æ˜¯å¾€å¾€å…·æœ‰æ›´é«˜çš„æ€§èƒ½ï¼Œ
å…¸å‹çš„ä¾‹å­å¦‚ä¸‹ï¼š

```rust
fn get(&self, index: K) -> Option<&V>;
fn get_mut(&mut self, index: K) -> Option<&mut V>;
unsafe fn get_unchecked(&self, index: K) -> &V;
unsafe fn get_unchecked_mut(&mut self, index: K) -> &mut V;
```

[`TempDir::path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.path
[`TempDir::into_path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.into_path

### æ ‡å‡†åº“ç¤ºä¾‹

- [`std::io::Cursor::get_mut`](https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut)
- [`std::ptr::Unique::get_mut`](https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut)
- [`std::sync::PoisonError::get_mut`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut)
- [`std::sync::atomic::AtomicBool::get_mut`](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut)
- [`std::collections::hash_map::OccupiedEntry::get_mut`](https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut)
- [`<[T]>::get_unchecked`](https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked)

## ä¸€ä¸ªé›†åˆä¸Šçš„æ–¹æ³•ï¼Œå¦‚æœè¿”å›è¿­ä»£å™¨ï¼Œéœ€éµå¾ªå‘½åè§„åˆ™ï¼š`iter`, `iter_mut`, `into_iter` (C-ITER)

```rust
fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>
fn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>
fn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>
```
ä¸Šé¢çš„è§„åˆ™é€‚ç”¨äºåŒæ„æ€§çš„æ•°æ®é›†åˆã€‚ä¸ä¹‹ç›¸åï¼Œ`str`ç±»å‹æ˜¯ä¸€ä¸ªutf8å­—èŠ‚æ•°ç»„åˆ‡ç‰‡ï¼Œä¸åŒæ„æ€§é›†åˆæœ‰ä¸€ç‚¹å¾®å¦™çš„å·®åˆ«ï¼Œå®ƒå¯ä»¥è®¤ä¸ºæ˜¯å­—èŠ‚é›†åˆï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯å­—ç¬¦é›†åˆï¼Œå› æ­¤å®ƒæä¾›äº†[`str::bytes`]å»éå†å­—èŠ‚ï¼Œè¿˜æœ‰[`str::chars`]å»éå†å­—ç¬¦ï¼Œè€Œå¹¶æ²¡æœ‰ç›´æ¥å®šä¹‰`iter`ç­‰æ–¹æ³•ã€‚

[`str::bytes`]: https://doc.rust-lang.org/std/primitive.str.html#method.bytes
[`str::chars`]: https://doc.rust-lang.org/std/primitive.str.html#method.chars

ä¸Šè¿°è§„åˆ™åªé€‚ç”¨äºæ–¹æ³•ï¼Œå¹¶ä¸é€‚ç”¨äºå‡½æ•°ã€‚ä¾‹å¦‚`url`åŒ…çš„[`percent_encode`]å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ç”¨äºéå†ç™¾åˆ†æ¯”ç¼–ç ([Percent encoding](https://en.wikipedia.org/wiki/Percent-encoding))çš„å­—ç¬¦ä¸²ç‰‡æ®µ. åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨`iter`/`iter_mut`/`into_iter`è¯¸å¦‚æ­¤ç±»çš„å‡½æ•°å‘½åæ— æ³•è¡¨è¾¾ä»»ä½•å…·ä½“çš„å«ä¹‰ã€‚

[`percent_encode`]: https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html
[RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md

### æ ‡å‡†åº“ç¤ºä¾‹

- [`Vec::iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)
- [`Vec::iter_mut`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut)
- [`Vec::into_iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter)
- [`BTreeMap::iter`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter)
- [`BTreeMap::iter_mut`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut)

## è¿­ä»£å™¨çš„ç±»å‹åº”è¯¥ä¸äº§ç”Ÿå®ƒçš„æ–¹æ³•åç›¸åŒ¹é…(C-ITER-TY)
ä¾‹å¦‚å½¢å¦‚`into_iter()`çš„æ–¹æ³•åº”è¯¥è¿”å›ä¸€ä¸ª`IntoIter`ç±»å‹ï¼Œä¸ä¹‹ç›¸ä¼¼ï¼Œå…¶å®ƒä»»ä½•è¿”å›è¿­ä»£å™¨çš„æ–¹æ³•ä¹Ÿåº”è¯¥éµå¾ªè¿™ç§å‘½åæƒ¯ä¾‹ã€‚

ä¸Šè¿°è§„åˆ™ä¸»è¦åº”ç”¨äºæ–¹æ³•ï¼Œä½†æ˜¯ç»å¸¸å¯¹äºå‡½æ•°ä¹Ÿé€‚ç”¨ã€‚ä¾‹å¦‚ä¸Šæ–‡æåˆ°çš„urlåŒ…ä¸­çš„[`percent_encode`]å‡½æ•°ï¼Œè¿”å›äº†ä¸€ä¸ª[`PercentEncode`]ç±»å‹.

[PercentEncode-type]: https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html

ç‰¹åˆ«æ˜¯ï¼Œå½“è¿™äº›ç±»å‹è·ŸåŒ…åå‰ç¼€ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå°†å…·å¤‡éå¸¸æ¸…æ™°çš„å«ä¹‰ï¼Œä¾‹å¦‚[`vec::IntoIter`].

[`vec::IntoIter`]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html

### æ ‡å‡†åº“ç¤ºä¾‹

* [`Vec::iter`] returns [`Iter`][slice::Iter]
* [`Vec::iter_mut`] returns [`IterMut`][slice::IterMut]
* [`Vec::into_iter`] returns [`IntoIter`][vec::IntoIter]
* [`BTreeMap::keys`] returns [`Keys`][btree_map::Keys]
* [`BTreeMap::values`] returns [`Values`][btree_map::Values]

[`Vec::iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter
[slice::Iter]: https://doc.rust-lang.org/std/slice/struct.Iter.html
[`Vec::iter_mut`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut
[slice::IterMut]: https://doc.rust-lang.org/std/slice/struct.IterMut.html
[`Vec::into_iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter
[vec::IntoIter]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html
[`BTreeMap::keys`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys
[btree_map::Keys]: https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html
[`BTreeMap::values`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values
[btree_map::Values]: https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html


<a id="c-feature"></a>
## Cargo Featureçš„åç§°ä¸åº”è¯¥åŒ…å«å ä½è¯(C-FEATURE)

ä¸è¦åœ¨[Cargo feature]ä¸­åŒ…å«æ— æ³•ä¼ è¾¾ä»»ä½•æ„ä¹‰çš„è¯ï¼Œä¾‹å¦‚`use-abc`æˆ–`with-abc`ï¼Œç›´æ¥å‘½åä¸º`abc`å³å¯ã€‚

[Cargo feature]: http://doc.crates.io/manifest.html#the-features-section

ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯ï¼šä¸€ä¸ªåŒ…å¯¹æ ‡å‡†åº“æœ‰å¯é€‰æ€§çš„ä¾èµ–ã€‚æ ‡å‡†çš„å†™æ³•å¦‚ä¸‹ï¼š

```toml
# åœ¨Cargo.tomlä¸­

[features]
default = ["std"]
std = []
```

```rust
// åœ¨æˆ‘ä»¬è‡ªå®šä¹‰çš„lib.rsä¸­

#![cfg_attr(not(feature = "std"), no_std)]
```
é™¤äº†`std`ä¹‹å¤–ï¼Œä¸è¦ä½¿ç”¨ä»»ä½•`ust-std`æˆ–è€…`with-std`ç­‰è‡ªä»¥ä¸ºå¾ˆæœ‰åˆ›é€ æ€§çš„åç§°ã€‚

## å‘½åè¦ä½¿ç”¨ä¸€è‡´æ€§çš„è¯åº(C-WORD-ORDER)

è¿™æ˜¯ä¸€äº›æ ‡å‡†åº“ä¸­çš„é”™è¯¯ç±»å‹:

- [`JoinPathsError`](https://doc.rust-lang.org/std/env/struct.JoinPathsError.html)
- [`ParseBoolError`](https://doc.rust-lang.org/std/str/struct.ParseBoolError.html)
- [`ParseCharError`](https://doc.rust-lang.org/std/char/struct.ParseCharError.html)
- [`ParseFloatError`](https://doc.rust-lang.org/std/num/struct.ParseFloatError.html)
- [`ParseIntError`](https://doc.rust-lang.org/std/num/struct.ParseIntError.html)
- [`RecvTimeoutError`](https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html)
- [`StripPrefixError`](https://doc.rust-lang.org/std/path/struct.StripPrefixError.html)

å®ƒä»¬éƒ½ä½¿ç”¨äº†`è°“è¯­-å®¾è¯­-é”™è¯¯`çš„è¯åºï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è¡¨è¾¾ä¸€ä¸ªç½‘ç»œåœ°å€æ— æ³•åˆ†æçš„é”™è¯¯ï¼Œç”±äºè¯åºä¸€è‡´æ€§çš„åŸåˆ™ï¼Œå‘½ååº”è¯¥å¦‚ä¸‹`ParseAddrError`,è€Œä¸æ˜¯`AddrParseError`ã€‚

è¯åºå’Œä¸ªäººä¹ æƒ¯æœ‰å¾ˆå¤§å…³ç³»ï¼Œæƒ³è¦æ³¨æ„çš„æ˜¯ï¼Œä½ å¯ä»¥é€‰æ‹©åˆé€‚çš„è¯åºï¼Œä½†æ˜¯è¦åœ¨åŒ…çš„èŒƒç•´å†…ä¿æŒä¸€è‡´æ€§ï¼Œå°±å¦‚æ ‡å‡†åº“ä¸­çš„åŒ…ä¸€æ ·ã€‚



================================================
FILE: ci/copy-assets.sh
================================================
#!/usr/bin/env bash

cp ./assets/CNAME ./book/
cp ./assets/*.html ./book/
cp ./assets/sitemap.xml ./book/


================================================
FILE: src/about-book.md
================================================
<img src="https://github.com/sunface/rust-course/blob/main/assets/banner.jpg?raw=true" />

Rust è¯­è¨€çœŸçš„å¥½ï¼šè¿ç»­å…«å¹´æˆä¸ºå…¨ä¸–ç•Œæœ€å—æ¬¢è¿çš„è¯­è¨€ã€æ²¡æœ‰ GC ä¹Ÿæ— éœ€æ‰‹åŠ¨å†…å­˜ç®¡ç†ã€æ€§èƒ½æ¯”è‚© C++/C è¿˜èƒ½ç›´æ¥è°ƒç”¨å®ƒä»¬çš„ä»£ç ã€å®‰å…¨æ€§æé«˜ - æ€»æœ‰å…¬å¸è¯´ä½¿ç”¨ Rust åä»¥å‰çš„å¤§éƒ¨åˆ† bug éƒ½å°†è‡ªåŠ¨æ¶ˆå¤±ã€å…¨ä¸–ç•Œæœ€å¥½çš„åŒ…ç®¡ç†å·¥å…· Cargo ç­‰ç­‰ã€‚ä½†...

**æœ‰äººè¯´: "Rust å¤ªéš¾äº†ï¼Œå­¦äº†ä¹Ÿæ²¡ç”¨"**

å¯¹äºåé¢ä¸€å¥è¯æˆ‘ä»¬æŒä¿ç•™æ„è§ï¼Œå¦‚æœä»¥æ‰¾å·¥ä½œä¸ºæ ‡å‡†ï¼Œé‚£å›½å†…ç¯å¢ƒç¡®å®è¿˜ä¸å¥½ï¼Œä½†å¦‚æœä½ æƒ³æˆä¸ºæ›´ä¼˜ç§€çš„ç¨‹åºå‘˜æˆ–è€…æ˜¯ç©è½¬å¼€æºï¼Œé‚£ Rust è¿˜çœŸæ˜¯ä¸é”™çš„é€‰æ‹©ï¼Œå…·ä½“åŸå› è§[ä¸‹ä¸€ç« ](https://course.rs/into-rust.html)ã€‚

è‡³äº Rust éš¾å­¦ï¼Œé‚£æ­£æ˜¯æœ¬ä¹¦è¦è§£å†³çš„é—®é¢˜ï¼Œå¦‚æœçœ‹å®Œåï¼Œä½ è§‰å¾—æ²¡æœ‰å­¦ä¼š Rustï¼Œå¯ä»¥æ‰¾æˆ‘ä»¬é€€æ¬¾ï¼Œå“¦æŠ±æ­‰ï¼Œè¿™æ˜¯å¼€æºä¹¦ï¼Œé‚£å°±é€€ ğŸŒŸ å§ :)

å¦‚æœçœ‹åˆ°è¿™é‡Œï¼Œå¤§å®¶è§‰å¾—è¿™æœ¬ä¹¦çš„ä»‹ç»å¹¶æ²¡æœ‰å¸å¼•åˆ°ä½ ï¼Œä¸è¦ç«‹å³æ”¾å¼ƒï¼Œå¼ºçƒˆå»ºè®®è¯»ä¸€ä¸‹[è¿›å…¥ Rust ç¼–ç¨‹ä¸–ç•Œ](https://course.rs/into-rust.html)ï¼Œé‚£é‡Œä¼šæœ‰ä¸ä¸€æ ·çš„ç²¾å½©ã€‚

## é…å¥—ç»ƒä¹ é¢˜

å¯¹äºå­¦ä¹ ç¼–ç¨‹è€Œè¨€ï¼Œè¯»ä¸€ç¯‡æ–‡ç« ä¸å¦‚åšå‡ é“ç»ƒä¹ é¢˜ï¼Œæ­¤è¯è™½ç„¶å¤¸å¼ ï¼Œä½†æ˜¯ä¹Ÿä¸æ— é“ç†ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œæ—¢è¯»ä¹¦åˆåšç»ƒä¹ é¢˜ï¼Œæ•ˆæœä¼šä¸ä¼šæ›´å¥½ï¼Ÿå†åŠ ä¸Šç»ƒä¹ é¢˜æ˜¯ä¹¦æœ¬çš„é…å¥—å‘¢ï¼Ÿ :P

- [Rust è¯­è¨€å®æˆ˜](https://github.com/sunface/rust-by-practice), Rust è¯­è¨€åœ£ç»é…å¥—ä¹ é¢˜ï¼Œæ”¯æŒä¸­è‹±åŒè¯­ï¼Œå¯ä»¥åœ¨å³ä¸Šè§’åˆ‡æ¢

## åˆ›ä½œæ„Ÿæ‚Ÿ

æˆªè‡³ç›®å‰ï¼ŒRust è¯­è¨€åœ£ç»å·²å†™äº† 170 ä½™ç« ï¼Œ110 ä½™ä¸‡å­—ï¼Œå†ç» 1000 å¤šä¸ªå°æ—¶ï¼Œæ¯ä¸€ä¸ªç« èŠ‚éƒ½æ˜¯æ‰‹åŠ¨å†™å°±ï¼Œæ²¡æœ‰ä»»ä½•æœºç¿»å’Œè´¨é‡ä¸Šçš„å¦¥å( ç›¸ä¿¡æ·±å…¥é˜…è¯»è¿‡çš„è¯»è€…éƒ½èƒ½ä½“ä¼šåˆ°è¿™ä¸€ç‚¹ )ã€‚

æ›¾ç»æœ‰è¯»è€…é—®è¿‡ "è¿™ä¹ˆå¥½çš„ä¹¦ä¸ºä½•è¦å¼€æºï¼Œè€Œä¸æ˜¯å‡ºç‰ˆ?"ï¼ŒåŸå› å¾ˆç®€å•ï¼š**åªæœ‰å®Œå…¨å¼€æºæ‰èƒ½å®Œç¾åœ°å‘ˆç°å‡ºæˆ‘æƒ³è¦çš„æ•™å­¦æ•ˆæœ**ã€‚

æ€»ä¹‹ï¼ŒRust è¦åœ¨å›½å†…çœŸæ­£å‘å±•èµ·æ¥ï¼Œå¿…é¡»å¾—æœ‰ä¸€äº›è¿½é€æ¢¦æƒ³çš„äººåœ¨åšç€ä¸è®¡ä»˜å‡ºçš„äº‹æƒ…ï¼Œè€Œæˆ‘å¸Œæœ›è‡ªå·±èƒ½è´¡çŒ®ä¸€ä»½å¾®è–„ä¹‹åŠ›ã€‚

ä½†æ˜¯è¦è¯´å®Œå…¨æ— æ¬²æ— æ±‚ï¼Œé‚£ä¹Ÿæ˜¯ä¸å¯èƒ½çš„ï¼Œçœ‹åˆ°é¡¹ç›®å¤šäº†ä¸€é¢— ğŸŒŸï¼Œé‚£æ„Ÿè§‰...æ£’æäº†ï¼Œå› ä¸ºå®ƒä»£è¡¨äº†è¯»è€…çš„è®¤å¯å’Œç§°èµã€‚

ä½ ä»¬ç”¨æŒ‡å°–ç»˜åˆ¶çš„æ˜Ÿç©ºï¼Œé‚£é‡Œç¹æ˜Ÿç‚¹ç‚¹ï¼Œæ¯ä¸€é¢—éƒ½åœ¨é¼“åŠ±ç€æ€€æ£ç€å¼€æºæ¢¦æƒ³çš„ç¨‹åºå‘˜æŠ«è†æ–©æ£˜ã€ä¸æ–­å‰è¡Œï¼Œä¸å¤¸å¼ çš„è¯´ï¼Œæ²¡æœ‰ä½ ä»¬ï¼Œå¼€æºä¸–ç•Œå°±æ²¡æœ‰æ˜Ÿå…‰ï¼Œè‡ªç„¶ä¹Ÿå°±ä¸ä¼šæœ‰ä»Šå¤©çš„å¼€æºç››ä¸–ã€‚

å› æ­¤ï¼Œ**æˆ‘æ³è¯·å¤§å®¶ï¼Œå¦‚æœè§‰å¾—ä¹¦è¿˜å¯ä»¥ï¼Œå°±åœ¨ä½ çš„æŒ‡å°–æ˜Ÿç©ºç»˜åˆ¶ä¸€é¢—æ–°çš„ ğŸŒŸï¼ŒæŒ‡å¼•æˆ‘ä»¬ç»§ç»­ç ¥ç ºå‰è¡Œ**ã€‚è¿™ä¸ªäººä¸–é—´ï¼Œå› å–„æ„è€Œç¾å¥½ã€‚

æœ€åï¼Œèƒ½é€šè¿‡å¼€æºåœ¨èŒ«èŒ«äººæµ·ä¸­ä¸å¤§å®¶ç›¸è¯†ï¼Œè¿™æ„Ÿè§‰çœŸå¥½ :D

## ğŸ† è´¡çŒ®è€…

éå¸¸æ„Ÿè°¢æœ¬æ•™ç¨‹çš„[æ‰€æœ‰è´¡çŒ®è€…](https://github.com/sunface/rust-course/graphs/contributors)ï¼Œæ­£æ˜¯æœ‰äº†ä½ ä»¬ï¼Œæ‰æœ‰äº†ç°åœ¨çš„é«˜è´¨é‡ Rust æ•™ç¨‹!

<br />

ğŸ†

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/EluvK">
                <img src="https://avatars.githubusercontent.com/u/36977935?v=4" width="160px" alt=""/>
                <br />
                <sub><b>EluvK</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/AllanDowney">
                <img src="https://avatars.githubusercontent.com/u/82752697?v=4?s=100"  width="160px" alt=""/>
                <br />
                <sub><b>AllanDowney</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

<br />

ğŸ…

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/JesseAtSZ">
                <img src="https://avatars.githubusercontent.com/u/35264598?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>JesseAtSZ</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/Rustln">
                <img src="https://avatars.githubusercontent.com/u/100085326?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>Rustln</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/1132719438">
                <img src="https://avatars.githubusercontent.com/u/10138791?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>1132719438</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/zongzi531">
                <img src="https://avatars.githubusercontent.com/u/22429236?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>zongzi531</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>



================================================
FILE: src/beat-ai.md
================================================
## Beat AI
ä¸“å±äºè½¯ä»¶å¼€å‘å·¥ç¨‹å¸ˆçš„ AI å…¥é—¨åœ£ç»ã€‚ä»ç¥ç»ç½‘ç»œåˆ°å¤§æ¨¡å‹ï¼Œä»é«˜å±‚è®¾è®¡åˆ°å¾®è§‚åŸç†ï¼Œä»å·¥ç¨‹å®ç°åˆ°ç®—æ³•ï¼Œå­¦å®Œåï¼Œä½ ä¼šå‘ç° AI ä¹Ÿå¹¶ä¸æ˜¯æƒ³è±¡ä¸­é‚£ä¹ˆé«˜ä¸å¯æ”€ã€æ— æ³•æˆ˜èƒœï¼ŒJust beat it !

- å®˜æ–¹åœ°å€: [https://github.com/sunface/beat-ai](https://github.com/sunface/beat-ai)
  
## ç›®å‰è¿›åº¦
å‡†å¤‡å¼€å§‹åŠ¨ç¬”ï¼Œé¢„è®¡åœ¨ 2024.08 ä¹‹å‰ä¼šå®ŒæˆåŸºæœ¬çš„ç« èŠ‚ã€‚

## å…³äºä½œè€…
ä½œè€…å¹¶ä¸æ˜¯å†™ä¹¦çš„å°ç™½ï¼Œå·²ç»æœ‰ä¸€æœ¬ <<Rustè¯­è¨€åœ£ç»>> ï¼Œåœ¨ Rust é¢†åŸŸæ˜¯ç›®å‰æœ€ç«çš„ä¹¦ç±ï¼Œå¤‡å—å¥½è¯„ã€‚

## Q & A
Q: ä¸ºä»€ä¹ˆåˆåŒå’å•å†™ä¸€æœ¬ AI å…¥é—¨ä¹¦ç±ï¼Ÿ

A: ä¸€èˆ¬æ¥è¯´ï¼Œæ‡‚ AI çš„å¾€å¾€å¹¶ä¸æ·±å…¥æ‡‚å·¥ç¨‹ï¼Œè€Œç²¾é€šå·¥ç¨‹çš„åˆä¸å¤ªæ‡‚ AIï¼Œæˆ‘ä»¬çš„ç›®çš„å°±æ˜¯å¡«è¡¥è¿™ä¸ª gapï¼Œä»¥å·¥ç¨‹å¸ˆçš„è§’åº¦æ¥å‘ˆç° AI çš„ç›¸å…³çŸ¥è¯†ä½“ç³»ã€‚

Q: ä¸æ‡‚æ•°å­¦å¯ä»¥å­¦å—

A: ä¸€æœ¬ä¼˜ç§€çš„ä¹¦ç±å®ƒåº”è¯¥æ˜¯**å±‚æ¬¡ä¸°å¯Œã€ç»“æ„æ¸…æ™°ã€æ·±å…¥æµ…å‡ºã€é€šä¿—æ˜“æ‡‚**çš„ï¼Œèƒ½æ»¡è¶³ä¸åŒè¯»è€…ç¾¤ä½“çš„éœ€æ±‚ã€‚æœ¬ä¹¦ä¹Ÿæ˜¯ï¼Œå°±ç®—è¯»è€…å¤§å¤§ä¸æ‡‚æ•°å­¦ï¼Œæ— éå°±æ˜¯æ— æ³•æ·±å…¥åˆ°ç®—æ³•å±‚é¢ï¼Œä½†æ˜¯å¹¶ä¸å¦¨ç¢æ·±å…¥å­¦ä¹ ç†è§£ AIï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¯¹ç®—æ³•è¿›è¡Œä¸€äº›æ·±å…¥æµ…å‡ºçš„è¶£å‘³è®²è§£ã€‚

Q: æ²¡æœ‰è½¯ä»¶å¼€å‘çš„èƒŒæ™¯ï¼Œä¸å¤ªæ‡‚å·¥ç¨‹ï¼Œä¹Ÿä¸æ‡‚æ•°å­¦ï¼Œèƒ½å­¦å—?

A: ç­”æ¡ˆåŸºæœ¬åŒä¸Šï¼Œåƒäººåƒé¢ï¼Œå„æœ‰æ‰€è·ã€‚


================================================
FILE: src/community.md
================================================
[Binary file]


================================================
FILE: src/github.md
================================================
# GitHub



================================================
FILE: src/index-list.md
================================================
# å¿«é€ŸæŸ¥è¯¢å…¥å£

<<Rust è¯­è¨€åœ£ç»>> æ—¢ç„¶è‡ªè¯©ä¸º Rust æ—¥å¸¸å¼€å‘å·¥å…·ä¹¦ï¼Œé‚£å°±å¾—æœ‰å·¥å…·ä¹¦çš„æ ·å­ï¼Œå¦‚æœæ²¡æœ‰äº†å¿«é€Ÿç´¢å¼•æŸ¥è¯¢çš„åŠŸèƒ½ï¼Œä¹Ÿå°±æ²¡æœ‰äº†çµé­‚ã€‚

å› æ­¤æˆ‘ä»¬å†³å®šåœ¨è¿™é‡Œæä¾›ä¸€ä¸ªå¯¹å…¨ä¹¦å†…å®¹è¿›è¡Œå¿«é€Ÿç´¢å¼•çš„é€”å¾„ã€‚ç†è®ºä¸Šæ¥è¯´ï¼Œ**ä½ æƒ³æŸ¥çš„ä»»ä½•ä¸œè¥¿åœ¨è¿™é‡Œéƒ½å¯ä»¥å¿«é€Ÿçš„è¢«æ‰¾åˆ°å¹¶èƒ½è¿›å…¥ç›¸åº”çš„ç« èŠ‚æŸ¥çœ‹è¯¦ç»†çš„ä»‹ç»**ã€‚

å¯èƒ½å¤§å®¶ä¼šæœ‰ç–‘é—®ï¼Œä¸æ˜¯æœ‰ç«™å†…æœç´¢åŠŸèƒ½å˜›ï¼Ÿæ˜¯çš„ï¼Œä½†æ˜¯å°´å°¬çš„æ˜¯ï¼šé¦–å…ˆå®ƒä¸æ”¯æŒä¸­æ–‡ï¼Œå…¶æ¬¡å°±ç®—æ”¯æŒäº†ä¸­æ–‡ï¼Œä¹Ÿä¸€æ ·ä¸å¥½ç”¨ï¼Œæˆ‘ä»¬éœ€è¦çš„æ˜¯å¿«é€Ÿç²¾å‡†åœ°æ‰¾åˆ°å†…å®¹è€Œä¸æ˜¯æ¨¡ç³Šçš„æŸ¥è¯¢å†…å®¹ã€‚

# ç´¢å¼•åˆ—è¡¨ doing

<a id="head"></a>

|    NN     |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |
| :-------: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: |
| [#](#sym) | [A](#a) | [B](#b) | [C](#c) | [D](#d) | [E](#e) | [F](#f) | [G](#g) | [H](#h) |
|  [I](#i)  | [J](#j) | [K](#k) | [L](#l) | [M](#m) | [N](#n) | [O](#o) | [P](#p) | [Q](#q) |
|  [R](#r)  | [S](#s) | [T](#t) | [U](#u) | [V](#v) | [W](#w) | [X](#x) | [Y](#y) | [Z](#z) |

</br>

|       NN        |    NN    |     NN     |
| :-------------: | :------: | :--------: |
| [Cargo](#cargo) | [Naming] | [Keywords] |

[naming]: https://course.rs/practice/naming.html
[keywords]: https://course.rs/appendix/keywords.html

[bottom](#bottom)

## Sym

| åç§°                              | å…³é”®å­—         | ç®€ä»‹                                                                                 |
| --------------------------------- | -------------- | ------------------------------------------------------------------------------------ |
| `[?]`                             | é”™è¯¯ä¼ æ’­       | ç”¨äºç®€åŒ–é”™è¯¯ä¼ æ’­                                                                     |
| `[()]`                            | å•å…ƒç±»å‹       | å•å…ƒç±»å‹ï¼Œæ— è¿”å›å€¼                                                                   |
| `!` : 1. [å‡½æ•°] 2. [ç±»å‹]         | æ°¸ä¸è¿”å›       | æ°¸ä¸è¿”å›                                                                             |
| `[&]`                             | å¼•ç”¨           | å¸¸è§„å¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼ŒæŒ‡å‘äº†å¯¹è±¡å­˜å‚¨çš„å†…å­˜åœ°å€                                     |
| `[\*]`                            | è§£å¼•ç”¨         | è§£å‡ºå¼•ç”¨æ‰€æŒ‡å‘çš„å€¼                                                                   |
| `[@]`                             | å˜é‡ç»‘å®š       | ä¸ºä¸€ä¸ªå­—æ®µç»‘å®šå¦å¤–ä¸€ä¸ªå˜é‡                                                           |
| `_` : 1. [å¿½ç•¥å˜é‡] 2. [æ¨¡å¼åŒ¹é…] | å¿½ç•¥           | 1. å¿½ç•¥è¯¥å€¼æˆ–è€…ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šç»™ä½ ä¸€ä¸ª `å˜é‡æœªä½¿ç”¨çš„` çš„è­¦å‘Š<br>2. æ¨¡å¼åŒ¹é…é€šé…ç¬¦ |
| `['a: 'b]`                        | ç”Ÿå‘½å‘¨æœŸçº¦æŸ   | ç”¨æ¥è¯´æ˜ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸçš„é•¿çŸ­                                                           |
| `[{:?}] {:#?}`                    | æ‰“å°ç»“æ„ä½“ä¿¡æ¯ | ä½¿ç”¨ `#[derive(Debug)]` æ´¾ç”Ÿå®ç° `Debug` ç‰¹å¾ï¼Œå¦è§ [æ ¼å¼åŒ–è¾“å‡º]                     |
| `[::]`                            | å…³è”å‡½æ•°       | å®šä¹‰åœ¨ `impl` ä¸­ä¸”æ²¡æœ‰ `self` çš„å‡½æ•°                                                 |
|                                   |                |

`[?]`: https://course.rs/basic/result-error/result.html#ä¼ æ’­ç•Œçš„å¤§æ˜æ˜Ÿ-
`[()]`: https://course.rs/basic/base-type/function.html#æ— è¿”å›å€¼
`[å‡½æ•°]`: https://course.rs/basic/base-type/function.html#æ°¸ä¸è¿”å›çš„å‘æ•£å‡½æ•°-
`[ç±»å‹]`: https://course.rs/advance/into-types/custom-type.html#æ°¸ä¸è¿”å›ç±»å‹
`[&]`: https://course.rs/basic/ownership/borrowing.html#å¼•ç”¨ä¸è§£å¼•ç”¨
`[\*]`: https://course.rs/basic/ownership/borrowing.html#å¼•ç”¨ä¸è§£å¼•ç”¨
`[@]`: https://course.rs/basic/match-pattern/all-patterns.html#ç»‘å®š
`['a: 'b]`: https://course.rs/advance/lifetime/advance.html#ç”Ÿå‘½å‘¨æœŸçº¦æŸ-hrtb
`[{:?}]`: https://course.rs/basic/compound-type/struct.html#ä½¿ç”¨-derivedebug-æ¥æ‰“å°ç»“æ„ä½“çš„ä¿¡æ¯
`[å¿½ç•¥å˜é‡]`: https://course.rs/basic/variable.html#ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡
`[æ¨¡å¼åŒ¹é…]`: https://course.rs/basic/match-pattern/match-if-let.html#_-é€šé…ç¬¦
`[::]`: https://course.rs/basic/method.html#å…³è”å‡½æ•°
`[æ ¼å¼åŒ–è¾“å‡º]`: https://course.rs/basic/formatted-output.html#-ä¸-

[back](#head)

## A

| åç§°          | å…³é”®å­—   | ç®€ä»‹                                                                                                                   |
| ------------- | -------- | ---------------------------------------------------------------------------------------------------------------------- |
| [array æ•°ç»„]  | æ•°ç»„     | é•¿åº¦å›ºå®š<br>å…ƒç´ å¿…é¡»æœ‰ç›¸åŒçš„ç±»å‹<br>ä¾æ¬¡çº¿æ€§æ’åˆ—<br>å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®å…¶ä¸­çš„å…ƒç´ <br>`let a: [i32; 5] = [1, 2, 3, 4, 5];` |
| [array slice] | æ•°ç»„åˆ‡ç‰‡ | `let slice: &[i32] = &a[1..3];`                                                                                        |
| [as è½¬æ¢]     | ç±»å‹è½¬æ¢ | `(x as T)`                                                                                                             |
|               | KWA      |                                                                                                                        |

[array æ•°ç»„]: https://course.rs/basic/compound-type/array.html
[array slice]: https://course.rs/basic/compound-type/array.html#æ•°ç»„åˆ‡ç‰‡
[as è½¬æ¢]: https://course.rs/advance/into-types/converse.html#asè½¬æ¢

[back](#head)

## B

| åç§°               | å…³é”®å­—       | ç®€ä»‹                                                                                                                            |
| ------------------ | ------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| [å˜é‡é®è”½]         | shadowing    | å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåè€…ä¼šé®è”½æ‰å‰è€…                                                                                          |
| [å˜é‡è¦†ç›–]         | æ¨¡å¼åŒ¹é…     | æ— è®ºæ˜¯æ˜¯ `match` è¿˜æ˜¯ `if let`ï¼Œä»–ä»¬éƒ½å¯ä»¥åœ¨æ¨¡å¼åŒ¹é…æ—¶è¦†ç›–æ‰è€çš„å€¼ï¼Œç»‘å®šæ–°çš„å€¼                                                  |
| [å˜é‡ä½œç”¨åŸŸ]       | æ‰€æœ‰æƒ       | ä½œç”¨åŸŸæ˜¯ä¸€ä¸ªå˜é‡åœ¨ç¨‹åºä¸­æœ‰æ•ˆçš„èŒƒå›´                                                                                              |
| [è¡¨è¾¾å¼] ä¸ [è¯­å¥] |              | è¡¨è¾¾å¼ï¼šè¿›è¡Œæ±‚å€¼ï¼Œç»“å°¾æ—  `;`ï¼Œæœ‰è¿”å›å€¼ï¼Œå¦‚ `x + 9` å¦è§ [é™„å½• C]</br>è¯­å¥ï¼šå®Œæˆä¸€ä¸ªæ“ä½œï¼Œç»“å°¾æœ‰ `;` ï¼Œæ— è¿”å›å€¼ï¼Œå¦‚ `let x = 9;` |
| [bool å¸ƒå°”]        | å¸ƒå°”ç±»å‹     | `true` `false`ï¼Œå ç”¨ 1 å­—èŠ‚                                                                                                     |
| [Box\<T\>]         | æ™ºèƒ½æŒ‡é’ˆ     | å…è®¸ä½ å°†ä¸€ä¸ªå€¼åˆ†é…åˆ°å †ä¸Šï¼Œç„¶ååœ¨æ ˆä¸Šä¿ç•™ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘å †ä¸Šçš„æ•°æ®                                                              |
| [break]            | å¾ªç¯æ§åˆ¶     | ç›´æ¥è·³å‡ºå½“å‰æ•´ä¸ªå¾ªç¯                                                                                                            |
| [backtrace æ ˆå±•å¼€] | ä¸å¯æ¢å¤é”™è¯¯ | `RUST_BACKTRACE=1 cargo run`                                                                                                    |
|                    | KWB          |                                                                                                                                 |

[å˜é‡é®è”½]: https://course.rs/basic/variable.html#å˜é‡é®è”½shadowing
[å˜é‡è¦†ç›–]: https://course.rs/basic/match-pattern/match-if-let.html#å˜é‡è¦†ç›–
[å˜é‡ä½œç”¨åŸŸ]: https://course.rs/basic/ownership/ownership.html#å˜é‡ä½œç”¨åŸŸ
[bool å¸ƒå°”]: https://course.rs/basic/base-type/char-bool.html#å¸ƒå°”bool
[è¡¨è¾¾å¼]: https://course.rs/basic/base-type/statement-expression.html#è¡¨è¾¾å¼
[è¯­å¥]: https://course.rs/basic/base-type/statement-expression.html#è¯­å¥
[é™„å½• c]: https://course.rs/appendix/expressions.html
[break]: https://course.rs/basic/flow-control.html#break
[backtrace æ ˆå±•å¼€]: https://course.rs/basic/result-error/panic.html#backtrace-æ ˆå±•å¼€
[box\<t\>]: https://course.rs/advance/smart-pointer/box.html#ä½¿ç”¨-boxt-å°†æ•°æ®å­˜å‚¨åœ¨å †ä¸Š

[back](#head)

## C

| åç§°               | å…³é”®å­—   | ç®€ä»‹                                                                                                             |
| ------------------ | -------- | ---------------------------------------------------------------------------------------------------------------- |
| [char å­—ç¬¦]        | å­—ç¬¦ç±»å‹ | ä½¿ç”¨ `''` è¡¨ç¤ºï¼Œæ‰€æœ‰çš„ Unicode å€¼                                                                                |
| [const å¸¸é‡]       | constant | `const MAX_POINTS: u32 = 100_000;`                                                                               |
| [const æ³›å‹]       | æ³›å‹     | `const N: usize` é’ˆå¯¹å€¼çš„æ³›å‹ï¼Œé€‚åˆå¤„ç†æ•°ç»„é•¿åº¦çš„é—®é¢˜                                                            |
| [const æ³›å‹è¡¨è¾¾å¼] | æ³›å‹     |                                                                                                                  |
| [Copy æ‹·è´]        | æµ…æ‹·è´   | ä»»ä½•åŸºæœ¬ç±»å‹çš„ç»„åˆå¯ä»¥ `Copy`ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯å¯ä»¥ `Copy` çš„ã€‚                              |
| [continue]         | å¾ªç¯æ§åˆ¶ | è·³è¿‡å½“å‰å½“æ¬¡çš„å¾ªç¯ï¼Œå¼€å§‹ä¸‹æ¬¡çš„å¾ªç¯                                                                               |
| [Clone å…‹éš†]       | æ·±æ‹·è´   | éœ€è¦å¤åˆ¶å †ä¸Šçš„æ•°æ®æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `.clone()` æ–¹æ³•                                                                   |
| [Closure]          | é—­åŒ…     | é—­åŒ…æ˜¯ä¸€ç§åŒ¿åå‡½æ•°ï¼Œå®ƒå¯ä»¥èµ‹å€¼ç»™å˜é‡ä¹Ÿå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶å®ƒå‡½æ•°ï¼Œä¸åŒäºå‡½æ•°çš„æ˜¯ï¼Œå®ƒå…è®¸[æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼] |
|                    | KWC      |                                                                                                                  |

[char å­—ç¬¦]: https://course.rs/basic/base-type/char-bool.html#å­—ç¬¦ç±»å‹char
[const å¸¸é‡]: https://course.rs/basic/variable.html#å˜é‡å’Œå¸¸é‡ä¹‹é—´çš„å·®å¼‚
[copy æ‹·è´]: https://course.rs/basic/ownership/ownership.html#æ‹·è´æµ…æ‹·è´
[clone å…‹éš†]: https://course.rs/basic/ownership/ownership.html#å…‹éš†æ·±æ‹·è´
[continue]: https://course.rs/basic/flow-control.html#continue
[const æ³›å‹]: https://course.rs/basic/trait/generic.html#const-æ³›å‹rust-151-ç‰ˆæœ¬å¼•å…¥çš„é‡è¦ç‰¹æ€§
[const æ³›å‹è¡¨è¾¾å¼]: https://course.rs/basic/trait/generic.html#const-æ³›å‹è¡¨è¾¾å¼
[closure]: https://course.rs/advance/functional-programing/closure.html
[æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼]: https://course.rs/advance/functional-programing/closure.html#æ•è·ä½œç”¨åŸŸä¸­çš„å€¼

[back](#head)

## D

| åç§°              | å…³é”®å­—   | ç®€ä»‹                                                                                                               |
| ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------ |
| [derive]          | æ´¾ç”Ÿç‰¹å¾ | `#[derive(Trait)]`ï¼Œè¢«æ ‡è®°çš„å¯¹è±¡è‡ªåŠ¨å®ç°å¯¹åº”çš„é»˜è®¤ç‰¹å¾<br>è¯¦è§ï¼š[é™„å½•-æ´¾ç”Ÿç‰¹å¾]                                    |
| [ç‚¹æ“ä½œç¬¦]        | ç±»å‹è½¬æ¢ | æ–¹æ³•è°ƒç”¨çš„ç‚¹æ“ä½œç¬¦ï¼Œåœ¨è°ƒç”¨æ—¶ï¼Œä¼šå‘ç”Ÿå¾ˆå¤šé­”æ³•èˆ¬çš„ç±»å‹è½¬æ¢<br>ä¾‹å¦‚ï¼šè‡ªåŠ¨å¼•ç”¨ã€è‡ªåŠ¨è§£å¼•ç”¨ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ç›´åˆ°ç±»å‹èƒ½åŒ¹é… |
| [Deref è§£å¼•ç”¨]    | æ™ºèƒ½æŒ‡é’ˆ |                                                                                                                    |
| [ä¸‰ç§ Deref è½¬æ¢] | æ™ºèƒ½æŒ‡é’ˆ |                                                                                                                    |
| [Drop é‡Šæ”¾èµ„æº]   | æ™ºèƒ½æŒ‡é’ˆ |                                                                                                                    |
|                   | KWD      |                                                                                                                    |

[derive]: https://course.rs/basic/trait/trait.html#é€šè¿‡-derive-æ´¾ç”Ÿç‰¹å¾
[é™„å½•-æ´¾ç”Ÿç‰¹å¾]: https://course.rs/appendix/derive.html
[ç‚¹æ“ä½œç¬¦]: https://course.rs/basic/converse.html#ç‚¹æ“ä½œç¬¦
[deref è§£å¼•ç”¨]: https://course.rs/advance/smart-pointer/deref.html#deref-è§£å¼•ç”¨
[ä¸‰ç§ deref è½¬æ¢]: https://course.rs/advance/smart-pointer/deref.html#ä¸‰ç§-deref-è½¬æ¢
[drop é‡Šæ”¾èµ„æº]: https://course.rs/advance/smart-pointer/drop.html#drop-é‡Šæ”¾èµ„æº

[back](#head)

## E

| åç§°              | å…³é”®å­—   | ç®€ä»‹                                     |
| ----------------- | -------- | ---------------------------------------- |
| [enum æšä¸¾]       | æšä¸¾ç±»å‹ | å…è®¸é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„æˆå‘˜æ¥å®šä¹‰ä¸€ä¸ªæšä¸¾ç±»å‹ |
| [enum åŒä¸€åŒ–ç±»å‹] | æšä¸¾æ–¹æ³• | æšä¸¾å®ç°æ–¹æ³•                             |
|                   | KWE      |                                          |

[enum æšä¸¾]: https://course.rs/basic/compound-type/enum.html#æšä¸¾
[enum åŒä¸€åŒ–ç±»å‹]: https://course.rs/basic/compound-type/enum.html#åŒä¸€åŒ–ç±»å‹

[back](#head)

## F

| åç§°             | å…³é”®å­—   | ç®€ä»‹                                                                                                                                                                                                                                                         |
| ---------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [æµ®ç‚¹æ•°]         | æ•°å€¼ç±»å‹ | `f32`<br>`f64`(é»˜è®¤ç±»å‹)                                                                                                                                                                                                                                     |
| [for å¾ªç¯]       | å¾ªç¯æ§åˆ¶ | `for item in &collection {}`                                                                                                                                                                                                                                 |
| ['fn' å‡½æ•°]      |          | å‡½æ•°åå’Œå˜é‡åä½¿ç”¨ `è›‡å½¢å‘½åæ³•(snake case)`<br>å‡½æ•°çš„ä½ç½®å¯ä»¥éšä¾¿æ”¾<br>æ¯ä¸ªå‡½æ•°å‚æ•°éƒ½éœ€è¦æ ‡æ³¨ç±»å‹                                                                                                                                                            |
| [è°ƒç”¨åŒåçš„æ–¹æ³•] |          | 1. é»˜è®¤è°ƒç”¨ç±»å‹ä¸Šçš„æ–¹æ³•<br>`Struct.function(receiver_if_method, next_arg, ...);`<br>2. æ˜¾å¼è°ƒç”¨ç‰¹å¾ä¸Šçš„æ–¹æ³•<br>`Trait::function(receiver_if_method, next_arg, ...);`<br>3. [å®Œå…¨é™å®šè¯­æ³•]<br>`<Type as Trait>::function(receiver_if_method, next_arg, ...);` |
| [ä¸‰ç§ Fn ç‰¹å¾]   | é—­åŒ…     | é—­åŒ…[æ•è·å˜é‡]æœ‰ä¸‰ç§é€”å¾„ï¼Œæ°å¥½å¯¹åº”å‡½æ•°å‚æ•°çš„ä¸‰ç§ä¼ å…¥æ–¹å¼ï¼šè½¬ç§»æ‰€æœ‰æƒã€å¯å˜å€Ÿç”¨ã€ä¸å¯å˜å€Ÿç”¨                                                                                                                                                                   |
| [ä¸‰ç§ Fn çš„å…³ç³»] | é—­åŒ…     |                                                                                                                                                                                                                                                              |
|                  | KWF      |                                                                                                                                                                                                                                                              |

[æµ®ç‚¹æ•°]: https://course.rs/basic/base-type/numbers.html#æµ®ç‚¹ç±»å‹
[for å¾ªç¯]: https://course.rs/basic/flow-control.html#for-å¾ªç¯
['fn' å‡½æ•°]: https://course.rs/basic/base-type/function.html
[è°ƒç”¨åŒåçš„æ–¹æ³•]: https://course.rs/basic/trait/advance-trait.html#è°ƒç”¨åŒåçš„æ–¹æ³•
[å®Œå…¨é™å®šè¯­æ³•]: https://course.rs/basic/trait/advance-trait.html#å®Œå…¨é™å®šè¯­æ³•
[ä¸‰ç§ fn ç‰¹å¾]: https://course.rs/advance/functional-programing/closure.html#ä¸‰ç§-fn-ç‰¹å¾
[æ•è·å˜é‡]: https://course.rs/advance/functional-programing/closure.html#æ•è·ä½œç”¨åŸŸä¸­çš„å€¼
[ä¸‰ç§ fn çš„å…³ç³»]: https://course.rs/advance/functional-programing/closure.html#ä¸‰ç§-fn-çš„å…³ç³»

[back](#head)

## G

| åç§°            | å…³é”®å­— | ç®€ä»‹                               |
| --------------- | ------ | ---------------------------------- |
| [Generics æ³›å‹] | æ³›å‹   | ç”¨åŒä¸€åŠŸèƒ½çš„å‡½æ•°å¤„ç†ä¸åŒç±»å‹çš„æ•°æ® |
|                 | KWG    |                                    |

[generics æ³›å‹]: https://course.rs/basic/trait/generic.html

[back](#head)

## H

| åç§°                  | å…³é”®å­—   | ç®€ä»‹                                                                                                |
| --------------------- | -------- | --------------------------------------------------------------------------------------------------- |
| [HashMap]             | å“ˆå¸Œç±»å‹ | `HashMap<K, V>`ï¼Œå­˜å‚¨çš„æ˜¯ä¸€ä¸€æ˜ å°„çš„ `KV` é”®å€¼å¯¹ï¼Œå¹¶æä¾›äº†å¹³å‡å¤æ‚åº¦ä¸º `O(1)` çš„æŸ¥è¯¢æ–¹æ³•             |
| [HashMap::new()]      |          | åˆ›å»º HashMapï¼Œéœ€è¦æ‰‹åŠ¨é€šè¿‡ `use std::collections::HashMap;` å¼•å…¥åˆ°æˆ‘ä»¬å½“å‰çš„ä½œç”¨åŸŸä¸­æ¥              |
| `hash.insert(K, V)`   |          | æ’å…¥é”®å€¼å¯¹ï¼Œå¿…é¡»å£°æ˜ä¸º `mut`                                                                        |
| [å…ƒç»„åˆ›å»º HashMap]    |          | ä½¿ç”¨è¿­ä»£å™¨å’Œ collect æ–¹æ³•åˆ›å»º<br>`let teams_map: HashMap<_, _> = teams_list.into_iter().collect();` |
| [æŸ¥è¯¢ HashMap]        |          | é€šè¿‡ `get` æ–¹æ³•å¯ä»¥è·å–å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ª `Option<&T>` ç±»å‹                                             |
| [æ›´æ–° HashMap ä¸­çš„å€¼] |          |                                                                                                     |
|                       | KWH      |                                                                                                     |

[hashmap::new()]: https://course.rs/basic/collections/hashmap.html#ä½¿ç”¨-new-æ–¹æ³•åˆ›å»º
[å…ƒç»„åˆ›å»º hashmap]: https://course.rs/basic/collections/hashmap.html#ä½¿ç”¨è¿­ä»£å™¨å’Œ-collect-æ–¹æ³•åˆ›å»º
[æŸ¥è¯¢ hashmap]: https://course.rs/basic/collections/hashmap.html#æŸ¥è¯¢-hashmap
[æ›´æ–° hashmap ä¸­çš„å€¼]: https://course.rs/basic/collections/hashmap.html#æ›´æ–°-hashmap-ä¸­çš„å€¼

[back](#head)

## I

| åç§°                                         | å…³é”®å­—   | ç®€ä»‹                                                                  |
| -------------------------------------------- | -------- | --------------------------------------------------------------------- |
| [if else]                                    | æµç¨‹æ§åˆ¶ | æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„ä»£ç åˆ†æ”¯                                            |
| [else if]                                    | æµç¨‹æ§åˆ¶ | å¤„ç†å¤šé‡æ¡ä»¶                                                          |
| [if let åŒ¹é…]                                | æ¨¡å¼åŒ¹é… | å½“ä½ åªè¦åŒ¹é…ä¸€ä¸ªæ¡ä»¶ï¼Œä¸”å¿½ç•¥å…¶ä»–æ¡ä»¶æ—¶å°±ç”¨ `if let`ï¼Œå¦åˆ™éƒ½ç”¨ `match` |
| `impl Trait` 1. [å‡½æ•°å‚æ•°] 2. [å‡½æ•°è¿”å›ç±»å‹] |          |                                                                       |
|                                              | KWI      |                                                                       |

[if else]: https://course.rs/basic/flow-control.html#ä½¿ç”¨-if-æ¥åšåˆ†æ”¯æ§åˆ¶
[else if]: https://course.rs/basic/flow-control.html#ä½¿ç”¨-else-if-æ¥å¤„ç†å¤šé‡æ¡ä»¶
[if let åŒ¹é…]: https://course.rs/basic/match-pattern/match-if-let.html#if-let-åŒ¹é…
[å‡½æ•°å‚æ•°]: https://course.rs/basic/trait/trait.html#ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°
[å‡½æ•°è¿”å›ç±»å‹]: https://course.rs/basic/trait/trait.html#å‡½æ•°è¿”å›ä¸­çš„-impl-trait

[back](#head)

## J

| åç§° | å…³é”®å­— | ç®€ä»‹ |
| ---- | ------ | ---- |
|      | KWJ    |      |

[back](#head)

## K

| åç§° | å…³é”®å­— | ç®€ä»‹ |
| ---- | ------ | ---- |
|      | KWK    |      |

[back](#head)

## L

| åç§°        | å…³é”®å­—   | ç®€ä»‹                           |
| ----------- | -------- | ------------------------------ |
| [let]       | å˜é‡ç»‘å®š | `let x : u32 = 5;`             |
| [let mut]   | å¯å˜å˜é‡ | `let mut x : u32 = 5; x = 9;`  |
| [loop å¾ªç¯] | å¾ªç¯æ§åˆ¶ | æ— é™å¾ªç¯ï¼Œæ³¨æ„è¦é…åˆ [`break`] |
|             | KWL      |                                |

[let]: https://course.rs/basic/variable.html#å˜é‡ç»‘å®š
[let mut]: https://course.rs/basic/variable.html#å˜é‡å¯å˜æ€§
[`break`]: https://course.rs/basic/flow-control.html#break
[loop å¾ªç¯]: https://course.rs/basic/flow-control.html#loop-å¾ªç¯

[back](#head)

## M

| åç§°            | å…³é”®å­—     | ç®€ä»‹                                                                                                                                                                     |
| --------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [æ¨¡å¼ç»‘å®š]      | æ¨¡å¼åŒ¹é…   | ä»æ¨¡å¼ä¸­å–å‡ºç»‘å®šçš„å€¼                                                                                                                                                     |
| [å…¨æ¨¡å¼åˆ—è¡¨]    | æ¨¡å¼åŒ¹é…   | åˆ—å‡ºäº†æ‰€æœ‰çš„æ¨¡å¼åŒ¹é…                                                                                                                                                     |
| [Method æ–¹æ³•]   | `impl`     | Rust çš„æ–¹æ³•å¾€å¾€è·Ÿç»“æ„ä½“ã€æšä¸¾ã€ç‰¹å¾ä¸€èµ·ä½¿ç”¨                                                                                                                              |
| [Method getter] | `getter`   | æ–¹æ³•åè·Ÿç»“æ„ä½“çš„å­—æ®µåç›¸åŒ                                                                                                                                               |
| [match åŒ¹é…]    | æ¨¡å¼åŒ¹é…   | 1. `match` çš„åŒ¹é…å¿…é¡»è¦ç©·ä¸¾å‡ºæ‰€æœ‰å¯èƒ½ï¼Œå› æ­¤è¿™é‡Œç”¨ `_ ` æ¥ä»£è¡¨æœªåˆ—å‡ºçš„æ‰€æœ‰å¯èƒ½æ€§<br>2. `match` çš„æ¯ä¸€ä¸ªåˆ†æ”¯éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸”æ‰€æœ‰åˆ†æ”¯çš„è¡¨è¾¾å¼æœ€ç»ˆè¿”å›å€¼çš„ç±»å‹å¿…é¡»ç›¸åŒ |
| [matches! å®]   | æ¨¡å¼åŒ¹é…   | å°†ä¸€ä¸ªè¡¨è¾¾å¼è·Ÿæ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œç„¶åè¿”å›åŒ¹é…çš„ç»“æœ `true` æˆ– `false`                                                                                                         |
| [match guard]   | åŒ¹é…å®ˆå«   | ä½äº `match` åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– `if` æ¡ä»¶ï¼Œå®ƒèƒ½ä¸ºåˆ†æ”¯æ¨¡å¼æä¾›æ›´è¿›ä¸€æ­¥çš„åŒ¹é…æ¡ä»¶                                                                                          |
| [move ç§»åŠ¨]     | è½¬ç§»æ‰€æœ‰æƒ | `let s2 = s1;`<br>`s1` æ‰€æœ‰æƒè½¬ç§»ç»™äº† `s2`ï¼Œ`s1` å¤±æ•ˆ                                                                                                                    |
|                 | KWM        |                                                                                                                                                                          |

[æ¨¡å¼ç»‘å®š]: https://course.rs/basic/match-pattern/match-if-let.html#æ¨¡å¼ç»‘å®š
[match åŒ¹é…]: https://course.rs/basic/match-pattern/match-if-let.html#match-åŒ¹é…
[matches! å®]: https://course.rs/basic/match-pattern/match-if-let.html#matcheså®
[move ç§»åŠ¨]: https://course.rs/basic/ownership/ownership.html#è½¬ç§»æ‰€æœ‰æƒ
[å…¨æ¨¡å¼åˆ—è¡¨]: https://course.rs/basic/match-pattern/all-patterns.html
[match guard]: https://course.rs/basic/match-pattern/all-patterns.html#åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶
[method æ–¹æ³•]: https://course.rs/basic/method.html#å®šä¹‰æ–¹æ³•
[method getter]: https://course.rs/basic/method.html#æ–¹æ³•åè·Ÿç»“æ„ä½“å­—æ®µåç›¸åŒ

[back](#head)

## N

| åç§°                | å…³é”®å­—  | ç®€ä»‹                                                                                       |
| ------------------- | ------- | ------------------------------------------------------------------------------------------ |
| [newtype for Trait] | newtype | ä¸ºä¸€ä¸ª[å…ƒç»„ç»“æ„ä½“]åˆ›å»ºæ–°ç±»å‹ã€‚è¯¥å…ƒç»„ç»“æ„ä½“å°è£…æœ‰ä¸€ä¸ªå­—æ®µï¼Œè¯¥å­—æ®µå°±æ˜¯å¸Œæœ›å®ç°ç‰¹å¾çš„å…·ä½“ç±»å‹ |
| [newtype ]          | newtype | æ·±å…¥ Rust ç±»å‹                                                                             |
|                     | KWN     |                                                                                            |

[newtype for trait]: https://course.rs/basic/trait/advance-trait.html#åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ç‰¹å¾newtype
[å…ƒç»„ç»“æ„ä½“]: https://course.rs/basic/compound-type/struct.html#å…ƒç»„ç»“æ„ä½“tuple-struct
[newtype ]: http://localhost:8080/advance/into-types/custom-type.html#newtype

[back](#head)

## O

| åç§°          | å…³é”®å­—      | ç®€ä»‹                                                            |
| ------------- | ----------- | --------------------------------------------------------------- |
| [Option]      | Option æšä¸¾ | ç”¨äºå¤„ç†ç©ºå€¼ï¼Œ**ä¸€ä¸ªå˜é‡è¦ä¹ˆæœ‰å€¼ï¼š`Some(T)`, è¦ä¹ˆä¸ºç©ºï¼š`None`** |
| [Option è§£æ„] | æ¨¡å¼åŒ¹é…    | å¯ä»¥é€šè¿‡ `match` æ¥å®ç°                                         |
|               | KWO         |                                                                 |

[option]: https://course.rs/basic/compound-type/enum.html#option-æšä¸¾ç”¨äºå¤„ç†ç©ºå€¼
[option è§£æ„]: https://course.rs/basic/match-pattern/option.html#åŒ¹é…-optiont

[back](#head)

## P

| åç§°                  | å…³é”®å­—       | ç®€ä»‹                                                                 |
| --------------------- | ------------ | -------------------------------------------------------------------- |
| [panic! ä¸å¯æ¢å¤é”™è¯¯] | ä¸å¯æ¢å¤é”™è¯¯ | ç¨‹åºä¼šæ‰“å°å‡ºä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œå±•å¼€æŠ¥é”™ç‚¹å¾€å‰çš„å‡½æ•°è°ƒç”¨å †æ ˆï¼Œæœ€åé€€å‡ºç¨‹åº |
| [panic åŸç†å‰–æ]      | ä¸å¯æ¢å¤é”™è¯¯ |                                                                      |
| [println!]            | æ ¼å¼åŒ–å‚æ•°   | å¯¹è¾“å‡ºå†…å®¹æ ¼å¼æœ‰æ›´å¤šè¦æ±‚                                             |
|                       | KWP          |                                                                      |

[panic! ä¸å¯æ¢å¤é”™è¯¯]: https://course.rs/basic/result-error/panic.html#panic-ä¸ä¸å¯æ¢å¤é”™è¯¯
[panic åŸç†å‰–æ]: https://course.rs/basic/result-error/panic.html#panic-åŸç†å‰–æ
[println!]: https://course.rs/basic/formatted-output.html#æ ¼å¼åŒ–å‚æ•°

[back](#head)

## Q

| åç§° | å…³é”®å­— | ç®€ä»‹ |
| ---- | ------ | ---- |
|      | KWQ    |      |

[back](#head)

## R

| åç§°                   | å…³é”®å­—     | ç®€ä»‹                                                                               |
| ---------------------- | ---------- | ---------------------------------------------------------------------------------- |
| [Range åºåˆ—]           |            | ç”Ÿæˆè¿ç»­çš„æ•°å€¼<br> åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹<br> `..` å³åŠå¼€åŒºé—´ <br>`..=` é—­åˆåŒºé—´ |
| [Result å¯æ¢å¤çš„é”™è¯¯]  | å¯æ¢å¤é”™è¯¯ | `enum Result<T, E> { Ok(T), Err(E), }`                                             |
| [å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†] | å¯æ¢å¤é”™è¯¯ | å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†                                                               |
|                        | KWR        |                                                                                    |

[range åºåˆ—]: https://course.rs/basic/base-type/numbers.html#åºåˆ—range
[result å¯æ¢å¤çš„é”™è¯¯]: https://course.rs/basic/result-error/result.html#å¯æ¢å¤çš„é”™è¯¯-result
[å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†]: https://course.rs/basic/result-error/result.html#å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†

[back](#head)

## S

| åç§°                   | å…³é”®å­—        | ç®€ä»‹                                                                                                                     |
| ---------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------ |
| [æ‰€æœ‰æƒä¸å †æ ˆ]         |               | Rust æ‰€æœ‰æƒæä¾›çš„å¼ºå¤§ä¿éšœ                                                                                                |
| [æ‰€æœ‰æƒåŸåˆ™]           |               | Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ `æœ‰ä¸”åªæœ‰` ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)<br> å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)                   |
| [slice åˆ‡ç‰‡]           | `&str`        | å…è®¸ä½ å¼•ç”¨ `String` ä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ª `String` <br>è¯­æ³•ï¼š`[å¼€å§‹ç´¢å¼•..ç»ˆæ­¢ç´¢å¼•]`<br>å­—ç¬¦ä¸²å­—é¢é‡æ˜¯åˆ‡ç‰‡ |
| [String å­—ç¬¦ä¸²]        | `String` ç±»å‹ | Rust ä¸­çš„å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„(1 - 4)                                            |
| [String æ“ä½œ]          | `String` æ–¹æ³• | ç”±äº `String` æ˜¯å¯å˜å­—ç¬¦ä¸²ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¯¹å®ƒè¿›è¡Œåˆ›å»ºã€å¢åˆ æ“ä½œ                                                           |
| [String è½¬ä¹‰]          | `String` æ–¹æ³• | é€šè¿‡è½¬ä¹‰çš„æ–¹å¼ `\` è¾“å‡º ASCII å’Œ Unicode å­—ç¬¦                                                                            |
| [struct ç»“æ„ä½“]        | ç»“æ„ä½“        | é€šè¿‡å…³é”®å­— `struct` å®šä¹‰<br>ä¸€ä¸ªæ¸…æ™°æ˜ç¡®çš„ç»“æ„ä½“ `åç§°`<br>å‡ ä¸ªæœ‰åå­—çš„ç»“æ„ä½“ `å­—æ®µ`<br>é€šè¿‡ `.` è®¿é—®å­—æ®µ                |
| [self &self &mut self] | Method æ–¹æ³•   | `self` æŒ‡ä»£ç±»å‹çš„å®ä¾‹                                                                                                    |
| [Self ä¸ self]         |               | `self` æŒ‡ä»£å½“å‰çš„å®ä¾‹å¯¹è±¡ï¼Œ`Self` æŒ‡ä»£ç‰¹å¾æˆ–è€…æ–¹æ³•ç±»å‹çš„åˆ«å                                                             |
| [ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•]     | ç”Ÿå‘½å‘¨æœŸ      | `&'a i32`                                                                                                                |
| [ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤]         | ç”Ÿå‘½å‘¨æœŸ      |                                                                                                                          |
| [ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™è¡¥å……] | ç”Ÿå‘½å‘¨æœŸ      |                                                                                                                          |
| [å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]     | ç”Ÿå‘½å‘¨æœŸ      |                                                                                                                          |
| [ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]   | ç”Ÿå‘½å‘¨æœŸ      |                                                                                                                          |
| [æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]     | ç”Ÿå‘½å‘¨æœŸ      |                                                                                                                          |
| [é™æ€ç”Ÿå‘½å‘¨æœŸ]         | ç”Ÿå‘½å‘¨æœŸ      | `&'static` æ‹¥æœ‰è¯¥ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨å¯ä»¥å’Œæ•´ä¸ªç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå¦è§ [&'static å’Œ T: 'static]                                   |
|                        | KWS           |                                                                                                                          |

[æ‰€æœ‰æƒä¸å †æ ˆ]: https://course.rs/basic/ownership/ownership.html#æ‰€æœ‰æƒä¸å †æ ˆ
[æ‰€æœ‰æƒåŸåˆ™]: https://course.rs/basic/ownership/ownership.html#æ‰€æœ‰æƒåŸåˆ™
[slice åˆ‡ç‰‡]: https://course.rs/basic/compound-type/string-slice.html#åˆ‡ç‰‡slice
[string å­—ç¬¦ä¸²]: https://course.rs/basic/compound-type/string-slice.html#ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²
[string æ“ä½œ]: https://course.rs/basic/compound-type/string-slice.html#æ“ä½œå­—ç¬¦ä¸²
[string è½¬ä¹‰]: https://course.rs/basic/compound-type/string-slice.html#å­—ç¬¦ä¸²è½¬ä¹‰
[struct ç»“æ„ä½“]: https://course.rs/basic/compound-type/struct.html
[self &self &mut self]: https://course.rs/basic/method.html#selfself-å’Œ-mut-self
[self ä¸ self]: https://course.rs/basic/trait/trait-object#self-ä¸-self
[ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•]: https://course.rs/basic/lifetime.html#ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•
[ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤]: https://course.rs/basic/lifetime.html#ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤
[ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™è¡¥å……]: https://course.rs/advance/lifetime/advance.html#ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™è¡¥å……
[å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]: https://course.rs/basic/lifetime.html#å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
[ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]: https://course.rs/basic/lifetime.html#ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
[æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ]: https://course.rs/basic/lifetime.html#æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
[é™æ€ç”Ÿå‘½å‘¨æœŸ]: https://course.rs/basic/lifetime.html#é™æ€ç”Ÿå‘½å‘¨æœŸ
[&'static å’Œ t: 'static]: https://course.rs/advance/lifetime/static.html

[back](#head)

## T

| åç§°                                                     | å…³é”®å­—     | ç®€ä»‹                                                                                                                                                                                        |
| -------------------------------------------------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Tuple å…ƒç»„]                                             |            | ç”±å¤šç§ç±»å‹ç»„åˆä¸€èµ·ï¼Œå…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œå…ƒç»„ä¸­å…ƒç´ çš„é¡ºåºä¹Ÿæ˜¯å›ºå®šçš„<br>ç”¨æ¨¡å¼åŒ¹é…è§£æ„å…ƒç»„ï¼š`let (x, y, z) = (20, 19.2, 1)`<br>ç”¨ `.` æ¥è®¿é—®å…ƒç»„ï¼š`tuple.0` ç´¢å¼•ä» 0 å¼€å§‹                     |
| [Tuple Struct]                                           | å…ƒç»„ç»“æ„ä½“ | ç»“æ„ä½“å¿…é¡»è¦æœ‰åç§°ï¼Œä½†å­—æ®µå¯ä»¥æ²¡æœ‰åç§°<br>`struct Color(i32, i32, i32);`                                                                                                                    |
| [Trait ç‰¹å¾]                                             | ç‰¹å¾       | ä¸€ä¸ªå¯ä»¥è¢«å…±äº«çš„è¡Œä¸ºï¼Œåªè¦å®ç°äº†ç‰¹å¾ï¼Œä½ å°±èƒ½ä½¿ç”¨è¯¥è¡Œä¸º                                                                                                                                      |
| [T: Trait]                                               | ç‰¹å¾çº¦æŸ   | è¿˜å¯ä»¥æœ‰å¤šé‡çº¦æŸï¼Œ`T: Trait1 + Trait2`<br>å¦è§ï¼š[where çº¦æŸ]                                                                                                                                |
| [Trait Object]                                           | ç‰¹å¾å¯¹è±¡   | ç‰¹å¾å¯¹è±¡æŒ‡å‘å®ç°äº† `Trait` ç‰¹å¾çš„ç±»å‹çš„å®ä¾‹ï¼Œå¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡ç‰¹å¾å¯¹è±¡æ‰¾åˆ°å…·ä½“è°ƒç”¨çš„ç±»å‹æ–¹æ³•                                                                                                 |
| `type` 1. [å…³è”ç±»å‹] 2. [é»˜è®¤æ³›å‹ç±»å‹å‚æ•°] 3. [ç±»å‹åˆ«å] |            | 1. `type Item;`<br>`Self` ç”¨æ¥æŒ‡ä»£å½“å‰è°ƒç”¨è€…çš„å…·ä½“ç±»å‹ï¼Œé‚£ä¹ˆ `Self::em` å°±ç”¨æ¥æŒ‡ä»£è¯¥ç±»å‹å®ç°ä¸­å®šä¹‰çš„ `Item` ç±»å‹<br>2. `type Output = Struct;`<br>æŒ‡å®šä¸€ä¸ªé»˜è®¤å€¼ï¼Œè¿”å›ä¸€ä¸ªå…³è”ç±»å‹ `Output` |
| [ç‰¹å¾å®šä¹‰ä¸­çš„ç‰¹å¾çº¦æŸ]                                   | ç‰¹å¾       | ç”¨æ¥è¯´æ˜ä¸€ä¸ªç‰¹å¾éœ€è¦å®ç°å¦ä¸€ä¸ªç‰¹å¾                                                                                                                                                          |
| [TryInto è½¬æ¢]                                           | ç±»å‹è½¬æ¢   | å°è¯•è¿›è¡Œä¸€æ¬¡è½¬æ¢ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Result`ï¼Œå¯ä»¥å¯¹å…¶è¿›è¡Œç›¸åº”çš„é”™è¯¯å¤„ç†                                                                                                                           |
|                                                          | KWT        |                                                                                                                                                                                             |

[tuple å…ƒç»„]: https://course.rs/basic/compound-type/tuple.html#å…ƒç»„
[tuple struct]: https://course.rs/basic/compound-type/struct.html#å…ƒç»„ç»“æ„ä½“tuple-struct
[trait ç‰¹å¾]: https://course.rs/basic/trait/trait.html#å®šä¹‰ç‰¹å¾
[t: trait]: https://course.rs/basic/trait/trait.html#ç‰¹å¾çº¦æŸtrait-bound
[trait object]: https://course.rs/basic/trait/trait-object.html#ç‰¹å¾å¯¹è±¡å®šä¹‰
[å…³è”ç±»å‹]: https://course.rs/basic/trait/advance-trait.html#å…³è”ç±»å‹
[é»˜è®¤æ³›å‹ç±»å‹å‚æ•°]: https://course.rs/basic/trait/advance-trait.html#é»˜è®¤æ³›å‹ç±»å‹å‚æ•°
[ç‰¹å¾å®šä¹‰ä¸­çš„ç‰¹å¾çº¦æŸ]: https://course.rs/basic/trait/advance-trait.html#ç‰¹å¾å®šä¹‰ä¸­çš„ç‰¹å¾çº¦æŸ
[tryinto è½¬æ¢]: https://course.rs/advance/into-types/converse.html#tryinto-è½¬æ¢
[ç±»å‹åˆ«å]: https://course.rs/advance/into-types/custom-type.html#ç±»å‹åˆ«åtype-alias

[back](#head)

## U

| åç§°               | å…³é”®å­—     | ç®€ä»‹                                                              |
| ------------------ | ---------- | ----------------------------------------------------------------- |
| [Unit-like Struct] | å•å…ƒç»“æ„ä½“ | æ²¡æœ‰ä»»ä½•å­—æ®µå’Œå±æ€§<br>`struct AlwaysEqual;`                       |
| [unwrap & expect]  | å¯æ¢å¤é”™è¯¯ | å¦‚æœè¿”å›æˆåŠŸï¼Œå°±å°† `Ok(T)` ä¸­çš„å€¼å–å‡ºæ¥ï¼Œå¦‚æœå¤±è´¥ï¼Œå°±ç›´æ¥ `panic` |
|                    | KWU        |                                                                   |

[unit-like struct]: https://course.rs/basic/compound-type/struct.html#å•å…ƒç»“æ„ä½“unit-like-struct
[unwrap & expect]: https://course.rs/basic/result-error/result.html#å¤±è´¥å°±-panic-unwrap-å’Œ-expect

[back](#head)

## V

| åç§°                       | å…³é”®å­—   | ç®€ä»‹                                                                                           |
| -------------------------- | -------- | ---------------------------------------------------------------------------------------------- |
| [Vector åŠ¨æ€æ•°ç»„]          | åŠ¨æ€æ•°ç»„ | `Vec<T>`ï¼ŒåŠ¨æ€æ•°ç»„å…è®¸ä½ å­˜å‚¨å¤šä¸ªå€¼ï¼Œè¿™äº›å€¼åœ¨å†…å­˜ä¸­ä¸€ä¸ªç´§æŒ¨ç€å¦ä¸€ä¸ªæ’åˆ—ã€‚åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„å…ƒç´  |
| [Vec::new]                 |          | åˆ›å»ºåŠ¨æ€æ•°ç»„                                                                                   |
| [vec!\[\]]                 |          | åˆ›å»ºåŠ¨æ€æ•°ç»„ï¼Œèƒ½åœ¨åˆ›å»ºæ—¶ç»™äºˆåˆå§‹åŒ–å€¼                                                           |
| [vec.push]                 |          | å‘æ•°ç»„å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼Œå¿…é¡»å£°æ˜ä¸º `mut`                                                           |
| [vec.get]                  |          | ä» Vector ä¸­è¯»å–å…ƒç´ ï¼Œè¿”å› `Option<&T>`                                                        |
| `&vec[index]`              |          | ä» Vector ä¸­è¯»å–å…ƒç´ ï¼Œä½¿ç”¨ä¸‹æ ‡ç´¢å¼•è®¿é—®ï¼Œä» 0 å¼€å§‹                                              |
| [è¿­ä»£éå† Vector ä¸­çš„å…ƒç´ ] |          | å¦‚æœæƒ³è¦ä¾æ¬¡è®¿é—®æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¯ä»¥ä½¿ç”¨è¿­ä»£çš„æ–¹å¼å»éå†æ•°ç»„                                     |
| [å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ]       |          | é€šè¿‡ä½¿ç”¨æšä¸¾ç±»å‹å’Œç‰¹å¾å¯¹è±¡æ¥å®ç°ä¸åŒç±»å‹å…ƒç´ çš„å­˜å‚¨                                             |
|                            | KWV      |                                                                                                |

[vector åŠ¨æ€æ•°ç»„]: https://course.rs/basic/collections/vector.html
[vec::new]: https://course.rs/basic/collections/vector.html#vecnew
[vec!\[\]]: https://course.rs/basic/collections/vector.html#vec
[vec.push]: https://course.rs/basic/collections/vector.html#æ›´æ–°-vector
[vec.get]: https://course.rs/basic/collections/vector.html#ä»-vector-ä¸­è¯»å–å…ƒç´ 
[è¿­ä»£éå† vector ä¸­çš„å…ƒç´ ]: https://course.rs/basic/collections/vector.html#è¿­ä»£éå†-vector-ä¸­çš„å…ƒç´ 
[å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ]: https://course.rs/basic/collections/vector.html#å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ 

[back](#head)

## W

| åç§°         | å…³é”®å­—   | ç®€ä»‹                                                              |
| ------------ | -------- | ----------------------------------------------------------------- |
| [while å¾ªç¯] | å¾ªç¯æ§åˆ¶ | å½“æ¡ä»¶ä¸º `true` æ—¶ï¼Œç»§ç»­å¾ªç¯ï¼Œæ¡ä»¶ä¸º `false`ï¼Œè·³å‡ºå¾ªç¯            |
| [where çº¦æŸ] | ç‰¹å¾çº¦æŸ | å½“ç‰¹å¾çº¦æŸå˜å¤šæ—¶ï¼Œå‡½æ•°ç­¾åä¼šå¾ˆå¤æ‚ï¼Œå¯ä»¥ç”¨ `where` åšå½¢å¼ä¸Šçš„æ”¹è¿› |
|              | KWW      |                                                                   |

[while å¾ªç¯]: https://course.rs/basic/flow-control.html#while-å¾ªç¯
[where çº¦æŸ]: https://course.rs/basic/trait/trait.html#where-çº¦æŸ

[back](#head)

## X

| åç§° | å…³é”®å­— | ç®€ä»‹ |
| ---- | ------ | ---- |
|      | KWX    |      |

[back](#head)

## Y

| åç§° | å…³é”®å­— | ç®€ä»‹ |
| ---- | ------ | ---- |
|      | KWY    |      |

[back](#head)

## Z

| åç§°         | å…³é”®å­—   | ç®€ä»‹                                                                                                             |
| ------------ | -------- | ---------------------------------------------------------------------------------------------------------------- |
| [æ•´æ•°]       | æ•°å€¼ç±»å‹ | æœ‰ç¬¦å·æ•´æ•°ï¼Œ`i8`ï¼Œ`i16`ï¼Œ`i32`ï¼Œ`i64`ï¼Œ`i128`ï¼Œ`isize`<br>æ— ç¬¦å·æ•´æ•°ï¼Œ`u8`ï¼Œ`u16`ï¼Œ`u32`ï¼Œ`u64`ï¼Œ`u128`ï¼Œ`usize` |
| [æ•´å½¢å­—é¢é‡] | è¿›åˆ¶ä¹¦å†™ | åè¿›åˆ¶ `98_222`<br>åå…­è¿›åˆ¶ `0xff`<br>å…«è¿›åˆ¶ `0o77`<br>äºŒè¿›åˆ¶ `0b1111_0000`<br>å­—èŠ‚(ä»…é™äº`u8`) `b'A'`           |
|              | KWZ      |                                                                                                                  |

[æ•´æ•°]: https://course.rs/basic/base-type/numbers.html#æ•´æ•°ç±»å‹
[æ•´å½¢å­—é¢é‡]: https://course.rs/basic/base-type/numbers.html#æ•´æ•°ç±»å‹

[back](#head)

## Cargo

| åç§°  | å…³é”®å­— | ç®€ä»‹ |
| ----- | ------ | ---- |
| Cargo | KWCG   |      |

[back](#head)

<a id="bottom"></a>



================================================
FILE: src/into-rust.md
================================================
[Binary file]


================================================
FILE: src/practice.md
================================================
## è¯¾åä¹ é¢˜

[https://practice.rs](https://practice.rs)


================================================
FILE: src/rust-weekly.md
================================================
# ã€ŒRust è¯­è¨€å‘¨åˆŠã€ ç¬¬ 17 æœŸ Â· 2022-07-15
Rustè¯­è¨€å‘¨åˆŠç²¾é€‰å…¨ä¸–ç•Œè¿‡å»ä¸€å‘¨(æˆ–è€…å‡ å‘¨)çš„ä¼˜ç§€æ–‡ç« ã€æ–°é—»ã€å¼€æºé¡¹ç›®å’Œè¯­è¨€åŠ¨æ€ã€‚

æœ¬å‘¨åˆŠç”± RustCn å€¾æƒ…æ‰“é€ ï¼Œå…¶ä¸­ï¼Œ `[Zh]` æ ‡è¯†çš„ä¸­æ–‡èµ„æ–™ç”± Rust ç¿»è¯‘è®¡åˆ’æä¾›ï¼Œå¹¶ä¸”åŸå§‹çš„ Markdown æ–‡æ¡£å·²[å…¨éƒ¨å¼€æº](https://github.com/rustlang-cn/rustt)ï¼Œæ¬¢è¿å¤§å®¶é˜…è¯»å’Œè®¢é˜…ã€‚

> RustCnï¼šhttps://hirust.cn, å…¬ä¼—å·: Rustè¯­è¨€ä¸­æ–‡ç½‘

<img src="https://pica.zhimg.com/80/v2-2826dfca738cdc1795e77d12eb269906_1440w.png">
<h5 align="center">é¢˜å›¾: Tauri å‘å¸ƒ 1.0 ç‰ˆæœ¬</h5>


## å®˜æ–¹æ–°é—»

1ã€[Zh] [Rust å‘å¸ƒ 1.62 ç‰ˆæœ¬](https://course.rs/appendix/rust-versions/1.62.html)

å¦‚æœå¤§å®¶æœŸå¾… Rust åƒå…¶å®ƒè¯­è¨€ä¸€æ ·ï¼Œæ¯ä¸€ä¸ªæ–°ç‰ˆæœ¬éƒ½å¸¦æ¥å¤§é‡æ–°ç‰¹æ€§ï¼Œé‚£ä½ ä»¬å¯è¦å¤±æœ›äº†ï¼Œ1.62 çš„æ›´æ–°å†…å®¹ç›¸å½“å°‘ï¼Œç”šè‡³ä¸å¦‚æŸäº›è¯­è¨€ä¸€ä¸ª minor ç‰ˆæœ¬çš„æ›´æ–°åŠ›åº¦ï¼Œä½†**é”™ä¸åœ¨ Rust**ï¼Œå»ºè®®å¤§å®¶äº†è§£ä¸‹ Rust çš„[ç‰ˆæœ¬å‘å¸ƒæµç¨‹](https://course.rs/appendix/rust-version.html)ï¼Œå°±æ˜ç™½å…¶ä¸­çš„å¼¯å¼¯ç»•ç»•äº†ã€‚

## å¼€æºé¡¹ç›®

1ã€[åŸºäº Rust çš„æ“ä½œç³»ç»Ÿè®­ç»ƒè¥](https://github.com/LearningOS/rust-based-os-comp2022)

è¯¥è®­ç»ƒè¥æœ‰ä¸€ä¸ªé…å¥—æ•™ç¨‹ï¼Œå°†å¸¦å¤§å®¶ä»é›¶å¼€å§‹ä½¿ç”¨ Rust ç¼–å†™ RISC-V æ¶æ„çš„ ç±» Unix å†…æ ¸ ã€‚

æˆ‘è‡ªå·±ä¹Ÿåšå¼€æºï¼Œæ·±çŸ¥è¿™ä»¶äº‹ä¼šå ç”¨å¤šå°‘çš„æ—¶é—´å’Œç²¾åŠ›ï¼Œç”šè‡³è¿˜ä¼šé­äººéè®®ï¼Œè€Œæˆ‘ä»…ä»…æ˜¯å†™å†™ä¹¦ï¼Œè·Ÿä½œè€…è¿™ç§å¤§ä½¬ä¸€æ¯”ï¼Œå·®è·å°±å¤ªå¤§äº†... Respect!

2ã€[Tauri å‘å¸ƒ 1.0 ç‰ˆæœ¬](https://tauri.app/blog/tauri_1_0/)

è™½ç„¶ Tauri å¾ˆæœ‰åï¼Œä½†æ˜¯ä¸ºé˜²æœ‰åŒå­¦ä¸çŸ¥é“èƒŒæ™¯ï¼Œè¿˜æ˜¯ç®€å•ä»‹ç»ä¸‹ï¼šå®ƒæ˜¯ä¸€æ¬¾è·¨å¹³å°çš„æ¡Œé¢åº”ç”¨å¼€å‘æ¡†æ¶ï¼Œè™½ç„¶å†…æ ¸æ˜¯ä½¿ç”¨ Rust å¼€å‘ï¼Œä½†æ˜¯å¼€å‘è€…å¯ä»¥ä½¿ç”¨è‡ªå·±å–œæ¬¢çš„å‰ç«¯æ¡†æ¶( `react`, `vue`, `vite` )æ¥æ„å»ºè‡ªå·±çš„ç”¨æˆ·ç•Œé¢ï¼Œæœ€ç»ˆç¼–è¯‘ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæ–¹ä¾¿åœ¨å„ä¸ªä¸åŒçš„æ“ä½œç³»ç»Ÿé—´åˆ†å‘è¿è¡Œã€‚æ€»ä¹‹ï¼Œä½ å¯ä»¥å°† Tauri å½“ä½œæ˜¯ç†å¿µæ›´å…ˆè¿›çš„ Electron.js ã€‚

è¨€å½’æ­£ä¼ ï¼Œåœ¨å†ç» 1 å¹´å¤šçš„æ—¶é—´åï¼ŒTauri ç»ˆäºå‘å¸ƒäº† 1.0 ç‰ˆæœ¬ï¼Œè¿™ä¹Ÿæ ‡å¿—ç€å®ƒå·²ç»å¯ä»¥åœ¨ç”Ÿäº§ç¯å¢ƒæ­£å¼ä½¿ç”¨ï¼Œå¹¶ä¸”ç›®å‰æ¥çœ‹ï¼Œå®˜æ–¹æ–‡æ¡£è¿˜ç®—å¯ä»¥ï¼Œç”šè‡³è¿˜æä¾›äº†[ä¸­æ–‡æ–‡æ¡£](https://tauri.app/zh/v1/guides/getting-started/prerequisites)ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘è¿˜å‘ç°äº†ä¸€ä¸ª[å®è—æ•™å­¦ç³»åˆ—](https://zhuanlan.zhihu.com/p/539708101)ï¼Œå€¼å¾—ä¸€è¯»ã€‚

3ã€[lettre å‘å¸ƒ 0.1.0 ç‰ˆæœ¬](https://lettre.rs/post/lettre-0-10/)

`lettre` æ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„é‚®ä»¶å‘é€åº“ï¼Œå®ƒç®€å•æ˜“ç”¨ã€å®‰å…¨å¯é ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ï¼Œå®ƒçš„ç›®æ ‡**ä¸æ˜¯æ”¯æŒæ‰€æœ‰çš„é‚®ä»¶ RFC æ ‡å‡†**ï¼Œå› æ­¤åœ¨ä½ æœ‰ç‰¹æ®Šéœ€æ±‚æ—¶ï¼Œå¯èƒ½ä¼šéœ€è¦è‡ªå·±åŠ¨æ‰‹ï¼Œä¸°è¡£è¶³é£Ÿã€‚

è¯¥åº“ç›®å‰å·²è¢«å¤šä¸ªé¡¹ç›®ä½¿ç”¨ï¼ŒåŒ…æ‹¬å¤§åé¼é¼çš„ `crates.io`ã€‚ 

4ã€[workers-rs: ä½¿ç”¨ Rust + WebAssembly å®ç° Cloudflare çš„ Workers](https://github.com/cloudflare/workers-rs)

Cloudflare å·²ç»æˆä¸ºå…¨ä¸–ç•Œæœ€å¤§çš„ DNS æœåŠ¡å•†ï¼Œè€Œä¸”å®ƒçš„ä¸šåŠ¡ä¸ä»…ä»…æ˜¯ DNSï¼Œç›®å‰äº‘è®¡ç®—æ–¹é¢ä¹Ÿè¿›è¡Œçš„å¦‚ç«å¦‚è¼ã€‚CF æœ€å¤§çš„ä¼˜åŠ¿ä¸ä»…ä»…åœ¨äº DNS çš„å¿«é€Ÿå’Œç¨³å®šï¼Œè¿˜åœ¨äºå®ƒæä¾›äº†å¤šç§æ–¹å¼æ¥æ‰©å±•ä½ çš„ DNS ä½¿ç”¨ï¼Œä¾‹å¦‚ä½ å¯ä»¥ä½¿ç”¨ Rust æ¥å˜æˆå®ƒçš„ workerã€‚

ä¸ºäº†ä¾¿äºæœ‰éœ€è¦çš„åŒå­¦è¿›ä¸€æ­¥å­¦ä¹ è¯¥å¦‚ä½•ä½¿ç”¨ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ç¯‡[å®æˆ˜æ–‡ç« ](https://logankeenan.com/posts/running-a-rust-server-in-a-cloudflare-worker/)ï¼Œå€¼å¾—ä¸€çœ‹ã€‚


## ç²¾é€‰æ–‡ç« 

1ã€[è¿‡ç¨‹å®æ­ç§˜ II](https://blog.jetbrains.com/rust/2022/07/07/procedural-macros-under-the-hood-part-ii/)

æƒ³è¦äº†è§£è¿‡ç¨‹å®æ˜¯å¦‚ä½•ç¼–è¯‘ã€æ€ä¹ˆè·Ÿ IDE äº’åŠ¨çš„å—ï¼Ÿæ¥çœ‹çœ‹è¿™ä¸ªç³»åˆ—çš„æ–‡ç« ï¼Œä½œè€…æ¥è‡ª Intellij Rust æ’ä»¶å¼€å‘ç»„ï¼Œä¹‹å‰è¿˜ç»™ RustCon åˆ†äº«è¿‡ï¼Œå¹²è´§æ»¡æ»¡ã€‚

æœ¬æ–‡æ˜¯ç³»åˆ—æ–‡ç« ä¸­çš„ç¬¬äºŒç¯‡ï¼Œç¬¬ä¸€ç¯‡è§[è¿™é‡Œ](https://blog.jetbrains.com/rust/2022/03/18/procedural-macros-under-the-hood-part-i/)ã€‚


2ã€[youtube][æœ‰å­—å¹•] [AWS åœ¨æ„å»º Rust SDK æ–¹é¢çš„å®è·µ](https://www.youtube.com/watch?v=N0XMjokwTIM)

å¦‚æœæ²¡æœ‰äºšé©¬é€Šè¿™å‡ å¹´å¯¹ Rust çš„å¤§åŠ›(è‚†)æ”¯(é¼“)æŒ(å¹)ï¼ŒRust ä¹Ÿä¸ä¼šèµ°åˆ°ä»Šå¤©è¿™ä¸ªåœ°æ­¥ã€‚å‡ºäºæ•¬æ„ï¼Œæ”¾ä¸Šè¿™ä¸ªè§†é¢‘ï¼Œäº‹å®ä¸Šï¼Œé‡Œé¢æ›´å¤šçš„æ˜¯å¯¹è‡ªå·±äº§å“çš„å®£ä¼  = ï¼Œ = ç‰¹åˆ«æ˜¯ç¬¬ä¸€éƒ¨åˆ†ï¼Œå¤§å®¶å¯ä»¥è·³ç€çœ‹ï¼Œä¸€äº›å…³äºåº•å±‚çš„è®²è§£è¿˜æ˜¯å€¼å¾—ä¸€çœ‹çš„ã€‚

3ã€[Zh] [åœ¨ GCC 13 ä¸­ï¼Œå¤§å®¶å¯èƒ½å°†çœ‹åˆ° Rust çš„èº«å½±](https://www.oschina.net/news/202630/gcc-rust-approved-by-gcc-steering-committee)

ç›®å‰æ¥è¯´ï¼ŒRust çš„ç¼–è¯‘å™¨å®ç°æ˜¯åŸºäº LLVM çš„ï¼Œè€Œæˆ‘ä»¬å¯èƒ½å¾ˆå¿«å°†çœ‹åˆ°åŸºäº GCC çš„å®ç°ï¼Œä¸ LLVM ä¸åŒï¼Œæ–°çš„ç¼–è¯‘å™¨å°†èƒ½è·å¾— GCC å†…éƒ¨ä¼˜åŒ–é€šé“çš„æ‰€æœ‰è®¿é—®æƒï¼ŒåŒæ—¶å¸¦æ¥æ›´å¤šçš„ç›®æ ‡å¹³å°çš„æ”¯æŒï¼Œä»¥åŠäº«å— GCC ä¼—å¤šçš„æ’ä»¶ç”Ÿæ€ã€‚

è¯¥é¡¹ç›®å·²ç»å†æ—¶å¤šå¹´(ä» Rust 0.9 ç‰ˆæœ¬å¼€å§‹)ï¼Œæˆ‘ä¸€åº¦æ€€ç–‘å¯èƒ½æ°¸è¿œéƒ½æ— æ³•çœ‹åˆ°å®ƒçš„èº«å½±ï¼Œæ²¡æƒ³åˆ°ç°åœ¨çªç„¶å®˜å®£äº†ï¼Œä½†æ˜¯é¡¹ç›®ä¾ç„¶è¿˜å¤„äºæ—©æœŸé˜¶æ®µï¼Œå½“å‰çš„ç›®æ ‡æ˜¯åœ¨ GCC 13 ä¸­æä¾›æµ‹è¯•çº§åˆ«çš„æ”¯æŒã€‚

å†åŠ ä¸Š Rust å³å°†åœ¨ Linux 5.20 ä¸­å‡ºç°ï¼Œå¯ä»¥é¢„æ–™ï¼Œ Rust çš„æœªæ¥å°†æ›´åŠ ç¾å¥½ï¼Œå¤§å®¶ä¸€èµ·æœŸå¾…å§ï¼

4ã€[C++ å¤§æˆ˜ Rust ç³»åˆ—ï¼šå¯å˜æ€§å’Œæ‰€æœ‰æƒ](https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership)

è™½ç„¶ Rust å°†æ‰€æœ‰æƒå‘æ‰¬å…‰å¤§ï¼Œä½†æ˜¯å’±ä¸èƒ½è¯´ Rust å‘æ˜äº†æ‰€æœ‰æƒï¼Œæ¯•ç«Ÿä¼—æ‰€å‘¨çŸ¥ï¼šRust è¯­è¨€æ˜¯å€Ÿé‰´å¤§å¸ˆ :P  

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä½œè€…å°†ä»‹ç» C++ å’Œ Rust åœ¨å®ç°æ‰€æœ‰æƒã€å¯å˜æ€§æ–¹é¢çš„ä¸åŒè®¾è®¡å“²å­¦ï¼Œä»¥åŠæ ‡å‡†åº“ã€ç¼–è¯‘å™¨å±‚é¢çš„æ”¯æŒã€‚

5ã€[Rust é”™è¯¯ä»‹ç»ï¼Œæ¯”ä½ æƒ³è¦çš„æ›´å¤š](https://www.shuttle.rs/blog/2022/06/30/error-handling)

æ–‡ç« ä¸é”™ï¼Œæ ‡é¢˜ä¹Ÿä¸é”™ï¼ è™½ç„¶ä½ æƒ³è¦çš„é”™è¯¯å¤„ç†å‡ ä¹éƒ½å¯ä»¥åœ¨ `https://course.rs` ä¸Šæ‰¾åˆ°ï¼Œä½†æ˜¯è¿™ç¯‡æ–‡ç« ä¾ç„¶å€¼å¾—ä¸€çœ‹ã€‚

6ã€[Youtube][æœ‰å­—å¹•] [ä¸ºä½•ä½ çš„ Rust ç¼–è¯‘è¿™ä¹ˆæ…¢ï¼Ÿ](https://www.youtube.com/watch?v=pMiqRM5ooNw)

è§†é¢‘è´¨é‡è‡ªç„¶éå¸¸é«˜ï¼Œä»å„ä¸ªæ–¹é¢ä»‹ç»äº†è¯¥å¦‚ä½•æå‡ Rust çš„ç¼–è¯‘é€Ÿåº¦ï¼Œå¹²è´§æ»¡æ»¡ï¼Œå¼ºçƒˆæ¨èã€‚

ä½†...æˆ‘çš„å¤©ï¼Œæˆ‘çœŸçš„ä½©æœä½œè€…ï¼Œå°±ä»¥ Rust å‘¨åˆŠä¸¾ä¾‹å§ï¼Œæ¯æ¬¡å‘¨åˆŠåŸºæœ¬éƒ½è¦èŠ±è´¹æˆ‘å‡ ä¸ªå°æ—¶ï¼Œé‚£ä¸€ä¸ªå°†è¿‘ 3 ä¸ªå°æ—¶çš„å¹²è´§è§†é¢‘ï¼Œè¦å‡†å¤‡å¤šä¹…ï¼Ÿç®€ç›´æ˜¯å·ç‹åœ¨ä¸– :)

ç”šè‡³æœ‰äººè¯„è®ºåˆ°ï¼šè¿™ä¸ªæ˜¯ä¸€ä¸ª AMSR è§†é¢‘...


7ã€[Rustä¸­çš„å†å€Ÿç”¨](https://haibane-tenshi.github.io/rust-reborrowing/)

å¤§å®¶éƒ½çŸ¥é“ Rust ä¸­çš„ç”Ÿå‘½å‘¨æœŸå¾ˆéš¾ï¼Œé‚£ä½ ä»¬è°ˆè°ˆå¯¹å€Ÿç”¨çš„å°è±¡ï¼Œéš¾å—ï¼Ÿæˆ‘çŒœï¼Œå¤§å¤šæ•°äººä¼šè¯´ä¸éš¾ã€‚å…¶å®ä¸ç„¶ï¼ŒRust ä¸­çš„å€Ÿç”¨å¹¶ä¸ä»…ä»…æ˜¯ä¹¦ä¸Šä»‹ç»çš„é‚£äº›ï¼Œä¾‹å¦‚**å†å€Ÿç”¨(reborrowing)**ï¼Œä½ å¬è¯´è¿‡å—ï¼Ÿ

8ã€[æˆ‘å¾ˆå¼ºï¼Œä½† Rust æ›´å¼º](https://blog.polybdenum.com/2022/06/25/an-unfortunate-experience-with-rust.html)

ä½œè€…è¯´ä»–å¯¹äº Rust æå…¶æœ‰ç»éªŒï¼Œä½†æ˜¯å°±ç®—è¿™æ ·çš„é«˜æ‰‹ï¼Œä¾ç„¶é¿å…ä¸äº†è¢« Rust æ‰€æ•™è‚²ï¼Œä½ é—®æ€ä¹ˆä¸ªæ•™è‚²æ³•ï¼Ÿå½“ç„¶æ˜¯è·Ÿç¼–è¯‘å™¨ææ–—å’¯ã€‚

å…¶å®ï¼Œä»æˆ‘ä¸ªäººè€Œè¨€ï¼Œéå¸¸æ¨èå¤§å®¶çœ‹çœ‹è¿™ç±»æ–‡ç« ï¼Œé‚£äº›å…³äº Rust å¦‚ä½•æˆåŠŸçš„è¥é”€æ–‡ï¼Œçˆ½åˆ™çˆ½çŸ£ï¼Œå¯¹äºæŠ€æœ¯å´æ— å¤šå¤§å¸®åŠ©ã€‚è€Œè¿™ç§é”™è¯¯å®è·µç±»çš„æ–‡ç« ï¼Œå´èƒ½å¸®åŠ©æˆ‘ä»¬å°‘èµ°å¾ˆå¤šå¼¯è·¯ï¼



================================================
FILE: src/rustt.md
================================================
# Rustt ç¿»è¯‘è®¡åˆ’

ğŸ¥‡Rustt ç¿»è¯‘è®¡åˆ’ï¼Œè¿™é‡Œæœ‰å›½å†…æœ€ä¼˜è´¨ã€æœ€å®æ—¶çš„ Rust æŠ€æœ¯æ–‡ç« ã€å­¦ä¹ èµ„æ–™å’Œæ–°é—»èµ„è®¯ï¼Œæ¬¢è¿å¤§å®¶[å‰å¾€é˜…è¯»å’Œè®¢é˜…](https://github.com/studyrs/Rustt)ã€‚

## æœ€è¿‘ä¼˜ç§€ä½œå“å±•

| ä¸­æ–‡å |   ç¿»è¯‘æ—¶é—´ | ä½œè€… |
| ------- | -------- | ----- |
| [series][Rust å…­è¾¹å½¢æ¶æ„](https://github.com/studyrs/Rustt/tree/main/Articles/%5B2022-04-03%5D%20Rust%20å…­è¾¹å½¢æ¶æ„) | 2022-04-04 | [trdthg](https://github.com/trdthg) |
| [ç”¨ Rust å†™ Devops å·¥å…·](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-02%5D%20ç”¨%20Rust%20å†™%20DevOps%20å·¥å…·.md) | 2022-04-03 | [Xiaobin.Liu](https://github.com/lxbwolf) |
| [Rust å¤§ä½¬ç»™åˆå­¦è€…çš„å­¦ä¹ å»ºè®®](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-02%5D%20Rust%20å¤§ä½¬ç»™åˆå­¦è€…çš„å­¦ä¹ å»ºè®®.md) | 2022-04-02 | [Asura](https://github.com/asur4s) |
| [Rust èƒŒåå¹¶ä¸æ˜¯å…¬å¸](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-01%5D%20Rust%20èƒŒåå¹¶ä¸æ˜¯å…¬å¸.md) | 2022-04-01 | [å­æ®Š](https://github.com/allenli178) |
| [åœ¨ Rust ä¸­ä½¿ç”¨ epoll å®ç°éé˜»å¡ IO](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-03-29%5D%20åœ¨%20Rust%20ä¸­ä½¿ç”¨%20epoll%20å®ç°åŸºæœ¬çš„éé˜»å¡%20IO.md) | 2022-03-29 | [BK0717](https://github.com/hyuuko) | 



================================================
FILE: src/rusty-book.md
================================================
<h1 align="center">Rusty Book( é”ˆä¹¦ )</h1>

<div align="center">
    <img width="100%" src="https://github.com/studyrs/rusty-book/blob/main/assets/banner.gif?raw=true" />
</div>
   
<div align="center">

</div>

åœ¨ Rust å…ƒå®‡å®™ï¼Œæœ€ä¼˜ç§€çš„é¡¹ç›®å¯ä»¥ç§°ä¹‹ä¸º `rusty`ï¼Œç”¨å’±ä¸­å›½è¯æ¥è¯´ï¼Œå°±æ˜¯å¤Ÿé”ˆ( ç§€ )ã€‚

å¦‚æœä½ æœ‰ä»¥ä¸‹éœ€æ±‚ï¼Œå¯ä»¥æ¥çœ‹çœ‹é”ˆä¹¦ï¼Œå®ƒç»å¯¹ä¸ä¼šè®©ä½ å¤±æœ›ï¼š

- æƒ³è¦çŸ¥é“ç°åœ¨ä¼˜ç§€çš„ã€å…³æ³¨åº¦é«˜çš„ Rust é¡¹ç›®æœ‰å“ªäº›

- å‘ç°ä¸€äº›å¥½ç©ã€æœ‰è¶£ã€é…·ç‚«çš„å¼€æºåº“

- éœ€è¦å¯»æ‰¾æŸä¸ªç±»å‹çš„åº“ï¼Œä¾‹å¦‚ï¼Œä¸€ä¸ª HTTP å®¢æˆ·ç«¯æˆ– ProtoBuffer ç¼–ç åº“ï¼Œè¦æ±‚æ˜¯å¥½ç”¨ã€æ›´æ–°æ´»è·ƒã€é«˜è´¨é‡

- æƒ³è¦å¯»æ‰¾å¸¸ç”¨æ“ä½œçš„ä»£ç ç‰‡æ®µï¼Œç”¨äºç†Ÿæ‚‰ Rust æˆ–è€…ç›´æ¥å¤åˆ¶ç²˜è´´åˆ°è‡ªå·±çš„é¡¹ç›®ä¸­ï¼Œä¾‹å¦‚æ–‡ä»¶æ“ä½œã€æ•°æ®åº“æ“ä½œã€HTTP è¯·æ±‚ã€æ’åºç®—æ³•ã€æ­£åˆ™ç­‰

åœ¨çº¿é˜…è¯»é”ˆä¹¦:[Githubåœ°å€](https://github.com/rustlang-cn/rusty-book)



================================================
FILE: src/some-thoughts.md
================================================
[Binary file]


================================================
FILE: src/SUMMARY.md
================================================
[Binary file]


================================================
FILE: src/advance/errors.md
================================================
[Binary file]


================================================
FILE: src/advance/global-variable.md
================================================
# å…¨å±€å˜é‡

åœ¨ä¸€äº›åœºæ™¯ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦å…¨å±€å˜é‡æ¥ç®€åŒ–çŠ¶æ€å…±äº«çš„ä»£ç ï¼ŒåŒ…æ‹¬å…¨å±€ IDï¼Œå…¨å±€æ•°æ®å­˜å‚¨ç­‰ç­‰ï¼Œä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹æœ‰å“ªäº›åˆ›å»ºå…¨å±€å˜é‡çš„æ–¹æ³•ã€‚

é¦–å…ˆï¼Œæœ‰ä¸€ç‚¹å¯ä»¥è‚¯å®šï¼Œå…¨å±€å˜é‡çš„ç”Ÿå‘½å‘¨æœŸè‚¯å®šæ˜¯`'static`ï¼Œä½†æ˜¯ä¸ä»£è¡¨å®ƒéœ€è¦ç”¨`static`æ¥å£°æ˜ï¼Œä¾‹å¦‚å¸¸é‡ã€å­—ç¬¦ä¸²å­—é¢å€¼ç­‰æ— éœ€ä½¿ç”¨`static`è¿›è¡Œå£°æ˜ï¼ŒåŸå› æ˜¯å®ƒä»¬å·²ç»è¢«æ‰“åŒ…åˆ°äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚

ä¸‹é¢æˆ‘ä»¬ä»ç¼–è¯‘æœŸåˆå§‹åŒ–åŠè¿è¡ŒæœŸåˆå§‹åŒ–ä¸¤ä¸ªç±»åˆ«æ¥ä»‹ç»ä¸‹å…¨å±€å˜é‡æœ‰å“ªäº›ç±»å‹åŠè¯¥å¦‚ä½•ä½¿ç”¨ã€‚

## ç¼–è¯‘æœŸåˆå§‹åŒ–

æˆ‘ä»¬å¤§å¤šæ•°ä½¿ç”¨çš„å…¨å±€å˜é‡éƒ½åªéœ€è¦åœ¨ç¼–è¯‘æœŸåˆå§‹åŒ–å³å¯ï¼Œä¾‹å¦‚é™æ€é…ç½®ã€è®¡æ•°å™¨ã€çŠ¶æ€å€¼ç­‰ç­‰ã€‚

#### é™æ€å¸¸é‡

å…¨å±€å¸¸é‡å¯ä»¥åœ¨ç¨‹åºä»»ä½•ä¸€éƒ¨åˆ†ä½¿ç”¨ï¼Œå½“ç„¶ï¼Œå¦‚æœå®ƒæ˜¯å®šä¹‰åœ¨æŸä¸ªæ¨¡å—ä¸­ï¼Œä½ éœ€è¦å¼•å…¥å¯¹åº”çš„æ¨¡å—æ‰èƒ½ä½¿ç”¨ã€‚å¸¸é‡ï¼Œé¡¾åæ€ä¹‰å®ƒæ˜¯ä¸å¯å˜çš„ï¼Œå¾ˆé€‚åˆç”¨ä½œé™æ€é…ç½®ï¼š

```rust
const MAX_ID: usize =  usize::MAX / 2;
fn main() {
   println!("ç”¨æˆ·IDå…è®¸çš„æœ€å¤§å€¼æ˜¯{}",MAX_ID);
}
```

**å¸¸é‡ä¸æ™®é€šå˜é‡çš„åŒºåˆ«**

- å…³é”®å­—æ˜¯`const`è€Œä¸æ˜¯`let`
- å®šä¹‰å¸¸é‡å¿…é¡»æŒ‡æ˜ç±»å‹ï¼ˆå¦‚ i32ï¼‰ä¸èƒ½çœç•¥
- å®šä¹‰å¸¸é‡æ—¶å˜é‡çš„å‘½åè§„åˆ™ä¸€èˆ¬æ˜¯å…¨éƒ¨å¤§å†™
- å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸè¿›è¡Œå®šä¹‰ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸè´¯ç©¿æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šå°½å¯èƒ½å°†å…¶å†…è”åˆ°ä»£ç ä¸­ï¼Œæ‰€ä»¥åœ¨ä¸åŒåœ°æ–¹å¯¹åŒä¸€å¸¸é‡çš„å¼•ç”¨å¹¶ä¸èƒ½ä¿è¯å¼•ç”¨åˆ°ç›¸åŒçš„å†…å­˜åœ°å€
- å¸¸é‡çš„èµ‹å€¼åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼/æ•°å­¦è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯è¯´å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æœŸå°±èƒ½è®¡ç®—å‡ºçš„å€¼ï¼Œå¦‚æœéœ€è¦åœ¨è¿è¡Œæ—¶æ‰èƒ½å¾—å‡ºç»“æœçš„å€¼æ¯”å¦‚å‡½æ•°ï¼Œåˆ™ä¸èƒ½èµ‹å€¼ç»™å¸¸é‡è¡¨è¾¾å¼
- å¯¹äºå˜é‡å‡ºç°é‡å¤çš„å®šä¹‰(ç»‘å®š)ä¼šå‘ç”Ÿå˜é‡é®ç›–ï¼Œåé¢å®šä¹‰çš„å˜é‡ä¼šé®ä½å‰é¢å®šä¹‰çš„å˜é‡ï¼Œå¸¸é‡åˆ™ä¸å…è®¸å‡ºç°é‡å¤çš„å®šä¹‰

#### é™æ€å˜é‡

é™æ€å˜é‡å…è®¸å£°æ˜ä¸€ä¸ªå…¨å±€çš„å˜é‡ï¼Œå¸¸ç”¨äºå…¨å±€æ•°æ®ç»Ÿè®¡ï¼Œä¾‹å¦‚æˆ‘ä»¬å¸Œæœ›ç”¨ä¸€ä¸ªå˜é‡æ¥ç»Ÿè®¡ç¨‹åºå½“å‰çš„æ€»è¯·æ±‚æ•°ï¼š

```rust
static mut REQUEST_RECV: usize = 0;
fn main() {
   unsafe {
        REQUEST_RECV += 1;
        assert_eq!(REQUEST_RECV, 1);
   }
}
```

Rust è¦æ±‚å¿…é¡»ä½¿ç”¨`unsafe`è¯­å¥å—æ‰èƒ½è®¿é—®å’Œä¿®æ”¹`static`å˜é‡ï¼Œå› ä¸ºè¿™ç§ä½¿ç”¨æ–¹å¼å¾€å¾€å¹¶ä¸å®‰å…¨ï¼Œå…¶å®ç¼–è¯‘å™¨æ˜¯å¯¹çš„ï¼Œå½“åœ¨å¤šçº¿ç¨‹ä¸­åŒæ—¶å»ä¿®æ”¹æ—¶ï¼Œä¼šä¸å¯é¿å…çš„é‡åˆ°è„æ•°æ®ã€‚

åªæœ‰åœ¨åŒä¸€çº¿ç¨‹å†…æˆ–è€…ä¸åœ¨ä¹æ•°æ®çš„å‡†ç¡®æ€§æ—¶ï¼Œæ‰åº”è¯¥ä½¿ç”¨å…¨å±€é™æ€å˜é‡ã€‚

å’Œå¸¸é‡ç›¸åŒï¼Œå®šä¹‰é™æ€å˜é‡çš„æ—¶å€™å¿…é¡»èµ‹å€¼ä¸ºåœ¨ç¼–è¯‘æœŸå°±å¯ä»¥è®¡ç®—å‡ºçš„å€¼(å¸¸é‡è¡¨è¾¾å¼/æ•°å­¦è¡¨è¾¾å¼)ï¼Œä¸èƒ½æ˜¯è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å‡ºçš„å€¼(å¦‚å‡½æ•°)

**é™æ€å˜é‡å’Œå¸¸é‡çš„åŒºåˆ«**

- é™æ€å˜é‡ä¸ä¼šè¢«å†…è”ï¼Œåœ¨æ•´ä¸ªç¨‹åºä¸­ï¼Œé™æ€å˜é‡åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œæ‰€æœ‰çš„å¼•ç”¨éƒ½ä¼šæŒ‡å‘åŒä¸€ä¸ªåœ°å€
- å­˜å‚¨åœ¨é™æ€å˜é‡ä¸­çš„å€¼å¿…é¡»è¦å®ç° Sync trait

#### åŸå­ç±»å‹

æƒ³è¦å…¨å±€è®¡æ•°å™¨ã€çŠ¶æ€æ§åˆ¶ç­‰åŠŸèƒ½ï¼Œåˆæƒ³è¦çº¿ç¨‹å®‰å…¨çš„å®ç°ï¼ŒåŸå­ç±»å‹æ˜¯éå¸¸å¥½çš„åŠæ³•ã€‚

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);
fn main() {
    for _ in 0..100 {
        REQUEST_RECV.fetch_add(1, Ordering::Relaxed);
    }

    println!("å½“å‰ç”¨æˆ·è¯·æ±‚æ•°{:?}",REQUEST_RECV);
}
```

å…³äºåŸå­ç±»å‹çš„è®²è§£çœ‹[è¿™ç¯‡æ–‡ç« ](https://course.rs/advance/concurrency-with-threads/sync2.html)

#### ç¤ºä¾‹ï¼šå…¨å±€ ID ç”Ÿæˆå™¨

æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ä¸Šé¢çš„å†…å®¹å®ç°ä¸€ä¸ªå…¨å±€ ID ç”Ÿæˆå™¨:

```rust
use std::sync::atomic::{Ordering, AtomicUsize};

struct Factory{
    factory_id: usize,
}

static GLOBAL_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
const MAX_ID: usize = usize::MAX / 2;

fn generate_id()->usize{
    // æ£€æŸ¥ä¸¤æ¬¡æº¢å‡ºï¼Œå¦åˆ™ç›´æ¥åŠ ä¸€å¯èƒ½å¯¼è‡´æº¢å‡º
    let current_val = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if current_val > MAX_ID{
        panic!("Factory ids overflowed");
    }
    GLOBAL_ID_COUNTER.fetch_add(1, Ordering::Relaxed);
    let next_id = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if next_id > MAX_ID{
        panic!("Factory ids overflowed");
    }
    next_id
}

impl Factory{
    fn new()->Self{
        Self{
            factory_id: generate_id()
        }
    }
}
```

## è¿è¡ŒæœŸåˆå§‹åŒ–

ä»¥ä¸Šçš„é™æ€åˆå§‹åŒ–æœ‰ä¸€ä¸ªè‡´å‘½çš„é—®é¢˜ï¼šæ— æ³•ç”¨å‡½æ•°è¿›è¡Œé™æ€åˆå§‹åŒ–ï¼Œä¾‹å¦‚ä½ å¦‚æœæƒ³å£°æ˜ä¸€ä¸ªå…¨å±€çš„`Mutex`é”ï¼š

```rust
use std::sync::Mutex;
static NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));

fn main() {
    let v = NAMES.lock().unwrap();
    println!("{}",v);
}
```

è¿è¡ŒåæŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --> src/main.rs:3:42
  |
3 | static NAMES: Mutex<String> = Mutex::new(String::from("sunface"));
```

ä½†ä½ åˆå¿…é¡»åœ¨å£°æ˜æ—¶å°±å¯¹`NAMES`è¿›è¡Œåˆå§‹åŒ–ï¼Œæ­¤æ—¶å°±é™·å…¥äº†ä¸¤éš¾çš„å¢ƒåœ°ã€‚å¥½åœ¨å¤©æ— ç»äººä¹‹è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`lazy_static`åŒ…æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

#### lazy_static

[`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs)æ˜¯ç¤¾åŒºæä¾›çš„éå¸¸å¼ºå¤§çš„å®ï¼Œç”¨äºæ‡’åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¹‹å‰çš„é™æ€å˜é‡éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸåˆå§‹åŒ–çš„ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨å‡½æ•°è°ƒç”¨è¿›è¡Œèµ‹å€¼ï¼Œè€Œ`lazy_static`å…è®¸æˆ‘ä»¬åœ¨è¿è¡ŒæœŸåˆå§‹åŒ–é™æ€å˜é‡ï¼

```rust
use std::sync::Mutex;
use lazy_static::lazy_static;
lazy_static! {
    static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
}

fn main() {
    let mut v = NAMES.lock().unwrap();
    v.push_str(", Myth");
    println!("{}",v);
}
```

å½“ç„¶ï¼Œä½¿ç”¨`lazy_static`åœ¨æ¯æ¬¡è®¿é—®é™æ€å˜é‡æ—¶ï¼Œä¼šæœ‰è½»å¾®çš„æ€§èƒ½æŸå¤±ï¼Œå› ä¸ºå…¶å†…éƒ¨å®ç°ç”¨äº†ä¸€ä¸ªåº•å±‚çš„å¹¶å‘åŸè¯­`std::sync::Once`ï¼Œåœ¨æ¯æ¬¡è®¿é—®è¯¥å˜é‡æ—¶ï¼Œç¨‹åºéƒ½ä¼šæ‰§è¡Œä¸€æ¬¡åŸå­æŒ‡ä»¤ç”¨äºç¡®è®¤é™æ€å˜é‡çš„åˆå§‹åŒ–æ˜¯å¦å®Œæˆã€‚

`lazy_static`å®ï¼ŒåŒ¹é…çš„æ˜¯`static ref`ï¼Œæ‰€ä»¥å®šä¹‰çš„é™æ€å˜é‡éƒ½æ˜¯ä¸å¯å˜å¼•ç”¨

å¯èƒ½æœ‰è¯»è€…ä¼šé—®ï¼Œä¸ºä½•éœ€è¦åœ¨è¿è¡ŒæœŸåˆå§‹åŒ–ä¸€ä¸ªé™æ€å˜é‡ï¼Œé™¤äº†ä¸Šé¢çš„å…¨å±€é”ï¼Œä½ ä¼šé‡åˆ°æœ€å¸¸è§çš„åœºæ™¯å°±æ˜¯ï¼š**ä¸€ä¸ªå…¨å±€çš„åŠ¨æ€é…ç½®ï¼Œå®ƒåœ¨ç¨‹åºå¼€å§‹åï¼Œæ‰åŠ è½½æ•°æ®è¿›è¡Œåˆå§‹åŒ–ï¼Œæœ€ç»ˆå¯ä»¥è®©å„ä¸ªçº¿ç¨‹ç›´æ¥è®¿é—®ä½¿ç”¨**

å†æ¥çœ‹ä¸€ä¸ªä½¿ç”¨`lazy_static`å®ç°å…¨å±€ç¼“å­˜çš„ä¾‹å­:

```rust
use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap<u32, &'static str> = {
        let mut m = HashMap::new();
        m.insert(0, "foo");
        m.insert(1, "bar");
        m.insert(2, "baz");
        m
    };
}

fn main() {
    // é¦–æ¬¡è®¿é—®`HASHMAP`çš„åŒæ—¶å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–
    println!("The entry for `0` is \"{}\".", HASHMAP.get(&0).unwrap());

    // åç»­çš„è®¿é—®ä»…ä»…è·å–å€¼ï¼Œå†ä¸ä¼šè¿›è¡Œä»»ä½•åˆå§‹åŒ–æ“ä½œ
    println!("The entry for `1` is \"{}\".", HASHMAP.get(&1).unwrap());
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`lazy_static`ç›´åˆ°è¿è¡Œåˆ°`main`ä¸­çš„ç¬¬ä¸€è¡Œä»£ç æ—¶ï¼Œæ‰è¿›è¡Œåˆå§‹åŒ–ï¼Œéå¸¸`lazy static`ã€‚

#### Box::leak

åœ¨`Box`æ™ºèƒ½æŒ‡é’ˆç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬æåˆ°äº†`Box::leak`å¯ä»¥ç”¨äºå…¨å±€å˜é‡ï¼Œä¾‹å¦‚ç”¨ä½œè¿è¡ŒæœŸåˆå§‹åŒ–çš„å…¨å±€åŠ¨æ€é…ç½®ï¼Œå…ˆæ¥çœ‹çœ‹å¦‚æœä¸ä½¿ç”¨`lazy_static`ä¹Ÿä¸ä½¿ç”¨`Box::leak`ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼š

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    unsafe {
        CONFIG = Some(&mut Config {
            a: "A".to_string(),
            b: "B".to_string(),
        });

        println!("{:?}", CONFIG)
    }
}
```

ä»¥ä¸Šä»£ç æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªå…¨å±€åŠ¨æ€é…ç½®`CONFIG`ï¼Œå¹¶ä¸”å…¶å€¼åˆå§‹åŒ–ä¸º`None`ï¼Œç„¶ååœ¨ç¨‹åºå¼€å§‹è¿è¡Œåï¼Œç»™å®ƒèµ‹äºˆç›¸åº”çš„å€¼ï¼Œè¿è¡ŒåæŠ¥é”™:

```console
error[E0716]: temporary value dropped while borrowed
  --> src/main.rs:10:28
   |
10 |            CONFIG = Some(&mut Config {
   |   _________-__________________^
   |  |_________|
   | ||
11 | ||             a: "A".to_string(),
12 | ||             b: "B".to_string(),
13 | ||         });
   | ||         ^-- temporary value is freed at the end of this statement
   | ||_________||
   |  |_________|assignment requires that borrow lasts for `'static`
   |            creates a temporary which is freed while still in use
```

å¯ä»¥çœ‹åˆ°ï¼ŒRust çš„å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸè§„åˆ™é™åˆ¶äº†æˆ‘ä»¬åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºè¯•å›¾å°†ä¸€ä¸ªå±€éƒ¨ç”Ÿå‘½å‘¨æœŸçš„å˜é‡èµ‹å€¼ç»™å…¨å±€ç”Ÿå‘½å‘¨æœŸçš„`CONFIG`ï¼Œè¿™æ˜æ˜¾æ˜¯ä¸å®‰å…¨çš„ã€‚

å¥½åœ¨`Rust`ä¸ºæˆ‘ä»¬æä¾›äº†`Box::leak`æ–¹æ³•ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªå˜é‡ä»å†…å­˜ä¸­æ³„æ¼(å¬ä¸Šå»æ€ªæ€ªçš„ï¼Œç«Ÿç„¶åšä¸»åŠ¨å†…å­˜æ³„æ¼)ï¼Œç„¶åå°†å…¶å˜ä¸º`'static`ç”Ÿå‘½å‘¨æœŸï¼Œæœ€ç»ˆè¯¥å˜é‡å°†å’Œç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤å¯ä»¥èµ‹å€¼ç»™å…¨å±€é™æ€å˜é‡`CONFIG`ã€‚

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        // å°†`c`ä»å†…å­˜ä¸­æ³„æ¼ï¼Œå˜æˆ`'static`ç”Ÿå‘½å‘¨æœŸ
        CONFIG = Some(Box::leak(c));
        println!("{:?}", CONFIG);
    }
}
```

#### ä»å‡½æ•°ä¸­è¿”å›å…¨å±€å˜é‡

é—®é¢˜åˆæ¥äº†ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦åœ¨è¿è¡ŒæœŸï¼Œä»ä¸€ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ªå…¨å±€å˜é‡è¯¥å¦‚ä½•åšï¼Ÿä¾‹å¦‚ï¼š

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    Some(&mut Config {
        a: "A".to_string(),
        b: "B".to_string(),
    })
}


fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```

æŠ¥é”™è¿™é‡Œå°±ä¸å±•ç¤ºäº†ï¼Œè·Ÿä¹‹å‰å¤§åŒå°å¼‚ï¼Œè¿˜æ˜¯ç”Ÿå‘½å‘¨æœŸå¼•èµ·çš„ï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•è§£å†³å‘¢ï¼Ÿä¾ç„¶å¯ä»¥ç”¨`Box::leak`:

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    Some(Box::leak(c))
}


fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```

## æ ‡å‡†åº“ä¸­çš„ Once å’Œ Lazy

åœ¨ Rust 1.70.0 ç‰ˆæœ¬ä¹‹å‰ï¼Œæ ‡å‡†åº“é€šè¿‡å®éªŒæ€§ API æä¾› `lazy::OnceCell` å’Œ `lazy::SyncOnceCell` æ¥å®ç°å•æ¬¡åˆå§‹åŒ–å®¹å™¨ï¼Œè¿™æ—¶ï¼Œæ‡’åˆå§‹åŒ–ä¸»è¦ä¾é  `lazy_static` ã€‚
éšç€ `cell::OnceCell` å’Œ `sync::OnceLock` åœ¨ 1.70.0 ä¸­ç¨³å®šå’Œ `LazyCell` å’Œ `LazyLock` åœ¨ 1.80.0 ä¸­ç¨³å®šï¼Œåªä½¿ç”¨æ ‡å‡†åº“å®ç°æ‡’åŠ è½½æˆä¸ºå¯èƒ½ã€‚

è¿™4ä¸ªå®¹å™¨å¯ä»¥è¿™æ ·åŒºåˆ†ï¼š

|      | å•çº¿ç¨‹   | å¤šçº¿ç¨‹   |
|------|----------|----------|
| Once | OnceCell | OnceLock |
| Lazy | LazyCell | LazyLock |

å…¶ä¸­ï¼Œ`Lazy` ä¼šè‡ªåŠ¨æŒ‰éœ€åŠ è½½å†…å®¹ï¼Œè®©ä»£ç æ›´ç®€æ´ï¼Œæ›´äººæ€§åŒ–ï¼Œè€Œ `Once` åˆ™å¯ä»¥æ‰‹åŠ¨æŒ‡å®šåˆå§‹åŒ–çš„æ—¶æœºæˆ–ä½¿ç”¨ä¸åŒçš„æ–¹æ³•åˆå§‹åŒ–ï¼Œæ›´å¼ºå¤§ã€‚
`Cell` çš„å®ç°æ›´ç®€å•ï¼Œæ•ˆç‡ä¹Ÿæ›´é«˜ï¼Œä½†æ˜¯ä»–å¹¶ä¸ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œè€Œ `Lock` é€šè¿‡å†…éƒ¨åŒæ­¥æœºåˆ¶å®ç°äº†çº¿ç¨‹å®‰å…¨ã€‚

#### Once ä½¿ç”¨æ–¹æ³•

ä¸‹é¢ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ `Once` çš„ä½¿ç”¨æ–¹æ³•ï¼š

```rust
use std::{sync::OnceLock, thread};

fn main() {
    // å­çº¿ç¨‹ä¸­è°ƒç”¨
    let handle = thread::spawn(|| {
        let logger = Logger::global();
        logger.log("thread message".to_string());
    });

    // ä¸»çº¿ç¨‹è°ƒç”¨
    let logger = Logger::global();
    logger.log("some message".to_string());

    let logger2 = Logger::global();
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

static LOGGER: OnceLock<Logger> = OnceLock::new();

impl Logger {
    fn global() -> &'static Logger {
        // è·å–æˆ–åˆå§‹åŒ– Logger
        LOGGER.get_or_init(|| {
            println!("Logger is being created..."); // åˆå§‹åŒ–æ‰“å°
            Logger
        })
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

ä»¥ä¸Šä»£ç æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ª `global()` å…³è”å‡½æ•°ï¼Œå¹¶åœ¨å…¶å†…éƒ¨è°ƒç”¨ `get_or_init` è¿›è¡Œåˆå§‹åŒ– `Logger`ï¼Œä¹‹ååœ¨ä¸åŒçº¿ç¨‹ä¸Šå¤šæ¬¡è°ƒç”¨ `Logger::global()` è·å–å…¶å®ä¾‹ã€‚
ç”±äºéœ€è¦åœ¨å¤šä¸ªçº¿ç¨‹ä¸­ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨äº† `OnceLock`ã€‚ä»¥ä¸‹æ˜¯è¾“å‡ºï¼š

```console
Logger is being created...
some message
other message
thread message
```

å¯ä»¥çœ‹åˆ°ï¼Œ`Logger is being created...` åœ¨å¤šä¸ªçº¿ç¨‹ä¸­ä½¿ç”¨ä¹Ÿåªè¢«æ‰“å°äº†ä¸€æ¬¡ã€‚

#### Lazy ä½¿ç”¨æ–¹æ³•

ä¸Šè¿°ä¾‹å­å¦‚æœä½¿ç”¨ `LazyLock` æ¥å®ç°ï¼Œåˆ™å¯ä»¥å˜å¾—æ›´åŠ ç®€æ´ï¼š

```rust
use std::{sync::LazyLock, thread};

fn main() {
    // å­çº¿ç¨‹ä¸­è°ƒç”¨
    let handle = thread::spawn(|| {
        let logger = &LOGGER;
        logger.log("thread message".to_string());
    });

    // ä¸»çº¿ç¨‹è°ƒç”¨
    let logger = &LOGGER;
    logger.log("some message".to_string());

    let logger2 = &LOGGER;
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

static LOGGER: LazyLock<Logger> = LazyLock::new(Logger::new);

impl Logger {
    fn new() -> Logger {
        println!("Logger is being created...");
        Logger
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `LazyLock::new` æ–¹æ³•ç›´æ¥å¯¹å…¨å±€å˜é‡ `LOGGER` è¿›è¡Œèµ‹å€¼ï¼Œå¹¶ä¼ å…¥ä¸€ä¸ªåˆå§‹åŒ–å‡½æ•°ã€‚
ä½¿ç”¨çš„æ—¶å€™ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨å¯¹å…¨å±€å˜é‡çš„å¼•ç”¨ã€‚åœ¨è·å–å¼•ç”¨çš„æ—¶å€™ï¼Œ `LazyLock` ä¼šè‡ªåŠ¨æ£€æŸ¥åˆå§‹åŒ–çš„çŠ¶æ€å¹¶è¿›è¡Œåˆå§‹åŒ–ã€‚

## æ€»ç»“

åœ¨ Rust ä¸­æœ‰å¾ˆå¤šæ–¹å¼å¯ä»¥åˆ›å»ºä¸€ä¸ªå…¨å±€å˜é‡ï¼Œæœ¬ç« ä¹Ÿåªæ˜¯ä»‹ç»äº†å…¶ä¸­ä¸€éƒ¨åˆ†ï¼Œæ›´å¤šçš„è¿˜ç­‰å¾…å¤§å®¶è‡ªå·±å»æŒ–æ˜å­¦ä¹ (å½“ç„¶ï¼Œæœªæ¥å¯èƒ½æœ¬ç« èŠ‚ä¼šä¸æ–­å®Œå–„ï¼Œæœ€åå˜æˆä¸€ä¸ªå·¨æ— éœ¸- , -)ã€‚

ç®€å•æ¥è¯´ï¼Œå…¨å±€å˜é‡å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼š

- ç¼–è¯‘æœŸåˆå§‹åŒ–çš„å…¨å±€å˜é‡ï¼Œ`const`åˆ›å»ºå¸¸é‡ï¼Œ`static`åˆ›å»ºé™æ€å˜é‡ï¼Œ`Atomic`åˆ›å»ºåŸå­ç±»å‹
- è¿è¡ŒæœŸåˆå§‹åŒ–çš„å…¨å±€å˜é‡ï¼Œ`lazy_static`ç”¨äºæ‡’åˆå§‹åŒ–ï¼Œ`Box::leak`åˆ©ç”¨å†…å­˜æ³„æ¼å°†ä¸€ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸå˜ä¸º`'static`



================================================
FILE: src/advance/hrtb.md
================================================
# é«˜é˜¶ç‰¹å¾çº¦æŸ(HRTB) todo


https://www.reddit.com/r/rust/comments/s6g16d/help_with_hrtb_lifetimes/

## for<'a>

https://www.reddit.com/r/rust/comments/rq43c6/generic_fn_impl_for_iterating_over_mut_items_twice/

https://www.reddit.com/r/rust/comments/6uobit/fora_lifetime_syntax/







================================================
FILE: src/advance/intro.md
================================================
# Rust é«˜çº§è¿›é˜¶

æ­å–œä½ ï¼Œå­¦ä¼š Rust åŸºç¡€åï¼Œé‡‘ä¸¹å¤§é“å·²åœ¨å‘ä½ æ‹›æ‰‹ï¼Œå¤§éƒ¨åˆ† Rust ä»£ç å¯¹ä½ æ¥è¯´éƒ½æ˜¯å®¶å¸¸ä¾¿é¥­ï¼Œç®€å•å¾—å¾ˆã€‚å¯æ˜¯ï¼Œå¯¹äºä¸€é—¨éš¾åº¦ä¼ è¨€åœ¨å¤–çš„è¯­è¨€ï¼Œæ€ä¹ˆå¯èƒ½å¦‚æ­¤ç®€å•çš„å°±è¢«å¾æœï¼Œæœ€éš¾çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’±è¿˜æ²¡è§è¿‡é•¿å•¥æ ·å‘¢ã€‚

ä»æœ¬ç« å¼€å§‹ï¼Œæˆ‘ä»¬å°†è¿›å…¥ Rust çš„è¿›é˜¶å­¦ä¹ ç¯èŠ‚ï¼Œä¸åŸºç¡€ç¯èŠ‚ä¸åŒçš„æ˜¯ï¼Œç”±äºä½ å·²ç»å¯¹ Rust æœ‰äº†ä¸€å®šçš„è®¤è¯†ï¼Œå› æ­¤æˆ‘ä»¬**ä¸ä¼šå†å¯¹å¾ˆå¤šç»†èŠ‚è¿›è¡Œç¿»æ¥è¦†å»çš„è¯¦ç»†è®²è§£ï¼Œç”šè‡³ä¼šä¸€å¸¦è€Œè¿‡**ã€‚

æ€»ä¹‹ï¼Œæ¬¢è¿æ¥åˆ°é«˜çº§ Rust çš„ä¸–ç•Œï¼Œå…¨æ–°çš„ Bossï¼Œå…¨æ–°çš„è£…å¤‡ï¼Œä½ å‡†å¤‡å¥½äº†å—ï¼Ÿ



================================================
FILE: src/advance/macro.md
================================================
# Macro å®ç¼–ç¨‹

åœ¨ç¼–ç¨‹ä¸–ç•Œå¯ä»¥è¯´æ˜¯è°ˆâ€œå®â€è‰²å˜ï¼ŒåŸå› åœ¨äº C è¯­è¨€ä¸­çš„å®æ˜¯éå¸¸å±é™©çš„ä¸œä¸œï¼Œä½†å¹¶ä¸æ˜¯æ‰€æœ‰è¯­è¨€éƒ½åƒ C è¿™æ ·ï¼Œä¾‹å¦‚å¯¹äºå¤è€çš„è¯­è¨€ Lisp æ¥è¯´ï¼Œå®å°±æ˜¯å°±æ˜¯ä¸€ä¸ªéå¸¸å¼ºå¤§çš„å¥½å¸®æ‰‹ã€‚

é‚£è¯è¯´å›æ¥ï¼Œåœ¨ Rust ä¸­å®åˆ°åº•æ˜¯å¥½æ˜¯åå‘¢ï¼Ÿæœ¬ç« å°†å¸¦ä½ æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚

äº‹å®ä¸Šï¼Œæˆ‘ä»¬è™½ç„¶æ²¡æœ‰è§è¿‡å®ï¼Œä½†æ˜¯å·²ç»å¤šæ¬¡ç”¨è¿‡å®ƒï¼Œä¾‹å¦‚åœ¨å…¨ä¹¦çš„ç¬¬ä¸€ä¸ªä¾‹å­ä¸­å°±ç”¨åˆ°äº†ï¼š`println!("ä½ å¥½ï¼Œä¸–ç•Œ")`ï¼Œè¿™é‡Œ `println!` å°±æ˜¯ä¸€ä¸ªæœ€å¸¸ç”¨çš„å®ï¼Œå¯ä»¥çœ‹åˆ°å®ƒå’Œå‡½æ•°æœ€å¤§çš„åŒºåˆ«æ˜¯ï¼šå®ƒåœ¨è°ƒç”¨æ—¶å¤šäº†ä¸€ä¸ª `!`ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜æœ‰ `vec!` ã€`assert_eq!` éƒ½æ˜¯ç›¸å½“å¸¸ç”¨çš„ï¼Œå¯ä»¥è¯´**å®åœ¨ Rust ä¸­æ— å¤„ä¸åœ¨**ã€‚

ç»†å¿ƒçš„è¯»è€…å¯èƒ½ä¼šæ³¨æ„åˆ° `println!` åé¢è·Ÿç€çš„æ˜¯ `()`ï¼Œè€Œ `vec!` åé¢è·Ÿç€çš„æ˜¯ `[]`ï¼Œè¿™æ˜¯å› ä¸ºå®çš„å‚æ•°å¯ä»¥ä½¿ç”¨ `()`ã€`[]` ä»¥åŠ `{}`:

```rust
fn main() {
    println!("aaaa");
    println!["aaaa"];
    println!{"aaaa"}
}
```

è™½ç„¶ä¸‰ç§ä½¿ç”¨å½¢å¼çš†å¯ï¼Œä½†æ˜¯ Rust å†…ç½®çš„å®éƒ½æœ‰è‡ªå·±çº¦å®šä¿—æˆçš„ä½¿ç”¨æ–¹å¼ï¼Œä¾‹å¦‚ `vec![...]`ã€`assert_eq!(...)` ç­‰ã€‚

åœ¨ Rust ä¸­å®åˆ†ä¸ºä¸¤å¤§ç±»ï¼š**å£°æ˜å¼å®( _declarative macros_ )** `macro_rules!` å’Œä¸‰ç§**è¿‡ç¨‹å®( _procedural macros_ )**:

- `#[derive]`ï¼Œåœ¨ä¹‹å‰å¤šæ¬¡è§åˆ°çš„æ´¾ç”Ÿå®ï¼Œå¯ä»¥ä¸ºç›®æ ‡ç»“æ„ä½“æˆ–æšä¸¾æ´¾ç”ŸæŒ‡å®šçš„ä»£ç ï¼Œä¾‹å¦‚ `Debug` ç‰¹å¾
- ç±»å±æ€§å®(Attribute-like macro)ï¼Œç”¨äºä¸ºç›®æ ‡æ·»åŠ è‡ªå®šä¹‰çš„å±æ€§
- ç±»å‡½æ•°å®(Function-like macro)ï¼Œçœ‹ä¸Šå»å°±åƒæ˜¯å‡½æ•°è°ƒç”¨

å¦‚æœæ„Ÿè§‰éš¾ä»¥ç†è§£ï¼Œä¹Ÿä¸å¿…æ‹…å¿ƒï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†é€ä¸ªçœ‹çœ‹å®ƒä»¬çš„åºå±±çœŸé¢ç›®ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œå…ˆæ¥çœ‹ä¸‹ä¸ºä½•éœ€è¦å®ï¼Œç‰¹åˆ«æ˜¯ Rust çš„å‡½æ•°æ˜æ˜å·²ç»å¾ˆå¼ºå¤§äº†ã€‚

## å®å’Œå‡½æ•°çš„åŒºåˆ«

å®å’Œå‡½æ•°çš„åŒºåˆ«å¹¶ä¸å°‘ï¼Œè€Œä¸”å¯¹äºå®æ“…é•¿çš„é¢†åŸŸï¼Œå‡½æ•°å…¶å®æ˜¯æœ‰äº›æ— èƒ½ä¸ºåŠ›çš„ã€‚

#### å…ƒç¼–ç¨‹

ä»æ ¹æœ¬ä¸Šæ¥è¯´ï¼Œå®æ˜¯é€šè¿‡ä¸€ç§ä»£ç æ¥ç”Ÿæˆå¦ä¸€ç§ä»£ç ï¼Œå¦‚æœå¤§å®¶ç†Ÿæ‚‰å…ƒç¼–ç¨‹ï¼Œå°±ä¼šå‘ç°ä¸¤è€…çš„å…±åŒç‚¹ã€‚

åœ¨[é™„å½• D](https://course.rs/appendix/derive.html)ä¸­è®²åˆ°çš„ `derive` å±æ€§ï¼Œå°±ä¼šè‡ªåŠ¨ä¸ºç»“æ„ä½“æ´¾ç”Ÿå‡ºç›¸åº”ç‰¹å¾æ‰€éœ€çš„ä»£ç ï¼Œä¾‹å¦‚ `#[derive(Debug)]`ï¼Œè¿˜æœ‰ç†Ÿæ‚‰çš„ `println!` å’Œ `vec!`ï¼Œæ‰€æœ‰çš„è¿™äº›å®éƒ½ä¼šå±•å¼€æˆç›¸åº”çš„ä»£ç ï¼Œä¸”å¾ˆå¯èƒ½æ˜¯é•¿å¾—å¤šçš„ä»£ç ã€‚

æ€»ä¹‹ï¼Œå…ƒç¼–ç¨‹å¯ä»¥å¸®æˆ‘ä»¬å‡å°‘æ‰€éœ€ç¼–å†™çš„ä»£ç ï¼Œä¹Ÿå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘ç»´æŠ¤çš„æˆæœ¬ï¼Œè™½ç„¶å‡½æ•°å¤ç”¨ä¹Ÿæœ‰ç±»ä¼¼çš„ä½œç”¨ï¼Œä½†æ˜¯å®ä¾ç„¶æ‹¥æœ‰è‡ªå·±ç‹¬ç‰¹çš„ä¼˜åŠ¿ã€‚

#### å¯å˜å‚æ•°

Rust çš„å‡½æ•°ç­¾åæ˜¯å›ºå®šçš„ï¼šå®šä¹‰äº†ä¸¤ä¸ªå‚æ•°ï¼Œå°±å¿…é¡»ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œå¤šä¸€ä¸ªå°‘ä¸€ä¸ªéƒ½ä¸è¡Œï¼Œå¯¹äºä» JS/TS è¿‡æ¥çš„åŒå­¦ï¼Œè¿™ä¸€ç‚¹å…¶å®æ˜¯æœ‰äº›æ¼äººçš„ã€‚

è€Œå®å°±å¯ä»¥æ‹¥æœ‰å¯å˜æ•°é‡çš„å‚æ•°ï¼Œä¾‹å¦‚å¯ä»¥è°ƒç”¨ä¸€ä¸ªå‚æ•°çš„ `println!("hello")`ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨ä¸¤ä¸ªå‚æ•°çš„ `println!("hello {}", name)`ã€‚

#### å®å±•å¼€

ç”±äºå®ä¼šè¢«å±•å¼€æˆå…¶å®ƒä»£ç ï¼Œä¸”è¿™ä¸ªå±•å¼€è¿‡ç¨‹æ˜¯å‘ç”Ÿåœ¨ç¼–è¯‘å™¨å¯¹ä»£ç è¿›è¡Œè§£é‡Šä¹‹å‰ã€‚å› æ­¤ï¼Œå®å¯ä»¥ä¸ºæŒ‡å®šçš„ç±»å‹å®ç°æŸä¸ªç‰¹å¾ï¼šå…ˆå°†å®å±•å¼€æˆå®ç°ç‰¹å¾çš„ä»£ç åï¼Œå†è¢«ç¼–è¯‘ã€‚

è€Œå‡½æ•°å°±åšä¸åˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒç›´åˆ°è¿è¡Œæ—¶æ‰èƒ½è¢«è°ƒç”¨ï¼Œè€Œç‰¹å¾éœ€è¦åœ¨ç¼–è¯‘æœŸè¢«å®ç°ã€‚

#### å®çš„ç¼ºç‚¹

ç›¸å¯¹å‡½æ•°æ¥è¯´ï¼Œç”±äºå®æ˜¯åŸºäºä»£ç å†å±•å¼€æˆä»£ç ï¼Œå› æ­¤å®ç°ç›¸æ¯”å‡½æ•°æ¥è¯´ä¼šæ›´åŠ å¤æ‚ï¼Œå†åŠ ä¸Šå®çš„è¯­æ³•æ›´ä¸ºå¤æ‚ï¼Œæœ€ç»ˆå¯¼è‡´å®šä¹‰å®çš„ä»£ç ç›¸å½“åœ°éš¾è¯»ï¼Œä¹Ÿéš¾ä»¥ç†è§£å’Œç»´æŠ¤ã€‚

## å£°æ˜å¼å® `macro_rules!`

åœ¨ Rust ä¸­ä½¿ç”¨æœ€å¹¿çš„å°±æ˜¯å£°æ˜å¼å®ï¼Œå®ƒä»¬ä¹Ÿæœ‰ä¸€äº›å…¶å®ƒçš„ç§°å‘¼ï¼Œä¾‹å¦‚ç¤ºä¾‹å®( macros by example )ã€`macro_rules!` æˆ–å¹²è„†ç›´æ¥ç§°å‘¼ä¸º**å®**ã€‚

å£°æ˜å¼å®å…è®¸æˆ‘ä»¬å†™å‡ºç±»ä¼¼ `match` çš„ä»£ç ã€‚`match` è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªæ§åˆ¶ç»“æ„ï¼Œå…¶æ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œç„¶åå°†è¡¨è¾¾å¼çš„ç»“æœä¸å¤šä¸ªæ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œä¸€æ—¦åŒ¹é…äº†æŸä¸ªæ¨¡å¼ï¼Œåˆ™è¯¥æ¨¡å¼ç›¸å…³è”çš„ä»£ç å°†è¢«æ‰§è¡Œ:

```rust
match target {
    æ¨¡å¼1 => è¡¨è¾¾å¼1,
    æ¨¡å¼2 => {
        è¯­å¥1;
        è¯­å¥2;
        è¡¨è¾¾å¼2
    },
    _ => è¡¨è¾¾å¼3
}
```

è€Œ**å®ä¹Ÿæ˜¯å°†ä¸€ä¸ªå€¼è·Ÿå¯¹åº”çš„æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œä¸”è¯¥æ¨¡å¼ä¼šä¸ç‰¹å®šçš„ä»£ç ç›¸å…³è”**ã€‚ä½†æ˜¯ä¸ `match` ä¸åŒçš„æ˜¯ï¼Œ**å®é‡Œçš„å€¼æ˜¯ä¸€æ®µ Rust æºä»£ç **(å­—é¢é‡)ï¼Œæ¨¡å¼ç”¨äºè·Ÿè¿™æ®µæºä»£ç çš„ç»“æ„ç›¸æ¯”è¾ƒï¼Œä¸€æ—¦åŒ¹é…ï¼Œä¼ å…¥å®çš„é‚£æ®µæºä»£ç å°†è¢«æ¨¡å¼å…³è”çš„ä»£ç æ‰€æ›¿æ¢ï¼Œæœ€ç»ˆå®ç°å®å±•å¼€ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ**æ‰€æœ‰çš„è¿™äº›éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸå‘ç”Ÿï¼Œå¹¶æ²¡æœ‰è¿è¡ŒæœŸçš„æ€§èƒ½æŸè€—**ã€‚

#### ç®€åŒ–ç‰ˆçš„ vec!

åœ¨[åŠ¨æ€æ•°ç»„ Vector ç« èŠ‚](https://course.rs/basic/collections/vector.html#vec)ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ä½¿ç”¨ `vec!` æ¥ä¾¿æ·çš„åˆå§‹åŒ–ä¸€ä¸ªåŠ¨æ€æ•°ç»„:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

æœ€é‡è¦çš„æ˜¯ï¼Œé€šè¿‡ `vec!` åˆ›å»ºçš„åŠ¨æ€æ•°ç»„æ”¯æŒä»»ä½•å…ƒç´ ç±»å‹ï¼Œä¹Ÿå¹¶æ²¡æœ‰é™åˆ¶æ•°ç»„çš„é•¿åº¦ï¼Œå¦‚æœä½¿ç”¨å‡½æ•°ï¼Œæˆ‘ä»¬æ˜¯æ— æ³•åšåˆ°è¿™ä¸€ç‚¹çš„ã€‚

å¥½åœ¨æˆ‘ä»¬æœ‰ `macro_rules!`ï¼Œæ¥çœ‹çœ‹è¯¥å¦‚ä½•ä½¿ç”¨å®ƒæ¥å®ç° `vec!`ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€åŒ–å®ç°ï¼š

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

ç®€åŒ–å®ç°ç‰ˆæœ¬ï¼Ÿè¿™ä¹Ÿå¤ªéš¾äº†å§ï¼ï¼åªèƒ½è¯´ï¼Œæ¬¢è¿æ¥åˆ°å®çš„ä¸–ç•Œï¼Œåœ¨è¿™é‡Œä½ èƒ½è§åˆ°ä¼˜é›… Rust çš„å¦ä¸€é¢:) æ ‡å‡†åº“ä¸­çš„ `vec!` è¿˜åŒ…å«äº†é¢„åˆ†é…å†…å­˜ç©ºé—´çš„ä»£ç ï¼Œå¦‚æœå¼•å…¥è¿›æ¥ï¼Œé‚£å¤§å®¶å°†æ›´éš¾ä»¥æ¥å—ã€‚

`#[macro_export]` æ³¨é‡Šå°†å®è¿›è¡Œäº†å¯¼å‡ºï¼Œè¿™æ ·å…¶å®ƒçš„åŒ…å°±å¯ä»¥å°†è¯¥å®å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œç„¶åæ‰èƒ½ä½¿ç”¨ã€‚å¯èƒ½æœ‰åŒå­¦ä¼šæé—®ï¼šæˆ‘ä»¬åœ¨ä½¿ç”¨æ ‡å‡†åº“ `vec!` æ—¶ä¹Ÿæ²¡æœ‰å¼•å…¥å®å•Šï¼Œé‚£æ˜¯å› ä¸º Rust å·²ç»é€šè¿‡ [`std::prelude`](https://course.rs/appendix/prelude.html) çš„æ–¹å¼ä¸ºæˆ‘ä»¬è‡ªåŠ¨å¼•å…¥äº†ã€‚

ç´§æ¥ç€ï¼Œå°±ä½¿ç”¨ `macro_rules!` è¿›è¡Œäº†å®å®šä¹‰ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å®çš„åç§°æ˜¯ `vec`ï¼Œè€Œä¸æ˜¯ `vec!`ï¼Œåè€…çš„æ„Ÿå¹å·åªåœ¨è°ƒç”¨æ—¶æ‰éœ€è¦ã€‚

`vec` çš„å®šä¹‰ç»“æ„è·Ÿ `match` è¡¨è¾¾å¼å¾ˆåƒï¼Œä½†è¿™é‡Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªåˆ†æ”¯ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªæ¨¡å¼ `( $( $x:expr ),* )`ï¼Œè·Ÿæ¨¡å¼ç›¸å…³è”çš„ä»£ç å°±åœ¨ `=>` ä¹‹åã€‚ä¸€æ—¦æ¨¡å¼æˆåŠŸåŒ¹é…ï¼Œé‚£è¿™æ®µç›¸å…³è”çš„ä»£ç å°±ä¼šæ›¿æ¢ä¼ å…¥çš„æºä»£ç ã€‚

ç”±äº `vec` å®åªæœ‰ä¸€ä¸ªæ¨¡å¼ï¼Œå› æ­¤å®ƒåªèƒ½åŒ¹é…ä¸€ç§æºä»£ç ï¼Œå…¶å®ƒç±»å‹çš„éƒ½å°†å¯¼è‡´æŠ¥é”™ï¼Œè€Œæ›´å¤æ‚çš„å®å¾€å¾€ä¼šæ‹¥æœ‰æ›´å¤šçš„åˆ†æ”¯ã€‚

è™½ç„¶å®å’Œ `match` éƒ½ç§°ä¹‹ä¸ºæ¨¡å¼ï¼Œä½†æ˜¯å‰è€…è·Ÿ[åè€…](https://course.rs/basic/match-pattern/all-patterns.html)çš„æ¨¡å¼è§„åˆ™æ˜¯ä¸åŒçš„ã€‚å¦‚æœå¤§å®¶æƒ³è¦æ›´æ·±å…¥çš„äº†è§£å®çš„æ¨¡å¼ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™é‡Œ](https://doc.rust-lang.org/reference/macros-by-example.html)ã€‚

#### æ¨¡å¼è§£æ

è€Œç°åœ¨ï¼Œæˆ‘ä»¬å…ˆæ¥ç®€å•è®²è§£ä¸‹ `( $( $x:expr ),* )` çš„å«ä¹‰ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨åœ†æ‹¬å· `()` å°†æ•´ä¸ªå®æ¨¡å¼åŒ…è£¹å…¶ä¸­ã€‚ç´§éšå…¶åçš„æ˜¯ `$()`ï¼Œè·Ÿæ‹¬å·ä¸­æ¨¡å¼ç›¸åŒ¹é…çš„å€¼(ä¼ å…¥çš„ Rust æºä»£ç )ä¼šè¢«æ•è·ï¼Œç„¶åç”¨äºä»£ç æ›¿æ¢ã€‚åœ¨è¿™é‡Œï¼Œæ¨¡å¼ `$x:expr` ä¼šåŒ¹é…ä»»ä½• Rust è¡¨è¾¾å¼å¹¶ç»™äºˆè¯¥æ¨¡å¼ä¸€ä¸ªåç§°ï¼š`$x`ã€‚

`$()` ä¹‹åçš„é€—å·è¯´æ˜ `$()` æ‰€åŒ¹é…çš„ä»£ç ä½¿ç”¨é€—å·åˆ†éš”ç¬¦åˆ†å‰²ï¼Œç´§éšé€—å·ä¹‹åçš„ `*` è¯´æ˜ `*` ä¹‹å‰çš„æ¨¡å¼(`$()`å†…çš„éƒ¨åˆ†)ä¼šè¢«åŒ¹é…é›¶æ¬¡æˆ–ä»»æ„å¤šæ¬¡(ç±»ä¼¼æ­£åˆ™è¡¨è¾¾å¼)(ä¸”ä»¥é€—å·åˆ†å‰²)ã€‚

å½“æˆ‘ä»¬ä½¿ç”¨ `vec![1, 2, 3]` æ¥è°ƒç”¨è¯¥å®æ—¶ï¼Œ`$x` æ¨¡å¼å°†è¢«åŒ¹é…ä¸‰æ¬¡ï¼Œåˆ†åˆ«æ˜¯ `1`ã€`2`ã€`3`ã€‚ä¸ºäº†å¸®åŠ©å¤§å®¶å·©å›ºï¼Œæˆ‘ä»¬å†æ¥ä¸€èµ·è¿‡ä¸€ä¸‹ï¼š

1. `$()` ä¸­åŒ…å«çš„æ˜¯æ¨¡å¼ `$x:expr`ï¼Œè¯¥æ¨¡å¼ä¸­çš„ `expr` è¡¨ç¤ºä¼šåŒ¹é…ä»»ä½• Rust è¡¨è¾¾å¼ï¼Œå¹¶ç»™äºˆè¯¥æ¨¡å¼ä¸€ä¸ªåç§° `$x`
2. å› æ­¤ `$x` æ¨¡å¼å¯ä»¥è·Ÿæ•´æ•° `1` è¿›è¡ŒåŒ¹é…ï¼Œä¹Ÿå¯ä»¥è·Ÿå­—ç¬¦ä¸² "hello" è¿›è¡ŒåŒ¹é…: `vec!["hello", "world"]`
3. `$()` ä¹‹åçš„é€—å·ï¼Œæ„å‘³ç€ `1` ã€ `2` å’Œ `3` ä¹‹é—´ä½¿ç”¨é€—å·è¿›è¡Œåˆ†å‰²
4. `*` è¯´æ˜ä¹‹å‰çš„æ¨¡å¼å¯ä»¥å‡ºç°é›¶æ¬¡ä¹Ÿå¯ä»¥ä»»æ„æ¬¡ï¼Œè¿™é‡Œå‡ºç°äº†ä¸‰æ¬¡

__éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ­¤å¤„ç®€åŒ–çš„ `vec!` å®ç°ä¸­ï¼Œ `3` åé¢æ˜¯ä¸èƒ½ç»§ç»­æ¥é€—å·çš„( `vec![1, 2, 3]` åˆæ³•ï¼Œä½† `vec![1, 2, 3,]` ä¸åˆæ³•)ï¼Œè¦åŒ¹é…æœ€åä¸€ä¸ªå¯æœ‰å¯æ— çš„é€—å·ï¼Œå¯å‚è€ƒRustå®˜æ–¹çš„ `vec!` å®å®šä¹‰ï¼Œå…³é”®ä»£ç å¦‚ä¸‹ï¼š__

```rust
($($x:expr),+ $(,)?) => (
    <[_]>::into_vec(
        // This rustc_box is not required, but it produces a dramatic improvement in compile
        // time when constructing arrays with many elements.
        #[rustc_box]
        $crate::boxed::Box::new([$($x),+])
    )
);
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ä¸æ¨¡å¼ç›¸å…³è”ã€åœ¨ `=>` ä¹‹åçš„ä»£ç ï¼š

```rust
{
    {
        let mut temp_vec = Vec::new();
        $(
            temp_vec.push($x);
        )*
        temp_vec
    }
};
```

è¿™é‡Œå°±æ¯”è¾ƒå¥½ç†è§£äº†ï¼Œ`$()` ä¸­çš„ `temp_vec.push()` å°†æ ¹æ®æ¨¡å¼åŒ¹é…çš„æ¬¡æ•°ç”Ÿæˆå¯¹åº”çš„ä»£ç ï¼Œå½“è°ƒç”¨ `vec![1, 2, 3]` æ—¶ï¼Œä¸‹é¢è¿™æ®µç”Ÿæˆçš„ä»£ç å°†æ›¿ä»£ä¼ å…¥çš„æºä»£ç ï¼Œä¹Ÿå°±æ˜¯æ›¿ä»£ `vec![1, 2, 3]` :

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

å¦‚æœæ˜¯ `let v = vec![1, 2, 3]`ï¼Œé‚£ç”Ÿæˆçš„ä»£ç æœ€åè¿”å›çš„å€¼ `temp_vec` å°†è¢«èµ‹äºˆç»™å˜é‡ `v`ï¼Œç­‰åŒäº :

```rust
let v = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå®ï¼Œå®ƒå¯ä»¥æ¥å—ä»»æ„ç±»å‹å’Œæ•°é‡çš„å‚æ•°ï¼Œå¹¶ä¸”ç†è§£äº†å…¶è¯­æ³•çš„å«ä¹‰ã€‚

#### æœªæ¥å°†è¢«æ›¿ä»£çš„ `macro_rules`

å¯¹äº `macro_rules` æ¥è¯´ï¼Œå®ƒæ˜¯å­˜åœ¨ä¸€äº›é—®é¢˜çš„ï¼Œå› æ­¤ï¼ŒRust è®¡åˆ’åœ¨æœªæ¥ä½¿ç”¨æ–°çš„å£°æ˜å¼å®æ¥æ›¿æ¢å®ƒï¼šå·¥ä½œæ–¹å¼ç±»ä¼¼ï¼Œä½†æ˜¯è§£å†³äº†ç›®å‰å­˜åœ¨çš„ä¸€äº›é—®é¢˜ï¼Œåœ¨é‚£ä¹‹åï¼Œ`macro_rules` å°†å˜ä¸º `deprecated` çŠ¶æ€ã€‚

ç”±äºç»å¤§å¤šæ•° Rust å¼€å‘è€…éƒ½æ˜¯å®çš„ç”¨æˆ·è€Œä¸æ˜¯ç¼–å†™è€…ï¼Œå› æ­¤åœ¨è¿™é‡Œæˆ‘ä»¬ä¸ä¼šå¯¹ `macro_rules` è¿›è¡Œæ›´æ·±å…¥çš„å­¦ä¹ ï¼Œå¦‚æœå¤§å®¶æ„Ÿå…´è¶£ï¼Œå¯ä»¥çœ‹çœ‹è¿™æœ¬ä¹¦ [ â€œThe Little Book of Rust Macrosâ€](https://veykril.github.io/tlborm/)ã€‚

## ç”¨è¿‡ç¨‹å®ä¸ºå±æ€§æ ‡è®°ç”Ÿæˆä»£ç 

ç¬¬äºŒç§å¸¸ç”¨çš„å®å°±æ˜¯[_è¿‡ç¨‹å®_](https://doc.rust-lang.org/reference/procedural-macros.html) ( _procedural macros_ )ï¼Œä»å½¢å¼ä¸Šæ¥çœ‹ï¼Œè¿‡ç¨‹å®è·Ÿå‡½æ•°è¾ƒä¸ºç›¸åƒï¼Œä½†è¿‡ç¨‹å®æ˜¯ä½¿ç”¨æºä»£ç ä½œä¸ºè¾“å…¥å‚æ•°ï¼ŒåŸºäºä»£ç è¿›è¡Œä¸€ç³»åˆ—æ“ä½œåï¼Œå†è¾“å‡ºä¸€æ®µå…¨æ–°çš„ä»£ç ã€‚**æ³¨æ„ï¼Œè¿‡ç¨‹å®ä¸­çš„ derive å®è¾“å‡ºçš„ä»£ç å¹¶ä¸ä¼šæ›¿æ¢ä¹‹å‰çš„ä»£ç ï¼Œè¿™ä¸€ç‚¹ä¸å£°æ˜å®æœ‰å¾ˆå¤§çš„ä¸åŒï¼**

è‡³äºå‰æ–‡æåˆ°çš„è¿‡ç¨‹å®çš„ä¸‰ç§ç±»å‹(è‡ªå®šä¹‰ `derive`ã€å±æ€§å®ã€å‡½æ•°å®)ï¼Œå®ƒä»¬çš„å·¥ä½œæ–¹å¼éƒ½æ˜¯ç±»ä¼¼çš„ã€‚

å½“**åˆ›å»ºè¿‡ç¨‹å®**æ—¶ï¼Œå®ƒçš„å®šä¹‰å¿…é¡»è¦æ”¾å…¥ä¸€ä¸ªç‹¬ç«‹çš„åŒ…ä¸­ï¼Œä¸”åŒ…çš„ç±»å‹ä¹Ÿæ˜¯ç‰¹æ®Šçš„ï¼Œè¿™ä¹ˆåšçš„åŸå› ç›¸å½“å¤æ‚ï¼Œå¤§å®¶åªè¦çŸ¥é“è¿™ç§é™åˆ¶åœ¨æœªæ¥å¯èƒ½ä¼šæœ‰æ‰€æ”¹å˜å³å¯ã€‚

> äº‹å®ä¸Šï¼Œæ ¹æ®[è¿™ä¸ªè¯´æ³•](https://www.reddit.com/r/rust/comments/t1oa1e/what_are_the_complex_technical_reasons_why/)ï¼Œè¿‡ç¨‹å®æ”¾å…¥ç‹¬ç«‹åŒ…çš„åŸå› åœ¨äºå®ƒå¿…é¡»å…ˆè¢«ç¼–è¯‘åæ‰èƒ½ä½¿ç”¨ï¼Œå¦‚æœè¿‡ç¨‹å®å’Œä½¿ç”¨å®ƒçš„ä»£ç åœ¨ä¸€ä¸ªåŒ…ï¼Œå°±å¿…é¡»å…ˆå•ç‹¬å¯¹è¿‡ç¨‹å®çš„ä»£ç è¿›è¡Œç¼–è¯‘ï¼Œç„¶åå†å¯¹æˆ‘ä»¬çš„ä»£ç è¿›è¡Œç¼–è¯‘ï¼Œä½†æ‚²å‰§çš„æ˜¯ Rust çš„ç¼–è¯‘å•å…ƒæ˜¯åŒ…ï¼Œå› æ­¤ä½ æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ã€‚

å‡è®¾æˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ª `derive` ç±»å‹çš„è¿‡ç¨‹å®ï¼š

```rust
use proc_macro;

#[proc_macro_derive(HelloMacro)]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

ç”¨äºå®šä¹‰è¿‡ç¨‹å®çš„å‡½æ•° `some_name` ä½¿ç”¨ `TokenStream` ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œå¹¶ä¸”è¿”å›çš„ä¹Ÿæ˜¯åŒä¸€ä¸ªç±»å‹ã€‚`TokenStream` æ˜¯åœ¨ `proc_macro` åŒ…ä¸­å®šä¹‰çš„ï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒä»£è¡¨äº†ä¸€ä¸ª `Token` åºåˆ—ã€‚

åœ¨ç†è§£äº†è¿‡ç¨‹å®çš„åŸºæœ¬å®šä¹‰åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹è¯¥å¦‚ä½•åˆ›å»ºä¸‰ç§ç±»å‹çš„è¿‡ç¨‹å®ï¼Œé¦–å…ˆï¼Œä»å¤§å®¶æœ€ç†Ÿæ‚‰çš„ `derive` å¼€å§‹ã€‚

## è‡ªå®šä¹‰ `derive` è¿‡ç¨‹å®

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç‰¹å¾ `HelloMacro`ï¼Œç°åœ¨æœ‰ä¸¤ç§æ–¹å¼è®©ç”¨æˆ·ä½¿ç”¨å®ƒï¼š

- ä¸ºæ¯ä¸ªç±»å‹æ‰‹åŠ¨å®ç°è¯¥ç‰¹å¾ï¼Œå°±åƒä¹‹å‰[ç‰¹å¾ç« èŠ‚](https://course.rs/basic/trait/trait.html#ä¸ºç±»å‹å®ç°ç‰¹å¾)æ‰€åšçš„
- ä½¿ç”¨è¿‡ç¨‹å®æ¥ç»Ÿä¸€å®ç°è¯¥ç‰¹å¾ï¼Œè¿™æ ·ç”¨æˆ·åªéœ€è¦å¯¹ç±»å‹è¿›è¡Œæ ‡è®°å³å¯ï¼š`#[derive(HelloMacro)]`

ä»¥ä¸Šä¸¤ç§æ–¹å¼å¹¶æ²¡æœ‰å­°ä¼˜å­°åŠ£ï¼Œä¸»è¦åœ¨äºä¸åŒçš„ç±»å‹æ˜¯å¦å¯ä»¥ä½¿ç”¨åŒæ ·çš„é»˜è®¤ç‰¹å¾å®ç°ï¼Œå¦‚æœå¯ä»¥ï¼Œé‚£è¿‡ç¨‹å®çš„æ–¹å¼å¯ä»¥å¸®æˆ‘ä»¬å‡å°‘å¾ˆå¤šä»£ç å®ç°:

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Sunfei;

#[derive(HelloMacro)]
struct Sunface;

fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

ç®€å•å—ï¼Ÿç®€å•ï¼ä¸è¿‡ä¸ºäº†å®ç°è¿™æ®µä»£ç å±•ç¤ºçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åˆ›å»ºç›¸åº”çš„è¿‡ç¨‹å®æ‰è¡Œã€‚ é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„å·¥ç¨‹ç”¨äºæ¼”ç¤ºï¼š

```shell
$ cargo new hello_macro
$ cd hello_macro/
$ touch src/lib.rs
```

æ­¤æ—¶ï¼Œ`src` ç›®å½•ä¸‹åŒ…å«ä¸¤ä¸ªæ–‡ä»¶ `lib.rs` å’Œ `main.rs`ï¼Œå‰è€…æ˜¯ `lib` åŒ…æ ¹ï¼Œåè€…æ˜¯äºŒè¿›åˆ¶åŒ…æ ¹ï¼Œå¦‚æœå¤§å®¶å¯¹åŒ…æ ¹ä¸ç†Ÿæ‚‰ï¼Œå¯ä»¥çœ‹çœ‹[è¿™é‡Œ](https://course.rs/basic/crate-module/crate.html)ã€‚

æ¥ä¸‹æ¥ï¼Œå…ˆåœ¨ `src/lib.rs` ä¸­å®šä¹‰è¿‡ç¨‹å®æ‰€éœ€çš„ `HelloMacro` ç‰¹å¾å’Œå…¶å…³è”å‡½æ•°:

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

ç„¶ååœ¨ `src/main.rs` ä¸­ç¼–å†™ä¸»ä½“ä»£ç ï¼Œé¦–å…ˆæ˜ å…¥å¤§å®¶è„‘æµ·çš„å¯èƒ½ä¼šæ˜¯å¦‚ä¸‹å®ç°:

```rust
use hello_macro::HelloMacro;

struct Sunfei;

impl HelloMacro for Sunfei {
    fn hello_macro() {
        println!("Hello, Macro! My name is Sunfei!");
    }
}

struct Sunface;

impl HelloMacro for Sunface {
    fn hello_macro() {
        println!("Hello, Macro! My name is Sunface!");
    }
}

fn main() {
    Sunfei::hello_macro();
}
```

ä½†æ˜¯è¿™ç§æ–¹å¼æœ‰ä¸ªé—®é¢˜ï¼Œå¦‚æœæƒ³è¦å®ç°ä¸åŒçš„æ‹›å‘¼å†…å®¹ï¼Œå°±éœ€è¦ä¸ºæ¯ä¸€ä¸ªç±»å‹éƒ½å®ç°ä¸€æ¬¡ç›¸åº”çš„ç‰¹å¾ï¼ŒRust ä¸æ”¯æŒåå°„ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•åœ¨è¿è¡Œæ—¶è·å¾—ç±»å‹åã€‚

ä½¿ç”¨å®ï¼Œå°±ä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼š

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Sunfei;

#[derive(HelloMacro)]
struct Sunface;

fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

ç®€å•æ˜äº†çš„ä»£ç æ€»æ˜¯ä»¤äººæ„‰å¿«ï¼Œä¸ºäº†è®©ä»£ç è¿è¡Œèµ·æ¥ï¼Œè¿˜éœ€è¦å®šä¹‰ä¸‹è¿‡ç¨‹å®ã€‚å°±å¦‚å‰æ–‡æåˆ°çš„ï¼Œç›®å‰åªèƒ½åœ¨å•ç‹¬çš„åŒ…ä¸­å®šä¹‰è¿‡ç¨‹å®ï¼Œå°½ç®¡æœªæ¥è¿™ç§é™åˆ¶ä¼šè¢«å–æ¶ˆï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬è¿˜å¾—éµå¾ªè¿™ä¸ªè§„åˆ™ã€‚

å®æ‰€åœ¨çš„åŒ…åè‡ªç„¶ä¹Ÿæœ‰è¦æ±‚ï¼Œå¿…é¡»ä»¥ `derive` ä¸ºåç¼€ï¼Œå¯¹äº `hello_macro` å®è€Œè¨€ï¼ŒåŒ…åå°±åº”è¯¥æ˜¯ `hello_macro_derive`ã€‚åœ¨ä¹‹å‰åˆ›å»ºçš„ `hello_macro` é¡¹ç›®æ ¹ç›®å½•ä¸‹ï¼Œè¿è¡Œå¦‚ä¸‹å‘½ä»¤ï¼Œåˆ›å»ºä¸€ä¸ªå•ç‹¬çš„ `lib` åŒ…:

```rust
cargo new hello_macro_derive --lib
```

è‡³æ­¤ï¼Œ `hello_macro` é¡¹ç›®çš„ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š

```shell
hello_macro
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ lib.rs
â””â”€â”€ hello_macro_derive
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ src
        â””â”€â”€ lib.rs
```

ç”±äºè¿‡ç¨‹å®æ‰€åœ¨çš„åŒ…è·Ÿæˆ‘ä»¬çš„é¡¹ç›®ç´§å¯†ç›¸è¿ï¼Œå› æ­¤å°†å®ƒæ”¾åœ¨é¡¹ç›®ä¹‹ä¸­ã€‚ç°åœ¨ï¼Œé—®é¢˜åˆæ¥äº†ï¼Œè¯¥å¦‚ä½•åœ¨é¡¹ç›®çš„ `src/main.rs` ä¸­å¼•ç”¨ `hello_macro_derive` åŒ…çš„å†…å®¹ï¼Ÿ

æ–¹æ³•æœ‰ä¸¤ç§ï¼Œç¬¬ä¸€ç§æ˜¯å°† `hello_macro_derive` å‘å¸ƒåˆ° `crates.io` æˆ– `GitHub` ä¸­ï¼Œå°±åƒæˆ‘ä»¬å¼•ç”¨çš„å…¶å®ƒä¾èµ–ä¸€æ ·ï¼›å¦ä¸€ç§å°±æ˜¯ä½¿ç”¨ç›¸å¯¹è·¯å¾„å¼•å…¥çš„æœ¬åœ°åŒ–æ–¹å¼ï¼Œä¿®æ”¹ `hello_macro/Cargo.toml` æ–‡ä»¶æ·»åŠ ä»¥ä¸‹å†…å®¹:

```toml
[dependencies]
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
# ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ç›¸å¯¹è·¯å¾„
# hello_macro_derive = { path = "./hello_macro_derive" }
```

æ­¤æ—¶ï¼Œ`hello_macro` é¡¹ç›®å°±å¯ä»¥æˆåŠŸçš„å¼•ç”¨åˆ° `hello_macro_derive` æœ¬åœ°åŒ…äº†ï¼Œå¯¹äºé¡¹ç›®ä¾èµ–å¼•å…¥çš„è¯¦ç»†ä»‹ç»ï¼Œå¯ä»¥å‚è§ [Cargo ç« èŠ‚](https://course.rs/cargo/dependency.html)ã€‚

å¦å¤–ï¼Œå­¦ä¹ è¿‡ç¨‹æ›´å¥½çš„åŠæ³•æ˜¯é€šè¿‡å±•å¼€å®æ¥é˜…è¯»å’Œè°ƒè¯•è‡ªå·±å†™çš„å®ï¼Œè¿™é‡Œéœ€è¦ç”¨åˆ°ä¸€ä¸ª cargo-expand çš„å·¥å…·ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢çš„å‘½ä»¤å®‰è£…
```bash
cargo install cargo-expand
```

æ¥ä¸‹æ¥ï¼Œå°±åˆ°äº†é‡å¤´æˆç¯èŠ‚ï¼Œä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•å®šä¹‰è¿‡ç¨‹å®ã€‚

#### å®šä¹‰è¿‡ç¨‹å®

é¦–å…ˆï¼Œåœ¨ `hello_macro_derive/Cargo.toml` æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š

```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```

å…¶ä¸­ `syn` å’Œ `quote` ä¾èµ–åŒ…éƒ½æ˜¯å®šä¹‰è¿‡ç¨‹å®æ‰€å¿…éœ€çš„ï¼ŒåŒæ—¶ï¼Œè¿˜éœ€è¦åœ¨ `[lib]` ä¸­å°†è¿‡ç¨‹å®çš„å¼€å…³å¼€å¯ : `proc-macro = true`ã€‚

å…¶æ¬¡ï¼Œåœ¨ `hello_macro_derive/src/lib.rs` ä¸­æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š

```rust
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;
use syn::DeriveInput;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // åŸºäº input æ„å»º AST è¯­æ³•æ ‘
    let ast:DeriveInput = syn::parse(input).unwrap();

    // æ„å»ºç‰¹å¾å®ç°ä»£ç 
    impl_hello_macro(&ast)
}
```

è¿™ä¸ªå‡½æ•°çš„ç­¾åæˆ‘ä»¬åœ¨ä¹‹å‰å·²ç»ä»‹ç»è¿‡ï¼Œæ€»ä¹‹ï¼Œè¿™ç§å½¢å¼çš„è¿‡ç¨‹å®å®šä¹‰æ˜¯ç›¸å½“é€šç”¨çš„ï¼Œä¸‹é¢æ¥åˆ†æä¸‹è¿™æ®µä»£ç ã€‚

é¦–å…ˆæœ‰ä¸€ç‚¹ï¼Œå¯¹äºç»å¤§å¤šæ•°è¿‡ç¨‹å®è€Œè¨€ï¼Œè¿™æ®µä»£ç å¾€å¾€åªåœ¨ `impl_hello_macro(&ast)` ä¸­çš„å®ç°æœ‰æ‰€åŒºåˆ«ï¼Œå¯¹äºå…¶å®ƒéƒ¨åˆ†åŸºæœ¬éƒ½æ˜¯ä¸€è‡´çš„ï¼Œå¦‚åŒ…çš„å¼•å…¥ã€å®å‡½æ•°çš„ç­¾åã€è¯­æ³•æ ‘æ„å»ºç­‰ã€‚

`proc_macro` åŒ…æ˜¯ Rust è‡ªå¸¦çš„ï¼Œå› æ­¤æ— éœ€åœ¨ `Cargo.toml` ä¸­å¼•å…¥ä¾èµ–ï¼Œå®ƒåŒ…å«äº†ç›¸å…³çš„ç¼–è¯‘å™¨ `API`ï¼Œå¯ä»¥ç”¨äºè¯»å–å’Œæ“ä½œ Rust æºä»£ç ã€‚

ç”±äºæˆ‘ä»¬ä¸º `hello_macro_derive` å‡½æ•°æ ‡è®°äº† `#[proc_macro_derive(HelloMacro)]`ï¼Œå½“ç”¨æˆ·ä½¿ç”¨ `#[derive(HelloMacro)]` æ ‡è®°äº†ä»–çš„ç±»å‹åï¼Œ`hello_macro_derive` å‡½æ•°å°±å°†è¢«è°ƒç”¨ã€‚è¿™é‡Œçš„ç§˜è¯€å°±æ˜¯ç‰¹å¾å `HelloMacro`ï¼Œå®ƒå°±åƒä¸€åº§æ¡¥æ¢ï¼Œå°†ç”¨æˆ·çš„ç±»å‹å’Œè¿‡ç¨‹å®è”ç³»åœ¨ä¸€èµ·ã€‚

`syn` å°†å­—ç¬¦ä¸²å½¢å¼çš„ Rust ä»£ç è§£æä¸ºä¸€ä¸ª AST æ ‘çš„æ•°æ®ç»“æ„ï¼Œè¯¥æ•°æ®ç»“æ„å¯ä»¥åœ¨éšåçš„ `impl_hello_macro` å‡½æ•°ä¸­è¿›è¡Œæ“ä½œã€‚æœ€åï¼Œæ“ä½œçš„ç»“æœåˆä¼šè¢« `quote` åŒ…è½¬æ¢å› Rust ä»£ç ã€‚è¿™äº›åŒ…éå¸¸å…³é”®ï¼Œå¯ä»¥å¸®æˆ‘ä»¬èŠ‚çœå¤§é‡çš„ç²¾åŠ›ï¼Œå¦åˆ™ä½ éœ€è¦è‡ªå·±å»ç¼–å†™æ”¯æŒä»£ç è§£æå’Œè¿˜åŸçš„è§£æå™¨ï¼Œè¿™å¯ä¸æ˜¯ä¸€ä»¶ç®€å•çš„ä»»åŠ¡ï¼

deriveè¿‡ç¨‹å®åªèƒ½ç”¨åœ¨struct/enum/unionä¸Šï¼Œå¤šæ•°ç”¨åœ¨ç»“æ„ä½“ä¸Šï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ä¸€ä¸ªç»“æ„ä½“ç”±å“ªäº›éƒ¨åˆ†ç»„æˆ:
```rust
// visï¼Œå¯è§†èŒƒå›´             identï¼Œæ ‡è¯†ç¬¦     genericï¼ŒèŒƒå‹    fields: ç»“æ„ä½“çš„å­—æ®µ
pub              struct    User            <'a, T>          {

// vis   ident   type
   pub   name:   &'a T,

}
```

å…¶ä¸­typeè¿˜å¯ä»¥ç»†åˆ†ï¼Œå…·ä½“è¯·é˜…è¯»synæ–‡æ¡£æˆ–æºç 

`syn::parse` è°ƒç”¨ä¼šè¿”å›ä¸€ä¸ª `DeriveInput` ç»“æ„ä½“æ¥ä»£è¡¨è§£æåçš„ Rust ä»£ç :

```rust
DeriveInput {
    // --snip--
    vis: Visibility,
    ident: Ident {
        ident: "Sunfei",
        span: #0 bytes(95..103)
    },
    generics: Generics,
    // Dataæ˜¯ä¸€ä¸ªæšä¸¾ï¼Œåˆ†åˆ«æ˜¯DataStructï¼ŒDataEnumï¼ŒDataUnionï¼Œè¿™é‡Œä»¥ DataStruct ä¸ºä¾‹
    data: Data(
        DataStruct {
            struct_token: Struct,
            fields: Fields,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

ä»¥ä¸Šå°±æ˜¯æºä»£ç  `struct Sunfei;` è§£æåçš„ç»“æœï¼Œé‡Œé¢æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„:

- `fields: Fields` æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œ`Fields::Named`, `Fields::Unnamed`, `Fields::Unit` åˆ†åˆ«è¡¨ç¤ºç»“æ„ä½“ä¸­çš„æ˜¾å¼å‘½åå­—æ®µï¼ˆå¦‚ä¾‹å­æ‰€ç¤ºï¼‰ï¼Œå…ƒç»„æˆ–å…ƒç»„å˜ä½“ä¸­çš„åŒ¿åå­—æ®µ(ä¾‹å¦‚`Some(T)`)ï¼Œå•å…ƒç±»å‹æˆ–å•å…ƒå˜ä½“å­—æ®µï¼ˆä¾‹å¦‚`None` ï¼‰ã€‚
- `ident: "Sunfei"` è¯´æ˜ç±»å‹åç§°ä¸º `Sunfei`ï¼Œ `ident` æ˜¯æ ‡è¯†ç¬¦ `identifier` çš„ç®€å†™

å¦‚æœæƒ³è¦äº†è§£æ›´å¤šçš„ä¿¡æ¯ï¼Œå¯ä»¥æŸ¥çœ‹ [`syn` æ–‡æ¡£](https://docs.rs/syn/1.0/syn/struct.DeriveInput.html)ã€‚

å¤§å®¶å¯èƒ½ä¼šæ³¨æ„åˆ°åœ¨ `hello_macro_derive` å‡½æ•°ä¸­æœ‰ `unwrap` çš„è°ƒç”¨ï¼Œä¹Ÿè®¸ä¼šä»¥ä¸ºè¿™æ˜¯ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæ²¡æœ‰åšé”™è¯¯å¤„ç†ï¼Œå®é™…ä¸Šå¹¶ä¸æ˜¯çš„ã€‚ç”±äºè¯¥å‡½æ•°åªèƒ½è¿”å› `TokenStream` è€Œä¸æ˜¯ `Result`ï¼Œé‚£ä¹ˆåœ¨æŠ¥é”™æ—¶ç›´æ¥ `panic` æ¥æŠ›å‡ºé”™è¯¯å°±æˆäº†ç›¸å½“å¥½çš„é€‰æ‹©ã€‚å½“ç„¶ï¼Œè¿™é‡Œå®é™…ä¸Šè¿˜æ˜¯åšäº†ç®€åŒ–ï¼Œåœ¨ç”Ÿäº§é¡¹ç›®ä¸­ï¼Œä½ åº”è¯¥é€šè¿‡ `panic!` æˆ– `expect` æŠ›å‡ºæ›´å…·ä½“çš„æŠ¥é”™ä¿¡æ¯ã€‚

è‡³æ­¤ï¼Œè¿™ä¸ªå‡½æ•°å¤§å®¶åº”è¯¥å·²ç»åŸºæœ¬ç†è§£äº†ï¼Œä¸‹é¢æ¥çœ‹çœ‹å¦‚ä½•æ„å»ºç‰¹å¾å®ç°çš„ä»£ç ï¼Œä¹Ÿæ˜¯è¿‡ç¨‹å®çš„æ ¸å¿ƒç›®æ ‡:

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

é¦–å…ˆï¼Œå°†ç»“æ„ä½“çš„åç§°èµ‹äºˆç»™ `name`ï¼Œä¹Ÿå°±æ˜¯ `name` ä¸­ä¼šåŒ…å«ä¸€ä¸ªå­—æ®µï¼Œå®ƒçš„å€¼æ˜¯å­—ç¬¦ä¸² "Sunfei"ã€‚

å…¶æ¬¡ï¼Œä½¿ç”¨ `quote!` å¯ä»¥å®šä¹‰æˆ‘ä»¬æƒ³è¦è¿”å›çš„ Rust ä»£ç ã€‚ç”±äºç¼–è¯‘å™¨éœ€è¦çš„å†…å®¹å’Œ `quote!` ç›´æ¥è¿”å›çš„ä¸ä¸€æ ·ï¼Œå› æ­¤è¿˜éœ€è¦ä½¿ç”¨ `.into` æ–¹æ³•å…¶è½¬æ¢ä¸º `TokenStream`ã€‚

å¤§å®¶æ³¨æ„åˆ° `#name` çš„ä½¿ç”¨äº†å—ï¼Ÿè¿™ä¹Ÿæ˜¯ `quote!` æä¾›çš„åŠŸèƒ½ä¹‹ä¸€ï¼Œå¦‚æœæƒ³è¦æ·±å…¥äº†è§£ `quote`ï¼Œå¯ä»¥çœ‹çœ‹[å®˜æ–¹æ–‡æ¡£](https://docs.rs/quote)ã€‚

ç‰¹å¾çš„ `hell_macro()` å‡½æ•°åªæœ‰ä¸€ä¸ªåŠŸèƒ½ï¼Œå°±æ˜¯ä½¿ç”¨ `println!` æ‰“å°ä¸€è¡Œæ¬¢è¿è¯­å¥ã€‚

å…¶ä¸­ `stringify!` æ˜¯ Rust æä¾›çš„å†…ç½®å®ï¼Œå¯ä»¥å°†ä¸€ä¸ªè¡¨è¾¾å¼(ä¾‹å¦‚ `1 + 2`)åœ¨ç¼–è¯‘æœŸè½¬æ¢æˆä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼(`"1 + 2"`)ï¼Œè¯¥å­—é¢é‡ä¼šç›´æ¥æ‰“åŒ…è¿›ç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå…·æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸã€‚è€Œ `format!` å®ä¼šå¯¹è¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ï¼Œæœ€ç»ˆç»“æœæ˜¯ä¸€ä¸ª `String` ç±»å‹ã€‚åœ¨è¿™é‡Œä½¿ç”¨ `stringify!` æœ‰ä¸¤ä¸ªå¥½å¤„:

- `#name` å¯èƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦å®ƒçš„å­—é¢å€¼å½¢å¼
- å¯ä»¥å‡å°‘ä¸€æ¬¡ `String` å¸¦æ¥çš„å†…å­˜åˆ†é…

åœ¨è¿è¡Œä¹‹å‰ï¼Œå¯ä»¥å…ˆç”¨ expand å±•å¼€å®ï¼Œè§‚å¯Ÿæ˜¯å¦æœ‰é”™è¯¯æˆ–ç¬¦åˆé¢„æœŸ:
```shell
$ cargo expand --bin hello_macro
```
```rust
struct Sunfei;
impl HelloMacro for Sunfei {
    fn hello_macro() {
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &["Hello, Macro! My name is ", "!\n"],
                    &[::core::fmt::ArgumentV1::new_display(&"Sunfei")],
                ),
            );
        };
    }
}
struct Sunface;
impl HelloMacro for Sunface {
    fn hello_macro() {
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &["Hello, Macro! My name is ", "!\n"],
                    &[::core::fmt::ArgumentV1::new_display(&"Sunface")],
                ),
            );
        };
    }
}
fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

ä»å±•å¼€çš„ä»£ç ä¹Ÿèƒ½çœ‹å‡ºderiveå®çš„ç‰¹æ€§ï¼Œ`struct Sunfei;` å’Œ `struct Sunface;` éƒ½è¢«ä¿ç•™äº†ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€å `impl_hello_macro()` è¿”å›çš„tokenè¢«åŠ åˆ°ç»“æ„ä½“åé¢ï¼Œè¿™å’Œç±»å±æ€§å®å¯ä»¥ä¿®æ”¹è¾“å…¥
çš„tokenæ˜¯ä¸ä¸€æ ·çš„ï¼Œinputçš„tokenå¹¶ä¸èƒ½è¢«ä¿®æ”¹ã€‚

è‡³æ­¤ï¼Œè¿‡ç¨‹å®çš„å®šä¹‰ã€ç‰¹å¾å®šä¹‰ã€ä¸»ä½“ä»£ç éƒ½å·²ç»å®Œæˆï¼Œè¿è¡Œä¸‹è¯•è¯•:

```shell
$ cargo run

     Running `target/debug/hello_macro`
Hello, Macro! My name is Sunfei!
Hello, Macro! My name is Sunface!
```

Bingoï¼Œè™½ç„¶è¿‡ç¨‹æœ‰äº›å¤æ‚ï¼Œä½†æ˜¯ç»“æœè¿˜æ˜¯å¾ˆå–œäººï¼Œæˆ‘ä»¬ç»ˆäºå®Œæˆäº†è‡ªå·±çš„ç¬¬ä¸€ä¸ªè¿‡ç¨‹å®ï¼

ä¸‹é¢æ¥å®ç°ä¸€ä¸ªæ›´å®ç”¨çš„ä¾‹å­ï¼Œå®ç°å®˜æ–¹çš„#[derive(Default)]å®ï¼ŒåºŸè¯ä¸è¯´ç›´æ¥å¼€å¹²:

```rust
extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{self, Data};
use syn::DeriveInput;

#[proc_macro_derive(MyDefault)]
pub fn my_default(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    let id = ast.ident;

    let Data::Struct(s) = ast.data else{
        panic!("MyDefault derive macro must use in struct");
    };

    // å£°æ˜ä¸€ä¸ªæ–°çš„astï¼Œç”¨äºåŠ¨æ€æ„å»ºå­—æ®µèµ‹å€¼çš„token
    let mut field_ast = quote!();

    // è¿™é‡Œå°±æ˜¯è¦åŠ¨æ€æ·»åŠ tokençš„åœ°æ–¹äº†ï¼Œéœ€è¦åŠ¨æ€å®ŒæˆSelfçš„å­—æ®µèµ‹å€¼
    for (idx,f) in s.fields.iter().enumerate() {
        let (field_id, field_ty) = (&f.ident, &f.ty);


        if field_id.is_none(){
             //æ²¡æœ‰identè¡¨ç¤ºæ˜¯åŒ¿åå­—æ®µï¼Œå¯¹äºåŒ¿åå­—æ®µï¼Œéƒ½éœ€è¦æ·»åŠ  `#field_idx: #field_type::default(),` è¿™æ ·çš„ä»£ç 
            let field_idx  = syn::Index::from(idx);
            field_ast.extend(quote! {
                # field_idx: # field_ty::default(),
            });
        }else{
            //å¯¹äºå‘½åå­—æ®µï¼Œéƒ½éœ€è¦æ·»åŠ  `#field_name: #field_type::default(),` è¿™æ ·çš„ä»£ç 
            field_ast.extend(quote! {
                # field_id: # field_ty::default(),
            });
        }
    }

    quote! {
        impl Default for # id {
            fn default() -> Self {
                Self {
                    # field_ast
                }
            }
        }
    }.into()
}
```

ç„¶åæ¥å†™ä½¿ç”¨ä»£ç :

```rust
#[derive(MyDefault)]
struct SomeData (u32,String);

#[derive(MyDefault)]
struct User {
    name: String,
    data: SomeData,
}

fn main() {

}
```

ç„¶åæˆ‘ä»¬å…ˆå±•å¼€ä»£ç çœ‹ä¸€çœ‹

```rust
struct SomeData(u32, String);
impl Default for SomeData {
    fn default() -> Self {
        Self {
            0: u32::default(),
            1: String::default(),
        }
    }
}
struct User {
    name: String,
    data: SomeData,
}
impl Default for User {
    fn default() -> Self {
        Self {
            name: String::default(),
            data: SomeData::default(),
        }
    }
}
fn main() {}
```

å±•å¼€çš„ä»£ç ç¬¦åˆé¢„æœŸï¼Œç„¶åæˆ‘ä»¬ä¿®æ”¹ä¸€ä¸‹ä½¿ç”¨ä»£ç å¹¶æµ‹è¯•ç»“æœ

```rust
#[derive(MyDefault, Debug)]
struct SomeData (u32,String);

#[derive(MyDefault, Debug)]
struct User {
    name: String,
    data: SomeData,
}

fn main() {
    println!("{:?}", User::default());
}
```

æ‰§è¡Œ

```shell
$ cargo run

    Running `target/debug/aaa`
User { name: "", data: SomeData(0, "") }
```



æ¥ä¸‹æ¥ï¼Œå†æ¥çœ‹çœ‹è¿‡ç¨‹å®çš„å¦å¤–ä¸¤ç§ç±»å‹è·Ÿ `derive` ç±»å‹æœ‰ä½•åŒºåˆ«ã€‚

## ç±»å±æ€§å®(Attribute-like macros)

ç±»å±æ€§è¿‡ç¨‹å®è·Ÿ `derive` å®ç±»ä¼¼ï¼Œä½†æ˜¯å‰è€…å…è®¸æˆ‘ä»¬å®šä¹‰è‡ªå·±çš„å±æ€§ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ`derive` åªèƒ½ç”¨äºç»“æ„ä½“å’Œæšä¸¾ï¼Œè€Œç±»å±æ€§å®å¯ä»¥ç”¨äºå…¶å®ƒç±»å‹é¡¹ï¼Œä¾‹å¦‚å‡½æ•°ã€‚

å‡è®¾æˆ‘ä»¬åœ¨å¼€å‘ä¸€ä¸ª `web` æ¡†æ¶ï¼Œå½“ç”¨æˆ·é€šè¿‡ `HTTP GET` è¯·æ±‚è®¿é—® `/` æ ¹è·¯å¾„æ—¶ï¼Œä½¿ç”¨ `index` å‡½æ•°ä¸ºå…¶æä¾›æœåŠ¡:

```rust
#[route(GET, "/")]
fn index() {
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œä»£ç åŠŸèƒ½éå¸¸æ¸…æ™°ã€ç®€æ´ï¼Œè¿™é‡Œçš„ `#[route]` å±æ€§å°±æ˜¯ä¸€ä¸ªè¿‡ç¨‹å®ï¼Œå®ƒçš„å®šä¹‰å‡½æ•°å¤§æ¦‚å¦‚ä¸‹ï¼š

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

ä¸ `derive` å®ä¸åŒï¼Œç±»å±æ€§å®çš„å®šä¹‰å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•°ï¼š

- ç¬¬ä¸€ä¸ªå‚æ•°æ—¶ç”¨äºè¯´æ˜å±æ€§åŒ…å«çš„å†…å®¹ï¼š`Get, "/"` éƒ¨åˆ†
- ç¬¬äºŒä¸ªæ˜¯å±æ€§æ‰€æ ‡æ³¨çš„ç±»å‹é¡¹ï¼Œåœ¨è¿™é‡Œæ˜¯ `fn index() {...}`ï¼Œæ³¨æ„ï¼Œå‡½æ•°ä½“ä¹Ÿè¢«åŒ…å«å…¶ä¸­

é™¤æ­¤ä¹‹å¤–ï¼Œç±»å±æ€§å®è·Ÿ `derive` å®çš„å·¥ä½œæ–¹å¼å¹¶æ— åŒºåˆ«ï¼šåˆ›å»ºä¸€ä¸ªåŒ…ï¼Œç±»å‹æ˜¯ `proc-macro`ï¼Œæ¥ç€å®ç°ä¸€ä¸ªå‡½æ•°ç”¨äºç”Ÿæˆæƒ³è¦çš„ä»£ç ã€‚

## ç±»å‡½æ•°å®(Function-like macros)

ç±»å‡½æ•°å®å¯ä»¥è®©æˆ‘ä»¬å®šä¹‰åƒå‡½æ•°é‚£æ ·è°ƒç”¨çš„å®ï¼Œä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œå®ƒè·Ÿå£°æ˜å® `macro_rules` è¾ƒä¸ºç±»ä¼¼ã€‚

åŒºåˆ«åœ¨äºï¼Œ`macro_rules` çš„å®šä¹‰å½¢å¼ä¸ `match` åŒ¹é…éå¸¸ç›¸åƒï¼Œè€Œç±»å‡½æ•°å®çš„å®šä¹‰å½¢å¼åˆ™ç±»ä¼¼äºä¹‹å‰è®²è¿‡çš„ä¸¤ç§è¿‡ç¨‹å®:

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

è€Œä½¿ç”¨å½¢å¼åˆ™ç±»ä¼¼äºå‡½æ•°è°ƒç”¨:

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

å¤§å®¶å¯èƒ½ä¼šå¥½å¥‡ï¼Œä¸ºä½•æˆ‘ä»¬ä¸ä½¿ç”¨å£°æ˜å® `macro_rules` æ¥å®šä¹‰å‘¢ï¼ŸåŸå› æ˜¯è¿™é‡Œéœ€è¦å¯¹ `SQL` è¯­å¥è¿›è¡Œè§£æå¹¶æ£€æŸ¥å…¶æ­£ç¡®æ€§ï¼Œè¿™ä¸ªå¤æ‚çš„è¿‡ç¨‹æ˜¯ `macro_rules` éš¾ä»¥å¯¹ä»˜çš„ï¼Œ**è€Œè¿‡ç¨‹å®ç›¸æ¯”èµ·æ¥å°±ä¼šçµæ´»çš„å¤š**ã€‚

## è¡¥å……å­¦ä¹ èµ„æ–™

1. [dtolnay/proc-macro-workshop](https://github.com/dtolnay/proc-macro-workshop)ï¼Œå­¦ä¹ å¦‚ä½•ç¼–å†™è¿‡ç¨‹å®
2. [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)ï¼Œå­¦ä¹ å¦‚ä½•ç¼–å†™å£°æ˜å® `macro_rules!`
3. [syn](https://crates.io/crates/syn) å’Œ [quote](https://crates.io/crates/quote) ï¼Œç”¨äºç¼–å†™è¿‡ç¨‹å®çš„åŒ…ï¼Œå®ƒä»¬çš„æ–‡æ¡£æœ‰å¾ˆå¤šå€¼å¾—å­¦ä¹ çš„ä¸œè¥¿
4. [Structuring, testing and debugging procedural macro crates](https://www.reddit.com/r/rust/comments/rjumsg/any_good_resources_for_learning_rust_macros/)ï¼Œä»æµ‹è¯•ã€debugã€ç»“æ„åŒ–çš„è§’åº¦æ¥ç¼–å†™è¿‡ç¨‹å®
5. [blog.turbo.fish](https://blog.turbo.fish)ï¼Œé‡Œé¢çš„è¿‡ç¨‹å®ç³»åˆ—æ–‡ç« å€¼å¾—ä¸€è¯»
6. [Rust å®å°å†Œä¸­æ–‡ç‰ˆ](https://zjp-cn.github.io/tlborm/)ï¼Œéå¸¸è¯¦ç»†çš„è§£é‡Šäº†å®å„ç§çŸ¥è¯†

## æ€»ç»“

Rust ä¸­çš„å®ä¸»è¦åˆ†ä¸ºä¸¤å¤§ç±»ï¼šå£°æ˜å®å’Œè¿‡ç¨‹å®ã€‚

å£°æ˜å®ç›®å‰ä½¿ç”¨ `macro_rules` è¿›è¡Œåˆ›å»ºï¼Œå®ƒçš„å½¢å¼ç±»ä¼¼äº `match` åŒ¹é…ï¼Œå¯¹äºç”¨æˆ·è€Œè¨€ï¼Œå¯è¯»æ€§å’Œç»´æŠ¤æ€§éƒ½è¾ƒå·®ã€‚ç”±äºå…¶å­˜åœ¨çš„é—®é¢˜å’Œé™åˆ¶ï¼Œåœ¨æœªæ¥ï¼Œ `macro_rules` ä¼šè¢« `deprecated`ï¼ŒRust ä¼šä½¿ç”¨ä¸€ä¸ªæ–°çš„å£°æ˜å®æ¥æ›¿ä»£å®ƒã€‚

è€Œè¿‡ç¨‹å®çš„å®šä¹‰æ›´åƒæ˜¯æˆ‘ä»¬å¹³æ—¶å†™å‡½æ•°çš„æ–¹å¼ï¼Œå› æ­¤å®ƒæ›´åŠ çµæ´»ï¼Œå®ƒåˆ†ä¸ºä¸‰ç§ç±»å‹ï¼š`derive` å®ã€ç±»å±æ€§å®ã€ç±»å‡½æ•°å®ï¼Œå…·ä½“åœ¨æ–‡ä¸­éƒ½æœ‰ä»‹ç»ã€‚

è™½ç„¶ Rust ä¸­çš„å®å¾ˆå¼ºå¤§ï¼Œä½†æ˜¯å®ƒå¹¶ä¸åº”è¯¥æˆä¸ºæˆ‘ä»¬çš„å¸¸è§„æ­¦å™¨ï¼ŒåŸå› æ˜¯å®ƒä¼šå½±å“ Rust ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œæˆ‘ç›¸ä¿¡æ²¡æœ‰å‡ ä¸ªäººæ„¿æ„å»ç»´æŠ¤åˆ«äººå†™çš„å® ï¼šï¼‰

å› æ­¤ï¼Œå¤§å®¶åº”è¯¥ç†Ÿæ‚‰å®çš„ä½¿ç”¨åœºæ™¯ï¼Œä½†æ˜¯ä¸è¦æ»¥ç”¨ï¼Œå½“ä½ çœŸçš„éœ€è¦æ—¶ï¼Œå†å›æ¥æŸ¥çœ‹æœ¬ç« äº†è§£å®ç°ç»†èŠ‚ï¼Œè¿™æ‰æ˜¯æœ€å®Œç¾çš„ä½¿ç”¨æ–¹å¼ã€‚



================================================
FILE: src/advance/simd.md
================================================
# SIMD

ç”±äº Rust æœ€æ–°ä¹Ÿæ˜¯ä¸‡ä¼—ç©ç›®çš„ `Portable SIMD` è¿˜æ²¡æœ‰å®Œå…¨æˆç†Ÿï¼Œåªèƒ½åœ¨ `nightly` ç‰ˆæœ¬ä¸­ä½¿ç”¨ï¼Œå› æ­¤åŠŸèƒ½ä¸Šå¯èƒ½è¿˜å­˜åœ¨å˜æ•°ï¼Œé‰´äºæ­¤ï¼Œæœ¬æ–‡ä¸ä¼šæ·±å…¥ä»‹ç»åœ¨ Rust ä¸­å¦‚ä½•ç¼–å†™ SIMD ä»£ç ï¼Œè€Œæ˜¯å°†ç›®å…‰èšé›†åœ¨ä¸¤ä¸ªç‚¹ä¸Šï¼šä½•ä¸º `SIMD` ä»¥åŠå…³äº `Portable SIMD` çš„ç®€å•ä»‹ç»ã€‚



================================================
FILE: src/advance/async/async-await.md
================================================
[Binary file]


================================================
FILE: src/advance/async/future-excuting.md
================================================
# åº•å±‚æ¢ç§˜: Future æ‰§è¡Œå™¨ä¸ä»»åŠ¡è°ƒåº¦

å¼‚æ­¥ç¼–ç¨‹èƒŒååˆ°åº•è—æœ‰ä»€ä¹ˆç§˜å¯†ï¼Ÿç©¶ç«Ÿæ˜¯å“ªåªå¹•åä¹‹æ‰‹åœ¨æ“çºµè¿™ä¸€åˆ‡ï¼Ÿå¦‚æœä½ å¯¹è¿™äº›æ„Ÿå…´è¶£ï¼Œå°±ç»§ç»­çœ‹ä¸‹å»ï¼Œå¦åˆ™å¯ä»¥ç›´æ¥è·³è¿‡ï¼Œå› ä¸ºæœ¬ç« èŠ‚çš„å†…å®¹å¯¹äºä¸€ä¸ª API å·¥ç¨‹å¸ˆå¹¶æ²¡æœ‰å¤ªå¤šå¸®åŠ©ã€‚

ä½†æ˜¯å¦‚æœä½ å¸Œæœ›èƒ½æ·±å…¥ç†è§£ `Rust` çš„ `async/.await` ä»£ç æ˜¯å¦‚ä½•å·¥ä½œã€ç†è§£è¿è¡Œæ—¶å’Œæ€§èƒ½ï¼Œç”šè‡³æœªæ¥æƒ³è¦æ„å»ºè‡ªå·±çš„ `async` è¿è¡Œæ—¶æˆ–ç›¸å…³å·¥å…·ï¼Œé‚£ä¹ˆæœ¬ç« èŠ‚ç»ˆç©¶ä¸ä¼šè¾œè´Ÿäºä½ ã€‚

## Future ç‰¹å¾

`Future` ç‰¹å¾æ˜¯ Rust å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒï¼Œæ¯•ç«Ÿå¼‚æ­¥å‡½æ•°æ˜¯å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒï¼Œè€Œ `Future` æ°æ°æ˜¯å¼‚æ­¥å‡½æ•°çš„è¿”å›å€¼å’Œè¢«æ‰§è¡Œçš„å…³é”®ã€‚

é¦–å…ˆï¼Œæ¥ç»™å‡º `Future` çš„å®šä¹‰ï¼šå®ƒæ˜¯ä¸€ä¸ªèƒ½äº§å‡ºå€¼çš„å¼‚æ­¥è®¡ç®—(è™½ç„¶è¯¥å€¼å¯èƒ½ä¸ºç©ºï¼Œä¾‹å¦‚ `()` )ã€‚å…‰çœ‹è¿™ä¸ªå®šä¹‰ï¼Œå¯èƒ½ä¼šè§‰å¾—å¾ˆç©ºæ´ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ä¸€ä¸ªç®€åŒ–ç‰ˆçš„ `Future` ç‰¹å¾:

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}
```

åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬æåˆ°è¿‡ `Future` éœ€è¦è¢«æ‰§è¡Œå™¨`poll`(è½®è¯¢)åæ‰èƒ½è¿è¡Œï¼Œè¯ºï¼Œè¿™é‡Œ `poll` å°±æ¥äº†ï¼Œé€šè¿‡è°ƒç”¨è¯¥æ–¹æ³•ï¼Œå¯ä»¥æ¨è¿› `Future` çš„è¿›ä¸€æ­¥æ‰§è¡Œï¼Œç›´åˆ°è¢«åˆ‡èµ°ä¸ºæ­¢( è¿™é‡Œä¸å¥½ç†è§£ï¼Œä½†æ˜¯ä½ åªéœ€è¦çŸ¥é“ `Future` å¹¶ä¸èƒ½ä¿è¯åœ¨ä¸€æ¬¡ `poll` ä¸­å°±è¢«æ‰§è¡Œå®Œï¼Œåé¢ä¼šè¯¦è§£ä»‹ç»)ã€‚

è‹¥åœ¨å½“å‰ `poll` ä¸­ï¼Œ `Future` å¯ä»¥è¢«å®Œæˆï¼Œåˆ™ä¼šè¿”å› `Poll::Ready(result)` ï¼Œåä¹‹åˆ™è¿”å› `Poll::Pending`ï¼Œ å¹¶ä¸”å®‰æ’ä¸€ä¸ª `wake` å‡½æ•°ï¼šå½“æœªæ¥ `Future` å‡†å¤‡å¥½è¿›ä¸€æ­¥æ‰§è¡Œæ—¶ï¼Œ è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œç„¶åç®¡ç†è¯¥ `Future` çš„æ‰§è¡Œå™¨(ä¾‹å¦‚ä¸Šä¸€ç« èŠ‚ä¸­çš„`block_on`å‡½æ•°)ä¼šå†æ¬¡è°ƒç”¨ `poll` æ–¹æ³•ï¼Œæ­¤æ—¶ `Future` å°±å¯ä»¥ç»§ç»­æ‰§è¡Œäº†ã€‚

å¦‚æœæ²¡æœ‰ `wake` æ–¹æ³•ï¼Œé‚£æ‰§è¡Œå™¨æ— æ³•çŸ¥é“æŸä¸ª `Future` æ˜¯å¦å¯ä»¥ç»§ç»­è¢«æ‰§è¡Œï¼Œé™¤éæ‰§è¡Œå™¨å®šæœŸçš„è½®è¯¢æ¯ä¸€ä¸ª `Future`ï¼Œç¡®è®¤å®ƒæ˜¯å¦èƒ½è¢«æ‰§è¡Œï¼Œä½†è¿™ç§ä½œæ³•æ•ˆç‡è¾ƒä½ã€‚è€Œæœ‰äº† `wake`ï¼Œ`Future` å°±å¯ä»¥ä¸»åŠ¨é€šçŸ¥æ‰§è¡Œå™¨ï¼Œç„¶åæ‰§è¡Œå™¨å°±å¯ä»¥ç²¾ç¡®çš„æ‰§è¡Œè¯¥ `Future`ã€‚ è¿™ç§â€œäº‹ä»¶é€šçŸ¥ -> æ‰§è¡Œâ€çš„æ–¹å¼è¦è¿œæ¯”å®šæœŸå¯¹æ‰€æœ‰ `Future` è¿›è¡Œä¸€æ¬¡å…¨éå†æ¥çš„é«˜æ•ˆã€‚

ä¹Ÿè®¸å¤§å®¶è¿˜æ˜¯è¿·è¿·ç³Šç³Šçš„ï¼Œæ²¡äº‹ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªä¾‹å­æ¥è¯´æ˜ä¸‹ã€‚è€ƒè™‘ä¸€ä¸ªéœ€è¦ä» `socket` è¯»å–æ•°æ®çš„åœºæ™¯ï¼šå¦‚æœæœ‰æ•°æ®ï¼Œå¯ä»¥ç›´æ¥è¯»å–æ•°æ®å¹¶è¿”å› `Poll::Ready(data)`ï¼Œ ä½†å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œ`Future` ä¼šè¢«é˜»å¡ä¸”ä¸ä¼šå†ç»§ç»­æ‰§è¡Œï¼Œæ­¤æ—¶å®ƒä¼šæ³¨å†Œä¸€ä¸ª `wake` å‡½æ•°ï¼Œå½“ `socket` æ•°æ®å‡†å¤‡å¥½æ—¶ï¼Œè¯¥å‡½æ•°å°†è¢«è°ƒç”¨ä»¥é€šçŸ¥æ‰§è¡Œå™¨ï¼šæˆ‘ä»¬çš„ `Future` å·²ç»å‡†å¤‡å¥½äº†ï¼Œå¯ä»¥ç»§ç»­æ‰§è¡Œã€‚

ä¸‹é¢çš„ `SocketRead` ç»“æ„ä½“å°±æ˜¯ä¸€ä¸ª `Future`:

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socketæœ‰æ•°æ®ï¼Œå†™å…¥bufferä¸­å¹¶è¿”å›
            Poll::Ready(self.socket.read_buf())
        } else {
            // socketä¸­è¿˜æ²¡æ•°æ®
            //
            // æ³¨å†Œä¸€ä¸ª`wake`å‡½æ•°ï¼Œå½“æ•°æ®å¯ç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œ
            // ç„¶åå½“å‰Futureçš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨`poll`æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥è¯»å–åˆ°æ•°æ®
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

è¿™ç§ `Future` æ¨¡å‹å…è®¸å°†å¤šä¸ªå¼‚æ­¥æ“ä½œç»„åˆåœ¨ä¸€èµ·ï¼ŒåŒæ—¶è¿˜æ— éœ€ä»»ä½•å†…å­˜åˆ†é…ã€‚ä¸ä»…ä»…å¦‚æ­¤ï¼Œå¦‚æœä½ éœ€è¦åŒæ—¶è¿è¡Œå¤šä¸ª `Future`æˆ–é“¾å¼è°ƒç”¨å¤šä¸ª `Future` ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ— å†…å­˜åˆ†é…çš„çŠ¶æ€æœºå®ç°ï¼Œä¾‹å¦‚ï¼š

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

/// ä¸€ä¸ªSimpleFutureï¼Œå®ƒä¼šå¹¶å‘åœ°è¿è¡Œä¸¤ä¸ªFutureç›´åˆ°å®ƒä»¬å®Œæˆ
///
/// ä¹‹æ‰€ä»¥å¯ä»¥å¹¶å‘ï¼Œæ˜¯å› ä¸ºä¸¤ä¸ªFutureçš„è½®è¯¢å¯ä»¥äº¤æ›¿è¿›è¡Œï¼Œä¸€ä¸ªé˜»å¡ï¼Œå¦ä¸€ä¸ªå°±å¯ä»¥ç«‹åˆ»æ‰§è¡Œï¼Œåä¹‹äº¦ç„¶
pub struct Join<FutureA, FutureB> {
    // ç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µéƒ½åŒ…å«ä¸€ä¸ªFutureï¼Œå¯ä»¥è¿è¡Œç›´åˆ°å®Œæˆ.
    // ç­‰åˆ°Futureå®Œæˆåï¼Œå­—æ®µä¼šè¢«è®¾ç½®ä¸º `None`. è¿™æ ·Futureå®Œæˆåï¼Œå°±ä¸ä¼šå†è¢«è½®è¯¢
    a: Option<FutureA>,
    b: Option<FutureB>,
}

impl<FutureA, FutureB> SimpleFuture for Join<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        // å°è¯•å»å®Œæˆä¸€ä¸ª Future `a`
        if let Some(a) = &mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // å°è¯•å»å®Œæˆä¸€ä¸ª Future `b`
        if let Some(b) = &mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() && self.b.is_none() {
            // ä¸¤ä¸ª Futureéƒ½å·²å®Œæˆ - æˆ‘ä»¬å¯ä»¥æˆåŠŸåœ°è¿”å›äº†
            Poll::Ready(())
        } else {
            // è‡³å°‘è¿˜æœ‰ä¸€ä¸ª Future æ²¡æœ‰å®Œæˆä»»åŠ¡ï¼Œå› æ­¤è¿”å› `Poll::Pending`.
            // å½“è¯¥ Future å†æ¬¡å‡†å¤‡å¥½æ—¶ï¼Œé€šè¿‡è°ƒç”¨`wake()`å‡½æ•°æ¥ç»§ç»­æ‰§è¡Œ
            Poll::Pending
        }
    }
}
```

ä¸Šé¢ä»£ç å±•ç¤ºäº†å¦‚ä½•åŒæ—¶è¿è¡Œå¤šä¸ª `Future`ï¼Œ ä¸”åœ¨æ­¤è¿‡ç¨‹ä¸­æ²¡æœ‰ä»»ä½•å†…å­˜åˆ†é…ï¼Œè®©å¹¶å‘ç¼–ç¨‹æ›´åŠ é«˜æ•ˆã€‚ ç±»ä¼¼çš„ï¼Œå¤šä¸ª`Future`ä¹Ÿå¯ä»¥ä¸€ä¸ªæ¥ä¸€ä¸ªçš„è¿ç»­è¿è¡Œï¼š

```rust
/// ä¸€ä¸ªSimpleFuture, å®ƒä½¿ç”¨é¡ºåºçš„æ–¹å¼ï¼Œä¸€ä¸ªæ¥ä¸€ä¸ªåœ°è¿è¡Œä¸¤ä¸ªFuture
//
// æ³¨æ„: ç”±äºæœ¬ä¾‹å­ç”¨äºæ¼”ç¤ºï¼Œå› æ­¤åŠŸèƒ½ç®€å•ï¼Œ`AndThenFut` ä¼šå‡è®¾ä¸¤ä¸ª Future åœ¨åˆ›å»ºæ—¶å°±å¯ç”¨äº†.
// è€ŒçœŸå®çš„`Andthen`å…è®¸æ ¹æ®ç¬¬ä¸€ä¸ª`Future`çš„è¾“å‡ºæ¥åˆ›å»ºç¬¬äºŒä¸ª`Future`ï¼Œå› æ­¤å¤æ‚çš„å¤šã€‚
pub struct AndThenFut<FutureA, FutureB> {
    first: Option<FutureA>,
    second: FutureB,
}

impl<FutureA, FutureB> SimpleFuture for AndThenFut<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(first) = &mut self.first {
            match first.poll(wake) {
                // æˆ‘ä»¬å·²ç»å®Œæˆäº†ç¬¬ä¸€ä¸ª Futureï¼Œ å¯ä»¥å°†å®ƒç§»é™¤ï¼Œ ç„¶åå‡†å¤‡å¼€å§‹è¿è¡Œç¬¬äºŒä¸ª
                Poll::Ready(()) => self.first.take(),
                // ç¬¬ä¸€ä¸ª Future è¿˜ä¸èƒ½å®Œæˆ
                Poll::Pending => return Poll::Pending,
            };
        }

        // è¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ç¬¬ä¸€ä¸ªFutureå·²ç»å®Œæˆï¼Œå°è¯•å»å®Œæˆç¬¬äºŒä¸ª
        self.second.poll(wake)
    }
}
```

è¿™äº›ä¾‹å­å±•ç¤ºäº†åœ¨ä¸éœ€è¦å†…å­˜å¯¹è±¡åˆ†é…ä»¥åŠæ·±å±‚åµŒå¥—å›è°ƒçš„æƒ…å†µä¸‹ï¼Œè¯¥å¦‚ä½•ä½¿ç”¨ `Future` ç‰¹å¾å»è¡¨è¾¾å¼‚æ­¥æ§åˆ¶æµã€‚ åœ¨äº†è§£äº†åŸºç¡€çš„æ§åˆ¶æµåï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹çœŸå®çš„ `Future` ç‰¹å¾æœ‰ä½•ä¸åŒä¹‹å¤„ã€‚

```rust
trait Future {
    type Output;
    fn poll(
        // é¦–å…ˆå€¼å¾—æ³¨æ„çš„åœ°æ–¹æ˜¯ï¼Œ`self`çš„ç±»å‹ä»`&mut self`å˜æˆäº†`Pin<&mut Self>`:
        self: Pin<&mut Self>,
        // å…¶æ¬¡å°†`wake: fn()` ä¿®æ”¹ä¸º `cx: &mut Context<'_>`:
        cx: &mut Context<'_>,
    ) -> Poll<Self::Output>;
}
```

é¦–å…ˆè¿™é‡Œå¤šäº†ä¸€ä¸ª `Pin` ï¼Œå…³äºå®ƒæˆ‘ä»¬ä¼šåœ¨åé¢ç« èŠ‚è¯¦ç»†ä»‹ç»ï¼Œç°åœ¨ä½ åªéœ€è¦çŸ¥é“ä½¿ç”¨å®ƒå¯ä»¥åˆ›å»ºä¸€ä¸ªæ— æ³•è¢«ç§»åŠ¨çš„ `Future` ï¼Œå› ä¸ºæ— æ³•è¢«ç§»åŠ¨ï¼Œæ‰€ä»¥å®ƒå°†å…·æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œæ„å‘³ç€æˆ‘ä»¬å¯ä»¥å­˜å‚¨å®ƒçš„æŒ‡é’ˆ(å¦‚æœå†…å­˜åœ°å€å¯èƒ½ä¼šå˜åŠ¨ï¼Œé‚£å­˜å‚¨æŒ‡é’ˆåœ°å€å°†æ¯«æ— æ„ä¹‰ï¼)ï¼Œä¹Ÿæ„å‘³ç€å¯ä»¥å®ç°ä¸€ä¸ªè‡ªå¼•ç”¨æ•°æ®ç»“æ„: `struct MyFut { a: i32, ptr_to_a: *const i32 }`ã€‚ è€Œå¯¹äº `async/await` æ¥è¯´ï¼Œ`Pin` æ˜¯ä¸å¯æˆ–ç¼ºçš„å…³é”®ç‰¹æ€§ã€‚

å…¶æ¬¡ï¼Œä» `wake: fn()` å˜æˆäº† `&mut Context<'_>` ã€‚æ„å‘³ç€ `wake` å‡½æ•°å¯ä»¥æºå¸¦æ•°æ®äº†ï¼Œä¸ºä½•è¦æºå¸¦æ•°æ®ï¼Ÿè€ƒè™‘ä¸€ä¸ªçœŸå®ä¸–ç•Œçš„åœºæ™¯ï¼Œä¸€ä¸ªå¤æ‚åº”ç”¨ä¾‹å¦‚ web æœåŠ¡å™¨å¯èƒ½æœ‰æ•°åƒè¿æ¥åŒæ—¶åœ¨çº¿ï¼Œé‚£ä¹ˆåŒæ—¶å°±æœ‰æ•°åƒ `Future` åœ¨è¢«åŒæ—¶ç®¡ç†ç€ï¼Œå¦‚æœä¸èƒ½æºå¸¦æ•°æ®ï¼Œå½“ä¸€ä¸ª `Future` è°ƒç”¨ `wake` åï¼Œæ‰§è¡Œå™¨è¯¥å¦‚ä½•çŸ¥é“æ˜¯å“ªä¸ª `Future` è°ƒç”¨äº† `wake` ,ç„¶åè¿›ä¸€æ­¥å» `poll` å¯¹åº”çš„ `Future` ï¼Ÿæ²¡æœ‰åŠæ³•ï¼é‚£ä¹‹å‰çš„ä¾‹å­ä¸ºå•¥å°±å¯ä»¥ä½¿ç”¨æ²¡æœ‰æºå¸¦æ•°æ®çš„ `wake` ï¼Ÿ å› ä¸ºè¶³å¤Ÿç®€å•ï¼Œä¸å­˜åœ¨æ­§ä¹‰æ€§ã€‚

æ€»ä¹‹ï¼Œåœ¨æ­£å¼åœºæ™¯è¦è¿›è¡Œ `wake` ï¼Œå°±å¿…é¡»æºå¸¦ä¸Šæ•°æ®ã€‚ è€Œ `Context` ç±»å‹é€šè¿‡æä¾›ä¸€ä¸ª `Waker` ç±»å‹çš„å€¼ï¼Œå°±å¯ä»¥ç”¨æ¥å”¤é†’ç‰¹å®šçš„çš„ä»»åŠ¡ã€‚

## ä½¿ç”¨ Waker æ¥å”¤é†’ä»»åŠ¡

å¯¹äº `Future` æ¥è¯´ï¼Œç¬¬ä¸€æ¬¡è¢« `poll` æ—¶æ— æ³•å®Œæˆä»»åŠ¡æ˜¯å¾ˆæ­£å¸¸çš„ã€‚ä½†å®ƒéœ€è¦ç¡®ä¿åœ¨æœªæ¥ä¸€æ—¦å‡†å¤‡å¥½æ—¶ï¼Œå¯ä»¥é€šçŸ¥æ‰§è¡Œå™¨å†æ¬¡å¯¹å…¶è¿›è¡Œ `poll` è¿›è€Œç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œè¯¥é€šçŸ¥å°±æ˜¯é€šè¿‡ `Waker` ç±»å‹å®Œæˆçš„ã€‚

`Waker` æä¾›äº†ä¸€ä¸ª `wake()` æ–¹æ³•å¯ä»¥ç”¨äºå‘Šè¯‰æ‰§è¡Œå™¨ï¼šç›¸å…³çš„ä»»åŠ¡å¯ä»¥è¢«å”¤é†’äº†ï¼Œæ­¤æ—¶æ‰§è¡Œå™¨å°±å¯ä»¥å¯¹ç›¸åº”çš„ `Future` å†æ¬¡è¿›è¡Œ `poll` æ“ä½œã€‚

#### æ„å»ºä¸€ä¸ªå®šæ—¶å™¨

ä¸‹é¢ä¸€èµ·æ¥å®ç°ä¸€ä¸ªç®€å•çš„å®šæ—¶å™¨ `Future` ã€‚ä¸ºäº†è®©ä¾‹å­å°½é‡ç®€å•ï¼Œå½“è®¡æ—¶å™¨åˆ›å»ºæ—¶ï¼Œæˆ‘ä»¬ä¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥ç€è®©è¯¥çº¿ç¨‹è¿›å…¥ç¡çœ ï¼Œç­‰ç¡çœ ç»“æŸåå†é€šçŸ¥ç»™ `Future` ã€‚

æ³¨æ„æœ¬ä¾‹å­è¿˜ä¼šåœ¨åé¢ç»§ç»­ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬é‡æ–°åˆ›å»ºä¸€ä¸ªå·¥ç¨‹æ¥æ¼”ç¤ºï¼šä½¿ç”¨ `cargo new --lib timer_future` æ¥åˆ›å»ºä¸€ä¸ªæ–°å·¥ç¨‹ï¼Œåœ¨ `lib` åŒ…çš„æ ¹è·¯å¾„ `src/lib.rs` ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š

```rust
use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
```

ç»§ç»­æ¥å®ç° `Future` å®šæ—¶å™¨ï¼Œä¹‹å‰æåˆ°: æ–°å»ºçº¿ç¨‹åœ¨ç¡çœ ç»“æŸåä¼šéœ€è¦å°†çŠ¶æ€åŒæ­¥ç»™å®šæ—¶å™¨ `Future` ï¼Œç”±äºæ˜¯å¤šçº¿ç¨‹ç¯å¢ƒï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ `Arc<Mutex<T>>` æ¥ä½œä¸ºä¸€ä¸ªå…±äº«çŠ¶æ€ï¼Œç”¨äºåœ¨æ–°çº¿ç¨‹å’Œ `Future` å®šæ—¶å™¨é—´å…±äº«ã€‚

```rust
pub struct TimerFuture {
    shared_state: Arc<Mutex<SharedState>>,
}

/// åœ¨Futureå’Œç­‰å¾…çš„çº¿ç¨‹é—´å…±äº«çŠ¶æ€
struct SharedState {
    /// å®šæ—¶(ç¡çœ )æ˜¯å¦ç»“æŸ
    completed: bool,

    /// å½“ç¡çœ ç»“æŸåï¼Œçº¿ç¨‹å¯ä»¥ç”¨`waker`é€šçŸ¥`TimerFuture`æ¥å”¤é†’ä»»åŠ¡
    waker: Option<Waker>,
}
```

ä¸‹é¢ç»™å‡º `Future` çš„å…·ä½“å®ç°:

```rust
impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // é€šè¿‡æ£€æŸ¥å…±äº«çŠ¶æ€ï¼Œæ¥ç¡®å®šå®šæ—¶å™¨æ˜¯å¦å·²ç»å®Œæˆ
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // è®¾ç½®`waker`ï¼Œè¿™æ ·æ–°çº¿ç¨‹åœ¨ç¡çœ (è®¡æ—¶)ç»“æŸåå¯ä»¥å”¤é†’å½“å‰çš„ä»»åŠ¡ï¼Œæ¥ç€å†æ¬¡å¯¹`Future`è¿›è¡Œ`poll`æ“ä½œ,
            //
            // ä¸‹é¢çš„`clone`æ¯æ¬¡è¢«`poll`æ—¶éƒ½ä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œå®é™…ä¸Šï¼Œåº”è¯¥æ˜¯åª`clone`ä¸€æ¬¡æ›´åŠ åˆç†ã€‚
            // é€‰æ‹©æ¯æ¬¡éƒ½`clone`çš„åŸå› æ˜¯ï¼š `TimerFuture`å¯ä»¥åœ¨æ‰§è¡Œå™¨çš„ä¸åŒä»»åŠ¡é—´ç§»åŠ¨ï¼Œå¦‚æœåªå…‹éš†ä¸€æ¬¡ï¼Œ
            // é‚£ä¹ˆè·å–åˆ°çš„`waker`å¯èƒ½å·²ç»è¢«ç¯¡æ”¹å¹¶æŒ‡å‘äº†å…¶å®ƒä»»åŠ¡ï¼Œæœ€ç»ˆå¯¼è‡´æ‰§è¡Œå™¨è¿è¡Œäº†é”™è¯¯çš„ä»»åŠ¡
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
```

ä»£ç å¾ˆç®€å•ï¼Œåªè¦æ–°çº¿ç¨‹è®¾ç½®äº† `shared_state.completed = true` ï¼Œé‚£ä»»åŠ¡å°±èƒ½é¡ºåˆ©ç»“æŸã€‚å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œä¼šä¸ºå½“å‰çš„ä»»åŠ¡å…‹éš†ä¸€ä»½ `Waker` ï¼Œè¿™æ ·æ–°çº¿ç¨‹å°±å¯ä»¥ä½¿ç”¨å®ƒæ¥å”¤é†’å½“å‰çš„ä»»åŠ¡ã€‚

æœ€åï¼Œå†æ¥åˆ›å»ºä¸€ä¸ª API ç”¨äºæ„å»ºå®šæ—¶å™¨å’Œå¯åŠ¨è®¡æ—¶çº¿ç¨‹:

```rust
impl TimerFuture {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„`TimerFuture`ï¼Œåœ¨æŒ‡å®šçš„æ—¶é—´ç»“æŸåï¼Œè¯¥`Future`å¯ä»¥å®Œæˆ
    pub fn new(duration: Duration) -> Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // åˆ›å»ºæ–°çº¿ç¨‹
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            // ç¡çœ æŒ‡å®šæ—¶é—´å®ç°è®¡æ—¶åŠŸèƒ½
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // é€šçŸ¥æ‰§è¡Œå™¨å®šæ—¶å™¨å·²ç»å®Œæˆï¼Œå¯ä»¥ç»§ç»­`poll`å¯¹åº”çš„`Future`äº†
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
```

è‡³æ­¤ï¼Œä¸€ä¸ªç®€å•çš„å®šæ—¶å™¨ `Future` å°±å·²åˆ›å»ºæˆåŠŸï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•ä½¿ç”¨å®ƒå‘¢ï¼Ÿç›¸ä¿¡éƒ¨åˆ†çˆ±åŠ¨è„‘ç­‹çš„è¯»è€…å·²ç»çŒœåˆ°äº†ï¼šæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ‰§è¡Œå™¨ï¼Œæ‰èƒ½è®©ç¨‹åºåŠ¨èµ·æ¥ã€‚

## æ‰§è¡Œå™¨ Executor

Rust çš„ `Future` æ˜¯æƒ°æ€§çš„ï¼šåªæœ‰å±è‚¡ä¸Šæ‹ä¸€æ‹ï¼Œå®ƒæ‰ä¼šåŠªåŠ›åŠ¨ä¸€åŠ¨ã€‚å…¶ä¸­ä¸€ä¸ªæ¨åŠ¨å®ƒçš„æ–¹å¼å°±æ˜¯åœ¨ `async` å‡½æ•°ä¸­ä½¿ç”¨ `.await` æ¥è°ƒç”¨å¦ä¸€ä¸ª `async` å‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸ªåªèƒ½è§£å†³ `async` å†…éƒ¨çš„é—®é¢˜ï¼Œé‚£ä¹ˆè¿™äº›æœ€å¤–å±‚çš„ `async` å‡½æ•°ï¼Œè°æ¥æ¨åŠ¨å®ƒä»¬è¿è¡Œå‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯æˆ‘ä»¬ä¹‹å‰å¤šæ¬¡æåˆ°çš„æ‰§è¡Œå™¨ `executor` ã€‚

æ‰§è¡Œå™¨ä¼šç®¡ç†ä¸€æ‰¹ `Future` (æœ€å¤–å±‚çš„ `async` å‡½æ•°)ï¼Œç„¶åé€šè¿‡ä¸åœåœ° `poll` æ¨åŠ¨å®ƒä»¬ç›´åˆ°å®Œæˆã€‚ æœ€å¼€å§‹ï¼Œæ‰§è¡Œå™¨ä¼šå…ˆ `poll` ä¸€æ¬¡ `Future` ï¼Œåé¢å°±ä¸ä¼šä¸»åŠ¨å» `poll` äº†ï¼Œè€Œæ˜¯ç­‰å¾… `Future` é€šè¿‡è°ƒç”¨ `wake` å‡½æ•°æ¥é€šçŸ¥å®ƒå¯ä»¥ç»§ç»­ï¼Œå®ƒæ‰ä¼šç»§ç»­å» `poll` ã€‚è¿™ç§ **wake é€šçŸ¥ç„¶å poll** çš„æ–¹å¼ä¼šä¸æ–­é‡å¤ï¼Œç›´åˆ° `Future` å®Œæˆã€‚

#### æ„å»ºæ‰§è¡Œå™¨

ä¸‹é¢æˆ‘ä»¬å°†å®ç°ä¸€ä¸ªç®€å•çš„æ‰§è¡Œå™¨ï¼Œå®ƒå¯ä»¥åŒæ—¶å¹¶å‘è¿è¡Œå¤šä¸ª `Future` ã€‚ä¾‹å­ä¸­ï¼Œéœ€è¦ç”¨åˆ° `futures` åŒ…çš„ `ArcWake` ç‰¹å¾ï¼Œå®ƒå¯ä»¥æä¾›ä¸€ä¸ªæ–¹ä¾¿çš„é€”å¾„å»æ„å»ºä¸€ä¸ª `Waker` ã€‚ç¼–è¾‘ `Cargo.toml` ï¼Œæ·»åŠ ä¸‹é¢ä¾èµ–:

```rust
[dependencies]
futures = "0.3"
```

åœ¨ä¹‹å‰çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬åœ¨ `src/lib.rs` ä¸­åˆ›å»ºäº†å®šæ—¶å™¨ `Future` ï¼Œç°åœ¨åœ¨ `src/main.rs` ä¸­æ¥åˆ›å»ºç¨‹åºçš„ä¸»ä½“å†…å®¹ï¼Œå¼€å§‹ä¹‹å‰ï¼Œå…ˆå¼•å…¥æ‰€éœ€çš„åŒ…ï¼š

```rust
use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // å¼•å…¥ä¹‹å‰å®ç°çš„å®šæ—¶å™¨æ¨¡å—
    timer_future::TimerFuture,
};
```

æ‰§è¡Œå™¨éœ€è¦ä»ä¸€ä¸ªæ¶ˆæ¯é€šé“( `channel` )ä¸­æ‹‰å–äº‹ä»¶ï¼Œç„¶åè¿è¡Œå®ƒä»¬ã€‚å½“ä¸€ä¸ªä»»åŠ¡å‡†å¤‡å¥½åï¼ˆå¯ä»¥ç»§ç»­æ‰§è¡Œï¼‰ï¼Œå®ƒä¼šå°†è‡ªå·±æ”¾å…¥æ¶ˆæ¯é€šé“ä¸­ï¼Œç„¶åç­‰å¾…æ‰§è¡Œå™¨ `poll` ã€‚

```rust
/// ä»»åŠ¡æ‰§è¡Œå™¨ï¼Œè´Ÿè´£ä»é€šé“ä¸­æ¥æ”¶ä»»åŠ¡ç„¶åæ‰§è¡Œ
struct Executor {
    ready_queue: Receiver<Arc<Task>>,
}

/// `Spawner`è´Ÿè´£åˆ›å»ºæ–°çš„`Future`ç„¶åå°†å®ƒå‘é€åˆ°ä»»åŠ¡é€šé“ä¸­
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender<Arc<Task>>,
}

/// ä¸€ä¸ªFutureï¼Œå®ƒå¯ä»¥è°ƒåº¦è‡ªå·±(å°†è‡ªå·±æ”¾å…¥ä»»åŠ¡é€šé“ä¸­)ï¼Œç„¶åç­‰å¾…æ‰§è¡Œå™¨å»`poll`
struct Task {
    /// è¿›è¡Œä¸­çš„Futureï¼Œåœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹ä¼šè¢«å®Œæˆ
    ///
    /// æŒ‰ç†æ¥è¯´`Mutex`åœ¨è¿™é‡Œæ˜¯å¤šä½™çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚ä½†æ˜¯ç”±äº
    /// Rustå¹¶ä¸èªæ˜ï¼Œå®ƒæ— æ³•çŸ¥é“`Future`åªä¼šåœ¨ä¸€ä¸ªçº¿ç¨‹å†…è¢«ä¿®æ”¹ï¼Œå¹¶ä¸ä¼šè¢«è·¨çº¿ç¨‹ä¿®æ”¹ã€‚å› æ­¤
    /// æˆ‘ä»¬éœ€è¦ä½¿ç”¨`Mutex`æ¥æ»¡è¶³è¿™ä¸ªç¬¨ç¬¨çš„ç¼–è¯‘å™¨å¯¹çº¿ç¨‹å®‰å…¨çš„æ‰§ç€ã€‚
    ///
    /// å¦‚æœæ˜¯ç”Ÿäº§çº§çš„æ‰§è¡Œå™¨å®ç°ï¼Œä¸ä¼šä½¿ç”¨`Mutex`ï¼Œå› ä¸ºä¼šå¸¦æ¥æ€§èƒ½ä¸Šçš„å¼€é”€ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯ä½¿ç”¨`UnsafeCell`
    future: Mutex<Option<BoxFuture<'static, ()>>>,

    /// å¯ä»¥å°†è¯¥ä»»åŠ¡è‡ªèº«æ”¾å›åˆ°ä»»åŠ¡é€šé“ä¸­ï¼Œç­‰å¾…æ‰§è¡Œå™¨çš„poll
    task_sender: SyncSender<Arc<Task>>,
}

fn new_executor_and_spawner() -> (Executor, Spawner) {
    // ä»»åŠ¡é€šé“å…è®¸çš„æœ€å¤§ç¼“å†²æ•°(ä»»åŠ¡é˜Ÿåˆ—çš„æœ€å¤§é•¿åº¦)
    // å½“å‰çš„å®ç°ä»…ä»…æ˜¯ä¸ºäº†ç®€å•ï¼Œåœ¨å®é™…çš„æ‰§è¡Œä¸­ï¼Œå¹¶ä¸ä¼šè¿™ä¹ˆä½¿ç”¨
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
```

ä¸‹é¢å†æ¥æ·»åŠ ä¸€ä¸ªæ–¹æ³•ç”¨äºç”Ÿæˆ `Future` , ç„¶åå°†å®ƒæ”¾å…¥ä»»åŠ¡é€šé“ä¸­:

```rust
impl Spawner {
    fn spawn(&self, future: impl Future<Output = ()> + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect("ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡");
    }
}
```

åœ¨æ‰§è¡Œå™¨ `poll` ä¸€ä¸ª `Future` ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦è°ƒç”¨ `wake` æ–¹æ³•è¿›è¡Œå”¤é†’ï¼Œç„¶åå†ç”± `Waker` è´Ÿè´£è°ƒåº¦è¯¥ä»»åŠ¡å¹¶å°†å…¶æ”¾å…¥ä»»åŠ¡é€šé“ä¸­ã€‚åˆ›å»º `Waker` çš„æœ€ç®€å•çš„æ–¹å¼å°±æ˜¯å®ç° `ArcWake` ç‰¹å¾ï¼Œå…ˆæ¥ä¸ºæˆ‘ä»¬çš„ä»»åŠ¡å®ç° `ArcWake` ç‰¹å¾ï¼Œè¿™æ ·å®ƒä»¬å°±èƒ½è¢«è½¬å˜æˆ `Waker` ç„¶åè¢«å”¤é†’:

```rust
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        // é€šè¿‡å‘é€ä»»åŠ¡åˆ°ä»»åŠ¡ç®¡é“çš„æ–¹å¼æ¥å®ç°`wake`ï¼Œè¿™æ ·`wake`åï¼Œä»»åŠ¡å°±èƒ½è¢«æ‰§è¡Œå™¨`poll`
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect("ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡");
    }
}
```

å½“ä»»åŠ¡å®ç°äº† `ArcWake` ç‰¹å¾åï¼Œå®ƒå°±å˜æˆäº† `Waker` ï¼Œåœ¨è°ƒç”¨ `wake()` å¯¹å…¶å”¤é†’åä¼šå°†ä»»åŠ¡å¤åˆ¶ä¸€ä»½æ‰€æœ‰æƒ( `Arc` )ï¼Œç„¶åå°†å…¶å‘é€åˆ°ä»»åŠ¡é€šé“ä¸­ã€‚æœ€åæˆ‘ä»¬çš„æ‰§è¡Œå™¨å°†ä»é€šé“ä¸­è·å–ä»»åŠ¡ï¼Œç„¶åè¿›è¡Œ `poll` æ‰§è¡Œï¼š

```rust
impl Executor {
    fn run(&self) {
        while let Ok(task) = self.ready_queue.recv() {
            // è·å–ä¸€ä¸ªfutureï¼Œè‹¥å®ƒè¿˜æ²¡æœ‰å®Œæˆ(ä»ç„¶æ˜¯Someï¼Œä¸æ˜¯None)ï¼Œåˆ™å¯¹å®ƒè¿›è¡Œä¸€æ¬¡pollå¹¶å°è¯•å®Œæˆå®ƒ
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // åŸºäºä»»åŠ¡è‡ªèº«åˆ›å»ºä¸€ä¸ª `LocalWaker`
                let waker = waker_ref(&task);
                let context = &mut Context::from_waker(&*waker);
                // `BoxFuture<T>`æ˜¯`Pin<Box<dyn Future<Output = T> + Send + 'static>>`çš„ç±»å‹åˆ«å
                // é€šè¿‡è°ƒç”¨`as_mut`æ–¹æ³•ï¼Œå¯ä»¥å°†ä¸Šé¢çš„ç±»å‹è½¬æ¢æˆ`Pin<&mut dyn Future + Send + 'static>`
                if future.as_mut().poll(context).is_pending() {
                    // Futureè¿˜æ²¡æ‰§è¡Œå®Œï¼Œå› æ­¤å°†å®ƒæ”¾å›ä»»åŠ¡ä¸­ï¼Œç­‰å¾…ä¸‹æ¬¡è¢«poll
                    *future_slot = Some(future);
                }
            }
        }
    }
}
```

æ­å–œï¼æˆ‘ä»¬ç»ˆäºæ‹¥æœ‰äº†è‡ªå·±çš„æ‰§è¡Œå™¨ï¼Œä¸‹é¢å†æ¥å†™ä¸€æ®µä»£ç ä½¿ç”¨è¯¥æ‰§è¡Œå™¨å»è¿è¡Œä¹‹å‰çš„å®šæ—¶å™¨ `Future` ï¼š

```rust
fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // ç”Ÿæˆä¸€ä¸ªä»»åŠ¡
    spawner.spawn(async {
        println!("howdy!");
        // åˆ›å»ºå®šæ—¶å™¨Futureï¼Œå¹¶ç­‰å¾…å®ƒå®Œæˆ
        TimerFuture::new(Duration::new(2, 0)).await;
        println!("done!");
    });

    // dropæ‰ä»»åŠ¡ï¼Œè¿™æ ·æ‰§è¡Œå™¨å°±çŸ¥é“ä»»åŠ¡å·²ç»å®Œæˆï¼Œä¸ä¼šå†æœ‰æ–°çš„ä»»åŠ¡è¿›æ¥
    drop(spawner);

    // è¿è¡Œæ‰§è¡Œå™¨ç›´åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º
    // ä»»åŠ¡è¿è¡Œåï¼Œä¼šå…ˆæ‰“å°`howdy!`, æš‚åœ2ç§’ï¼Œæ¥ç€æ‰“å° `done!`
    executor.run();
}
```

## æ‰§è¡Œå™¨å’Œç³»ç»Ÿ IO

å‰é¢æˆ‘ä»¬ä¸€èµ·çœ‹è¿‡ä¸€ä¸ªä½¿ç”¨ `Future` ä» `Socket` ä¸­å¼‚æ­¥è¯»å–æ•°æ®çš„ä¾‹å­:

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socketæœ‰æ•°æ®ï¼Œå†™å…¥bufferä¸­å¹¶è¿”å›
            Poll::Ready(self.socket.read_buf())
        } else {
            // socketä¸­è¿˜æ²¡æ•°æ®
            //
            // æ³¨å†Œä¸€ä¸ª`wake`å‡½æ•°ï¼Œå½“æ•°æ®å¯ç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œ
            // ç„¶åå½“å‰Futureçš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨`poll`æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥è¯»å–åˆ°æ•°æ®
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

è¯¥ä¾‹å­ä¸­ï¼Œ`Future` å°†ä» `Socket` è¯»å–æ•°æ®ï¼Œè‹¥å½“å‰è¿˜æ²¡æœ‰æ•°æ®ï¼Œåˆ™ä¼šè®©å‡ºå½“å‰çº¿ç¨‹çš„æ‰€æœ‰æƒï¼Œå…è®¸æ‰§è¡Œå™¨å»æ‰§è¡Œå…¶å®ƒçš„ `Future` ã€‚å½“æ•°æ®å‡†å¤‡å¥½åï¼Œä¼šè°ƒç”¨ `wake()` å‡½æ•°å°†è¯¥ `Future` çš„ä»»åŠ¡æ”¾å…¥ä»»åŠ¡é€šé“ä¸­ï¼Œç­‰å¾…æ‰§è¡Œå™¨çš„ `poll` ã€‚

å…³äºè¯¥æµç¨‹å·²ç»åå¤è®²äº†å¾ˆå¤šæ¬¡ï¼Œç›¸ä¿¡å¤§å®¶åº”è¯¥éå¸¸æ¸…æ¥šäº†ã€‚ç„¶è€Œè¯¥ä¾‹å­ä¸­è¿˜æœ‰ä¸€ä¸ªç–‘é—®æ²¡æœ‰è§£å†³ï¼š

- `set_readable_callback` æ–¹æ³•åˆ°åº•æ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Ÿæ€ä¹ˆæ‰èƒ½çŸ¥é“ `socket` ä¸­çš„æ•°æ®å·²ç»å¯ä»¥è¢«è¯»å–äº†ï¼Ÿ

å…³äºç¬¬äºŒç‚¹ï¼Œå…¶ä¸­ä¸€ä¸ªç®€å•ç²—æš´çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ–°çº¿ç¨‹ä¸åœçš„æ£€æŸ¥ `socket` ä¸­æ˜¯å¦æœ‰äº†æ•°æ®ï¼Œå½“æœ‰äº†åï¼Œå°±è°ƒç”¨ `wake()` å‡½æ•°ã€‚è¯¥æ–¹æ³•ç¡®å®å¯ä»¥æ»¡è¶³éœ€æ±‚ï¼Œä½†æ˜¯æ€§èƒ½ç€å®å¤ªä½äº†ï¼Œéœ€è¦ä¸ºæ¯ä¸ªé˜»å¡çš„ `Future` éƒ½åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹ï¼

åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œè¯¥é—®é¢˜å¾€å¾€æ˜¯é€šè¿‡æ“ä½œç³»ç»Ÿæä¾›çš„ `IO` å¤šè·¯å¤ç”¨æœºåˆ¶æ¥å®Œæˆï¼Œä¾‹å¦‚ `Linux` ä¸­çš„ **`epoll`**ï¼Œ`FreeBSD` å’Œ `macOS` ä¸­çš„ **`kqueue`** ï¼Œ`Windows` ä¸­çš„ **`IOCP`**, `Fuchisa`ä¸­çš„ **`ports`** ç­‰(å¯ä»¥é€šè¿‡ Rust çš„è·¨å¹³å°åŒ… `mio` æ¥ä½¿ç”¨å®ƒä»¬)ã€‚å€ŸåŠ© IO å¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªçº¿ç¨‹åŒæ—¶é˜»å¡åœ°å»ç­‰å¾…å¤šä¸ªå¼‚æ­¥ IO äº‹ä»¶ï¼Œä¸€æ—¦æŸä¸ªäº‹ä»¶å®Œæˆå°±ç«‹å³é€€å‡ºé˜»å¡å¹¶è¿”å›æ•°æ®ã€‚ç›¸å…³å®ç°ç±»ä¼¼äºä»¥ä¸‹ä»£ç ï¼š

```rust
struct IoBlocker {
    /* ... */
}

struct Event {
    // Eventçš„å”¯ä¸€IDï¼Œè¯¥äº‹ä»¶å‘ç”Ÿåï¼Œå°±ä¼šè¢«ç›‘å¬èµ·æ¥
    id: usize,

    // ä¸€ç»„éœ€è¦ç­‰å¾…æˆ–è€…å·²å‘ç”Ÿçš„ä¿¡å·
    signals: Signals,
}

impl IoBlocker {
    /// åˆ›å»ºéœ€è¦é˜»å¡ç­‰å¾…çš„å¼‚æ­¥IOäº‹ä»¶çš„é›†åˆ
    fn new() -> Self { /* ... */ }

    /// å¯¹æŒ‡å®šçš„IOäº‹ä»¶è¡¨ç¤ºå…´è¶£
    fn add_io_event_interest(
        &self,

        /// äº‹ä»¶æ‰€ç»‘å®šçš„socket
        io_object: &IoObject,

        event: Event,
    ) { /* ... */ }

    /// è¿›å…¥é˜»å¡ï¼Œç›´åˆ°æŸä¸ªäº‹ä»¶å‡ºç°
    fn block(&self) -> Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// å½“socketçš„æ•°æ®å¯ä»¥è¯»å–æ—¶ï¼Œæ‰“å° "Socket 1 is now READABLE"
println!("Socket {:?} is now {:?}", event.id, event.signals);
```

è¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªæ‰§è¡Œå™¨çº¿ç¨‹ï¼Œå®ƒä¼šæ¥æ”¶ IO äº‹ä»¶å¹¶å°†å…¶åˆ†å‘åˆ°å¯¹åº”çš„ `Waker` ä¸­ï¼Œæ¥ç€åè€…ä¼šå”¤é†’ç›¸å…³çš„ä»»åŠ¡ï¼Œæœ€ç»ˆé€šè¿‡æ‰§è¡Œå™¨ `poll` åï¼Œä»»åŠ¡å¯ä»¥é¡ºåˆ©åœ°ç»§ç»­æ‰§è¡Œ, è¿™ç§ IO è¯»å–æµç¨‹å¯ä»¥ä¸åœçš„å¾ªç¯ï¼Œç›´åˆ° `socket` å…³é—­ã€‚



================================================
FILE: src/advance/async/getting-started.md
================================================
[Binary file]


================================================
FILE: src/advance/async/intro.md
================================================
# å¼‚æ­¥ç¼–ç¨‹

åœ¨è‰°éš¾çš„å­¦å®Œ Rust å…¥é—¨å’Œè¿›é˜¶æ‰€æœ‰çš„ 70 ä¸ªç« èŠ‚åï¼Œæˆ‘ä»¬ç»ˆäºæ¥åˆ°äº†è¿™é‡Œã€‚å‡å¦‚ä¹‹å‰æ”€ç™»çš„æ˜¯ç ç©†æœ—ç›å³°ï¼Œé‚£ä¹ˆç°åœ¨æ”€ç™»çš„å°±æ˜¯ä¹”æˆˆé‡Œå³°( æ¯”ç å³°è¿˜éš¾æ”€çˆ¬... )ã€‚

å¦‚æœä½ æƒ³å¼€å‘ Web æœåŠ¡å™¨ã€æ•°æ®åº“é©±åŠ¨ã€æ¶ˆæ¯æœåŠ¡ç­‰éœ€è¦é«˜å¹¶å‘çš„æœåŠ¡ï¼Œé‚£ä¹ˆæœ¬ç« çš„å†…å®¹å°†å€¼å¾—è®¤çœŸå¯¹å¾…å’Œå­¦ä¹ ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ·±å…¥äº†è§£ async/await çš„ä½¿ç”¨æ–¹å¼åŠèƒŒåçš„åŸç†ã€‚

> æœ¬ç« åœ¨å†…å®¹ä¸Šå¤§é‡å€Ÿé‰´å’Œç¿»è¯‘äº†åŸç‰ˆè‹±æ–‡ä¹¦ç±[Asynchronous Programming In Rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html), ç‰¹æ­¤æ„Ÿè°¢



================================================
FILE: src/advance/async/multi-futures-simultaneous.md
================================================
[Binary file]


================================================
FILE: src/advance/async/pain-points-and-workarounds.md
================================================
[Binary file]


================================================
FILE: src/advance/async/pin-unpin.md
================================================
[Binary file]


================================================
FILE: src/advance/async/web-server.md
================================================
[Binary file]


================================================
FILE: src/advance/circle-self-ref/circle-reference.md
================================================
# Weak ä¸å¾ªç¯å¼•ç”¨

Rust çš„å®‰å…¨æ€§æ˜¯ä¼—æ‰€å‘¨çŸ¥çš„ï¼Œä½†æ˜¯ä¸ä»£è¡¨å®ƒä¸ä¼šå†…å­˜æ³„æ¼ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯åŒæ—¶ä½¿ç”¨ `Rc<T>` å’Œ `RefCell<T>` åˆ›å»ºå¾ªç¯å¼•ç”¨ï¼Œæœ€ç»ˆè¿™äº›å¼•ç”¨çš„è®¡æ•°éƒ½æ— æ³•è¢«å½’é›¶ï¼Œå› æ­¤ `Rc<T>` æ‹¥æœ‰çš„å€¼ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾æ¸…ç†ã€‚

## ä½•ä¸ºå¾ªç¯å¼•ç”¨

å…³äºå†…å­˜æ³„æ¼ï¼Œå¦‚æœä½ æ²¡æœ‰å……è¶³çš„ Rust ç»éªŒï¼Œå¯èƒ½éƒ½æ— æ³•é€ å‡ºä¸€ä»½ä»£ç æ¥å†ç°å®ƒï¼š

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæœ‰äº›å¤æ‚çš„æšä¸¾ç±»å‹ `List`ï¼Œè¿™ä¸ªç±»å‹å¾ˆæœ‰æ„æ€ï¼Œå®ƒçš„æ¯ä¸ªå€¼éƒ½æŒ‡å‘äº†å¦ä¸€ä¸ª `List`ï¼Œæ­¤å¤–ï¼Œå¾—ç›Šäº `Rc` çš„ä½¿ç”¨è¿˜å…è®¸å¤šä¸ªå€¼æŒ‡å‘ä¸€ä¸ª `List`ï¼š

<img alt="" src="https://pica.zhimg.com/80/v2-0db007dfb4167ebc22f50cf5b5a85f53_1440w.png" class="center"  />

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸ªçŸ©å½¢æ¡†èŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ª `List` ç±»å‹ï¼Œå®ƒä»¬æˆ–è€…æ˜¯æ‹¥æœ‰å€¼ä¸”æŒ‡å‘å¦ä¸€ä¸ª `List` çš„`Cons`ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªæ²¡æœ‰å€¼çš„ç»ˆç»“ç‚¹ `Nil`ã€‚åŒæ—¶ï¼Œç”±äº `RefCell` çš„ä½¿ç”¨ï¼Œæ¯ä¸ª `List` æ‰€æŒ‡å‘çš„ `List` è¿˜èƒ½å¤Ÿè¢«ä¿®æ”¹ã€‚

ä¸‹é¢æ¥ä½¿ç”¨ä¸€ä¸‹è¿™ä¸ªå¤æ‚çš„ `List` æšä¸¾ï¼š

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("açš„åˆå§‹åŒ–rcè®¡æ•° = {}", Rc::strong_count(&a));
    println!("aæŒ‡å‘çš„èŠ‚ç‚¹ = {:?}", a.tail());

    // åˆ›å»º`b`åˆ°`a`çš„å¼•ç”¨
    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("åœ¨båˆ›å»ºåï¼Œaçš„rcè®¡æ•° = {}", Rc::strong_count(&a));
    println!("bçš„åˆå§‹åŒ–rcè®¡æ•° = {}", Rc::strong_count(&b));
    println!("bæŒ‡å‘çš„èŠ‚ç‚¹ = {:?}", b.tail());

    // åˆ©ç”¨RefCellçš„å¯å˜æ€§ï¼Œåˆ›å»ºäº†`a`åˆ°`b`çš„å¼•ç”¨
    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("åœ¨æ›´æ”¹aåï¼Œbçš„rcè®¡æ•° = {}", Rc::strong_count(&b));
    println!("åœ¨æ›´æ”¹aåï¼Œaçš„rcè®¡æ•° = {}", Rc::strong_count(&a));

    // ä¸‹é¢ä¸€è¡Œprintln!å°†å¯¼è‡´å¾ªç¯å¼•ç”¨
    // æˆ‘ä»¬å¯æ€œçš„8MBå¤§å°çš„mainçº¿ç¨‹æ ˆç©ºé—´å°†è¢«å®ƒå†²å®ï¼Œæœ€ç»ˆé€ æˆæ ˆæº¢å‡º
    // println!("a next item = {:?}", a.tail());
}
```

è¿™ä¸ªç±»å‹å®šä¹‰çœ‹ç€å¤æ‚ï¼Œä½¿ç”¨èµ·æ¥æ›´å¤æ‚ï¼ä¸è¿‡æ’é™¤è¿™äº›å› ç´ ï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ™°çœ‹å‡ºï¼š

1. åœ¨åˆ›å»ºäº† `a` åï¼Œç´§æ¥ç€å°±ä½¿ç”¨ `a` åˆ›å»ºäº† `b`ï¼Œå› æ­¤ `b` å¼•ç”¨äº† `a`
2. ç„¶åæˆ‘ä»¬åˆåˆ©ç”¨ `Rc` å…‹éš†äº† `b`ï¼Œç„¶åé€šè¿‡ `RefCell` çš„å¯å˜æ€§ï¼Œè®© `a` å¼•ç”¨äº† `b`

è‡³æ­¤æˆ‘ä»¬æˆåŠŸåˆ›å»ºäº†å¾ªç¯å¼•ç”¨`a`-> `b` -> `a` -> `b` Â·Â·Â·Â·

å…ˆæ¥è§‚å¯Ÿä¸‹å¼•ç”¨è®¡æ•°ï¼š

```console
açš„åˆå§‹åŒ–rcè®¡æ•° = 1
aæŒ‡å‘çš„èŠ‚ç‚¹ = Some(RefCell { value: Nil })
åœ¨båˆ›å»ºåï¼Œaçš„rcè®¡æ•° = 2
bçš„åˆå§‹åŒ–rcè®¡æ•° = 1
bæŒ‡å‘çš„èŠ‚ç‚¹ = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
åœ¨æ›´æ”¹aåï¼Œbçš„rcè®¡æ•° = 2
åœ¨æ›´æ”¹aåï¼Œaçš„rcè®¡æ•° = 2
```

åœ¨ `main` å‡½æ•°ç»“æŸå‰ï¼Œ`a` å’Œ `b` çš„å¼•ç”¨è®¡æ•°å‡æ˜¯ `2`ï¼Œéšå `b` è§¦å‘ `Drop`ï¼Œæ­¤æ—¶å¼•ç”¨è®¡æ•°ä¼šå˜ä¸º `1`ï¼Œå¹¶ä¸ä¼šå½’ `0`ï¼Œå› æ­¤ `b` æ‰€æŒ‡å‘å†…å­˜ä¸ä¼šè¢«é‡Šæ”¾ï¼ŒåŒç†å¯å¾— `a` æŒ‡å‘çš„å†…å­˜ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾ï¼Œæœ€ç»ˆå‘ç”Ÿäº†å†…å­˜æ³„æ¼ã€‚

ä¸‹é¢ä¸€å¼ å›¾å¾ˆå¥½çš„å±•ç¤ºäº†è¿™ç§å¼•ç”¨å¾ªç¯å…³ç³»ï¼š
<img alt="" src="https://pic1.zhimg.com/80/v2-2dbfc981f05019bf70bf81c93f956c35_1440w.png" class="center"  />

ç°åœ¨æˆ‘ä»¬è¿˜éœ€è¦è½»è½»çš„æ¨ä¸€ä¸‹ï¼Œè®©å¡”ç±³è¯ºéª¨ç‰Œè½°ç„¶å€’å¡Œã€‚åæ³¨é‡Šæœ€åä¸€è¡Œä»£ç ï¼Œè¯•ç€è¿è¡Œä¸‹ï¼š

```console
RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell {
...æ— ç©·æ— å°½
thread 'main' has overflowed its stack
fatal runtime error: stack overflow
```

é€šè¿‡ `a.tail` çš„è°ƒç”¨ï¼ŒRust è¯•å›¾æ‰“å°å‡º `a -> b -> a Â·Â·Â·` çš„æ‰€æœ‰å†…å®¹ï¼Œä½†æ˜¯åœ¨ä¸æ‡ˆçš„åŠªåŠ›åï¼Œ`main` çº¿ç¨‹ç»ˆäºä¸å ªé‡è´Ÿï¼Œå‘ç”Ÿäº†[æ ˆæº¢å‡º](https://course.rs/pitfalls/stack-overflow.html)ã€‚

ä»¥ä¸Šçš„ä»£ç å¯èƒ½å¹¶ä¸ä¼šé€ æˆä»€ä¹ˆå¤§çš„é—®é¢˜ï¼Œä½†æ˜¯åœ¨ä¸€ä¸ªæ›´åŠ å¤æ‚çš„ç¨‹åºä¸­ï¼Œç±»ä¼¼çš„é—®é¢˜å¯èƒ½ä¼šé€ æˆä½ çš„ç¨‹åºä¸æ–­åœ°åˆ†é…å†…å­˜ã€æ³„æ¼å†…å­˜ï¼Œæœ€ç»ˆç¨‹åºä¼šä¸å¹¸**OOM**ï¼Œå½“ç„¶è¿™å…¶ä¸­çš„ CPU æŸè€—ä¹Ÿä¸å¯å°è§‘ã€‚

æ€»ä¹‹ï¼Œåˆ›å»ºå¾ªç¯å¼•ç”¨å¹¶ä¸ç®€å•ï¼Œä½†æ˜¯ä¹Ÿå¹¶ä¸æ˜¯å®Œå…¨é‡ä¸åˆ°ï¼Œå½“ä½ ä½¿ç”¨ `RefCell<Rc<T>>` æˆ–è€…ç±»ä¼¼çš„ç±»å‹åµŒå¥—ç»„åˆï¼ˆå…·å¤‡å†…éƒ¨å¯å˜æ€§å’Œå¼•ç”¨è®¡æ•°ï¼‰æ—¶ï¼Œå°±è¦æ‰“èµ·ä¸‡åˆ†ç²¾ç¥ï¼Œå‰é¢å¯èƒ½æ˜¯æ·±æ¸Šï¼

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Ÿ å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦å®ç°ä¸Šé¢çš„åŠŸèƒ½ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨ `Weak`ã€‚

## Weak

`Weak` éå¸¸ç±»ä¼¼äº `Rc`ï¼Œä½†æ˜¯ä¸ `Rc` æŒæœ‰æ‰€æœ‰æƒä¸åŒï¼Œ`Weak` ä¸æŒæœ‰æ‰€æœ‰æƒï¼Œå®ƒä»…ä»…ä¿å­˜ä¸€ä»½æŒ‡å‘æ•°æ®çš„å¼±å¼•ç”¨ï¼šå¦‚æœä½ æƒ³è¦è®¿é—®æ•°æ®ï¼Œéœ€è¦é€šè¿‡ `Weak` æŒ‡é’ˆçš„ `upgrade` æ–¹æ³•å®ç°ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ªç±»å‹ä¸º `Option<Rc<T>>` çš„å€¼ã€‚

çœ‹åˆ°è¿™ä¸ªè¿”å›ï¼Œç›¸ä¿¡å¤§å®¶å°±æ‡‚äº†ï¼šä½•ä¸ºå¼±å¼•ç”¨ï¼Ÿå°±æ˜¯**ä¸ä¿è¯å¼•ç”¨å…³ç³»ä¾ç„¶å­˜åœ¨**ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œå°±è¿”å›ä¸€ä¸ª `None`ï¼

å› ä¸º `Weak` å¼•ç”¨ä¸è®¡å…¥æ‰€æœ‰æƒï¼Œå› æ­¤å®ƒ**æ— æ³•é˜»æ­¢æ‰€å¼•ç”¨çš„å†…å­˜å€¼è¢«é‡Šæ”¾æ‰**ï¼Œè€Œä¸” `Weak` æœ¬èº«ä¸å¯¹å€¼çš„å­˜åœ¨æ€§åšä»»ä½•æ‹…ä¿ï¼Œå¼•ç”¨çš„å€¼è¿˜å­˜åœ¨å°±è¿”å› `Some`ï¼Œä¸å­˜åœ¨å°±è¿”å› `None`ã€‚

#### Weak ä¸ Rc å¯¹æ¯”

æˆ‘ä»¬æ¥å°† `Weak` ä¸ `Rc` è¿›è¡Œä»¥ä¸‹ç®€å•å¯¹æ¯”ï¼š

| `Weak`                                          | `Rc`                                      |
| ----------------------------------------------- | ----------------------------------------- |
| ä¸è®¡æ•°                                          | å¼•ç”¨è®¡æ•°                                  |
| ä¸æ‹¥æœ‰æ‰€æœ‰æƒ                                    | æ‹¥æœ‰å€¼çš„æ‰€æœ‰æƒ                            |
| ä¸é˜»æ­¢å€¼è¢«é‡Šæ”¾(drop)                            | æ‰€æœ‰æƒè®¡æ•°å½’é›¶ï¼Œæ‰èƒ½ drop                 |
| å¼•ç”¨çš„å€¼å­˜åœ¨è¿”å› `Some`ï¼Œä¸å­˜åœ¨è¿”å› `None `     | å¼•ç”¨çš„å€¼å¿…å®šå­˜åœ¨                          |
| é€šè¿‡ `upgrade` å–åˆ° `Option<Rc<T>>`ï¼Œç„¶åå†å–å€¼ | é€šè¿‡ `Deref` è‡ªåŠ¨è§£å¼•ç”¨ï¼Œå–å€¼æ— éœ€ä»»ä½•æ“ä½œ |

é€šè¿‡è¿™ä¸ªå¯¹æ¯”ï¼Œå¯ä»¥éå¸¸æ¸…æ™°çš„çœ‹å‡º `Weak` ä¸ºä½•è¿™ä¹ˆå¼±ï¼Œè€Œè¿™ç§å¼±æ°æ°éå¸¸é€‚åˆæˆ‘ä»¬å®ç°ä»¥ä¸‹çš„åœºæ™¯ï¼š

- æŒæœ‰ä¸€ä¸ª `Rc` å¯¹è±¡çš„ä¸´æ—¶å¼•ç”¨ï¼Œå¹¶ä¸”ä¸åœ¨ä¹å¼•ç”¨çš„å€¼æ˜¯å¦ä¾ç„¶å­˜åœ¨
- é˜»æ­¢ `Rc` å¯¼è‡´çš„å¾ªç¯å¼•ç”¨ï¼Œå› ä¸º `Rc` çš„æ‰€æœ‰æƒæœºåˆ¶ï¼Œä¼šå¯¼è‡´å¤šä¸ª `Rc` éƒ½æ— æ³•è®¡æ•°å½’é›¶

ä½¿ç”¨æ–¹å¼ç®€å•æ€»ç»“ä¸‹ï¼š**å¯¹äºçˆ¶å­å¼•ç”¨å…³ç³»ï¼Œå¯ä»¥è®©çˆ¶èŠ‚ç‚¹é€šè¿‡ `Rc` æ¥å¼•ç”¨å­èŠ‚ç‚¹ï¼Œç„¶åè®©å­èŠ‚ç‚¹é€šè¿‡ `Weak` æ¥å¼•ç”¨çˆ¶èŠ‚ç‚¹**ã€‚

#### Weak æ€»ç»“

å› ä¸º `Weak` æœ¬èº«å¹¶ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œå› æ­¤æˆ‘ä»¬å†æ¥å¸®å¤§å®¶æ¢³ç†æ€»ç»“ä¸‹ï¼Œç„¶åå†é€šè¿‡ä¸€ä¸ªä¾‹å­ï¼Œæ¥å½»åº•æŒæ¡ã€‚

`Weak` é€šè¿‡ `use std::rc::Weak` æ¥å¼•å…¥ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹:

- å¯è®¿é—®ï¼Œä½†æ²¡æœ‰æ‰€æœ‰æƒï¼Œä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå› æ­¤ä¸ä¼šå½±å“è¢«å¼•ç”¨å€¼çš„é‡Šæ”¾å›æ”¶
- å¯ç”± `Rc<T>` è°ƒç”¨ `downgrade` æ–¹æ³•è½¬æ¢æˆ `Weak<T>`
- `Weak<T>` å¯ä½¿ç”¨ `upgrade` æ–¹æ³•è½¬æ¢æˆ `Option<Rc<T>>`ï¼Œå¦‚æœèµ„æºå·²ç»è¢«é‡Šæ”¾ï¼Œåˆ™ `Option` çš„å€¼æ˜¯ `None`
- å¸¸ç”¨äºè§£å†³å¾ªç¯å¼•ç”¨çš„é—®é¢˜

ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š

```rust
use std::rc::Rc;
fn main() {
    // åˆ›å»ºRcï¼ŒæŒæœ‰ä¸€ä¸ªå€¼5
    let five = Rc::new(5);

    // é€šè¿‡Rcï¼Œåˆ›å»ºä¸€ä¸ªWeakæŒ‡é’ˆ
    let weak_five = Rc::downgrade(&five);

    // Weakå¼•ç”¨çš„èµ„æºä¾ç„¶å­˜åœ¨ï¼Œå–åˆ°å€¼5
    let strong_five: Option<Rc<_>> = weak_five.upgrade();
    assert_eq!(*strong_five.unwrap(), 5);

    // æ‰‹åŠ¨é‡Šæ”¾èµ„æº`five`
    drop(five);

    // Weakå¼•ç”¨çš„èµ„æºå·²ä¸å­˜åœ¨ï¼Œå› æ­¤è¿”å›None
    let strong_five: Option<Rc<_>> = weak_five.upgrade();
    assert_eq!(strong_five, None);
}
```

éœ€è¦æ‰¿è®¤çš„æ˜¯ï¼Œä½¿ç”¨ `Weak` è®© Rust æœ¬æ¥å°±å ªå¿§çš„ä»£ç å¯è¯»æ€§åˆä¸‹é™äº†ä¸å°‘ï¼Œä½†æ˜¯ã€‚ã€‚ã€‚çœŸé¦™ï¼Œå› ä¸ºå¯ä»¥è§£å†³å¾ªç¯å¼•ç”¨äº†ã€‚

## ä½¿ç”¨ Weak è§£å†³å¾ªç¯å¼•ç”¨

ç†è®ºçŸ¥è¯†å·²ç»è¶³å¤Ÿï¼Œç°åœ¨ç”¨ä¸¤ä¸ªä¾‹å­æ¥æ¨¡æ‹Ÿä¸‹çœŸå®åœºæ™¯ä¸‹å¯èƒ½ä¼šé‡åˆ°çš„å¾ªç¯å¼•ç”¨ã€‚

#### å·¥å…·é—´çš„æ•…äº‹

å·¥å…·é—´é‡Œï¼Œæ¯ä¸ªå·¥å…·éƒ½æœ‰å…¶ä¸»äººï¼Œä¸”å¤šä¸ªå·¥å…·å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªä¸»äººï¼›åŒæ—¶ä¸€ä¸ªä¸»äººä¹Ÿå¯ä»¥æ‹¥æœ‰å¤šä¸ªå·¥å…·ï¼Œåœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œå°±å¾ˆå®¹æ˜“å½¢æˆå¾ªç¯å¼•ç”¨ï¼Œå¥½åœ¨æˆ‘ä»¬æœ‰ `Weak`ï¼š

```rust
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;

// ä¸»äºº
struct Owner {
    name: String,
    gadgets: RefCell<Vec<Weak<Gadget>>>,
}

// å·¥å…·
struct Gadget {
    id: i32,
    owner: Rc<Owner>,
}

fn main() {
    // åˆ›å»ºä¸€ä¸ª Owner
    // éœ€è¦æ³¨æ„ï¼Œè¯¥ Owner ä¹Ÿæ‹¥æœ‰å¤šä¸ª `gadgets`
    let gadget_owner : Rc<Owner> = Rc::new(
        Owner {
            name: "Gadget Man".to_string(),
            gadgets: RefCell::new(Vec::new()),
        }
    );

    // åˆ›å»ºå·¥å…·ï¼ŒåŒæ—¶ä¸ä¸»äººè¿›è¡Œå…³è”ï¼šåˆ›å»ºä¸¤ä¸ª gadgetï¼Œä»–ä»¬åˆ†åˆ«æŒæœ‰ gadget_owner çš„ä¸€ä¸ªå¼•ç”¨ã€‚
    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});

    // ä¸ºä¸»äººæ›´æ–°å®ƒæ‰€æ‹¥æœ‰çš„å·¥å…·
    // å› ä¸ºä¹‹å‰ä½¿ç”¨äº† `Rc`ï¼Œç°åœ¨å¿…é¡»è¦ä½¿ç”¨ `Weak`ï¼Œå¦åˆ™å°±ä¼šå¾ªç¯å¼•ç”¨
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));

    // éå† gadget_owner çš„ gadgets å­—æ®µ
    for gadget_opt in gadget_owner.gadgets.borrow().iter() {

        // gadget_opt æ˜¯ä¸€ä¸ª Weak<Gadget> ã€‚ å› ä¸º weak æŒ‡é’ˆä¸èƒ½ä¿è¯ä»–æ‰€å¼•ç”¨çš„å¯¹è±¡
        // ä»ç„¶å­˜åœ¨ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ˜¾å¼çš„è°ƒç”¨ upgrade() æ¥é€šè¿‡å…¶è¿”å›å€¼(Option<_>)æ¥åˆ¤
        // æ–­å…¶æ‰€æŒ‡å‘çš„å¯¹è±¡æ˜¯å¦å­˜åœ¨ã€‚
        // å½“ç„¶ï¼ŒOption ä¸º None çš„æ—¶å€™è¿™ä¸ªå¼•ç”¨åŸå¯¹è±¡å°±ä¸å­˜åœ¨äº†ã€‚
        let gadget = gadget_opt.upgrade().unwrap();
        println!("Gadget {} owned by {}", gadget.id, gadget.owner.name);
    }

    // åœ¨ main å‡½æ•°çš„æœ€åï¼Œgadget_ownerï¼Œgadget1 å’Œ gadget2 éƒ½è¢«é”€æ¯ã€‚
    // å…·ä½“æ˜¯ï¼Œå› ä¸ºè¿™å‡ ä¸ªç»“æ„ä½“ä¹‹é—´æ²¡æœ‰äº†å¼ºå¼•ç”¨ï¼ˆ`Rc<T>`ï¼‰ï¼Œæ‰€ä»¥ï¼Œå½“ä»–ä»¬é”€æ¯çš„æ—¶å€™ã€‚
    // é¦–å…ˆ gadget2 å’Œ gadget1 è¢«é”€æ¯ã€‚
    // ç„¶åå› ä¸º gadget_owner çš„å¼•ç”¨æ•°é‡ä¸º 0ï¼Œæ‰€ä»¥è¿™ä¸ªå¯¹è±¡å¯ä»¥è¢«é”€æ¯äº†ã€‚
    // å¾ªç¯å¼•ç”¨é—®é¢˜ä¹Ÿå°±é¿å…äº†
}
```

#### tree æ•°æ®ç»“æ„

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}

```

è¿™ä¸ªä¾‹å­å°±ç•™ç»™è¯»è€…è‡ªå·±è§£è¯»å’Œåˆ†æï¼Œæˆ‘ä»¬å°±ä¸ç”»è›‡æ·»è¶³äº†:ï¼‰

## unsafe è§£å†³å¾ªç¯å¼•ç”¨

é™¤äº†ä½¿ç”¨ Rust æ ‡å‡†åº“æä¾›çš„è¿™äº›ç±»å‹ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨ `unsafe` é‡Œçš„è£¸æŒ‡é’ˆæ¥è§£å†³è¿™äº›æ£˜æ‰‹çš„é—®é¢˜ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰è®²è§£ `unsafe`ï¼Œå› æ­¤è¿™é‡Œå°±ä¸è¿›è¡Œå±•å¼€ï¼Œåªé™„ä¸Š[æºç é“¾æ¥](https://github.com/sunface/rust-algos/blob/fbcdccf3e8178a9039329562c0de0fd01a3372fb/src/unsafe/self-ref.md)ï¼ŒæŒºé•¿çš„ï¼Œéœ€è¦è€å¿ƒ o_o

è™½ç„¶ `unsafe` ä¸å®‰å…¨ï¼Œä½†æ˜¯åœ¨å„ç§åº“çš„ä»£ç ä¸­ä¾ç„¶å¾ˆå¸¸è§ç”¨å®ƒæ¥å®ç°è‡ªå¼•ç”¨ç»“æ„ï¼Œä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹:

- æ€§èƒ½é«˜ï¼Œæ¯•ç«Ÿç›´æ¥ç”¨è£¸æŒ‡é’ˆæ“ä½œ
- ä»£ç æ›´ç®€å•æ›´ç¬¦åˆç›´è§‰: å¯¹æ¯”ä¸‹ `Option<Rc<RefCell<Node>>>`

## æ€»ç»“

æœ¬æ–‡æ·±å…¥è®²è§£äº†ä½•ä¸ºå¾ªç¯å¼•ç”¨ä»¥åŠå¦‚ä½•ä½¿ç”¨ `Weak` æ¥è§£å†³ï¼ŒåŒæ—¶è¿˜ç»“åˆ `Rc`ã€`RefCell`ã€`Weak` ç­‰å®ç°äº†ä¸¤ä¸ªæœ‰å®æˆ˜ä»·å€¼çš„ä¾‹å­ï¼Œè®©å¤§å®¶å¯¹æ™ºèƒ½æŒ‡é’ˆçš„ä½¿ç”¨æ›´åŠ èä¼šè´¯é€šã€‚

è‡³æ­¤ï¼Œæ™ºèƒ½æŒ‡é’ˆä¸€ç« å³å°†ç»“æŸï¼ˆä¸¥æ ¼æ¥è¯´è¿˜æœ‰ä¸€ä¸ª `Mutex` æ”¾åœ¨å¤šçº¿ç¨‹ä¸€ç« è®²è§£ï¼‰ï¼Œè€Œ Rust è¯­è¨€æœ¬èº«çš„å­¦ä¹ ä¹‹æ—…ä¹Ÿå³å°†ç»“æŸï¼Œåé¢æˆ‘ä»¬å°†æ·±å…¥å¤šçº¿ç¨‹ã€é¡¹ç›®å·¥ç¨‹ã€åº”ç”¨å®è·µã€æ€§èƒ½åˆ†æç­‰ç‰¹è‰²ä¸“é¢˜ï¼Œæ¥ä¸€ç¹ Rust åœ¨è¿™äº›é¢†åŸŸçš„é£é‡‡ã€‚



================================================
FILE: src/advance/circle-self-ref/intro.md
================================================
# å¾ªç¯å¼•ç”¨ä¸è‡ªå¼•ç”¨

å®ç°ä¸€ä¸ªé“¾è¡¨æ˜¯å­¦ä¹ å„å¤§ç¼–ç¨‹è¯­è¨€çš„å¸¸ç”¨æŠ€å·§ï¼Œä½†æ˜¯åœ¨ Rust ä¸­å®ç°é“¾è¡¨æ„å‘³ç€Â·Â·Â·Â·Hellï¼Œæ˜¯çš„ï¼Œä½ æ²¡çœ‹é”™ï¼ŒWelcome to hellã€‚

é“¾è¡¨åœ¨ Rust ä¸­ä¹‹æ‰€ä»¥è¿™ä¹ˆéš¾ï¼Œå®Œå…¨æ˜¯å› ä¸ºå¾ªç¯å¼•ç”¨å’Œè‡ªå¼•ç”¨çš„é—®é¢˜å¼•èµ·çš„ï¼Œè¿™ä¸¤ä¸ªé—®é¢˜å¯ä»¥è¯´ç»¼åˆäº† Rust çš„å¾ˆå¤šéš¾ç‚¹ï¼Œéš¾å‡ºäº†æ–°é«˜åº¦ï¼Œå› æ­¤æœ¬ä¹¦ä¸“é—¨å¼€è¾Ÿä¸€ç« ï¼Œåˆ†ä¸ºä¸Šä¸‹ä¸¤ç¯‡ï¼Œè¯•å›¾å½»åº•è§£å†³è¿™ä¸¤ä¸ªè€å¤§éš¾ã€‚

æœ¬ç« éš¾åº¦è¾ƒé«˜ï¼Œä½†æ˜¯éå¸¸å€¼å¾—æ·±å…¥é˜…è¯»ï¼Œå®ƒä¼šè®©ä½ å¯¹ Rust çš„ç†è§£ä¸Šå‡åˆ°ä¸€ä¸ªæ–°çš„å¢ƒç•Œã€‚



================================================
FILE: src/advance/circle-self-ref/self-referential.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/concurrency-parallelism.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/intro.md
================================================
# å¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹

å®‰å…¨å’Œé«˜æ•ˆçš„å¤„ç†å¹¶å‘æ˜¯ Rust è¯­è¨€çš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ã€‚éšç€ç°ä»£å¤„ç†å™¨çš„æ ¸å¿ƒæ•°ä¸æ–­å¢åŠ ï¼Œå¹¶å‘å’Œå¹¶è¡Œå·²ç»æˆä¸ºæ—¥å¸¸ç¼–ç¨‹ä¸å¯æˆ–ç¼ºçš„ä¸€éƒ¨åˆ†ï¼Œç”šè‡³äº Go è¯­è¨€å·²ç»å°†å¹¶å‘ç®€åŒ–åˆ°ä¸€ä¸ª `go` å…³é”®å­—å°±å¯ä»¥ã€‚

å¯æƒœçš„æ˜¯ï¼Œåœ¨ Rust ä¸­ç”±äºè¯­è¨€è®¾è®¡ç†å¿µã€å®‰å…¨ã€æ€§èƒ½çš„å¤šæ–¹é¢è€ƒè™‘ï¼Œå¹¶æ²¡æœ‰é‡‡ç”¨ Go è¯­è¨€å¤§é“è‡³ç®€çš„æ–¹å¼ï¼Œè€Œæ˜¯é€‰æ‹©äº†å¤šçº¿ç¨‹ä¸ `async/await` ç›¸ç»“åˆï¼Œä¼˜ç‚¹æ˜¯å¯æ§æ€§æ›´å¼ºã€æ€§èƒ½æ›´é«˜ï¼Œç¼ºç‚¹æ˜¯å¤æ‚åº¦å¹¶ä¸ä½ï¼Œå½“ç„¶è¿™ä¹Ÿæ˜¯ç³»ç»Ÿçº§è¯­è¨€çš„åº”æœ‰é€‰æ‹©ï¼š**ä½¿ç”¨å¤æ‚åº¦æ¢å–å¯æ§æ€§å’Œæ€§èƒ½**ã€‚

ä¸è¿‡ï¼Œå¤§å®¶ä¹Ÿä¸ç”¨æ‹…å¿ƒï¼Œæœ¬ä¹¦çš„ç›®æ ‡å°±æ˜¯é™ä½ Rust ä½¿ç”¨é—¨æ§›ï¼Œè¿™ä¸ªé—¨æ§›è‡ªç„¶ä¹ŸåŒ…æ‹¬å¦‚ä½•åœ¨ Rust ä¸­è¿›è¡Œå¼‚æ­¥å¹¶å‘ç¼–ç¨‹ï¼Œæˆ‘ä»¬å°†ä»å¤šçº¿ç¨‹ä»¥åŠ `async/await` ä¸¤ä¸ªæ–¹é¢å»æ·±å…¥æµ…å‡ºåœ°è®²è§£ï¼Œé¦–å…ˆï¼Œä»æœ¬ç« çš„å¤šçº¿ç¨‹å¼€å§‹ã€‚

åœ¨æœ¬ç« ï¼Œæˆ‘ä»¬å°†æ·±å…¥è®²è§£å¹¶å‘å’Œå¹¶è¡Œçš„åŒºåˆ«ä»¥åŠå¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹è¿›è¡Œ Rust å¹¶å‘ç¼–ç¨‹ï¼Œé‚£ä¹ˆå…ˆæ¥çœ‹çœ‹ä½•ä¸ºå¹¶è¡Œä¸å¹¶å‘ã€‚



================================================
FILE: src/advance/concurrency-with-threads/message-passing.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/races.md
================================================
# æ•°æ®ç«äº‰



================================================
FILE: src/advance/concurrency-with-threads/ref-counter-lock.md
================================================
# Rcã€Arcã€Mutexã€Rwlock(todo)

https://oribenshir.github.io/afternoon_rusting//blog/deref-smart-pointer


================================================
FILE: src/advance/concurrency-with-threads/send-sync.md
================================================
# åŸºäº Send å’Œ Sync çš„çº¿ç¨‹å®‰å…¨

ä¸ºä½• Rcã€RefCell å’Œè£¸æŒ‡é’ˆä¸å¯ä»¥åœ¨å¤šçº¿ç¨‹é—´ä½¿ç”¨ï¼Ÿå¦‚ä½•è®©è£¸æŒ‡é’ˆå¯ä»¥åœ¨å¤šçº¿ç¨‹ä½¿ç”¨ï¼Ÿæˆ‘ä»¬ä¸€èµ·æ¥æ¢å¯»ä¸‹è¿™äº›é—®é¢˜çš„ç­”æ¡ˆã€‚

## æ— æ³•ç”¨äºå¤šçº¿ç¨‹çš„`Rc`

å…ˆæ¥çœ‹ä¸€æ®µå¤šçº¿ç¨‹ä½¿ç”¨`Rc`çš„ä»£ç :

```rust
use std::thread;
use std::rc::Rc;
fn main() {
    let v = Rc::new(5);
    let t = thread::spawn(move || {
        println!("{}",v);
    });

    t.join().unwrap();
}
```

ä»¥ä¸Šä»£ç å°†`v`çš„æ‰€æœ‰æƒé€šè¿‡`move`è½¬ç§»åˆ°å­çº¿ç¨‹ä¸­ï¼Œçœ‹ä¼¼æ­£ç¡®å®åˆ™ä¼šæŠ¥é”™ï¼š

```console
error[E0277]: `Rc<i32>` cannot be sent between threads safely
------ çœç•¥éƒ¨åˆ†æŠ¥é”™ --------
    = help: within `[closure@src/main.rs:5:27: 7:6]`, the trait `Send` is not implemented for `Rc<i32>`
```

è¡¨é¢åŸå› æ˜¯`Rc`æ— æ³•åœ¨çº¿ç¨‹é—´å®‰å…¨çš„è½¬ç§»ï¼Œå®é™…æ˜¯ç¼–è¯‘å™¨ç»™äºˆæˆ‘ä»¬çš„é‚£å¥å¸®åŠ©: ```the trait `Send` is not implemented for `Rc<i32>` ```(`Rc<i32>`æœªå®ç°`Send`ç‰¹å¾), é‚£ä¹ˆæ­¤å¤„çš„`Send`ç‰¹å¾åˆæ˜¯ä½•æ–¹ç¥åœ£ï¼Ÿ

## Rc å’Œ Arc æºç å¯¹æ¯”

åœ¨ä»‹ç»`Send`ç‰¹å¾ä¹‹å‰ï¼Œå†æ¥çœ‹çœ‹`Arc`ä¸ºä½•å¯ä»¥åœ¨å¤šçº¿ç¨‹ä½¿ç”¨ï¼Œç„æœºåœ¨äºä¸¤è€…çš„æºç å®ç°ä¸Šï¼š

```rust
// Rcæºç ç‰‡æ®µ
impl<T: ?Sized> !marker::Send for Rc<T> {}
impl<T: ?Sized> !marker::Sync for Rc<T> {}

// Arcæºç ç‰‡æ®µ
unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}
unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}
```

`!`ä»£è¡¨ç§»é™¤ç‰¹å¾çš„ç›¸åº”å®ç°ï¼Œä¸Šé¢ä»£ç ä¸­`Rc<T>`çš„`Send`å’Œ`Sync`ç‰¹å¾è¢«ç‰¹åœ°ç§»é™¤äº†å®ç°ï¼Œè€Œ`Arc<T>`åˆ™ç›¸åï¼Œå®ç°äº†`Sync + Send`ï¼Œå†ç»“åˆä¹‹å‰çš„ç¼–è¯‘å™¨æŠ¥é”™ï¼Œå¤§æ¦‚å¯ä»¥æ˜ç™½äº†ï¼š`Send`å’Œ`Sync`æ˜¯åœ¨çº¿ç¨‹é—´å®‰å…¨ä½¿ç”¨ä¸€ä¸ªå€¼çš„å…³é”®ã€‚

## Send å’Œ Sync

`Send`å’Œ`Sync`æ˜¯ Rust å®‰å…¨å¹¶å‘çš„é‡ä¸­ä¹‹é‡ï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒä»¬åªæ˜¯æ ‡è®°ç‰¹å¾(marker traitï¼Œè¯¥ç‰¹å¾æœªå®šä¹‰ä»»ä½•è¡Œä¸ºï¼Œå› æ­¤éå¸¸é€‚åˆç”¨äºæ ‡è®°), æ¥çœ‹çœ‹å®ƒä»¬çš„ä½œç”¨ï¼š

- å®ç°`Send`çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„ä¼ é€’å…¶æ‰€æœ‰æƒ
- å®ç°`Sync`çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„å…±äº«(é€šè¿‡å¼•ç”¨)

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ½œåœ¨çš„ä¾èµ–ï¼šä¸€ä¸ªç±»å‹è¦åœ¨çº¿ç¨‹é—´å®‰å…¨çš„å…±äº«çš„å‰ææ˜¯ï¼ŒæŒ‡å‘å®ƒçš„å¼•ç”¨å¿…é¡»èƒ½åœ¨çº¿ç¨‹é—´ä¼ é€’ã€‚å› ä¸ºå¦‚æœå¼•ç”¨éƒ½ä¸èƒ½è¢«ä¼ é€’ï¼Œæˆ‘ä»¬å°±æ— æ³•åœ¨å¤šä¸ªçº¿ç¨‹é—´ä½¿ç”¨å¼•ç”¨å»è®¿é—®åŒä¸€ä¸ªæ•°æ®äº†ã€‚

ç”±ä¸Šå¯çŸ¥ï¼Œ**è‹¥ç±»å‹ T çš„å¼•ç”¨`&T`æ˜¯`Send`ï¼Œåˆ™`T`æ˜¯`Sync`**ã€‚

æ²¡æœ‰ä¾‹å­çš„æ¦‚å¿µè®²è§£éƒ½æ˜¯è€æµæ°“ï¼Œæ¥çœ‹çœ‹`RwLock`çš„å®ç°:

```rust
unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}
```

é¦–å…ˆ`RwLock`å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„å…±äº«ï¼Œé‚£å®ƒè‚¯å®šæ˜¯å®ç°äº†`Sync`ï¼Œä½†æ˜¯æˆ‘ä»¬çš„å…³æ³¨ç‚¹ä¸åœ¨è¿™é‡Œã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œ`RwLock`å¯ä»¥å¹¶å‘çš„è¯»ï¼Œè¯´æ˜å…¶ä¸­çš„å€¼`T`å¿…å®šä¹Ÿå¯ä»¥åœ¨çº¿ç¨‹é—´å…±äº«ï¼Œé‚£`T`å¿…å®šè¦å®ç°`Sync`ã€‚

æœä¸å…¶ç„¶ï¼Œä¸Šè¿°ä»£ç ä¸­ï¼Œ`T`çš„ç‰¹å¾çº¦æŸä¸­å°±æœ‰ä¸€ä¸ª`Sync`ç‰¹å¾ï¼Œé‚£é—®é¢˜åˆæ¥äº†ï¼Œ`Mutex`æ˜¯ä¸æ˜¯ç›¸åï¼Ÿå†æ¥çœ‹çœ‹:

```rust
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}
```

ä¸å‡ºæ‰€æ–™ï¼Œ`Mutex<T>`ä¸­çš„`T`å¹¶æ²¡æœ‰`Sync`ç‰¹å¾çº¦æŸã€‚

æ­¦å­¦ç§˜ç±å†å¥½ï¼Œä¸è§ç”Ÿæ­»ä¹Ÿæ˜¯èŠ±æ‹³ç»£è…¿ã€‚åŒæ ·çš„ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡å®æˆ˜æ¥å½»åº•æŒæ¡`Send`å’Œ`Sync`ï¼Œä½†åœ¨å®æˆ˜ä¹‹å‰ï¼Œå…ˆæ¥ç®€å•çœ‹çœ‹æœ‰å“ªäº›ç±»å‹å®ç°äº†å®ƒä»¬ã€‚

## å®ç°`Send`å’Œ`Sync`çš„ç±»å‹

åœ¨ Rust ä¸­ï¼Œå‡ ä¹æ‰€æœ‰ç±»å‹éƒ½é»˜è®¤å®ç°äº†`Send`å’Œ`Sync`ï¼Œè€Œä¸”ç”±äºè¿™ä¸¤ä¸ªç‰¹å¾éƒ½æ˜¯å¯è‡ªåŠ¨æ´¾ç”Ÿçš„ç‰¹å¾(é€šè¿‡`derive`æ´¾ç”Ÿ)ï¼Œæ„å‘³ç€ä¸€ä¸ªå¤åˆç±»å‹(ä¾‹å¦‚ç»“æ„ä½“), åªè¦å®ƒå†…éƒ¨çš„æ‰€æœ‰æˆå‘˜éƒ½å®ç°äº†`Send`æˆ–è€…`Sync`ï¼Œé‚£ä¹ˆå®ƒå°±è‡ªåŠ¨å®ç°äº†`Send`æˆ–`Sync`ã€‚

æ­£æ˜¯å› ä¸ºä»¥ä¸Šè§„åˆ™ï¼ŒRust ä¸­ç»å¤§å¤šæ•°ç±»å‹éƒ½å®ç°äº†`Send`å’Œ`Sync`ï¼Œé™¤äº†ä»¥ä¸‹å‡ ä¸ª(äº‹å®ä¸Šä¸æ­¢è¿™å‡ ä¸ªï¼Œåªä¸è¿‡å®ƒä»¬æ¯”è¾ƒå¸¸è§):

- è£¸æŒ‡é’ˆä¸¤è€…éƒ½æ²¡å®ç°ï¼Œå› ä¸ºå®ƒæœ¬èº«å°±æ²¡æœ‰ä»»ä½•å®‰å…¨ä¿è¯
- `UnsafeCell`ä¸æ˜¯`Sync`ï¼Œå› æ­¤`Cell`å’Œ`RefCell`ä¹Ÿä¸æ˜¯
- `Rc`ä¸¤è€…éƒ½æ²¡å®ç°(å› ä¸ºå†…éƒ¨çš„å¼•ç”¨è®¡æ•°å™¨ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„)

å½“ç„¶ï¼Œå¦‚æœæ˜¯è‡ªå®šä¹‰çš„å¤åˆç±»å‹ï¼Œé‚£æ²¡å®ç°é‚£å“¥ä¿©çš„å°±è¾ƒä¸ºå¸¸è§äº†ï¼š**åªè¦å¤åˆç±»å‹ä¸­æœ‰ä¸€ä¸ªæˆå‘˜ä¸æ˜¯`Send`æˆ–`Sync`ï¼Œé‚£ä¹ˆè¯¥å¤åˆç±»å‹ä¹Ÿå°±ä¸æ˜¯`Send`æˆ–`Sync`**ã€‚

**æ‰‹åŠ¨å®ç° `Send` å’Œ `Sync` æ˜¯ä¸å®‰å…¨çš„**ï¼Œé€šå¸¸å¹¶ä¸éœ€è¦æ‰‹åŠ¨å®ç° Send å’Œ Sync traitï¼Œå®ç°è€…éœ€è¦ä½¿ç”¨`unsafe`å°å¿ƒç»´æŠ¤å¹¶å‘å®‰å…¨ä¿è¯ã€‚

è‡³æ­¤ï¼Œç›¸å…³çš„æ¦‚å¿µå¤§å®¶å·²ç»æŒæ¡ï¼Œä½†æ˜¯æˆ‘æ•¢è‚¯å®šï¼Œå¯¹äºè¿™ä¸¤ä¸ªæ»‘ä¸æºœç§‹çš„å®¶ä¼™ï¼Œå¤§å®¶ä¾ç„¶ä¼šéå¸¸æ¨¡ç³Šï¼Œä¸çŸ¥é“å®ƒä»¬è¯¥å¦‚ä½•ä½¿ç”¨ã€‚é‚£ä¹ˆæˆ‘ä»¬æ¥ä¸€èµ·çœ‹çœ‹å¦‚ä½•è®©è£¸æŒ‡é’ˆå¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„ä½¿ç”¨ã€‚

## ä¸ºè£¸æŒ‡é’ˆå®ç°`Send`

ä¸Šé¢æˆ‘ä»¬æåˆ°è£¸æŒ‡é’ˆæ—¢æ²¡å®ç°`Send`ï¼Œæ„å‘³ç€ä¸‹é¢ä»£ç ä¼šæŠ¥é”™:

```rust
use std::thread;
fn main() {
    let p = 5 as *mut u8;
    let t = thread::spawn(move || {
        println!("{:?}",p);
    });

    t.join().unwrap();
}
```

æŠ¥é”™è·Ÿä¹‹å‰æ— äºŒï¼š ``` `*mut u8` cannot be sent between threads safely```, ä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æ— æ³•ä¸ºå…¶ç›´æ¥å®ç°`Send`ç‰¹å¾ï¼Œå¥½åœ¨å¯ä»¥ç”¨[`newtype`ç±»å‹](https://course.rs/advance/into-types/custom-type.html#newtype) :`struct MyBox(*mut u8);`ã€‚

è¿˜è®°å¾—ä¹‹å‰çš„è§„åˆ™å—ï¼šå¤åˆç±»å‹ä¸­æœ‰ä¸€ä¸ªæˆå‘˜æ²¡å®ç°`Send`ï¼Œè¯¥å¤åˆç±»å‹å°±ä¸æ˜¯`Send`ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨ä¸ºå®ƒå®ç°:

```rust
use std::thread;

#[derive(Debug)]
struct MyBox(*mut u8);
unsafe impl Send for MyBox {}
fn main() {
    let p = MyBox(5 as *mut u8);
    let t = thread::spawn(move || {
        println!("{:?}",p);
    });

    t.join().unwrap();
}
```

æ­¤æ—¶ï¼Œæˆ‘ä»¬çš„æŒ‡é’ˆå·²ç»å¯ä»¥æ¬¢å¿«çš„åœ¨å¤šçº¿ç¨‹é—´æ’’æ¬¢ï¼Œä»¥ä¸Šä»£ç å¾ˆç®€å•ï¼Œä½†æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼š`Send`å’Œ`Sync`æ˜¯`unsafe`ç‰¹å¾ï¼Œå®ç°æ—¶éœ€è¦ç”¨`unsafe`ä»£ç å—åŒ…è£¹ã€‚

## ä¸ºè£¸æŒ‡é’ˆå®ç°`Sync`

ç”±äº`Sync`æ˜¯å¤šçº¿ç¨‹é—´å…±äº«ä¸€ä¸ªå€¼ï¼Œå¤§å®¶å¯èƒ½ä¼šæƒ³è¿™ä¹ˆå®ç°ï¼š

```rust
use std::thread;
fn main() {
    let v = 5;
    let t = thread::spawn(|| {
        println!("{:?}",&v);
    });

    t.join().unwrap();
}
```

å…³äºè¿™ç§ç”¨æ³•ï¼Œåœ¨å¤šçº¿ç¨‹ç« èŠ‚ä¹Ÿæåˆ°è¿‡ï¼Œçº¿ç¨‹å¦‚æœç›´æ¥å»å€Ÿç”¨å…¶å®ƒçº¿ç¨‹çš„å˜é‡ï¼Œä¼šæŠ¥é”™:`closure may outlive the current function,`, åŸå› åœ¨äºç¼–è¯‘å™¨æ— æ³•ç¡®å®šä¸»çº¿ç¨‹`main`å’Œå­çº¿ç¨‹`t`è°çš„ç”Ÿå‘½å‘¨æœŸæ›´é•¿ï¼Œç‰¹åˆ«æ˜¯å½“ä¸¤ä¸ªçº¿ç¨‹éƒ½æ˜¯å­çº¿ç¨‹æ—¶ï¼Œæ²¡æœ‰ä»»ä½•äººçŸ¥é“å“ªä¸ªå­çº¿ç¨‹ä¼šå…ˆç»“æŸï¼ŒåŒ…æ‹¬ç¼–è¯‘å™¨ï¼

å› æ­¤æˆ‘ä»¬å¾—é…åˆ`Arc`å»ä½¿ç”¨:

```rust
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

#[derive(Debug)]
struct MyBox(*const u8);
unsafe impl Send for MyBox {}

fn main() {
    let b = &MyBox(5 as *const u8);
    let v = Arc::new(Mutex::new(b));
    let t = thread::spawn(move || {
        let _v1 =  v.lock().unwrap();
    });

    t.join().unwrap();
}
```

ä¸Šé¢ä»£ç å°†æ™ºèƒ½æŒ‡é’ˆ`v`çš„æ‰€æœ‰æƒè½¬ç§»ç»™æ–°çº¿ç¨‹ï¼ŒåŒæ—¶`v`åŒ…å«äº†ä¸€ä¸ªå¼•ç”¨ç±»å‹`b`ï¼Œå½“åœ¨æ–°çš„çº¿ç¨‹ä¸­è¯•å›¾è·å–å†…éƒ¨çš„å¼•ç”¨æ—¶ï¼Œä¼šæŠ¥é”™ï¼š

```console
error[E0277]: `*const u8` cannot be shared between threads safely
--> src/main.rs:25:13
|
25  |     let t = thread::spawn(move || {
|             ^^^^^^^^^^^^^ `*const u8` cannot be shared between threads safely
|
= help: within `MyBox`, the trait `Sync` is not implemented for `*const u8`
```

å› ä¸ºæˆ‘ä»¬è®¿é—®çš„å¼•ç”¨å®é™…ä¸Šè¿˜æ˜¯å¯¹ä¸»çº¿ç¨‹ä¸­çš„æ•°æ®çš„å€Ÿç”¨ï¼Œè½¬ç§»è¿›æ¥çš„ä»…ä»…æ˜¯å¤–å±‚çš„æ™ºèƒ½æŒ‡é’ˆå¼•ç”¨ã€‚è¦è§£å†³å¾ˆç®€å•ï¼Œä¸º`MyBox`å®ç°`Sync`:

```rust
unsafe impl Sync for MyBox {}
```

## æ€»ç»“

é€šè¿‡ä¸Šé¢çš„ä¸¤ä¸ªè£¸æŒ‡é’ˆçš„ä¾‹å­ï¼Œæˆ‘ä»¬äº†è§£äº†å¦‚ä½•å®ç°`Send`å’Œ`Sync`ï¼Œä»¥åŠå¦‚ä½•åªå®ç°`Send`è€Œä¸å®ç°`Sync`ï¼Œç®€å•æ€»ç»“ä¸‹ï¼š

1. å®ç°`Send`çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„ä¼ é€’å…¶æ‰€æœ‰æƒ, å®ç°`Sync`çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨çš„å…±äº«(é€šè¿‡å¼•ç”¨)
2. ç»å¤§éƒ¨åˆ†ç±»å‹éƒ½å®ç°äº†`Send`å’Œ`Sync`ï¼Œå¸¸è§çš„æœªå®ç°çš„æœ‰ï¼šè£¸æŒ‡é’ˆã€`Cell`ã€`RefCell`ã€`Rc` ç­‰
3. å¯ä»¥ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°`Send`å’Œ`Sync`ï¼Œä½†æ˜¯éœ€è¦`unsafe`ä»£ç å—
4. å¯ä»¥ä¸ºéƒ¨åˆ† Rust ä¸­çš„ç±»å‹å®ç°`Send`ã€`Sync`ï¼Œä½†æ˜¯éœ€è¦ä½¿ç”¨`newtype`ï¼Œä¾‹å¦‚æ–‡ä¸­çš„è£¸æŒ‡é’ˆä¾‹å­



================================================
FILE: src/advance/concurrency-with-threads/sync1.md
================================================
# çº¿ç¨‹åŒæ­¥ï¼šé”ã€Condvar å’Œä¿¡å·é‡

åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼ŒåŒæ­¥æ€§æå…¶çš„é‡è¦ï¼Œå½“ä½ éœ€è¦åŒæ—¶è®¿é—®ä¸€ä¸ªèµ„æºã€æ§åˆ¶ä¸åŒçº¿ç¨‹çš„æ‰§è¡Œæ¬¡åºæ—¶ï¼Œéƒ½éœ€è¦ä½¿ç”¨åˆ°åŒæ­¥æ€§ã€‚

åœ¨ Rust ä¸­æœ‰å¤šç§æ–¹å¼å¯ä»¥å®ç°åŒæ­¥æ€§ã€‚åœ¨ä¸Šä¸€èŠ‚ä¸­è®²åˆ°çš„æ¶ˆæ¯ä¼ é€’å°±æ˜¯åŒæ­¥æ€§çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œä¾‹å¦‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ¶ˆæ¯ä¼ é€’æ¥æ§åˆ¶ä¸åŒçº¿ç¨‹é—´çš„æ‰§è¡Œæ¬¡åºã€‚è¿˜å¯ä»¥ä½¿ç”¨å…±äº«å†…å­˜æ¥å®ç°åŒæ­¥æ€§ï¼Œä¾‹å¦‚é€šè¿‡é”å’ŒåŸå­æ“ä½œç­‰å¹¶å‘åŸè¯­æ¥å®ç°å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¸”å®‰å…¨åœ°å»è®¿é—®ä¸€ä¸ªèµ„æºã€‚

## è¯¥å¦‚ä½•é€‰æ‹©

å…±äº«å†…å­˜å¯ä»¥è¯´æ˜¯åŒæ­¥çš„çµé­‚ï¼Œå› ä¸ºæ¶ˆæ¯ä¼ é€’çš„åº•å±‚å®é™…ä¸Šä¹Ÿæ˜¯é€šè¿‡å…±äº«å†…å­˜æ¥å®ç°ï¼Œä¸¤è€…çš„åŒºåˆ«å¦‚ä¸‹ï¼š

- å…±äº«å†…å­˜ç›¸å¯¹æ¶ˆæ¯ä¼ é€’èƒ½èŠ‚çœå¤šæ¬¡å†…å­˜æ‹·è´çš„æˆæœ¬
- å…±äº«å†…å­˜çš„å®ç°ç®€æ´çš„å¤š
- å…±äº«å†…å­˜çš„é”ç«äº‰æ›´å¤š

æ¶ˆæ¯ä¼ é€’é€‚ç”¨çš„åœºæ™¯å¾ˆå¤šï¼Œæˆ‘ä»¬ä¸‹é¢åˆ—å‡ºäº†å‡ ä¸ªä¸»è¦çš„ä½¿ç”¨åœºæ™¯:

- éœ€è¦å¯é å’Œç®€å•çš„(ç®€å•ä¸ç­‰äºç®€æ´)å®ç°æ—¶
- éœ€è¦æ¨¡æ‹Ÿç°å®ä¸–ç•Œï¼Œä¾‹å¦‚ç”¨æ¶ˆæ¯å»é€šçŸ¥æŸä¸ªç›®æ ‡æ‰§è¡Œç›¸åº”çš„æ“ä½œæ—¶
- éœ€è¦ä¸€ä¸ªä»»åŠ¡å¤„ç†æµæ°´çº¿(ç®¡é“)æ—¶ï¼Œç­‰ç­‰

è€Œä½¿ç”¨å…±äº«å†…å­˜(å¹¶å‘åŸè¯­)çš„åœºæ™¯å¾€å¾€å°±æ¯”è¾ƒç®€å•ç²—æš´ï¼šéœ€è¦ç®€æ´çš„å®ç°ä»¥åŠæ›´é«˜çš„æ€§èƒ½æ—¶ã€‚

æ€»ä¹‹ï¼Œæ¶ˆæ¯ä¼ é€’ç±»ä¼¼ä¸€ä¸ªå•æ‰€æœ‰æƒçš„ç³»ç»Ÿï¼šä¸€ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå¦‚æœå¦ä¸€ä¸ªçº¿ç¨‹éœ€è¦è¯¥å€¼çš„æ‰€æœ‰æƒï¼Œéœ€è¦å°†æ‰€æœ‰æƒé€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œè½¬ç§»ã€‚è€Œå…±äº«å†…å­˜ç±»ä¼¼äºä¸€ä¸ªå¤šæ‰€æœ‰æƒçš„ç³»ç»Ÿï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®åŒä¸€ä¸ªå€¼ã€‚

## äº’æ–¥é” Mutex

æ—¢ç„¶æ˜¯å…±äº«å†…å­˜ï¼Œé‚£å¹¶å‘åŸè¯­è‡ªç„¶æ˜¯é‡ä¸­ä¹‹é‡ï¼Œå…ˆæ¥ä¸€èµ·çœ‹çœ‹çš‡å† ä¸Šçš„æ˜ç : äº’æ–¥é”`Mutex`(mutual exclusion çš„ç¼©å†™)ã€‚

`Mutex`è®©å¤šä¸ªçº¿ç¨‹å¹¶å‘çš„è®¿é—®åŒä¸€ä¸ªå€¼å˜æˆäº†æ’é˜Ÿè®¿é—®ï¼šåŒä¸€æ—¶é—´ï¼Œåªå…è®¸ä¸€ä¸ªçº¿ç¨‹`A`è®¿é—®è¯¥å€¼ï¼Œå…¶å®ƒçº¿ç¨‹éœ€è¦ç­‰å¾…`A`è®¿é—®å®Œæˆåæ‰èƒ½ç»§ç»­ã€‚

#### å•çº¿ç¨‹ä¸­ä½¿ç”¨ Mutex

å…ˆæ¥çœ‹çœ‹å•çº¿ç¨‹ä¸­`Mutex`è¯¥å¦‚ä½•ä½¿ç”¨:

```rust
use std::sync::Mutex;

fn main() {
    // ä½¿ç”¨`Mutex`ç»“æ„ä½“çš„å…³è”å‡½æ•°åˆ›å»ºæ–°çš„äº’æ–¥é”å®ä¾‹
    let m = Mutex::new(5);

    {
        // è·å–é”ï¼Œç„¶åderefä¸º`m`çš„å¼•ç”¨
        // lockè¿”å›çš„æ˜¯Result
        let mut num = m.lock().unwrap();
        *num = 6;
        // é”è‡ªåŠ¨è¢«drop
    }

    println!("m = {:?}", m);
}
```

åœ¨æ³¨é‡Šä¸­ï¼Œå·²ç»å¤§è‡´æè¿°äº†ä»£ç çš„åŠŸèƒ½ï¼Œä¸è¿‡æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼šå’Œ`Box`ç±»ä¼¼ï¼Œæ•°æ®è¢«`Mutex`æ‰€æ‹¥æœ‰ï¼Œè¦è®¿é—®å†…éƒ¨çš„æ•°æ®ï¼Œéœ€è¦ä½¿ç”¨æ–¹æ³•`m.lock()`å‘`m`ç”³è¯·ä¸€ä¸ªé”, è¯¥æ–¹æ³•ä¼š**é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°è·å–åˆ°é”**ï¼Œå› æ­¤å½“å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®è¯¥æ•°æ®æ—¶ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è·å–åˆ°é”ï¼Œå…¶å®ƒçº¿ç¨‹åªèƒ½é˜»å¡ç€ç­‰å¾…ï¼Œè¿™æ ·å°±ä¿è¯äº†æ•°æ®èƒ½è¢«å®‰å…¨çš„ä¿®æ”¹ï¼

**`m.lock()`æ–¹æ³•ä¹Ÿæœ‰å¯èƒ½æŠ¥é”™**ï¼Œä¾‹å¦‚å½“å‰æ­£åœ¨æŒæœ‰é”çš„çº¿ç¨‹`panic`äº†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå…¶å®ƒçº¿ç¨‹ä¸å¯èƒ½å†è·å¾—é”ï¼Œå› æ­¤`lock`æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

è¿™é‡Œä½ å¯èƒ½å¥‡æ€ªï¼Œ`m.lock`æ˜æ˜è¿”å›ä¸€ä¸ªé”ï¼Œæ€ä¹ˆå°±å˜æˆæˆ‘ä»¬çš„`num`æ•°å€¼äº†ï¼Ÿèªæ˜çš„è¯»è€…å¯èƒ½ä¼šæƒ³åˆ°æ™ºèƒ½æŒ‡é’ˆï¼Œæ²¡é”™ï¼Œå› ä¸º`Mutex<T>`æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå‡†ç¡®çš„è¯´æ˜¯`m.lock()`è¿”å›ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ`MutexGuard<T>`:

- å®ƒå®ç°äº†`Deref`ç‰¹å¾ï¼Œä¼šè¢«è‡ªåŠ¨è§£å¼•ç”¨åè·å¾—ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼Œè¯¥å¼•ç”¨æŒ‡å‘`Mutex`å†…éƒ¨çš„æ•°æ®
- å®ƒè¿˜å®ç°äº†`Drop`ç‰¹å¾ï¼Œåœ¨è¶…å‡ºä½œç”¨åŸŸåï¼Œè‡ªåŠ¨é‡Šæ”¾é”ï¼Œä»¥ä¾¿å…¶å®ƒçº¿ç¨‹èƒ½ç»§ç»­è·å–é”

æ­£å› ä¸ºæ™ºèƒ½æŒ‡é’ˆçš„ä½¿ç”¨ï¼Œä½¿å¾—æˆ‘ä»¬æ— éœ€ä»»ä½•æ“ä½œå°±èƒ½è·å–å…¶ä¸­çš„æ•°æ®ã€‚ å¦‚æœé‡Šæ”¾é”ï¼Œä½ éœ€è¦åšçš„ä»…ä»…æ˜¯åšå¥½é”çš„ä½œç”¨åŸŸç®¡ç†ï¼Œä¾‹å¦‚ä¸Šè¿°ä»£ç çš„å†…éƒ¨èŠ±æ‹¬å·ä½¿ç”¨ï¼Œå»ºè®®è¯»è€…å°è¯•ä¸‹å»æ‰å†…éƒ¨çš„èŠ±æ‹¬å·ï¼Œç„¶åå†æ¬¡å°è¯•è·å–ç¬¬äºŒä¸ªé”`num1`ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œå‹æƒ…æç¤ºï¼šä¸ä¼šæŠ¥é”™ï¼Œä½†æ˜¯ä¸»çº¿ç¨‹ä¼šæ°¸è¿œé˜»å¡ï¼Œå› ä¸ºä¸å¹¸å‘ç”Ÿäº†æ­»é”ã€‚

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    let mut num = m.lock().unwrap();
    *num = 6;
    // é”è¿˜æ²¡æœ‰è¢« drop å°±å°è¯•ç”³è¯·ä¸‹ä¸€ä¸ªé”ï¼Œå¯¼è‡´ä¸»çº¿ç¨‹é˜»å¡
    // drop(num); // æ‰‹åŠ¨ drop num ï¼Œå¯ä»¥è®© num1 ç”³è¯·åˆ°ä¸‹ä¸ªé”
    let mut num1 = m.lock().unwrap();
    *num1 = 7;
    // drop(num1); // æ‰‹åŠ¨ drop num1 ï¼Œè§‚å¯Ÿæ‰“å°ç»“æœçš„ä¸åŒ

    println!("m = {:?}", m);
}
```

#### å¤šçº¿ç¨‹ä¸­ä½¿ç”¨ Mutex

å•çº¿ç¨‹ä¸­ä½¿ç”¨é”ï¼Œè¯´å®è¯çº¯ç²¹æ˜¯ä¸ºäº†æ¼”ç¤ºåŠŸèƒ½ï¼Œæ¯•ç«Ÿå¤šçº¿ç¨‹æ‰æ˜¯é”çš„èˆå°ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ï¼Œå¦‚ä½•åœ¨å¤šçº¿ç¨‹ä¸‹ä½¿ç”¨`Mutex`æ¥è®¿é—®åŒä¸€ä¸ªèµ„æº.

##### æ— æ³•è¿è¡Œçš„`Rc<T>`

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    // é€šè¿‡`Rc`å®ç°`Mutex`çš„å¤šæ‰€æœ‰æƒ
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        // åˆ›å»ºå­çº¿ç¨‹ï¼Œå¹¶å°†`Mutex`çš„æ‰€æœ‰æƒæ‹·è´ä¼ å…¥åˆ°å­çº¿ç¨‹ä¸­
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰å­çº¿ç¨‹å®Œæˆ
    for handle in handles {
        handle.join().unwrap();
    }

    // è¾“å‡ºæœ€ç»ˆçš„è®¡æ•°ç»“æœ
    println!("Result: {}", *counter.lock().unwrap());
}
```

ç”±äºå­çº¿ç¨‹éœ€è¦é€šè¿‡`move`æ‹¿èµ°é”çš„æ‰€æœ‰æƒï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨å¤šæ‰€æœ‰æƒæ¥ä¿è¯æ¯ä¸ªçº¿ç¨‹éƒ½æ‹¿åˆ°æ•°æ®çš„ç‹¬ç«‹æ‰€æœ‰æƒï¼Œæ°å¥½æ™ºèƒ½æŒ‡é’ˆ[`Rc<T>`](https://course.rs/advance/smart-pointer/rc-arc.html)å¯ä»¥åšåˆ°(**ä¸Šé¢ä»£ç ä¼šæŠ¥é”™**ï¼å…·ä½“å¾€ä¸‹çœ‹ï¼Œåˆ«è·³è¿‡-, -)ã€‚

ä»¥ä¸Šä»£ç å®ç°äº†åœ¨å¤šçº¿ç¨‹ä¸­è®¡æ•°çš„åŠŸèƒ½ï¼Œç”±äºå¤šä¸ªçº¿ç¨‹éƒ½éœ€è¦å»ä¿®æ”¹è¯¥è®¡æ•°å™¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨é”æ¥ä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥ä¿®æ”¹è®¡æ•°å™¨ï¼Œå¦åˆ™ä¼šå¯¼è‡´è„æ•°æ®ï¼šæƒ³è±¡ä¸€ä¸‹ A çº¿ç¨‹å’Œ B çº¿ç¨‹åŒæ—¶æ‹¿åˆ°è®¡æ•°å™¨ï¼Œè·å–äº†å½“å‰å€¼`1`, å¹¶ä¸”åŒæ—¶å¯¹å…¶è¿›è¡Œäº†ä¿®æ”¹ï¼Œæœ€åå€¼å˜æˆ`2`ï¼Œä½ ä¼šä¸ä¼šåœ¨é£ä¸­å‡Œä¹±ï¼Ÿæ¯•ç«Ÿæ­£ç¡®çš„å€¼æ˜¯`3`ï¼Œå› ä¸ºä¸¤ä¸ªçº¿ç¨‹å„è‡ªåŠ  1ã€‚

å¯èƒ½æœ‰äººä¼šè¯´ï¼Œæœ‰é‚£ä¹ˆå·§çš„äº‹æƒ…å—ï¼Ÿäº‹å®ä¸Šï¼Œå¯¹äºäººç±»æ¥è¯´ï¼Œå› ä¸ºå¹²å•¥å•¥æ…¢ï¼Œå¹¶æ²¡æœ‰é‚£ä¹ˆå¤šå·§åˆï¼Œæ‰€ä»¥äººæ€»ä¼šå­˜åœ¨å·§åˆå¿ƒç†ã€‚ä½†æ˜¯å¯¹äºè®¡ç®—æœºè€Œè¨€ï¼Œæ¯ç§’å¯ä»¥è½»æ¾è¿è¡Œä¸Šäº¿æ¬¡ï¼Œåœ¨è¿™ç§é¢‘æ¬¡ä¸‹ï¼Œä¸€åˆ‡å·§åˆå‡ ä¹éƒ½å°†å¿…ç„¶å‘ç”Ÿï¼Œå› æ­¤åƒä¸‡ä¸è¦æœ‰ä»»ä½•ä¾¥å¹¸å¿ƒç†ã€‚

> å¦‚æœäº‹æƒ…æœ‰å˜åçš„å¯èƒ½ï¼Œä¸ç®¡è¿™ç§å¯èƒ½æ€§æœ‰å¤šå°ï¼Œå®ƒéƒ½ä¼šå‘ç”Ÿï¼ - åœ¨è®¡ç®—æœºé¢†åŸŸæ­ªæ‰“æ­£ç€çš„å¢¨è²å®šå¾‹

äº‹å®ä¸Šï¼Œä¸Šé¢çš„ä»£ç ä¼šæŠ¥é”™:

```console
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
                // `Rc`æ— æ³•åœ¨çº¿ç¨‹ä¸­å®‰å…¨çš„ä¼ è¾“
   --> src/main.rs:11:22
    |
13  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc<Mutex<i32>>` cannot be sent between threads safely
14  | |             let mut num = counter.lock().unwrap();
15  | |
16  | |             *num += 1;
17  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
     // `Rc`æ²¡æœ‰å®ç°`Send`ç‰¹å¾
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
```

é”™è¯¯ä¸­æåˆ°äº†ä¸€ä¸ªå…³é”®ç‚¹ï¼š`Rc<T>`æ— æ³•åœ¨çº¿ç¨‹ä¸­ä¼ è¾“ï¼Œå› ä¸ºå®ƒæ²¡æœ‰å®ç°`Send`ç‰¹å¾(åœ¨ä¸‹ä¸€èŠ‚å°†è¯¦ç»†ä»‹ç»)ï¼Œè€Œè¯¥ç‰¹å¾å¯ä»¥ç¡®ä¿æ•°æ®åœ¨çº¿ç¨‹ä¸­å®‰å…¨çš„ä¼ è¾“ã€‚

##### å¤šçº¿ç¨‹å®‰å…¨çš„ `Arc<T>`

å¥½åœ¨ï¼Œæˆ‘ä»¬æœ‰`Arc<T>`ï¼Œå¾—ç›Šäºå®ƒçš„[å†…éƒ¨è®¡æ•°å™¨](https://course.rs/advance/smart-pointer/rc-arc.html#å¤šçº¿ç¨‹æ— åŠ›çš„rc)æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ï¼Œå› æ­¤å¯ä»¥åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ä½¿ç”¨:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

ä»¥ä¸Šä»£ç å¯ä»¥é¡ºåˆ©è¿è¡Œ:

```console
Result: 10
```

#### å†…éƒ¨å¯å˜æ€§

åœ¨ä¹‹å‰ç« èŠ‚ï¼Œæˆ‘ä»¬æåˆ°è¿‡[å†…éƒ¨å¯å˜æ€§](https://course.rs/advance/smart-pointer/cell-refcell.html#å†…éƒ¨å¯å˜æ€§)ï¼Œå…¶ä¸­`Rc<T>`å’Œ`RefCell<T>`çš„ç»“åˆï¼Œå¯ä»¥å®ç°å•çº¿ç¨‹çš„å†…éƒ¨å¯å˜æ€§ã€‚

ç°åœ¨æˆ‘ä»¬åˆæœ‰äº†æ–°çš„æ­¦å™¨ï¼Œç”±äº`Mutex<T>`å¯ä»¥æ”¯æŒä¿®æ”¹å†…éƒ¨æ•°æ®ï¼Œå½“ç»“åˆ`Arc<T>`ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå¯ä»¥å®ç°å¤šçº¿ç¨‹çš„å†…éƒ¨å¯å˜æ€§ã€‚

ç®€å•æ€»ç»“ä¸‹ï¼š`Rc<T>/RefCell<T>`ç”¨äºå•çº¿ç¨‹å†…éƒ¨å¯å˜æ€§ï¼Œ `Arc<T>/Mutex<T>`ç”¨äºå¤šçº¿ç¨‹å†…éƒ¨å¯å˜æ€§ã€‚

#### éœ€è¦å°å¿ƒä½¿ç”¨çš„ Mutex

å¦‚æœæœ‰å…¶å®ƒè¯­è¨€çš„ç¼–ç¨‹ç»éªŒï¼Œå°±çŸ¥é“äº’æ–¥é”è¿™å®¶ä¼™ä¸å¥½å¯¹ä»˜ï¼Œæƒ³è¦æ­£ç¡®ä½¿ç”¨ï¼Œä½ å¾—ç‰¢è®°åœ¨å¿ƒï¼š

- åœ¨ä½¿ç”¨æ•°æ®å‰å¿…é¡»å…ˆè·å–é”
- åœ¨æ•°æ®ä½¿ç”¨å®Œæˆåï¼Œå¿…é¡»**åŠæ—¶**çš„é‡Šæ”¾é”ï¼Œæ¯”å¦‚æ–‡ç« å¼€å¤´çš„ä¾‹å­ï¼Œä½¿ç”¨å†…éƒ¨è¯­å¥å—çš„ç›®çš„å°±æ˜¯ä¸ºäº†åŠæ—¶çš„é‡Šæ”¾é”

è¿™ä¸¤ç‚¹çœ‹èµ·æ¥ä¸èµ·çœ¼ï¼Œä½†è¦æ­£ç¡®çš„ä½¿ç”¨ï¼Œå…¶å®æ˜¯ç›¸å½“ä¸ç®€å•çš„ï¼Œå¯¹äºå…¶å®ƒè¯­è¨€ï¼Œå¿˜è®°é‡Šæ”¾é”æ˜¯ç»å¸¸å‘ç”Ÿçš„ï¼Œè™½ç„¶ Rust é€šè¿‡æ™ºèƒ½æŒ‡é’ˆçš„`drop`æœºåˆ¶å¸®åŠ©æˆ‘ä»¬é¿å…äº†è¿™ä¸€ç‚¹ï¼Œä½†æ˜¯ç”±äºä¸åŠæ—¶é‡Šæ”¾é”å¯¼è‡´çš„æ€§èƒ½é—®é¢˜ä¹Ÿæ˜¯å¸¸è§çš„ã€‚

æ­£å› ä¸ºè¿™ç§å›°éš¾æ€§ï¼Œå¯¼è‡´å¾ˆå¤šç”¨æˆ·éƒ½çƒ­è¡·äºä½¿ç”¨æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼æ¥å®ç°åŒæ­¥ï¼Œä¾‹å¦‚ Go è¯­è¨€ç›´æ¥æŠŠ`channel`å†…ç½®åœ¨è¯­è¨€ç‰¹æ€§ä¸­ï¼Œç”šè‡³è¿˜æœ‰æ— é”çš„è¯­è¨€ï¼Œä¾‹å¦‚`erlang`ï¼Œå®Œå…¨ä½¿ç”¨`Actor`æ¨¡å‹ï¼Œä¾èµ–æ¶ˆæ¯ä¼ é€’æ¥å®Œæˆå…±äº«å’ŒåŒæ­¥ã€‚å¹¸å¥½ Rust çš„ç±»å‹ç³»ç»Ÿã€æ‰€æœ‰æƒæœºåˆ¶ã€æ™ºèƒ½æŒ‡é’ˆç­‰å¯ä»¥å¾ˆå¥½çš„å¸®åŠ©æˆ‘ä»¬å‡è½»ä½¿ç”¨é”æ—¶çš„è´Ÿæ‹…ã€‚

å¦ä¸€ä¸ªå€¼çš„æ³¨æ„çš„æ˜¯åœ¨ä½¿ç”¨`Mutex<T>`æ—¶ï¼ŒRust æ— æ³•å¸®æˆ‘ä»¬é¿å…æ‰€æœ‰çš„é€»è¾‘é”™è¯¯ï¼Œä¾‹å¦‚åœ¨ä¹‹å‰ç« èŠ‚ï¼Œæˆ‘ä»¬æåˆ°è¿‡ä½¿ç”¨`Rc<T>`å¯èƒ½ä¼šå¯¼è‡´[å¾ªç¯å¼•ç”¨çš„é—®é¢˜](https://course.rs/advance/circle-self-ref/circle-reference.html)ã€‚ç±»ä¼¼çš„ï¼Œ`Mutex<T>`ä¹Ÿå­˜åœ¨ä½¿ç”¨ä¸Šçš„é£é™©ï¼Œä¾‹å¦‚åˆ›å»ºæ­»é”(deadlock)ï¼šå½“ä¸€ä¸ªæ“ä½œè¯•å›¾é”ä½ä¸¤ä¸ªèµ„æºï¼Œç„¶åä¸¤ä¸ªçº¿ç¨‹å„è‡ªè·å–å…¶ä¸­ä¸€ä¸ªé”ï¼Œå¹¶è¯•å›¾è·å–å¦ä¸€ä¸ªé”æ—¶ï¼Œå°±ä¼šé€ æˆæ­»é”ã€‚

## æ­»é”

åœ¨ Rust ä¸­æœ‰å¤šç§æ–¹å¼å¯ä»¥åˆ›å»ºæ­»é”ï¼Œäº†è§£è¿™äº›æ–¹å¼æœ‰åŠ©äºä½ æå‰è§„é¿å¯èƒ½çš„é£é™©ï¼Œä¸€èµ·æ¥çœ‹çœ‹ã€‚

#### å•çº¿ç¨‹æ­»é”

è¿™ç§æ­»é”æ¯”è¾ƒå®¹æ˜“è§„é¿ï¼Œä½†æ˜¯å½“ä»£ç å¤æ‚åè¿˜æ˜¯æœ‰å¯èƒ½é‡åˆ°ï¼š

```rust
use std::sync::Mutex;

fn main() {
    let data = Mutex::new(0);
    let d1 = data.lock();
    let d2 = data.lock();
} // d1é”åœ¨æ­¤å¤„é‡Šæ”¾
```

éå¸¸ç®€å•ï¼Œåªè¦ä½ åœ¨å¦ä¸€ä¸ªé”è¿˜æœªè¢«é‡Šæ”¾æ—¶å»ç”³è¯·æ–°çš„é”ï¼Œå°±ä¼šè§¦å‘ï¼Œå½“ä»£ç å¤æ‚åï¼Œè¿™ç§æƒ…å†µå¯èƒ½å°±æ²¡æœ‰é‚£ä¹ˆæ˜¾çœ¼ã€‚

#### å¤šçº¿ç¨‹æ­»é”

å½“æˆ‘ä»¬æ‹¥æœ‰ä¸¤ä¸ªé”ï¼Œä¸”ä¸¤ä¸ªçº¿ç¨‹å„è‡ªä½¿ç”¨äº†å…¶ä¸­ä¸€ä¸ªé”ï¼Œç„¶åè¯•å›¾å»è®¿é—®å¦ä¸€ä¸ªé”æ—¶ï¼Œå°±å¯èƒ½å‘ç”Ÿæ­»é”ï¼š

```rust
use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex<i64> = Mutex::new(0);
    static ref MUTEX2: Mutex<i64> = Mutex::new(0);
}

fn main() {
    // å­˜æ”¾å­çº¿ç¨‹çš„å¥æŸ„
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // çº¿ç¨‹1
                if i_thread % 2 == 0 {
                    // é”ä½MUTEX1
                    let guard: MutexGuard<i64> = MUTEX1.lock().unwrap();

                    println!("çº¿ç¨‹ {} é”ä½äº†MUTEX1ï¼Œæ¥ç€å‡†å¤‡å»é”MUTEX2 !", i_thread);

                    // å½“å‰çº¿ç¨‹ç¡çœ ä¸€å°ä¼šå„¿ï¼Œç­‰å¾…çº¿ç¨‹2é”ä½MUTEX2
                    sleep(Duration::from_millis(10));

                    // å»é”MUTEX2
                    let guard = MUTEX2.lock().unwrap();
                // çº¿ç¨‹2
                } else {
                    // é”ä½MUTEX2
                    let _guard = MUTEX2.lock().unwrap();

                    println!("çº¿ç¨‹ {} é”ä½äº†MUTEX2, å‡†å¤‡å»é”MUTEX1", i_thread);

                    let _guard = MUTEX1.lock().unwrap();
                }
            }
        }));
    }

    // ç­‰å­çº¿ç¨‹å®Œæˆ
    for child in children {
        let _ = child.join();
    }

    println!("æ­»é”æ²¡æœ‰å‘ç”Ÿ");
}
```

åœ¨ä¸Šé¢çš„æè¿°ä¸­ï¼Œæˆ‘ä»¬ç”¨äº†"å¯èƒ½"äºŒå­—ï¼ŒåŸå› åœ¨äºæ­»é”åœ¨è¿™æ®µä»£ç ä¸­ä¸æ˜¯å¿…ç„¶å‘ç”Ÿçš„ï¼Œæ€»æœ‰ä¸€æ¬¡è¿è¡Œä½ èƒ½çœ‹åˆ°æœ€åä¸€è¡Œæ‰“å°è¾“å‡ºã€‚è¿™æ˜¯ç”±äºå­çº¿ç¨‹çš„åˆå§‹åŒ–é¡ºåºå’Œæ‰§è¡Œé€Ÿåº¦å¹¶ä¸ç¡®å®šï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šå“ªä¸ªçº¿ç¨‹ä¸­çš„é”å…ˆè¢«æ‰§è¡Œï¼Œå› æ­¤ä¹Ÿæ— æ³•ç¡®å®šä¸¤ä¸ªçº¿ç¨‹å¯¹é”çš„å…·ä½“ä½¿ç”¨é¡ºåºã€‚

ä½†æ˜¯ï¼Œå¯ä»¥ç®€å•çš„è¯´æ˜ä¸‹æ­»é”å‘ç”Ÿçš„å¿…ç„¶æ¡ä»¶ï¼šçº¿ç¨‹ 1 é”ä½äº†`MUTEX1`å¹¶ä¸”çº¿ç¨‹`2`é”ä½äº†`MUTEX2`ï¼Œç„¶åçº¿ç¨‹ 1 è¯•å›¾å»è®¿é—®`MUTEX2`ï¼ŒåŒæ—¶çº¿ç¨‹`2`è¯•å›¾å»è®¿é—®`MUTEX1`ï¼Œå°±ä¼šæ­»é”ã€‚ å› ä¸ºçº¿ç¨‹ 2 éœ€è¦ç­‰å¾…çº¿ç¨‹ 1 é‡Šæ”¾`MUTEX1`åï¼Œæ‰ä¼šé‡Šæ”¾`MUTEX2`ï¼Œè€Œä¸æ­¤åŒæ—¶ï¼Œçº¿ç¨‹ 1 éœ€è¦ç­‰å¾…çº¿ç¨‹ 2 é‡Šæ”¾`MUTEX2`åæ‰èƒ½é‡Šæ”¾`MUTEX1`ï¼Œè¿™ç§æƒ…å†µé€ æˆäº†ä¸¤ä¸ªçº¿ç¨‹éƒ½æ— æ³•é‡Šæ”¾å¯¹æ–¹éœ€è¦çš„é”ï¼Œæœ€ç»ˆæ­»é”ã€‚

é‚£ä¹ˆä¸ºä½•æŸäº›æ—¶å€™ï¼Œæ­»é”ä¸ä¼šå‘ç”Ÿï¼ŸåŸå› å¾ˆç®€å•ï¼Œçº¿ç¨‹ 2 åœ¨çº¿ç¨‹ 1 é”`MUTEX1`ä¹‹å‰ï¼Œå°±å·²ç»å…¨éƒ¨æ‰§è¡Œå®Œäº†ï¼Œéšä¹‹çº¿ç¨‹ 2 çš„`MUTEX2`å’Œ`MUTEX1`è¢«å…¨éƒ¨é‡Šæ”¾ï¼Œçº¿ç¨‹ 1 å¯¹é”çš„è·å–å°†ä¸å†æœ‰ç«äº‰è€…ã€‚ åŒç†ï¼Œçº¿ç¨‹ 1 è‹¥å…¨éƒ¨è¢«æ‰§è¡Œå®Œï¼Œé‚£çº¿ç¨‹ 2 ä¹Ÿä¸ä¼šè¢«é”ï¼Œå› æ­¤æˆ‘ä»¬åœ¨çº¿ç¨‹ 1 ä¸­é—´åŠ ä¸€ä¸ªç¡çœ ï¼Œå¢åŠ æ­»é”å‘ç”Ÿçš„æ¦‚ç‡ã€‚å¦‚æœä½ åœ¨çº¿ç¨‹ 2 ä¸­åŒæ ·çš„ä½ç½®ä¹Ÿå¢åŠ ä¸€ä¸ªç¡çœ ï¼Œé‚£æ­»é”å°†å¿…ç„¶å‘ç”Ÿ!

#### try_lock

ä¸`lock`æ–¹æ³•ä¸åŒï¼Œ`try_lock`ä¼š**å°è¯•**å»è·å–ä¸€æ¬¡é”ï¼Œå¦‚æœæ— æ³•è·å–ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œå› æ­¤**ä¸ä¼šå‘ç”Ÿé˜»å¡**:

```rust
use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex<i64> = Mutex::new(0);
    static ref MUTEX2: Mutex<i64> = Mutex::new(0);
}

fn main() {
    // å­˜æ”¾å­çº¿ç¨‹çš„å¥æŸ„
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // çº¿ç¨‹1
                if i_thread % 2 == 0 {
                    // é”ä½MUTEX1
                    let guard: MutexGuard<i64> = MUTEX1.lock().unwrap();

                    println!("çº¿ç¨‹ {} é”ä½äº†MUTEX1ï¼Œæ¥ç€å‡†å¤‡å»é”MUTEX2 !", i_thread);

                    // å½“å‰çº¿ç¨‹ç¡çœ ä¸€å°ä¼šå„¿ï¼Œç­‰å¾…çº¿ç¨‹2é”ä½MUTEX2
                    sleep(Duration::from_millis(10));

                    // å»é”MUTEX2
                    let guard = MUTEX2.try_lock();
                    println!("çº¿ç¨‹ {} è·å– MUTEX2 é”çš„ç»“æœ: {:?}", i_thread, guard);
                // çº¿ç¨‹2
                } else {
                    // é”ä½MUTEX2
                    let _guard = MUTEX2.lock().unwrap();

                    println!("çº¿ç¨‹ {} é”ä½äº†MUTEX2, å‡†å¤‡å»é”MUTEX1", i_thread);
                    sleep(Duration::from_millis(10));
                    let guard = MUTEX1.try_lock();
                    println!("çº¿ç¨‹ {} è·å– MUTEX1 é”çš„ç»“æœ: {:?}", i_thread, guard);
                }
            }
        }));
    }

    // ç­‰å­çº¿ç¨‹å®Œæˆ
    for child in children {
        let _ = child.join();
    }

    println!("æ­»é”æ²¡æœ‰å‘ç”Ÿ");
}
```

ä¸ºäº†æ¼”ç¤º`try_lock`çš„ä½œç”¨ï¼Œæˆ‘ä»¬ç‰¹å®šä½¿ç”¨äº†ä¹‹å‰å¿…å®šä¼šæ­»é”çš„ä»£ç ï¼Œå¹¶ä¸”å°†`lock`æ›¿æ¢æˆ`try_lock`ï¼Œä¸ä¹‹å‰çš„ç»“æœä¸åŒï¼Œè¿™æ®µä»£ç å°†ä¸ä¼šå†æœ‰æ­»é”å‘ç”Ÿï¼š

```console
çº¿ç¨‹ 0 é”ä½äº†MUTEX1ï¼Œæ¥ç€å‡†å¤‡å»é”MUTEX2 !
çº¿ç¨‹ 1 é”ä½äº†MUTEX2, å‡†å¤‡å»é”MUTEX1
çº¿ç¨‹ 1 è·å– MUTEX1 é”çš„ç»“æœ: Err("WouldBlock")
çº¿ç¨‹ 0 è·å– MUTEX2 é”çš„ç»“æœ: Ok(0)
æ­»é”æ²¡æœ‰å‘ç”Ÿ
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå½“`try_lock`å¤±è´¥æ—¶ï¼Œä¼šæŠ¥å‡ºä¸€ä¸ªé”™è¯¯:`Err("WouldBlock")`ï¼Œæ¥ç€çº¿ç¨‹ä¸­çš„å‰©ä½™ä»£ç ä¼šç»§ç»­æ‰§è¡Œï¼Œä¸ä¼šè¢«é˜»å¡ã€‚

> ä¸€ä¸ªæœ‰è¶£çš„å‘½åè§„åˆ™ï¼šåœ¨ Rust æ ‡å‡†åº“ä¸­ï¼Œä½¿ç”¨`try_xxx`éƒ½ä¼šå°è¯•è¿›è¡Œä¸€æ¬¡æ“ä½œï¼Œå¦‚æœæ— æ³•å®Œæˆï¼Œå°±ç«‹å³è¿”å›ï¼Œä¸ä¼šå‘ç”Ÿé˜»å¡ã€‚ä¾‹å¦‚æ¶ˆæ¯ä¼ é€’ç« èŠ‚ä¸­çš„`try_recv`ä»¥åŠæœ¬ç« èŠ‚ä¸­çš„`try_lock`

## è¯»å†™é” RwLock

`Mutex`ä¼šå¯¹æ¯æ¬¡è¯»å†™éƒ½è¿›è¡ŒåŠ é”ï¼Œä½†æŸäº›æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å¤§é‡çš„å¹¶å‘è¯»ï¼Œ`Mutex`å°±æ— æ³•æ»¡è¶³éœ€æ±‚äº†ï¼Œæ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨`RwLock`:

```rust
use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // åŒä¸€æ—¶é—´å…è®¸å¤šä¸ªè¯»
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // è¯»é”åœ¨æ­¤å¤„è¢«drop

    // åŒä¸€æ—¶é—´åªå…è®¸ä¸€ä¸ªå†™
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);

        // ä»¥ä¸‹ä»£ç ä¼šé˜»å¡å‘ç”Ÿæ­»é”ï¼Œå› ä¸ºè¯»å’Œå†™ä¸å…è®¸åŒæ—¶å­˜åœ¨
        // å†™é”wç›´åˆ°è¯¥è¯­å¥å—ç»“æŸæ‰è¢«é‡Šæ”¾ï¼Œå› æ­¤ä¸‹é¢çš„è¯»é”ä¾ç„¶å¤„äº`w`çš„ä½œç”¨åŸŸä¸­
        // let r1 = lock.read();
        // println!("{:?}",r1);
    }// å†™é”åœ¨æ­¤å¤„è¢«drop
}
```

`RwLock`åœ¨ä½¿ç”¨ä¸Šå’Œ`Mutex`åŒºåˆ«ä¸å¤§ï¼Œåªæœ‰åœ¨å¤šä¸ªè¯»çš„æƒ…å†µä¸‹ä¸é˜»å¡ç¨‹åºï¼Œå…¶ä»–å¦‚è¯»å†™ã€å†™è¯»ã€å†™å†™æƒ…å†µä¸‹å‡ä¼šå¯¹åè·å–é”çš„æ“ä½œè¿›è¡Œé˜»å¡ã€‚

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨`try_write`å’Œ`try_read`æ¥å°è¯•è¿›è¡Œä¸€æ¬¡å†™/è¯»ï¼Œè‹¥å¤±è´¥åˆ™è¿”å›é”™è¯¯:

```console
Err("WouldBlock")
```

ç®€å•æ€»ç»“ä¸‹`RwLock`:

1. åŒæ—¶å…è®¸å¤šä¸ªè¯»ï¼Œä½†æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªå†™
2. è¯»å’Œå†™ä¸èƒ½åŒæ—¶å­˜åœ¨
3. è¯»å¯ä»¥ä½¿ç”¨`read`ã€`try_read`ï¼Œå†™`write`ã€`try_write`, åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œ`try_xxx`ä¼šå®‰å…¨çš„å¤š

## Mutex è¿˜æ˜¯ RwLock

é¦–å…ˆç®€å•æ€§ä¸Š`Mutex`å®Œèƒœï¼Œå› ä¸ºä½¿ç”¨`RwLock`ä½ å¾—æ“å¿ƒå‡ ä¸ªé—®é¢˜ï¼š

- è¯»å’Œå†™ä¸èƒ½åŒæ—¶å‘ç”Ÿï¼Œå¦‚æœä½¿ç”¨`try_xxx`è§£å†³ï¼Œå°±å¿…é¡»åšå¤§é‡çš„é”™è¯¯å¤„ç†å’Œå¤±è´¥é‡è¯•æœºåˆ¶
- å½“è¯»å¤šå†™å°‘æ—¶ï¼Œå†™æ“ä½œå¯èƒ½ä¼šå› ä¸ºä¸€ç›´æ— æ³•è·å¾—é”å¯¼è‡´è¿ç»­å¤šæ¬¡å¤±è´¥([writer starvation](https://stackoverflow.com/questions/2190090/how-to-prevent-writer-starvation-in-a-read-write-lock-in-pthreads))
- RwLock å…¶å®æ˜¯æ“ä½œç³»ç»Ÿæä¾›çš„ï¼Œå®ç°åŸç†è¦æ¯”`Mutex`å¤æ‚çš„å¤šï¼Œå› æ­¤å•å°±é”çš„æ€§èƒ½è€Œè¨€ï¼Œæ¯”ä¸ä¸ŠåŸç”Ÿå®ç°çš„`Mutex`

å†æ¥ç®€å•æ€»ç»“ä¸‹ä¸¤è€…çš„ä½¿ç”¨åœºæ™¯ï¼š

- è¿½æ±‚é«˜å¹¶å‘è¯»å–æ—¶ï¼Œä½¿ç”¨`RwLock`ï¼Œå› ä¸º`Mutex`ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹å»è¯»å–
- å¦‚æœè¦ä¿è¯å†™æ“ä½œçš„æˆåŠŸæ€§ï¼Œä½¿ç”¨`Mutex`
- ä¸çŸ¥é“å“ªä¸ªåˆé€‚ï¼Œç»Ÿä¸€ä½¿ç”¨`Mutex`

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`RwLock`è™½ç„¶çœ‹ä¸Šå»è²Œä¼¼æä¾›äº†é«˜å¹¶å‘è¯»å–çš„èƒ½åŠ›ï¼Œä½†è¿™ä¸ªä¸èƒ½è¯´æ˜å®ƒçš„æ€§èƒ½æ¯”`Mutex`é«˜ï¼Œäº‹å®ä¸Š`Mutex`æ€§èƒ½è¦å¥½ä¸å°‘ï¼Œåè€…**å”¯ä¸€çš„é—®é¢˜ä¹Ÿä»…ä»…åœ¨äºä¸èƒ½å¹¶å‘è¯»å–**ã€‚

ä¸€ä¸ªå¸¸è§çš„ã€é”™è¯¯çš„ä½¿ç”¨`RwLock`çš„åœºæ™¯å°±æ˜¯ä½¿ç”¨`HashMap`è¿›è¡Œç®€å•è¯»å†™ï¼Œå› ä¸º`HashMap`çš„è¯»å’Œå†™éƒ½éå¸¸å¿«ï¼Œ`RwLock`çš„å¤æ‚å®ç°å’Œç›¸å¯¹ä½çš„æ€§èƒ½åè€Œä¼šå¯¼è‡´æ•´ä½“æ€§èƒ½çš„é™ä½ï¼Œå› æ­¤ä¸€èˆ¬æ¥è¯´æ›´é€‚åˆä½¿ç”¨`Mutex`ã€‚

æ€»ä¹‹ï¼Œå¦‚æœä½ è¦ä½¿ç”¨`RwLock`è¦ç¡®ä¿æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š**å¹¶å‘è¯»ï¼Œä¸”éœ€è¦å¯¹è¯»åˆ°çš„èµ„æºè¿›è¡Œ"é•¿æ—¶é—´"çš„æ“ä½œ**ï¼Œ`HashMap`ä¹Ÿè®¸æ»¡è¶³äº†å¹¶å‘è¯»çš„éœ€æ±‚ï¼Œä½†æ˜¯å¾€å¾€å¹¶ä¸èƒ½æ»¡è¶³åè€…ï¼š"é•¿æ—¶é—´"çš„æ“ä½œã€‚

> benchmark æ°¸è¿œæ˜¯ä½ åœ¨è¿·èŒ«æ—¶æœ€å¥½çš„æœ‹å‹ï¼

## ä¸‰æ–¹åº“æä¾›çš„é”å®ç°

æ ‡å‡†åº“åœ¨è®¾è®¡æ—¶æ€»ä¼šå­˜åœ¨å–èˆï¼Œå› ä¸ºå¾€å¾€æ€§èƒ½å¹¶ä¸æ˜¯æœ€å¥½çš„ï¼Œå¦‚æœä½ è¿½æ±‚æ€§èƒ½ï¼Œå¯ä»¥ä½¿ç”¨ä¸‰æ–¹åº“æä¾›çš„å¹¶å‘åŸè¯­:

- [parking_lot](https://crates.io/crates/parking_lot), åŠŸèƒ½æ›´å®Œå–„ã€ç¨³å®šï¼Œç¤¾åŒºè¾ƒä¸ºæ´»è·ƒï¼Œstar è¾ƒå¤šï¼Œæ›´æ–°è¾ƒä¸ºæ´»è·ƒ
- [spin](https://crates.io/crates/spin), åœ¨å¤šæ•°åœºæ™¯ä¸­æ€§èƒ½æ¯”`parking_lot`é«˜ä¸€ç‚¹ï¼Œæœ€è¿‘æ²¡æ€ä¹ˆæ›´æ–°

å¦‚æœä¸æ˜¯è¿½æ±‚ç‰¹åˆ«æè‡´çš„æ€§èƒ½ï¼Œå»ºè®®é€‰æ‹©å‰è€…ã€‚

## ç”¨æ¡ä»¶å˜é‡(Condvar)æ§åˆ¶çº¿ç¨‹çš„åŒæ­¥

`Mutex`ç”¨äºè§£å†³èµ„æºå®‰å…¨è®¿é—®çš„é—®é¢˜ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ‰‹æ®µæ¥è§£å†³èµ„æºè®¿é—®é¡ºåºçš„é—®é¢˜ã€‚è€Œ Rust è€ƒè™‘åˆ°äº†è¿™ä¸€ç‚¹ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†æ¡ä»¶å˜é‡(Condition Variables)ï¼Œå®ƒç»å¸¸å’Œ`Mutex`ä¸€èµ·ä½¿ç”¨ï¼Œå¯ä»¥è®©çº¿ç¨‹æŒ‚èµ·ï¼Œç›´åˆ°æŸä¸ªæ¡ä»¶å‘ç”Ÿåå†ç»§ç»­æ‰§è¡Œï¼Œå…¶å®`Condvar`æˆ‘ä»¬åœ¨ä¹‹å‰çš„å¤šçº¿ç¨‹ç« èŠ‚å°±å·²ç»è§åˆ°è¿‡ï¼Œç°åœ¨å†æ¥çœ‹ä¸€ä¸ªä¸åŒçš„ä¾‹å­ï¼š

```rust
use std::sync::{Arc,Mutex,Condvar};
use std::thread::{spawn,sleep};
use std::time::Duration;

fn main() {
    let flag = Arc::new(Mutex::new(false));
    let cond = Arc::new(Condvar::new());
    let cflag = flag.clone();
    let ccond = cond.clone();

    let hdl = spawn(move || {
        let mut lock = cflag.lock().unwrap();
        let mut counter = 0;

        while counter < 3 {
            while !*lock {
                // waitæ–¹æ³•ä¼šæ¥æ”¶ä¸€ä¸ªMutexGuard<'a, T>ï¼Œä¸”å®ƒä¼šè‡ªåŠ¨åœ°æš‚æ—¶é‡Šæ”¾è¿™ä¸ªé”ï¼Œä½¿å…¶ä»–çº¿ç¨‹å¯ä»¥æ‹¿åˆ°é”å¹¶è¿›è¡Œæ•°æ®æ›´æ–°ã€‚
                // åŒæ—¶å½“å‰çº¿ç¨‹åœ¨æ­¤å¤„ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°è¢«å…¶ä»–åœ°æ–¹notifyåï¼Œå®ƒä¼šå°†åŸæœ¬çš„MutexGuard<'a, T>è¿˜ç»™æˆ‘ä»¬ï¼Œå³é‡æ–°è·å–åˆ°äº†é”ï¼ŒåŒæ—¶å”¤é†’äº†æ­¤çº¿ç¨‹ã€‚
                lock = ccond.wait(lock).unwrap();
            }
            
            *lock = false;

            counter += 1;
            println!("inner counter: {}", counter);
        }
    });

    let mut counter = 0;
    loop {
        sleep(Duration::from_millis(1000));
        *flag.lock().unwrap() = true;
        counter += 1;
        if counter > 3 {
            break;
        }
        println!("outside counter: {}", counter);
        cond.notify_one();
    }
    hdl.join().unwrap();
    println!("{:?}", flag);
}
```

ä¾‹å­ä¸­é€šè¿‡ä¸»çº¿ç¨‹æ¥è§¦å‘å­çº¿ç¨‹å®ç°äº¤æ›¿æ‰“å°è¾“å‡ºï¼š

```console
outside counter: 1
inner counter: 1
outside counter: 2
inner counter: 2
outside counter: 3
inner counter: 3
Mutex { data: true, poisoned: false, .. }
```

## ä¿¡å·é‡ Semaphore

åœ¨å¤šçº¿ç¨‹ä¸­ï¼Œå¦ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µå°±æ˜¯ä¿¡å·é‡ï¼Œä½¿ç”¨å®ƒå¯ä»¥è®©æˆ‘ä»¬ç²¾å‡†çš„æ§åˆ¶å½“å‰æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡æœ€å¤§æ•°é‡ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä¸€ä¸ªæ–°æ¸¸æˆåˆšå¼€æœæ—¶(æœ‰äº›è¾ƒç«çš„è€æ¸¸æˆä¹Ÿä¼šï¼Œæ¯”å¦‚`wow`)ï¼Œå¾€å¾€ä¼šæ§åˆ¶æ¸¸æˆå†…ç©å®¶çš„åŒæ—¶åœ¨çº¿æ•°ï¼Œä¸€æ—¦è¶…è¿‡æŸä¸ªä¸´ç•Œå€¼ï¼Œå°±å¼€å§‹è¿›è¡Œæ’é˜Ÿè¿›æœã€‚è€Œåœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œä¹Ÿæœ‰å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡ä¿¡å·é‡æ¥æ§åˆ¶æœ€å¤§å¹¶å‘æ•°ï¼Œé˜²æ­¢æœåŠ¡å™¨èµ„æºè¢«æ’‘çˆ†ã€‚

æœ¬æ¥ Rust åœ¨æ ‡å‡†åº“ä¸­æœ‰æä¾›ä¸€ä¸ª[ä¿¡å·é‡å®ç°](https://doc.rust-lang.org/1.8.0/std/sync/struct.Semaphore.html), ä½†æ˜¯ç”±äºå„ç§åŸå› è¿™ä¸ªåº“ç°åœ¨å·²ç»ä¸å†æ¨èä½¿ç”¨äº†ï¼Œå› æ­¤æˆ‘ä»¬æ¨èä½¿ç”¨`tokio`ä¸­æä¾›çš„`Semaphore`å®ç°: [`tokio::sync::Semaphore`](https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/semaphore.rs)ã€‚

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));
    let mut join_handles = Vec::new();

    for _ in 0..5 {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        join_handles.push(tokio::spawn(async move {
            //
            // åœ¨è¿™é‡Œæ‰§è¡Œä»»åŠ¡...
            //
            drop(permit);
        }));
    }

    for handle in join_handles {
        handle.await.unwrap();
    }
}
```

ä¸Šé¢ä»£ç åˆ›å»ºäº†ä¸€ä¸ªå®¹é‡ä¸º 3 çš„ä¿¡å·é‡ï¼Œå½“æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡è¶…è¿‡ 3 æ—¶ï¼Œå‰©ä¸‹çš„ä»»åŠ¡éœ€è¦ç­‰å¾…æ­£åœ¨æ‰§è¡Œä»»åŠ¡å®Œæˆå¹¶å‡å°‘ä¿¡å·é‡ååˆ° 3 ä»¥å†…æ—¶ï¼Œæ‰èƒ½ç»§ç»­æ‰§è¡Œã€‚

è¿™é‡Œçš„å…³é”®å…¶å®è¯´ç™½äº†å°±åœ¨äºï¼šä¿¡å·é‡çš„ç”³è¯·å’Œå½’è¿˜ï¼Œä½¿ç”¨å‰éœ€è¦ç”³è¯·ä¿¡å·é‡ï¼Œå¦‚æœå®¹é‡æ»¡äº†ï¼Œå°±éœ€è¦ç­‰å¾…ï¼›ä½¿ç”¨åéœ€è¦é‡Šæ”¾ä¿¡å·é‡ï¼Œä»¥ä¾¿å…¶å®ƒç­‰å¾…è€…å¯ä»¥ç»§ç»­ã€‚

## æ€»ç»“

åœ¨å¾ˆå¤šæ—¶å€™ï¼Œæ¶ˆæ¯ä¼ é€’éƒ½æ˜¯éå¸¸å¥½ç”¨çš„æ‰‹æ®µï¼Œå®ƒå¯ä»¥è®©æˆ‘ä»¬çš„æ•°æ®åœ¨ä»»åŠ¡æµæ°´çº¿ä¸Šä¸æ–­æµè½¬ï¼Œå®ç°èµ·æ¥éå¸¸ä¼˜é›…ã€‚

ä½†æ˜¯å®ƒå¹¶ä¸èƒ½ä¼˜é›…çš„è§£å†³æ‰€æœ‰é—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬é¢ä¸´çš„çœŸå®ä¸–ç•Œæ˜¯éå¸¸å¤æ‚çš„ï¼Œæ— æ³•ç”¨æŸä¸€ç§é“¶å¼¹ç»Ÿä¸€è§£å†³ã€‚å½“é¢ä¸´æ¶ˆæ¯ä¼ é€’ä¸å¤ªé€‚ç”¨çš„åœºæ™¯æ—¶ï¼Œæˆ–è€…éœ€è¦æ›´å¥½çš„æ€§èƒ½å’Œç®€æ´æ€§æ—¶ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦ç”¨é”æ¥è§£å†³è¿™äº›é—®é¢˜ï¼Œå› ä¸ºé”å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€ä¸ªèµ„æºï¼Œç®€å•ç²—æš´ã€‚

é™¤äº†é”ä¹‹å¤–ï¼Œå…¶å®è¿˜æœ‰ä¸€ç§å¹¶å‘åŸè¯­å¯ä»¥å¸®åŠ©æˆ‘ä»¬è§£å†³å¹¶å‘è®¿é—®æ•°æ®çš„é—®é¢˜ï¼Œé‚£å°±æ˜¯åŸå­ç±»å‹ Atomicï¼Œåœ¨ä¸‹ä¸€ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¼šå¯¹å…¶è¿›è¡Œæ·±å…¥è®²è§£ã€‚




================================================
FILE: src/advance/concurrency-with-threads/sync2.md
================================================
# çº¿ç¨‹åŒæ­¥ï¼šAtomic åŸå­ç±»å‹ä¸å†…å­˜é¡ºåº

`Mutex`ç”¨èµ·æ¥ç®€å•ï¼Œä½†æ˜¯æ— æ³•å¹¶å‘è¯»ï¼Œ`RwLock`å¯ä»¥å¹¶å‘è¯»ï¼Œä½†æ˜¯ä½¿ç”¨åœºæ™¯è¾ƒä¸ºå—é™ä¸”æ€§èƒ½ä¸å¤Ÿï¼Œé‚£ä¹ˆæœ‰æ²¡æœ‰ä¸€ç§å…¨èƒ½æ€§é€‰æ‰‹å‘¢ï¼Ÿ æ¬¢è¿æˆ‘ä»¬çš„`Atomic`é—ªäº®ç™»åœºã€‚

ä» Rust1.34 ç‰ˆæœ¬åï¼Œå°±æ­£å¼æ”¯æŒåŸå­ç±»å‹ã€‚åŸå­æŒ‡çš„æ˜¯ä¸€ç³»åˆ—ä¸å¯è¢« CPU ä¸Šä¸‹æ–‡äº¤æ¢çš„æœºå™¨æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤ç»„åˆåœ¨ä¸€èµ·å°±å½¢æˆäº†åŸå­æ“ä½œã€‚åœ¨å¤šæ ¸ CPU ä¸‹ï¼Œå½“æŸä¸ª CPU æ ¸å¿ƒå¼€å§‹è¿è¡ŒåŸå­æ“ä½œæ—¶ï¼Œä¼šå…ˆæš‚åœå…¶å®ƒ CPU å†…æ ¸å¯¹å†…å­˜çš„æ“ä½œï¼Œä»¥ä¿è¯åŸå­æ“ä½œä¸ä¼šè¢«å…¶å®ƒ CPU å†…æ ¸æ‰€å¹²æ‰°ã€‚

ç”±äºåŸå­æ“ä½œæ˜¯é€šè¿‡æŒ‡ä»¤æä¾›çš„æ”¯æŒï¼Œå› æ­¤å®ƒçš„æ€§èƒ½ç›¸æ¯”é”å’Œæ¶ˆæ¯ä¼ é€’ä¼šå¥½å¾ˆå¤šã€‚ç›¸æ¯”è¾ƒäºé”è€Œè¨€ï¼ŒåŸå­ç±»å‹ä¸éœ€è¦å¼€å‘è€…å¤„ç†åŠ é”å’Œé‡Šæ”¾é”çš„é—®é¢˜ï¼ŒåŒæ—¶æ”¯æŒä¿®æ”¹ï¼Œè¯»å–ç­‰æ“ä½œï¼Œè¿˜å…·å¤‡è¾ƒé«˜çš„å¹¶å‘æ€§èƒ½ï¼Œå‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½æ”¯æŒåŸå­ç±»å‹ã€‚

å¯ä»¥çœ‹å‡ºåŸå­ç±»å‹æ˜¯æ— é”ç±»å‹ï¼Œä½†æ˜¯æ— é”ä¸ä»£è¡¨æ— éœ€ç­‰å¾…ï¼Œå› ä¸ºåŸå­ç±»å‹å†…éƒ¨ä½¿ç”¨äº†`CAS`å¾ªç¯ï¼Œå½“å¤§é‡çš„å†²çªå‘ç”Ÿæ—¶ï¼Œè¯¥ç­‰å¾…è¿˜æ˜¯å¾—[ç­‰å¾…](https://course.rs/advance/concurrency-with-threads/thread.html#å¤šçº¿ç¨‹çš„å¼€é”€)ï¼ä½†æ˜¯æ€»å½’æ¯”é”è¦å¥½ã€‚

> CAS å…¨ç§°æ˜¯ Compare and swap, å®ƒé€šè¿‡ä¸€æ¡æŒ‡ä»¤è¯»å–æŒ‡å®šçš„å†…å­˜åœ°å€ï¼Œç„¶ååˆ¤æ–­å…¶ä¸­çš„å€¼æ˜¯å¦ç­‰äºç»™å®šçš„å‰ç½®å€¼ï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™å°†å…¶ä¿®æ”¹ä¸ºæ–°çš„å€¼

## ä½¿ç”¨ Atomic ä½œä¸ºå…¨å±€å˜é‡

åŸå­ç±»å‹çš„ä¸€ä¸ªå¸¸ç”¨åœºæ™¯ï¼Œå°±æ˜¯ä½œä¸ºå…¨å±€å˜é‡æ¥ä½¿ç”¨:

```rust
use std::ops::Sub;
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -> JoinHandle<()> {
    thread::spawn(move || {
        for _ in 0..n {
            R.fetch_add(1, Ordering::Relaxed);
        }
    })
}

fn main() {
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS {
        threads.push(add_n_times(N_TIMES));
    }

    for thread in threads {
        thread.join().unwrap();
    }

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!("{:?}",Instant::now().sub(s));
}
```

ä»¥ä¸Šä»£ç å¯åŠ¨äº†æ•°ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½åœ¨ç–¯ç‹‚å¯¹å…¨å±€å˜é‡è¿›è¡ŒåŠ  1 æ“ä½œ, æœ€åå°†å®ƒä¸`çº¿ç¨‹æ•° * åŠ 1æ¬¡æ•°`è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå‘ç”Ÿäº†å› ä¸ºå¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹å¯¼è‡´äº†è„æ•°æ®ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå¿…å°†ä¸ç›¸ç­‰ã€‚å¥½åœ¨ï¼Œå®ƒæ²¡æœ‰è®©æˆ‘ä»¬å¤±æœ›ï¼Œä¸ä»…å¿«é€Ÿçš„å®Œæˆäº†ä»»åŠ¡ï¼Œè€Œä¸”ä¿è¯äº† 100%çš„å¹¶å‘å®‰å…¨æ€§ã€‚

å½“ç„¶ä»¥ä¸Šä»£ç çš„åŠŸèƒ½å…¶å®ä¹Ÿå¯ä»¥é€šè¿‡`Mutex`æ¥å®ç°ï¼Œä½†æ˜¯åè€…çš„å¼ºå¤§åŠŸèƒ½æ˜¯å»ºç«‹åœ¨é¢å¤–çš„æ€§èƒ½æŸè€—åŸºç¡€ä¸Šçš„ï¼Œå› æ­¤æ€§èƒ½ä¼šé€Šè‰²ä¸å°‘:

```console
Atomicå®ç°ï¼š673ms
Mutexå®ç°: 1136ms
```

å¯ä»¥çœ‹åˆ°`Atomic`å®ç°ä¼šæ¯”`Mutex`å¿«**41%**ï¼Œå®é™…ä¸Šåœ¨å¤æ‚åœºæ™¯ä¸‹è¿˜èƒ½æ›´å¿«(ç”šè‡³è¾¾åˆ° 4 å€çš„æ€§èƒ½å·®è·)ï¼

è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„: **å’Œ`Mutex`ä¸€æ ·ï¼Œ`Atomic`çš„å€¼å…·æœ‰å†…éƒ¨å¯å˜æ€§**ï¼Œä½ æ— éœ€å°†å…¶å£°æ˜ä¸º`mut`ï¼š

```rust
use std::sync::Mutex;
use std::sync::atomic::{Ordering, AtomicU64};

struct Counter {
    count: u64
}

fn main() {
    let n = Mutex::new(Counter {
        count: 0
    });

    n.lock().unwrap().count += 1;

    let n = AtomicU64::new(0);

    n.fetch_add(0, Ordering::Relaxed);
}
```

è¿™é‡Œæœ‰ä¸€ä¸ªå¥‡æ€ªçš„æšä¸¾æˆå‘˜`Ordering::Relaxed`, çœ‹ä¸Šå»å¾ˆåƒæ˜¯æ’åºä½œç”¨ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰åšæ’åºæ“ä½œå•Šï¼Ÿå®é™…ä¸Šå®ƒç”¨äºæ§åˆ¶åŸå­æ“ä½œä½¿ç”¨çš„**å†…å­˜é¡ºåº**ã€‚

## å†…å­˜é¡ºåº

å†…å­˜é¡ºåºæ˜¯æŒ‡ CPU åœ¨è®¿é—®å†…å­˜æ—¶çš„é¡ºåºï¼Œè¯¥é¡ºåºå¯èƒ½å—ä»¥ä¸‹å› ç´ çš„å½±å“ï¼š

- ä»£ç ä¸­çš„å…ˆåé¡ºåº
- ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´åœ¨ç¼–è¯‘é˜¶æ®µå‘ç”Ÿæ”¹å˜(å†…å­˜é‡æ’åº reordering)
- è¿è¡Œé˜¶æ®µå›  CPU çš„ç¼“å­˜æœºåˆ¶å¯¼è‡´é¡ºåºè¢«æ‰“ä¹±

#### ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´å†…å­˜é¡ºåºçš„æ”¹å˜

å¯¹äºç¬¬äºŒç‚¹ï¼Œæˆ‘ä»¬ä¸¾ä¸ªä¾‹å­ï¼š

```rust
static mut X: u64 = 0;
static mut Y: u64 = 1;

fn main() {
    ...     // A

    unsafe {
        ... // B
        X = 1;
        ... // C
        Y = 3;
        ... // D
        X = 2;
        ... // E
    }
}
```

å‡å¦‚åœ¨`C`å’Œ`D`ä»£ç ç‰‡æ®µä¸­ï¼Œæ ¹æœ¬æ²¡æœ‰ç”¨åˆ°`X = 1`ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å¾ˆå¯èƒ½ä¼šå°†`X = 1`å’Œ`X = 2`è¿›è¡Œåˆå¹¶:

```rust
 ...     // A

unsafe {
    ... // B
    X = 2;
    ... // C
    Y = 3;
    ... // D
    ... // E
}
```

è‹¥ä»£ç `A`ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ç”¨äºè¯»å–å…¨å±€é™æ€å˜é‡`X`ï¼Œåˆ™è¯¥çº¿ç¨‹å°†æ— æ³•è¯»å–åˆ°`X = 1`çš„ç»“æœï¼Œå› ä¸ºåœ¨ç¼–è¯‘é˜¶æ®µå°±å·²ç»è¢«ä¼˜åŒ–æ‰ã€‚

#### CPU ç¼“å­˜å¯¼è‡´çš„å†…å­˜é¡ºåºçš„æ”¹å˜

å‡è®¾ä¹‹å‰çš„`X = 1`æ²¡æœ‰è¢«ä¼˜åŒ–æ‰ï¼Œå¹¶ä¸”åœ¨ä»£ç ç‰‡æ®µ`A`ä¸­æœ‰ä¸€ä¸ªæ–°çš„çº¿ç¨‹:

```console
initial state: X = 0, Y = 1

THREAD Main     THREAD A
X = 1;          if X == 1 {
Y = 3;              Y *= 2;
X = 2;          }
```

æˆ‘ä»¬æ¥è®¨è®ºä¸‹ä»¥ä¸Šçº¿ç¨‹çŠ¶æ€ï¼Œ`Y`æœ€ç»ˆçš„å¯èƒ½å€¼(å¯èƒ½æ€§ä¾æ¬¡é™ä½):

- `Y = 3`: çº¿ç¨‹`Main`è¿è¡Œå®Œåæ‰è¿è¡Œçº¿ç¨‹`A`ï¼Œæˆ–è€…çº¿ç¨‹`A`è¿è¡Œå®Œåå†è¿è¡Œçº¿ç¨‹`Main`
- `Y = 6`: çº¿ç¨‹`Main`çš„`Y = 3`è¿è¡Œå®Œï¼Œä½†`X = 2`è¿˜æ²¡è¢«è¿è¡Œï¼Œ æ­¤æ—¶çº¿ç¨‹ A å¼€å§‹è¿è¡Œ`Y *= 2`, æœ€åæ‰è¿è¡Œ`Main`çº¿ç¨‹çš„`X = 2`
- `Y = 2`: çº¿ç¨‹`Main`æ­£åœ¨è¿è¡Œ`Y = 3`è¿˜æ²¡ç»“æŸï¼Œæ­¤æ—¶çº¿ç¨‹`A`æ­£åœ¨è¿è¡Œ`Y *= 2`, å› æ­¤`Y`å–åˆ°äº†å€¼ 1ï¼Œç„¶å`Main`çš„çº¿ç¨‹å°†`Y`è®¾ç½®ä¸º 3ï¼Œ ç´§æ¥ç€å°±è¢«çº¿ç¨‹`A`çš„`Y = 2`æ‰€è¦†ç›–
- `Y = 2`: ä¸Šé¢çš„è¿˜åªæ˜¯ä¸€èˆ¬çš„æ•°æ®ç«äº‰ï¼Œè¿™é‡Œè™½ç„¶äº§ç”Ÿäº†ç›¸åŒçš„ç»“æœ`2`ï¼Œä½†æ˜¯èƒŒåçš„åŸç†å¤§ç›¸å¾„åº­: çº¿ç¨‹`Main`è¿è¡Œå®Œ`Y = 3`ï¼Œä½†æ˜¯ CPU ç¼“å­˜ä¸­çš„`Y = 3`è¿˜æ²¡æœ‰è¢«åŒæ­¥åˆ°å…¶å®ƒ CPU ç¼“å­˜ä¸­ï¼Œæ­¤æ—¶çº¿ç¨‹`A`ä¸­çš„`Y *= 2`å°±å¼€å§‹è¯»å–`Y`ï¼Œç»“æœè¯»åˆ°äº†å€¼`1`ï¼Œæœ€ç»ˆè®¡ç®—å‡ºç»“æœ`2`

ç”šè‡³æ›´æ”¹æˆ:

```console
initial state: X = 0, Y = 1

THREAD Main     THREAD A
X = 1;          if X == 2 {
Y = 3;              Y *= 2;
X = 2;          }
```

è¿˜æ˜¯å¯èƒ½å‡ºç°`Y = 2`ï¼Œå› ä¸º`Main`çº¿ç¨‹ä¸­çš„`X`å’Œ`Y`è¢«åŒæ­¥åˆ°å…¶å®ƒ CPU ç¼“å­˜ä¸­çš„é¡ºåºæœªå¿…ä¸€è‡´ã€‚

#### é™å®šå†…å­˜é¡ºåºçš„ 5 ä¸ªè§„åˆ™

åœ¨ç†è§£äº†å†…å­˜é¡ºåºå¯èƒ½å­˜åœ¨çš„æ”¹å˜åï¼Œä½ å°±å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆ Rust æä¾›äº†`Ordering::Relaxed`ç”¨äºé™å®šå†…å­˜é¡ºåºäº†ï¼Œäº‹å®ä¸Šï¼Œè¯¥æšä¸¾æœ‰ 5 ä¸ªæˆå‘˜:

- **Relaxed**ï¼Œ è¿™æ˜¯æœ€å®½æ¾çš„è§„åˆ™ï¼Œå®ƒå¯¹ç¼–è¯‘å™¨å’Œ CPU ä¸åšä»»ä½•é™åˆ¶ï¼Œå¯ä»¥ä¹±åº
- **Release é‡Šæ”¾**ï¼Œè®¾å®šå†…å­˜å±éšœ(Memory barrier)ï¼Œä¿è¯å®ƒä¹‹å‰çš„æ“ä½œæ°¸è¿œåœ¨å®ƒä¹‹å‰ï¼Œä½†æ˜¯å®ƒåé¢çš„æ“ä½œå¯èƒ½è¢«é‡æ’åˆ°å®ƒå‰é¢
- **Acquire è·å–**, è®¾å®šå†…å­˜å±éšœï¼Œä¿è¯åœ¨å®ƒä¹‹åçš„è®¿é—®æ°¸è¿œåœ¨å®ƒä¹‹åï¼Œä½†æ˜¯å®ƒä¹‹å‰çš„æ“ä½œå´æœ‰å¯èƒ½è¢«é‡æ’åˆ°å®ƒåé¢ï¼Œå¾€å¾€å’Œ`Release`åœ¨ä¸åŒçº¿ç¨‹ä¸­è”åˆä½¿ç”¨
- **AcqRel**, æ˜¯ *Acquire* å’Œ *Release* çš„ç»“åˆï¼ŒåŒæ—¶æ‹¥æœ‰å®ƒä»¬ä¿©æä¾›çš„ä¿è¯ã€‚æ¯”å¦‚ä½ è¦å¯¹ä¸€ä¸ª `atomic` è‡ªå¢ 1ï¼ŒåŒæ—¶å¸Œæœ›è¯¥æ“ä½œä¹‹å‰å’Œä¹‹åçš„è¯»å–æˆ–å†™å…¥æ“ä½œä¸ä¼šè¢«é‡æ–°æ’åº
- **SeqCst é¡ºåºä¸€è‡´æ€§**ï¼Œ `SeqCst`å°±åƒæ˜¯`AcqRel`çš„åŠ å¼ºç‰ˆï¼Œå®ƒä¸ç®¡åŸå­æ“ä½œæ˜¯å±äºè¯»å–è¿˜æ˜¯å†™å…¥çš„æ“ä½œï¼Œåªè¦æŸä¸ªçº¿ç¨‹æœ‰ç”¨åˆ°`SeqCst`çš„åŸå­æ“ä½œï¼Œçº¿ç¨‹ä¸­è¯¥`SeqCst`æ“ä½œå‰çš„æ•°æ®æ“ä½œç»å¯¹ä¸ä¼šè¢«é‡æ–°æ’åœ¨è¯¥`SeqCst`æ“ä½œä¹‹åï¼Œä¸”è¯¥`SeqCst`æ“ä½œåçš„æ•°æ®æ“ä½œä¹Ÿç»å¯¹ä¸ä¼šè¢«é‡æ–°æ’åœ¨`SeqCst`æ“ä½œå‰ã€‚

è¿™äº›è§„åˆ™ç”±äºæ˜¯ç³»ç»Ÿæä¾›çš„ï¼Œå› æ­¤å…¶å®ƒè¯­è¨€æä¾›çš„ç›¸åº”è§„åˆ™ä¹Ÿå¤§åŒå°å¼‚ï¼Œå¤§å®¶å¦‚æœä¸æ˜ç™½å¯ä»¥çœ‹çœ‹å…¶å®ƒè¯­è¨€çš„ç›¸å…³è§£é‡Šã€‚

#### å†…å­˜å±éšœçš„ä¾‹å­

ä¸‹é¢æˆ‘ä»¬ä»¥`Release`å’Œ`Acquire`ä¸ºä¾‹ï¼Œä½¿ç”¨å®ƒä»¬æ„ç­‘å‡ºä¸€å¯¹å†…å­˜å±éšœï¼Œé˜²æ­¢ç¼–è¯‘å™¨å’Œ CPU å°†å±éšœå‰(Release)å’Œå±éšœå(Acquire)ä¸­çš„æ•°æ®æ“ä½œé‡æ–°æ’åœ¨å±éšœå›´æˆçš„èŒƒå›´ä¹‹å¤–:

```rust
use std::thread::{self, JoinHandle};
use std::sync::atomic::{Ordering, AtomicBool};

static mut DATA: u64 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn reset() {
    unsafe {
        DATA = 0;
    }
    READY.store(false, Ordering::Relaxed);
}

fn producer() -> JoinHandle<()> {
    thread::spawn(move || {
        unsafe {
            DATA = 100;                                 // A
        }
        READY.store(true, Ordering::Release);           // B: å†…å­˜å±éšœ â†‘
    })
}

fn consumer() -> JoinHandle<()> {
    thread::spawn(move || {
        while !READY.load(Ordering::Acquire) {}         // C: å†…å­˜å±éšœ â†“

        assert_eq!(100, unsafe { DATA });               // D
    })
}


fn main() {
    loop {
        reset();

        let t_producer = producer();
        let t_consumer = consumer();

        t_producer.join().unwrap();
        t_consumer.join().unwrap();
    }
}
```

åŸåˆ™ä¸Šï¼Œ`Acquire`ç”¨äºè¯»å–ï¼Œè€Œ`Release`ç”¨äºå†™å…¥ã€‚ä½†æ˜¯ç”±äºæœ‰äº›åŸå­æ“ä½œåŒæ—¶æ‹¥æœ‰è¯»å–å’Œå†™å…¥çš„åŠŸèƒ½ï¼Œæ­¤æ—¶å°±éœ€è¦ä½¿ç”¨`AcqRel`æ¥è®¾ç½®å†…å­˜é¡ºåºäº†ã€‚åœ¨å†…å­˜å±éšœä¸­è¢«å†™å…¥çš„æ•°æ®ï¼Œéƒ½å¯ä»¥è¢«å…¶å®ƒçº¿ç¨‹è¯»å–åˆ°ï¼Œä¸ä¼šæœ‰ CPU ç¼“å­˜çš„é—®é¢˜ã€‚

**å†…å­˜é¡ºåºçš„é€‰æ‹©**

1. ä¸çŸ¥é“æ€ä¹ˆé€‰æ‹©æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨`SeqCst`ï¼Œè™½ç„¶ä¼šç¨å¾®å‡æ…¢é€Ÿåº¦ï¼Œä½†æ˜¯æ…¢ä¸€ç‚¹ä¹Ÿæ¯”å‡ºç°é”™è¯¯å¥½
2. å¤šçº¿ç¨‹åªè®¡æ•°`fetch_add`è€Œä¸ä½¿ç”¨è¯¥å€¼è§¦å‘å…¶ä»–é€»è¾‘åˆ†æ”¯çš„ç®€å•ä½¿ç”¨åœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨`Relaxed`  
   å‚è€ƒ [Which std::sync::atomic::Ordering to use?](https://stackoverflow.com/questions/30407121/which-stdsyncatomicordering-to-use)

## å¤šçº¿ç¨‹ä¸­ä½¿ç”¨ Atomic

åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­è¦ä½¿ç”¨`Atomic`éœ€è¦é…åˆ`Arc`ï¼š

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // ç­‰å¾…å…¶å®ƒçº¿ç¨‹é‡Šæ”¾é”
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {:?}", panic);
    }
}
```

## Atomic èƒ½æ›¿ä»£é”å—

é‚£ä¹ˆåŸå­ç±»å‹æ—¢ç„¶è¿™ä¹ˆå…¨èƒ½ï¼Œå®ƒå¯ä»¥æ›¿ä»£é”å—ï¼Ÿç­”æ¡ˆæ˜¯ä¸è¡Œï¼š

- å¯¹äºå¤æ‚çš„åœºæ™¯ä¸‹ï¼Œé”çš„ä½¿ç”¨ç®€å•ç²—æš´ï¼Œä¸å®¹æ˜“æœ‰å‘
- `std::sync::atomic`åŒ…ä¸­ä»…æä¾›äº†æ•°å€¼ç±»å‹çš„åŸå­æ“ä½œï¼š`AtomicBool`, `AtomicIsize`, `AtomicUsize`, `AtomicI8`, `AtomicU16`ç­‰ï¼Œè€Œé”å¯ä»¥åº”ç”¨äºå„ç§ç±»å‹
- åœ¨æœ‰äº›æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½¿ç”¨é”æ¥é…åˆï¼Œä¾‹å¦‚ä¸Šä¸€ç« èŠ‚ä¸­ä½¿ç”¨`Mutex`é…åˆ`Condvar`

## Atomic çš„åº”ç”¨åœºæ™¯

äº‹å®ä¸Šï¼Œ`Atomic`è™½ç„¶å¯¹äºç”¨æˆ·ä¸å¤ªå¸¸ç”¨ï¼Œä½†æ˜¯å¯¹äºé«˜æ€§èƒ½åº“çš„å¼€å‘è€…ã€æ ‡å‡†åº“å¼€å‘è€…éƒ½éå¸¸å¸¸ç”¨ï¼Œå®ƒæ˜¯å¹¶å‘åŸè¯­çš„åŸºçŸ³ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›åœºæ™¯é€‚ç”¨ï¼š

- æ— é”(lock free)æ•°æ®ç»“æ„
- å…¨å±€å˜é‡ï¼Œä¾‹å¦‚å…¨å±€è‡ªå¢ ID, åœ¨åç»­ç« èŠ‚ä¼šä»‹ç»
- è·¨çº¿ç¨‹è®¡æ•°å™¨ï¼Œä¾‹å¦‚å¯ä»¥ç”¨äºç»Ÿè®¡æŒ‡æ ‡

ä»¥ä¸Šåˆ—å‡ºçš„åªæ˜¯`Atomic`é€‚ç”¨çš„éƒ¨åˆ†åœºæ™¯ï¼Œå…·ä½“åœºæ™¯éœ€è¦å¤§å®¶æœªæ¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚è¿›è¡Œæƒè¡¡é€‰æ‹©ã€‚



================================================
FILE: src/advance/concurrency-with-threads/thread.md
================================================
# ä½¿ç”¨çº¿ç¨‹

æ”¾åœ¨åå¹´å‰ï¼Œå¤šçº¿ç¨‹ç¼–ç¨‹å¯èƒ½è¿˜æ˜¯ä¸€ä¸ªå°‘æ•°äººæ‰æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä½†æ˜¯åœ¨ä»Šå¤©ï¼Œéšç€ç¼–ç¨‹è¯­è¨€çš„ä¸æ–­å‘å±•ï¼Œå¤šçº¿ç¨‹ã€å¤šåç¨‹ã€Actor ç­‰å¹¶å‘ç¼–ç¨‹æ–¹å¼å·²ç»æ·±å…¥äººå¿ƒï¼ŒåŒæ—¶å¤šçº¿ç¨‹ç¼–ç¨‹çš„é—¨æ§›ä¹Ÿåœ¨ä¸æ–­é™ä½ï¼Œæœ¬ç« èŠ‚æˆ‘ä»¬æ¥çœ‹çœ‹åœ¨ Rust ä¸­è¯¥å¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹ã€‚

## å¤šçº¿ç¨‹ç¼–ç¨‹çš„é£é™©

ç”±äºå¤šçº¿ç¨‹çš„ä»£ç æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•ä¿è¯çº¿ç¨‹é—´çš„æ‰§è¡Œé¡ºåºï¼Œè¿™ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜ï¼š

- ç«æ€æ¡ä»¶(race conditions)ï¼Œå¤šä¸ªçº¿ç¨‹ä»¥éä¸€è‡´æ€§çš„é¡ºåºåŒæ—¶è®¿é—®æ•°æ®èµ„æº
- æ­»é”(deadlocks)ï¼Œä¸¤ä¸ªçº¿ç¨‹éƒ½æƒ³ä½¿ç”¨æŸä¸ªèµ„æºï¼Œä½†æ˜¯åˆéƒ½åœ¨ç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æºåæ‰èƒ½ä½¿ç”¨ï¼Œç»“æœæœ€ç»ˆéƒ½æ— æ³•ç»§ç»­æ‰§è¡Œ
- ä¸€äº›å› ä¸ºå¤šçº¿ç¨‹å¯¼è‡´çš„å¾ˆéšæ™¦çš„ BUGï¼Œéš¾ä»¥å¤ç°å’Œè§£å†³

è™½ç„¶ Rust å·²ç»é€šè¿‡å„ç§æœºåˆ¶å‡å°‘äº†ä¸Šè¿°æƒ…å†µçš„å‘ç”Ÿï¼Œä½†æ˜¯ä¾ç„¶æ— æ³•å®Œå…¨é¿å…ä¸Šè¿°æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬åœ¨ç¼–ç¨‹æ—¶éœ€è¦æ ¼å¤–çš„å°å¿ƒï¼ŒåŒæ—¶æœ¬ä¹¦ä¹Ÿä¼šåˆ—å‡ºå¤šçº¿ç¨‹ç¼–ç¨‹æ—¶å¸¸è§çš„é™·é˜±ï¼Œè®©ä½ æå‰è§„é¿å¯èƒ½çš„é£é™©ã€‚

## åˆ›å»ºçº¿ç¨‹

ä½¿ç”¨ `thread::spawn` å¯ä»¥åˆ›å»ºçº¿ç¨‹ï¼š

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- çº¿ç¨‹å†…éƒ¨çš„ä»£ç ä½¿ç”¨é—­åŒ…æ¥æ‰§è¡Œ
- `main` çº¿ç¨‹ä¸€æ—¦ç»“æŸï¼Œç¨‹åºå°±ç«‹åˆ»ç»“æŸï¼Œå› æ­¤éœ€è¦ä¿æŒå®ƒçš„å­˜æ´»ï¼Œç›´åˆ°å…¶å®ƒå­çº¿ç¨‹å®Œæˆè‡ªå·±çš„ä»»åŠ¡
- `thread::sleep` ä¼šè®©å½“å‰çº¿ç¨‹ä¼‘çœ æŒ‡å®šçš„æ—¶é—´ï¼Œéšåå…¶å®ƒçº¿ç¨‹ä¼šè¢«è°ƒåº¦è¿è¡Œï¼ˆä¸Šä¸€èŠ‚å¹¶å‘ä¸å¹¶è¡Œä¸­æœ‰ç®€å•ä»‹ç»è¿‡ï¼‰ï¼Œå› æ­¤å°±ç®—ä½ çš„ç”µè„‘åªæœ‰ä¸€ä¸ª CPU æ ¸å¿ƒï¼Œè¯¥ç¨‹åºä¹Ÿä¼šè¡¨ç°çš„å¦‚åŒå¤š CPU æ ¸å¿ƒä¸€èˆ¬ï¼Œè¿™å°±æ˜¯å¹¶å‘ï¼

æ¥çœ‹çœ‹è¾“å‡ºï¼š

```console
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 4 from the main thread!
hi number 5 from the spawned thread!
```

å¦‚æœå¤šè¿è¡Œå‡ æ¬¡ï¼Œä½ ä¼šå‘ç°å¥½åƒæ¯æ¬¡è¾“å‡ºä¼šä¸å¤ªä¸€æ ·ï¼Œå› ä¸ºï¼šè™½è¯´çº¿ç¨‹å¾€å¾€æ˜¯è½®æµæ‰§è¡Œçš„ï¼Œä½†æ˜¯è¿™ä¸€ç‚¹æ— æ³•è¢«ä¿è¯ï¼çº¿ç¨‹è°ƒåº¦çš„æ–¹å¼å¾€å¾€å–å†³äºä½ ä½¿ç”¨çš„æ“ä½œç³»ç»Ÿã€‚æ€»ä¹‹ï¼Œ**åƒä¸‡ä¸è¦ä¾èµ–çº¿ç¨‹çš„æ‰§è¡Œé¡ºåº**ã€‚

## ç­‰å¾…å­çº¿ç¨‹çš„ç»“æŸ

ä¸Šé¢çš„ä»£ç ä½ ä¸ä½†å¯èƒ½æ— æ³•è®©å­çº¿ç¨‹ä» 1 é¡ºåºæ‰“å°åˆ° 10ï¼Œè€Œä¸”å¯èƒ½æ‰“å°çš„æ•°å­—ä¼šå˜å°‘ï¼Œå› ä¸ºä¸»çº¿ç¨‹ä¼šæå‰ç»“æŸï¼Œå¯¼è‡´å­çº¿ç¨‹ä¹Ÿéšä¹‹ç»“æŸï¼Œæ›´è¿‡åˆ†çš„æ˜¯ï¼Œå¦‚æœå½“å‰ç³»ç»Ÿç¹å¿™ï¼Œç”šè‡³è¯¥å­çº¿ç¨‹è¿˜æ²¡è¢«åˆ›å»ºï¼Œä¸»çº¿ç¨‹å°±å·²ç»ç»“æŸäº†ï¼

å› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–¹æ³•ï¼Œè®©ä¸»çº¿ç¨‹å®‰å…¨ã€å¯é åœ°ç­‰æ‰€æœ‰å­çº¿ç¨‹å®Œæˆä»»åŠ¡åï¼Œå† kill selfï¼š

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

é€šè¿‡è°ƒç”¨ `handle.join`ï¼Œå¯ä»¥è®©å½“å‰çº¿ç¨‹é˜»å¡ï¼Œç›´åˆ°å®ƒç­‰å¾…çš„å­çº¿ç¨‹çš„ç»“æŸï¼Œåœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œç”±äº `main` çº¿ç¨‹ä¼šè¢«é˜»å¡ï¼Œå› æ­¤å®ƒç›´åˆ°å­çº¿ç¨‹ç»“æŸåæ‰ä¼šè¾“å‡ºè‡ªå·±çš„ `1..5`ï¼š

```console
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

ä»¥ä¸Šè¾“å‡ºæ¸…æ™°çš„å±•ç¤ºäº†çº¿ç¨‹é˜»å¡çš„ä½œç”¨ï¼Œå¦‚æœä½ å°† `handle.join` æ”¾ç½®åœ¨ `main` çº¿ç¨‹ä¸­çš„ `for` å¾ªç¯åé¢ï¼Œé‚£å°±æ˜¯å¦å¤–ä¸€ä¸ªç»“æœï¼šä¸¤ä¸ªçº¿ç¨‹äº¤æ›¿è¾“å‡ºã€‚

## åœ¨çº¿ç¨‹é—­åŒ…ä¸­ä½¿ç”¨ move

åœ¨[é—­åŒ…](https://course.rs/advance/functional-programing/closure.html#move-å’Œ-fn)ç« èŠ‚ä¸­ï¼Œæœ‰è®²è¿‡ `move` å…³é”®å­—åœ¨é—­åŒ…ä¸­çš„ä½¿ç”¨å¯ä»¥è®©è¯¥é—­åŒ…æ‹¿èµ°ç¯å¢ƒä¸­æŸä¸ªå€¼çš„æ‰€æœ‰æƒï¼ŒåŒæ ·åœ°ï¼Œä½ å¯ä»¥ä½¿ç”¨ `move` æ¥å°†æ‰€æœ‰æƒä»ä¸€ä¸ªçº¿ç¨‹è½¬ç§»åˆ°å¦å¤–ä¸€ä¸ªçº¿ç¨‹ã€‚

é¦–å…ˆï¼Œæ¥çœ‹çœ‹åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ç›´æ¥ä½¿ç”¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­çš„æ•°æ®ä¼šå¦‚ä½•ï¼š

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

ä»¥ä¸Šä»£ç åœ¨å­çº¿ç¨‹çš„é—­åŒ…ä¸­æ•è·äº†ç¯å¢ƒä¸­çš„ `v` å˜é‡ï¼Œæ¥çœ‹çœ‹ç»“æœï¼š

```console
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

å…¶å®ä»£ç æœ¬èº«å¹¶æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œé—®é¢˜åœ¨äº Rust æ— æ³•ç¡®å®šæ–°çš„çº¿ç¨‹ä¼šæ´»å¤šä¹…ï¼ˆå¤šä¸ªçº¿ç¨‹çš„ç»“æŸé¡ºåºå¹¶ä¸æ˜¯å›ºå®šçš„ï¼‰ï¼Œæ‰€ä»¥ä¹Ÿæ— æ³•ç¡®å®šæ–°çº¿ç¨‹æ‰€å¼•ç”¨çš„ `v` æ˜¯å¦åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸€ç›´åˆæ³•ï¼š

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```

å¤§å®¶è¦è®°ä½ï¼Œçº¿ç¨‹çš„å¯åŠ¨æ—¶é—´ç‚¹å’Œç»“æŸæ—¶é—´ç‚¹æ˜¯ä¸ç¡®å®šçš„ï¼Œå› æ­¤å­˜åœ¨ä¸€ç§å¯èƒ½ï¼Œå½“ä¸»çº¿ç¨‹æ‰§è¡Œå®Œï¼Œ `v` è¢«é‡Šæ”¾æ‰æ—¶ï¼Œæ–°çš„çº¿ç¨‹å¾ˆå¯èƒ½è¿˜æ²¡æœ‰ç»“æŸç”šè‡³è¿˜æ²¡æœ‰è¢«åˆ›å»ºæˆåŠŸï¼Œæ­¤æ—¶æ–°çº¿ç¨‹å¯¹ `v` çš„å¼•ç”¨ç«‹åˆ»å°±ä¸å†åˆæ³•ï¼

å¥½åœ¨æŠ¥é”™é‡Œè¿›è¡Œäº†æç¤ºï¼š```to force the closure to take ownership of v (and any other referenced variables), use the `move` keyword```ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ `move` å…³é”®å­—æ‹¿èµ° `v` çš„æ‰€æœ‰æƒå³å¯ï¼š

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();

    // ä¸‹é¢ä»£ç ä¼šæŠ¥é”™borrow of moved value: `v`
    // println!("{:?}",v);
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå¾ˆç®€å•çš„ä»£ç ï¼Œè€Œä¸” Rust çš„æ‰€æœ‰æƒæœºåˆ¶ä¿è¯äº†æ•°æ®ä½¿ç”¨ä¸Šçš„å®‰å…¨ï¼š`v` çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™æ–°çš„çº¿ç¨‹åï¼Œ`main` çº¿ç¨‹å°†æ— æ³•ç»§ç»­ä½¿ç”¨ï¼šæœ€åä¸€è¡Œä»£ç å°†æŠ¥é”™ã€‚

## çº¿ç¨‹æ˜¯å¦‚ä½•ç»“æŸçš„

ä¹‹å‰æˆ‘ä»¬æåˆ° `main` çº¿ç¨‹æ˜¯ç¨‹åºçš„ä¸»çº¿ç¨‹ï¼Œä¸€æ—¦ç»“æŸï¼Œåˆ™ç¨‹åºéšä¹‹ç»“æŸï¼ŒåŒæ—¶å„ä¸ªå­çº¿ç¨‹ä¹Ÿå°†è¢«å¼ºè¡Œç»ˆæ­¢ã€‚é‚£ä¹ˆæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœçˆ¶çº¿ç¨‹ä¸æ˜¯ `main` çº¿ç¨‹ï¼Œé‚£ä¹ˆçˆ¶çº¿ç¨‹çš„ç»“æŸä¼šå¯¼è‡´ä»€ä¹ˆï¼Ÿè‡ªç”Ÿè‡ªç­è¿˜æ˜¯è¢«å¹²æ‰ï¼Ÿ

åœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­ï¼Œæ“ä½œç³»ç»Ÿæä¾›äº†ç›´æ¥æ€æ­»çº¿ç¨‹çš„æ¥å£ï¼Œç®€å•ç²—æš´ï¼Œä½†æ˜¯ Rust å¹¶æ²¡æœ‰æä¾›è¿™æ ·çš„æ¥å£ï¼ŒåŸå› åœ¨äºï¼Œç²—æš´åœ°ç»ˆæ­¢ä¸€ä¸ªçº¿ç¨‹å¯èƒ½ä¼šå¯¼è‡´èµ„æºæ²¡æœ‰é‡Šæ”¾ã€çŠ¶æ€æ··ä¹±ç­‰ä¸å¯é¢„æœŸçš„ç»“æœï¼Œä¸€å‘ä»¥å®‰å…¨è‡ªç§°çš„ Rustï¼Œè‡ªç„¶ä¸ä¼šç ¸è‡ªå·±çš„é¥­ç¢—ã€‚

é‚£ä¹ˆ Rust ä¸­çº¿ç¨‹æ˜¯å¦‚ä½•ç»“æŸçš„å‘¢ï¼Ÿç­”æ¡ˆå¾ˆç®€å•ï¼šçº¿ç¨‹çš„ä»£ç æ‰§è¡Œå®Œï¼Œçº¿ç¨‹å°±ä¼šè‡ªåŠ¨ç»“æŸã€‚ä½†æ˜¯å¦‚æœçº¿ç¨‹ä¸­çš„ä»£ç ä¸ä¼šæ‰§è¡Œå®Œå‘¢ï¼Ÿé‚£ä¹ˆæƒ…å†µå¯ä»¥åˆ†ä¸ºä¸¤ç§è¿›è¡Œè®¨è®ºï¼š

- çº¿ç¨‹çš„ä»»åŠ¡æ˜¯ä¸€ä¸ªå¾ªç¯ IO è¯»å–ï¼Œä»»åŠ¡æµç¨‹ç±»ä¼¼ï¼šIO é˜»å¡ï¼Œç­‰å¾…è¯»å–æ–°çš„æ•°æ® -> è¯»åˆ°æ•°æ®ï¼Œå¤„ç†å®Œæˆ -> ç»§ç»­é˜»å¡ç­‰å¾… Â·Â·Â· -> æ”¶åˆ° socket å…³é—­çš„ä¿¡å· -> ç»“æŸçº¿ç¨‹ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œç»å¤§éƒ¨åˆ†æ—¶é—´çº¿ç¨‹éƒ½å¤„äºé˜»å¡çš„çŠ¶æ€ï¼Œå› æ­¤è™½ç„¶çœ‹ä¸Šå»æ˜¯å¾ªç¯ï¼ŒCPU å ç”¨å…¶å®å¾ˆå°ï¼Œä¹Ÿæ˜¯ç½‘ç»œæœåŠ¡ä¸­æœ€æœ€å¸¸è§çš„æ¨¡å‹
- çº¿ç¨‹çš„ä»»åŠ¡æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œé‡Œé¢æ²¡æœ‰ä»»ä½•é˜»å¡ï¼ŒåŒ…æ‹¬ä¼‘çœ è¿™ç§æ“ä½œä¹Ÿæ²¡æœ‰ï¼Œæ­¤æ—¶ CPU å¾ˆä¸å¹¸çš„ä¼šè¢«è·‘æ»¡ï¼Œè€Œä¸”ä½ å¦‚æœæ²¡æœ‰è®¾ç½®ç»ˆæ­¢æ¡ä»¶ï¼Œè¯¥çº¿ç¨‹å°†æŒç»­è·‘æ»¡ä¸€ä¸ª CPU æ ¸å¿ƒï¼Œå¹¶ä¸”ä¸ä¼šè¢«ç»ˆæ­¢ï¼Œç›´åˆ° `main` çº¿ç¨‹çš„ç»“æŸ

ç¬¬ä¸€æƒ…å†µå¾ˆå¸¸è§ï¼Œæˆ‘ä»¬æ¥æ¨¡æ‹Ÿçœ‹çœ‹ç¬¬äºŒç§æƒ…å†µï¼š

```rust
use std::thread;
use std::time::Duration;
fn main() {
    // åˆ›å»ºä¸€ä¸ªçº¿ç¨‹A
    let new_thread = thread::spawn(move || {
        // å†åˆ›å»ºä¸€ä¸ªçº¿ç¨‹B
        thread::spawn(move || {
            loop {
                println!("I am a new thread.");
            }
        })
    });

    // ç­‰å¾…æ–°åˆ›å»ºçš„çº¿ç¨‹æ‰§è¡Œå®Œæˆ
    new_thread.join().unwrap();
    println!("Child thread is finish!");

    // ç¡çœ ä¸€æ®µæ—¶é—´ï¼Œçœ‹å­çº¿ç¨‹åˆ›å»ºçš„å­çº¿ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
    thread::sleep(Duration::from_millis(100));
}
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œ`main` çº¿ç¨‹åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ `A`ï¼ŒåŒæ—¶è¯¥æ–°çº¿ç¨‹åˆåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ `B`ï¼Œå¯ä»¥çœ‹åˆ° `A` çº¿ç¨‹åœ¨åˆ›å»ºå®Œ `B` çº¿ç¨‹åå°±ç«‹å³ç»“æŸäº†ï¼Œè€Œ `B` çº¿ç¨‹åˆ™åœ¨ä¸åœåœ°å¾ªç¯è¾“å‡ºã€‚

ä»ä¹‹å‰çš„çº¿ç¨‹ç»“æŸè§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥çŒœæµ‹ç¨‹åºå°†è¿™æ ·æ‰§è¡Œï¼š`A` çº¿ç¨‹ç»“æŸåï¼Œç”±å®ƒåˆ›å»ºçš„ `B` çº¿ç¨‹ä»åœ¨ç–¯ç‹‚è¾“å‡ºï¼Œç›´åˆ° `main` çº¿ç¨‹åœ¨ 100 æ¯«ç§’åç»“æŸã€‚å¦‚æœä½ æŠŠè¯¥æ—¶é—´å¢åŠ åˆ°å‡ åç§’ï¼Œå°±å¯ä»¥çœ‹åˆ°ä½ çš„ CPU æ ¸å¿ƒ 100% çš„ç››å†µäº†-,-

## å¤šçº¿ç¨‹çš„æ€§èƒ½

ä¸‹é¢æˆ‘ä»¬ä»å¤šä¸ªæ–¹é¢æ¥çœ‹çœ‹å¤šçº¿ç¨‹çš„æ€§èƒ½å¤§æ¦‚æ˜¯æ€ä¹ˆæ ·çš„ã€‚

#### åˆ›å»ºçº¿ç¨‹çš„æ€§èƒ½

æ®ä¸ç²¾ç¡®ä¼°ç®—ï¼Œåˆ›å»ºä¸€ä¸ªçº¿ç¨‹å¤§æ¦‚éœ€è¦ 0.24 æ¯«ç§’ï¼Œéšç€çº¿ç¨‹çš„å˜å¤šï¼Œè¿™ä¸ªå€¼ä¼šå˜å¾—æ›´å¤§ï¼Œå› æ­¤çº¿ç¨‹çš„åˆ›å»ºè€—æ—¶æ˜¯ä¸å¯å¿½ç•¥çš„ï¼Œåªæœ‰å½“çœŸçš„éœ€è¦å¤„ç†ä¸€ä¸ªå€¼å¾—ç”¨çº¿ç¨‹å»å¤„ç†çš„ä»»åŠ¡æ—¶ï¼Œæ‰ä½¿ç”¨çº¿ç¨‹ï¼Œä¸€äº›é¸¡æ¯›è’œçš®çš„ä»»åŠ¡ï¼Œå°±æ— éœ€åˆ›å»ºçº¿ç¨‹äº†ã€‚

#### åˆ›å»ºå¤šå°‘çº¿ç¨‹åˆé€‚

å› ä¸º CPU çš„æ ¸å¿ƒæ•°é™åˆ¶ï¼Œå½“ä»»åŠ¡æ˜¯ CPU å¯†é›†å‹æ—¶ï¼Œå°±ç®—çº¿ç¨‹æ•°è¶…è¿‡äº† CPU æ ¸å¿ƒæ•°ï¼Œä¹Ÿå¹¶ä¸èƒ½å¸®ä½ è·å¾—æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºæ¯ä¸ªçº¿ç¨‹çš„ä»»åŠ¡éƒ½å¯ä»¥è½»æ¾è®© CPU çš„æŸä¸ªæ ¸å¿ƒè·‘æ»¡ï¼Œæ—¢ç„¶å¦‚æ­¤ï¼Œè®©çº¿ç¨‹æ•°ç­‰äº CPU æ ¸å¿ƒæ•°æ˜¯æœ€å¥½çš„ã€‚

ä½†æ˜¯å½“ä½ çš„ä»»åŠ¡å¤§éƒ¨åˆ†æ—¶é—´éƒ½å¤„äºé˜»å¡çŠ¶æ€æ—¶ï¼Œå°±å¯ä»¥è€ƒè™‘å¢å¤šçº¿ç¨‹æ•°é‡ï¼Œè¿™æ ·å½“æŸä¸ªçº¿ç¨‹å¤„äºé˜»å¡çŠ¶æ€æ—¶ï¼Œä¼šè¢«åˆ‡èµ°ï¼Œè¿›è€Œè¿è¡Œå…¶å®ƒçš„çº¿ç¨‹ï¼Œå…¸å‹å°±æ˜¯ç½‘ç»œ IO æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸€ä¸ªè¿›æ¥çš„ç”¨æˆ·è¿æ¥åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å»å¤„ç†ï¼Œè¯¥è¿æ¥ç»å¤§éƒ¨åˆ†æ—¶é—´éƒ½æ˜¯å¤„äº IO è¯»å–é˜»å¡çŠ¶æ€ï¼Œå› æ­¤æœ‰é™çš„ CPU æ ¸å¿ƒå®Œå…¨å¯ä»¥å¤„ç†æˆç™¾ä¸Šåƒçš„ç”¨æˆ·è¿æ¥çº¿ç¨‹ï¼Œä½†æ˜¯äº‹å®ä¸Šï¼Œå¯¹äºè¿™ç§ç½‘ç»œ IO æƒ…å†µï¼Œä¸€èˆ¬éƒ½ä¸å†ä½¿ç”¨å¤šçº¿ç¨‹çš„æ–¹å¼äº†ï¼Œæ¯•ç«Ÿæ“ä½œç³»ç»Ÿçš„çº¿ç¨‹æ•°æ˜¯æœ‰é™çš„ï¼Œæ„å‘³ç€å¹¶å‘æ•°ä¹Ÿå¾ˆå®¹æ˜“è¾¾åˆ°ä¸Šé™ï¼Œè€Œä¸”è¿‡å¤šçš„çº¿ç¨‹ä¹Ÿä¼šå¯¼è‡´çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„ä»£ä»·è¿‡å¤§ï¼Œä½¿ç”¨ `async/await` çš„ `M:N` å¹¶å‘æ¨¡å‹ï¼Œå°±æ²¡æœ‰è¿™ä¸ªçƒ¦æ¼ã€‚

#### å¤šçº¿ç¨‹çš„å¼€é”€

ä¸‹é¢çš„ä»£ç æ˜¯ä¸€ä¸ªæ— é”å®ç°(CAS)çš„ `Hashmap` åœ¨å¤šçº¿ç¨‹ä¸‹çš„ä½¿ç”¨ï¼š

```rust
for i in 0..num_threads {
    let ht = Arc::clone(&ht);

    let handle = thread::spawn(move || {
        for j in 0..adds_per_thread {
            let key = thread_rng().gen::<u32>();
            let value = thread_rng().gen::<u32>();
            ht.set_item(key, value);
        }
    });

    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
```

æŒ‰ç†æ¥è¯´ï¼Œæ—¢ç„¶æ˜¯æ— é”å®ç°äº†ï¼Œé‚£ä¹ˆé”çš„å¼€é”€åº”è¯¥å‡ ä¹æ²¡æœ‰ï¼Œæ€§èƒ½ä¼šéšç€çº¿ç¨‹æ•°çš„å¢åŠ æ¥è¿‘çº¿æ€§å¢é•¿ï¼Œä½†æ˜¯çœŸçš„æ˜¯è¿™æ ·å—ï¼Ÿ

ä¸‹å›¾æ˜¯è¯¥ä»£ç åœ¨ `48` æ ¸æœºå™¨ä¸Šçš„è¿è¡Œç»“æœï¼š

<img alt="" src="https://pic3.zhimg.com/80/v2-af225672de09c0e377023f5f39dd87eb_1440w.png" class="center"  />

ä»å›¾ä¸Šå¯ä»¥æ˜æ˜¾çš„çœ‹å‡ºï¼šååå¹¶ä¸æ˜¯çº¿æ€§å¢é•¿ï¼Œå°¤å…¶ä» `16` æ ¸å¼€å§‹ï¼Œç”šè‡³å¼€å§‹è‚‰çœ¼å¯è§çš„ä¸‹é™ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

é™äºä¹¦æœ¬çš„ç¯‡å¹…æœ‰é™ï¼Œæˆ‘ä»¬åªèƒ½ç»™å‡ºå¤§æ¦‚çš„åŸå› ï¼š

- è™½ç„¶æ˜¯æ— é”ï¼Œä½†æ˜¯å†…éƒ¨æ˜¯ CAS å®ç°ï¼Œå¤§é‡çº¿ç¨‹çš„åŒæ—¶è®¿é—®ï¼Œä¼šè®© CAS é‡è¯•æ¬¡æ•°å¤§å¹…å¢åŠ 
- çº¿ç¨‹è¿‡å¤šæ—¶ï¼ŒCPU ç¼“å­˜çš„å‘½ä¸­ç‡ä¼šæ˜¾è‘—ä¸‹é™ï¼ŒåŒæ—¶å¤šä¸ªçº¿ç¨‹ç«äº‰ä¸€ä¸ª CPU Cache-line çš„æƒ…å†µä¹Ÿä¼šç»å¸¸å‘ç”Ÿ
- å¤§é‡è¯»å†™å¯èƒ½ä¼šè®©å†…å­˜å¸¦å®½ä¹Ÿæˆä¸ºç“¶é¢ˆ
- è¯»å’Œå†™ä¸ä¸€æ ·ï¼Œæ— é”æ•°æ®ç»“æ„çš„è¯»å¾€å¾€å¯ä»¥å¾ˆå¥½åœ°çº¿æ€§å¢é•¿ï¼Œä½†æ˜¯å†™ä¸è¡Œï¼Œå› ä¸ºå†™ç«äº‰å¤ªå¤§

æ€»ä¹‹ï¼Œå¤šçº¿ç¨‹çš„å¼€é”€å¾€å¾€æ˜¯åœ¨é”ã€æ•°æ®ç«äº‰ã€ç¼“å­˜å¤±æ•ˆä¸Šï¼Œè¿™äº›é™åˆ¶äº†ç°ä»£åŒ–è½¯ä»¶ç³»ç»Ÿéšç€ CPU æ ¸å¿ƒçš„å¢å¤šæ€§èƒ½ä¹Ÿçº¿æ€§å¢åŠ çš„é‡å¿ƒã€‚

## çº¿ç¨‹å±éšœ(Barrier)

åœ¨ Rust ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `Barrier` è®©å¤šä¸ªçº¿ç¨‹éƒ½æ‰§è¡Œåˆ°æŸä¸ªç‚¹åï¼Œæ‰ç»§ç»­ä¸€èµ·å¾€åæ‰§è¡Œï¼š

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            b.wait();
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

ä¸Šé¢ä»£ç ï¼Œæˆ‘ä»¬åœ¨çº¿ç¨‹æ‰“å°å‡º `before wait` åå¢åŠ äº†ä¸€ä¸ªå±éšœï¼Œç›®çš„å°±æ˜¯ç­‰æ‰€æœ‰çš„çº¿ç¨‹éƒ½æ‰“å°å‡º**before wait**åï¼Œå„ä¸ªçº¿ç¨‹å†ç»§ç»­æ‰§è¡Œï¼š

```console
before wait
before wait
before wait
before wait
before wait
before wait
after wait
after wait
after wait
after wait
after wait
after wait
```

## çº¿ç¨‹å±€éƒ¨å˜é‡(Thread Local Variable)

å¯¹äºå¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œçº¿ç¨‹å±€éƒ¨å˜é‡åœ¨ä¸€äº›åœºæ™¯ä¸‹éå¸¸æœ‰ç”¨ï¼Œè€Œ Rust é€šè¿‡æ ‡å‡†åº“å’Œä¸‰æ–¹åº“å¯¹æ­¤è¿›è¡Œäº†æ”¯æŒã€‚

#### æ ‡å‡†åº“ thread_local

ä½¿ç”¨ `thread_local` å®å¯ä»¥åˆå§‹åŒ–çº¿ç¨‹å±€éƒ¨å˜é‡ï¼Œç„¶ååœ¨çº¿ç¨‹å†…éƒ¨ä½¿ç”¨è¯¥å˜é‡çš„ `with` æ–¹æ³•è·å–å˜é‡å€¼ï¼š

```rust
use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// æ¯ä¸ªçº¿ç¨‹å¼€å§‹æ—¶éƒ½ä¼šæ‹¿åˆ°çº¿ç¨‹å±€éƒ¨å˜é‡çš„FOOçš„åˆå§‹å€¼
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// ç­‰å¾…çº¿ç¨‹å®Œæˆ
t.join().unwrap();

// å°½ç®¡å­çº¿ç¨‹ä¸­ä¿®æ”¹ä¸ºäº†3ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¾ç„¶æ‹¥æœ‰mainçº¿ç¨‹ä¸­çš„å±€éƒ¨å€¼ï¼š2
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});
```

ä¸Šé¢ä»£ç ä¸­ï¼Œ`FOO` å³æ˜¯æˆ‘ä»¬åˆ›å»ºçš„**çº¿ç¨‹å±€éƒ¨å˜é‡**ï¼Œæ¯ä¸ªæ–°çš„çº¿ç¨‹è®¿é—®å®ƒæ—¶ï¼Œéƒ½ä¼šä½¿ç”¨å®ƒçš„åˆå§‹å€¼ä½œä¸ºå¼€å§‹ï¼Œå„ä¸ªçº¿ç¨‹ä¸­çš„ `FOO` å€¼å½¼æ­¤äº’ä¸å¹²æ‰°ã€‚æ³¨æ„ `FOO` ä½¿ç”¨ `static` å£°æ˜ä¸ºç”Ÿå‘½å‘¨æœŸä¸º `'static` çš„é™æ€å˜é‡ã€‚

å¯ä»¥æ³¨æ„åˆ°ï¼Œçº¿ç¨‹ä¸­å¯¹ `FOO` çš„ä½¿ç”¨æ˜¯é€šè¿‡å€Ÿç”¨çš„æ–¹å¼ï¼Œä½†æ˜¯è‹¥æˆ‘ä»¬éœ€è¦æ¯ä¸ªçº¿ç¨‹ç‹¬è‡ªè·å–å®ƒçš„æ‹·è´ï¼Œæœ€åè¿›è¡Œæ±‡æ€»ï¼Œå°±æœ‰äº›å¼ºäººæ‰€éš¾äº†ã€‚

ä½ è¿˜å¯ä»¥åœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨çº¿ç¨‹å±€éƒ¨å˜é‡ï¼š

```rust
use std::cell::RefCell;

struct Foo;
impl Foo {
    thread_local! {
        static FOO: RefCell<usize> = RefCell::new(0);
    }
}

fn main() {
    Foo::FOO.with(|x| println!("{:?}", x));
}
```

æˆ–è€…é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä½¿ç”¨å®ƒ:

```rust
use std::cell::RefCell;
use std::thread::LocalKey;

thread_local! {
    static FOO: RefCell<usize> = RefCell::new(0);
}
struct Bar {
    foo: &'static LocalKey<RefCell<usize>>,
}
impl Bar {
    fn constructor() -> Self {
        Self {
            foo: &FOO,
        }
    }
}
```

#### ä¸‰æ–¹åº“ thread-local

é™¤äº†æ ‡å‡†åº“å¤–ï¼Œä¸€ä½å¤§ç¥è¿˜å¼€å‘äº† [thread-local](https://github.com/Amanieu/thread_local-rs) åº“ï¼Œå®ƒå…è®¸æ¯ä¸ªçº¿ç¨‹æŒæœ‰å€¼çš„ç‹¬ç«‹æ‹·è´ï¼š

```rust
use thread_local::ThreadLocal;
use std::sync::Arc;
use std::cell::Cell;
use std::thread;

let tls = Arc::new(ThreadLocal::new());
let mut v = vec![];
// åˆ›å»ºå¤šä¸ªçº¿ç¨‹
for _ in 0..5 {
    let tls2 = tls.clone();
    let handle = thread::spawn(move || {
        // å°†è®¡æ•°å™¨åŠ 1
        // è¯·æ³¨æ„ï¼Œç”±äºçº¿ç¨‹ ID åœ¨çº¿ç¨‹é€€å‡ºæ—¶ä¼šè¢«å›æ”¶ï¼Œå› æ­¤ä¸€ä¸ªçº¿ç¨‹æœ‰å¯èƒ½å›æ”¶å¦ä¸€ä¸ªçº¿ç¨‹çš„å¯¹è±¡
        // è¿™åªèƒ½åœ¨çº¿ç¨‹é€€å‡ºåå‘ç”Ÿï¼Œå› æ­¤ä¸ä¼šå¯¼è‡´ä»»ä½•ç«äº‰æ¡ä»¶
        let cell = tls2.get_or(|| Cell::new(0));
        cell.set(cell.get() + 1);
    });
    v.push(handle);
}
for handle in v {
    handle.join().unwrap();
}
// ä¸€æ—¦æ‰€æœ‰å­çº¿ç¨‹ç»“æŸï¼Œæ”¶é›†å®ƒä»¬çš„çº¿ç¨‹å±€éƒ¨å˜é‡ä¸­çš„è®¡æ•°å™¨å€¼ï¼Œç„¶åè¿›è¡Œæ±‚å’Œ
let tls = Arc::try_unwrap(tls).unwrap();
let total = tls.into_iter().fold(0, |x, y| {
    // æ‰“å°æ¯ä¸ªçº¿ç¨‹å±€éƒ¨å˜é‡ä¸­çš„è®¡æ•°å™¨å€¼ï¼Œå‘ç°ä¸ä¸€å®šæœ‰5ä¸ªçº¿ç¨‹ï¼Œ
    // å› ä¸ºä¸€äº›çº¿ç¨‹å·²é€€å‡ºï¼Œå¹¶ä¸”å…¶ä»–çº¿ç¨‹ä¼šå›æ”¶é€€å‡ºçº¿ç¨‹çš„å¯¹è±¡
    println!("x: {}, y: {}", x, y.get());
    x + y.get()
});

// å’Œä¸º5
assert_eq!(total, 5);
```

è¯¥åº“ä¸ä»…ä»…ä½¿ç”¨äº†å€¼çš„æ‹·è´ï¼Œè€Œä¸”è¿˜èƒ½è‡ªåŠ¨æŠŠå¤šä¸ªæ‹·è´æ±‡æ€»åˆ°ä¸€ä¸ªè¿­ä»£å™¨ä¸­ï¼Œæœ€åè¿›è¡Œæ±‚å’Œï¼Œéå¸¸å¥½ç”¨ã€‚

## ç”¨æ¡ä»¶æ§åˆ¶çº¿ç¨‹çš„æŒ‚èµ·å’Œæ‰§è¡Œ

æ¡ä»¶å˜é‡(Condition Variables)ç»å¸¸å’Œ `Mutex` ä¸€èµ·ä½¿ç”¨ï¼Œå¯ä»¥è®©çº¿ç¨‹æŒ‚èµ·ï¼Œç›´åˆ°æŸä¸ªæ¡ä»¶å‘ç”Ÿåå†ç»§ç»­æ‰§è¡Œï¼š

```rust
use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        println!("changing started");
        *started = true;
        cvar.notify_one();
    });

    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!("started changed");
}
```

ä¸Šè¿°ä»£ç æµç¨‹å¦‚ä¸‹ï¼š

1. `main` çº¿ç¨‹é¦–å…ˆè¿›å…¥ `while` å¾ªç¯ï¼Œè°ƒç”¨ `wait` æ–¹æ³•æŒ‚èµ·ç­‰å¾…å­çº¿ç¨‹çš„é€šçŸ¥ï¼Œå¹¶é‡Šæ”¾äº†é” `started`
2. å­çº¿ç¨‹è·å–åˆ°é”ï¼Œå¹¶å°†å…¶ä¿®æ”¹ä¸º `true`ï¼Œç„¶åè°ƒç”¨æ¡ä»¶å˜é‡çš„ `notify_one` æ–¹æ³•æ¥é€šçŸ¥ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œ

## åªè¢«è°ƒç”¨ä¸€æ¬¡çš„å‡½æ•°

æœ‰æ—¶ï¼Œæˆ‘ä»¬ä¼šéœ€è¦æŸä¸ªå‡½æ•°åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹åªè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œä¾‹å¦‚åˆå§‹åŒ–å…¨å±€å˜é‡ï¼Œæ— è®ºæ˜¯å“ªä¸ªçº¿ç¨‹å…ˆè°ƒç”¨å‡½æ•°æ¥åˆå§‹åŒ–ï¼Œéƒ½ä¼šä¿è¯å…¨å±€å˜é‡åªä¼šè¢«åˆå§‹åŒ–ä¸€æ¬¡ï¼Œéšåçš„å…¶å®ƒçº¿ç¨‹è°ƒç”¨å°±ä¼šå¿½ç•¥è¯¥å‡½æ•°ï¼š

```rust
use std::thread;
use std::sync::Once;

static mut VAL: usize = 0;
static INIT: Once = Once::new();

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!("{}", unsafe { VAL });
}
```

ä»£ç è¿è¡Œçš„ç»“æœå–å†³äºå“ªä¸ªçº¿ç¨‹å…ˆè°ƒç”¨ `INIT.call_once` ï¼ˆè™½ç„¶ä»£ç å…·æœ‰å…ˆåé¡ºåºï¼Œä½†æ˜¯çº¿ç¨‹çš„åˆå§‹åŒ–é¡ºåºå¹¶æ— æ³•è¢«ä¿è¯ï¼å› ä¸ºçº¿ç¨‹åˆå§‹åŒ–æ˜¯å¼‚æ­¥çš„ï¼Œä¸”è€—æ—¶è¾ƒä¹…ï¼‰ï¼Œè‹¥ `handle1` å…ˆï¼Œåˆ™è¾“å‡º `1`ï¼Œå¦åˆ™è¾“å‡º `2`ã€‚

**call_once æ–¹æ³•**

æ‰§è¡Œåˆå§‹åŒ–è¿‡ç¨‹ä¸€æ¬¡ï¼Œå¹¶ä¸”åªæ‰§è¡Œä¸€æ¬¡ã€‚

å¦‚æœå½“å‰æœ‰å¦ä¸€ä¸ªåˆå§‹åŒ–è¿‡ç¨‹æ­£åœ¨è¿è¡Œï¼Œçº¿ç¨‹å°†é˜»æ­¢è¯¥æ–¹æ³•è¢«è°ƒç”¨ã€‚

å½“è¿™ä¸ªå‡½æ•°è¿”å›æ—¶ï¼Œä¿è¯ä¸€äº›åˆå§‹åŒ–å·²ç»è¿è¡Œå¹¶å®Œæˆï¼Œå®ƒè¿˜ä¿è¯ç”±æ‰§è¡Œçš„é—­åŒ…æ‰€æ‰§è¡Œçš„ä»»ä½•å†…å­˜å†™å…¥éƒ½èƒ½è¢«å…¶ä»–çº¿ç¨‹åœ¨è¿™æ—¶å¯é åœ°è§‚å¯Ÿåˆ°ã€‚

## æ€»ç»“

[Rust çš„çº¿ç¨‹æ¨¡å‹](https://course.rs/advance/concurrency-with-threads/intro.html)æ˜¯ `1:1` æ¨¡å‹ï¼Œå› ä¸º Rust è¦ä¿æŒå°½é‡å°çš„è¿è¡Œæ—¶ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `thread::spawn` æ¥åˆ›å»ºçº¿ç¨‹ï¼Œåˆ›å»ºå‡ºçš„å¤šä¸ªçº¿ç¨‹ä¹‹é—´å¹¶ä¸å­˜åœ¨æ‰§è¡Œé¡ºåºå…³ç³»ï¼Œå› æ­¤ä»£ç é€»è¾‘åƒä¸‡ä¸è¦ä¾èµ–äºçº¿ç¨‹é—´çš„æ‰§è¡Œé¡ºåºã€‚

`main` çº¿ç¨‹è‹¥æ˜¯ç»“æŸï¼Œåˆ™æ‰€æœ‰å­çº¿ç¨‹éƒ½å°†è¢«ç»ˆæ­¢ï¼Œå¦‚æœå¸Œæœ›ç­‰å¾…å­çº¿ç¨‹ç»“æŸåï¼Œå†ç»“æŸ `main` çº¿ç¨‹ï¼Œä½ éœ€è¦ä½¿ç”¨åˆ›å»ºçº¿ç¨‹æ—¶è¿”å›çš„å¥æŸ„çš„ `join` æ–¹æ³•ã€‚

åœ¨çº¿ç¨‹ä¸­æ— æ³•ç›´æ¥å€Ÿç”¨å¤–éƒ¨ç¯å¢ƒä¸­çš„å˜é‡å€¼ï¼Œå› ä¸ºæ–°çº¿ç¨‹çš„å¯åŠ¨æ—¶é—´ç‚¹å’Œç»“æŸæ—¶é—´ç‚¹æ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥ Rust æ— æ³•ä¿è¯è¯¥çº¿ç¨‹ä¸­å€Ÿç”¨çš„å˜é‡åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¾ç„¶æ˜¯åˆæ³•çš„ã€‚ä½ å¯ä»¥ä½¿ç”¨ `move` å…³é”®å­—å°†å˜é‡çš„æ‰€æœ‰æƒè½¬ç§»ç»™æ–°çš„çº¿ç¨‹ï¼Œæ¥è§£å†³æ­¤é—®é¢˜ã€‚

çˆ¶çº¿ç¨‹ç»“æŸåï¼Œå­çº¿ç¨‹ä»åœ¨æŒç»­è¿è¡Œï¼Œç›´åˆ°å­çº¿ç¨‹çš„ä»£ç è¿è¡Œå®Œæˆæˆ–è€… `main` çº¿ç¨‹çš„ç»“æŸã€‚



================================================
FILE: src/advance/difficulties/pointer.md
================================================
# è£¸æŒ‡é’ˆã€å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆ TODO



================================================
FILE: src/advance/functional-programing/closure.md
================================================
[Binary file]


================================================
FILE: src/advance/functional-programing/intro.md
================================================
[Binary file]


================================================
FILE: src/advance/functional-programing/iterator.md
================================================
# è¿­ä»£å™¨ Iterator

å¦‚æœä½ è¯¢é—®ä¸€ä¸ª Rust èµ„æ·±å¼€å‘ï¼šå†™ Rust é¡¹ç›®æœ€éœ€è¦æŒæ¡ä»€ä¹ˆï¼Ÿç›¸ä¿¡è¿­ä»£å™¨å¾€å¾€å°±æ˜¯ç­”æ¡ˆä¹‹ä¸€ã€‚æ— è®ºä½ æ˜¯ç¼–ç¨‹æ–°æ‰‹äº¦æˆ–æ˜¯é«˜æ‰‹ï¼Œå®é™…ä¸Šå¤§æ¦‚ç‡éƒ½ç”¨è¿‡è¿­ä»£å™¨ï¼Œè™½ç„¶è‡ªå·±å¯èƒ½å¹¶æ²¡æœ‰æ„è¯†åˆ°è¿™ä¸€ç‚¹:)

è¿­ä»£å™¨å…è®¸æˆ‘ä»¬è¿­ä»£ä¸€ä¸ªè¿ç»­çš„é›†åˆï¼Œä¾‹å¦‚æ•°ç»„ã€åŠ¨æ€æ•°ç»„ `Vec`ã€`HashMap` ç­‰ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œåªéœ€å…³å¿ƒé›†åˆä¸­çš„å…ƒç´ å¦‚ä½•å¤„ç†ï¼Œè€Œæ— éœ€å…³å¿ƒå¦‚ä½•å¼€å§‹ã€å¦‚ä½•ç»“æŸã€æŒ‰ç…§ä»€ä¹ˆæ ·çš„ç´¢å¼•å»è®¿é—®ç­‰é—®é¢˜ã€‚

## For å¾ªç¯ä¸è¿­ä»£å™¨

ä»ç”¨é€”æ¥çœ‹ï¼Œè¿­ä»£å™¨è·Ÿ `for` å¾ªç¯é¢‡ä¸ºç›¸ä¼¼ï¼Œéƒ½æ˜¯å»éå†ä¸€ä¸ªé›†åˆï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒä»¬å­˜åœ¨ä¸å°çš„å·®åˆ«ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„å·®åˆ«å°±æ˜¯ï¼š**æ˜¯å¦é€šè¿‡ç´¢å¼•æ¥è®¿é—®é›†åˆ**ã€‚

ä¾‹å¦‚ä»¥ä¸‹çš„ JS ä»£ç å°±æ˜¯ä¸€ä¸ªå¾ªç¯ï¼š

```javascript
let arr = [1, 2, 3];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬è®¾ç½®ç´¢å¼•çš„å¼€å§‹ç‚¹å’Œç»“æŸç‚¹ï¼Œç„¶åå†é€šè¿‡ç´¢å¼•å»è®¿é—®å…ƒç´  `arr[i]`ï¼Œè¿™å°±æ˜¯å…¸å‹çš„å¾ªç¯ï¼Œæ¥å¯¹æ¯”ä¸‹ Rust ä¸­çš„ `for`ï¼š

```rust
let arr = [1, 2, 3];
for v in arr {
    println!("{}",v);
}
```

é¦–å…ˆï¼Œä¸å¾—ä¸è¯´è¿™ä¸¤è¯­æ³•è¿˜æŒºåƒï¼ä¸ JS å¾ªç¯ä¸åŒï¼Œ`Rust`ä¸­æ²¡æœ‰ä½¿ç”¨ç´¢å¼•ï¼Œå®ƒæŠŠ `arr` æ•°ç»„å½“æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œç›´æ¥å»éå†å…¶ä¸­çš„å…ƒç´ ï¼Œä»å“ªé‡Œå¼€å§‹ï¼Œä»å“ªé‡Œç»“æŸï¼Œéƒ½æ— éœ€æ“å¿ƒã€‚å› æ­¤ä¸¥æ ¼æ¥è¯´ï¼ŒRust ä¸­çš„ `for` å¾ªç¯æ˜¯ç¼–è¯‘å™¨æä¾›çš„è¯­æ³•ç³–ï¼Œæœ€ç»ˆè¿˜æ˜¯å¯¹è¿­ä»£å™¨ä¸­çš„å…ƒç´ è¿›è¡Œéå†ã€‚

é‚£åˆæœ‰åŒå­¦è¦å‘é—®äº†ï¼Œåœ¨ Rust ä¸­æ•°ç»„æ˜¯è¿­ä»£å™¨å—ï¼Ÿå› ä¸ºåœ¨ä¹‹å‰çš„ä»£ç ä¸­ç›´æ¥å¯¹æ•°ç»„ `arr` è¿›è¡Œäº†è¿­ä»£ï¼Œç­”æ¡ˆæ˜¯ `No`ã€‚é‚£æ—¢ç„¶æ•°ç»„ä¸æ˜¯è¿­ä»£å™¨ï¼Œä¸ºå•¥å’±å¯ä»¥å¯¹å®ƒçš„å…ƒç´ è¿›è¡Œè¿­ä»£å‘¢ï¼Ÿ

ç®€è€Œè¨€ä¹‹å°±æ˜¯æ•°ç»„å®ç°äº† `IntoIterator` ç‰¹å¾ï¼ŒRust é€šè¿‡ `for` è¯­æ³•ç³–ï¼Œè‡ªåŠ¨æŠŠå®ç°äº†è¯¥ç‰¹å¾çš„æ•°ç»„ç±»å‹è½¬æ¢ä¸ºè¿­ä»£å™¨ï¼ˆä½ ä¹Ÿå¯ä»¥ä¸ºè‡ªå·±çš„é›†åˆç±»å‹å®ç°æ­¤ç‰¹å¾ï¼‰ï¼Œæœ€ç»ˆè®©æˆ‘ä»¬å¯ä»¥ç›´æ¥å¯¹ä¸€ä¸ªæ•°ç»„è¿›è¡Œè¿­ä»£ï¼Œç±»ä¼¼çš„è¿˜æœ‰ï¼š

```rust
for i in 1..10 {
    println!("{}", i);
}
```

ç›´æ¥å¯¹æ•°å€¼åºåˆ—è¿›è¡Œè¿­ä»£ï¼Œä¹Ÿæ˜¯å¾ˆå¸¸è§çš„ä½¿ç”¨æ–¹å¼ã€‚

`IntoIterator` ç‰¹å¾æ‹¥æœ‰ä¸€ä¸ª `into_iter` æ–¹æ³•ï¼Œå› æ­¤æˆ‘ä»¬è¿˜å¯ä»¥æ˜¾å¼çš„æŠŠæ•°ç»„è½¬æ¢æˆè¿­ä»£å™¨ï¼š

```rust
let arr = [1, 2, 3];
for v in arr.into_iter() {
    println!("{}", v);
}
```

è¿­ä»£å™¨æ˜¯å‡½æ•°è¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ï¼Œå®ƒèµ‹äºˆäº† Rust è¿œè¶…äºå¾ªç¯çš„å¼ºå¤§è¡¨è¾¾èƒ½åŠ›ï¼Œæˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­ä¸€ä¸€ä¸ºå¤§å®¶è¿›è¡Œå±•ç°ã€‚

## æƒ°æ€§åˆå§‹åŒ–

åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯æƒ°æ€§çš„ï¼Œæ„å‘³ç€å¦‚æœä½ ä¸ä½¿ç”¨å®ƒï¼Œé‚£ä¹ˆå®ƒå°†ä¸ä¼šå‘ç”Ÿä»»ä½•äº‹ï¼š

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("{}", val);
}
```

åœ¨ `for` å¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬åªæ˜¯ç®€å•çš„åˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨ `v1_iter`ï¼Œæ­¤æ—¶ä¸ä¼šå‘ç”Ÿä»»ä½•è¿­ä»£è¡Œä¸ºï¼Œåªæœ‰åœ¨ `for` å¾ªç¯å¼€å§‹åï¼Œè¿­ä»£å™¨æ‰ä¼šå¼€å§‹è¿­ä»£å…¶ä¸­çš„å…ƒç´ ï¼Œæœ€åæ‰“å°å‡ºæ¥ã€‚

è¿™ç§æƒ°æ€§åˆå§‹åŒ–çš„æ–¹å¼ç¡®ä¿äº†åˆ›å»ºè¿­ä»£å™¨ä¸ä¼šæœ‰ä»»ä½•é¢å¤–çš„æ€§èƒ½æŸè€—ï¼Œå…¶ä¸­çš„å…ƒç´ ä¹Ÿä¸ä¼šè¢«æ¶ˆè€—ï¼Œåªæœ‰ä½¿ç”¨åˆ°è¯¥è¿­ä»£å™¨çš„æ—¶å€™ï¼Œä¸€åˆ‡æ‰å¼€å§‹ã€‚

## next æ–¹æ³•

å¯¹äº `for` å¦‚ä½•éå†è¿­ä»£å™¨ï¼Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒå¦‚ä½•å–å‡ºè¿­ä»£å™¨ä¸­çš„å…ƒç´ ï¼Ÿ

å…ˆæ¥çœ‹ä¸€ä¸ªç‰¹å¾ï¼š

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // çœç•¥å…¶ä½™æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•
}
```

å‘¦ï¼Œè¯¥ç‰¹å¾ç«Ÿç„¶å’Œè¿­ä»£å™¨ `iterator` åŒåï¼Œéš¾ä¸æˆã€‚ã€‚ã€‚æ²¡é”™ï¼Œå®ƒä»¬å°±æ˜¯æœ‰ä¸€è…¿ã€‚**è¿­ä»£å™¨ä¹‹æ‰€ä»¥æˆä¸ºè¿­ä»£å™¨ï¼Œå°±æ˜¯å› ä¸ºå®ç°äº† `Iterator` ç‰¹å¾**ï¼Œè¦å®ç°è¯¥ç‰¹å¾ï¼Œæœ€ä¸»è¦çš„å°±æ˜¯å®ç°å…¶ä¸­çš„ `next` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ§åˆ¶å¦‚ä½•ä»é›†åˆä¸­å–å€¼ï¼Œæœ€ç»ˆè¿”å›å€¼çš„ç±»å‹æ˜¯[å…³è”ç±»å‹](https://course.rs/basic/trait/advance-trait#å…³è”ç±»å‹) `Item`ã€‚

å› æ­¤ï¼Œä¹‹å‰é—®é¢˜çš„ç­”æ¡ˆå·²ç»å¾ˆæ˜æ˜¾ï¼š`for` å¾ªç¯é€šè¿‡ä¸åœè°ƒç”¨è¿­ä»£å™¨ä¸Šçš„ `next` æ–¹æ³•ï¼Œæ¥è·å–è¿­ä»£å™¨ä¸­çš„å…ƒç´ ã€‚

æ—¢ç„¶ `for` å¯ä»¥è°ƒç”¨ `next` æ–¹æ³•ï¼Œæ˜¯ä¸æ˜¯æ„å‘³ç€æˆ‘ä»¬ä¹Ÿå¯ä»¥ï¼Ÿæ¥è¯•è¯•ï¼š

```rust
fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}
```

æœä¸å…¶ç„¶ï¼Œå°† `arr` è½¬æ¢æˆè¿­ä»£å™¨åï¼Œé€šè¿‡è°ƒç”¨å…¶ä¸Šçš„ `next` æ–¹æ³•ï¼Œæˆ‘ä»¬è·å–äº† `arr` ä¸­çš„å…ƒç´ ï¼Œæœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š

- `next` æ–¹æ³•è¿”å›çš„æ˜¯ `Option` ç±»å‹ï¼Œå½“æœ‰å€¼æ—¶è¿”å› `Some(i32)`ï¼Œæ— å€¼æ—¶è¿”å› `None`
- éå†æ˜¯æŒ‰ç…§è¿­ä»£å™¨ä¸­å…ƒç´ çš„æ’åˆ—é¡ºåºä¾æ¬¡è¿›è¡Œçš„ï¼Œå› æ­¤æˆ‘ä»¬ä¸¥æ ¼æŒ‰ç…§æ•°ç»„ä¸­å…ƒç´ çš„é¡ºåºå–å‡ºäº† `Some(1)`ï¼Œ`Some(2)`ï¼Œ`Some(3)`
- æ‰‹åŠ¨è¿­ä»£å¿…é¡»å°†è¿­ä»£å™¨å£°æ˜ä¸º `mut` å¯å˜ï¼Œå› ä¸ºè°ƒç”¨ `next` ä¼šæ”¹å˜è¿­ä»£å™¨å…¶ä¸­çš„çŠ¶æ€æ•°æ®ï¼ˆå½“å‰éå†çš„ä½ç½®ç­‰ï¼‰ï¼Œè€Œ `for` å¾ªç¯å»è¿­ä»£åˆ™æ— éœ€æ ‡æ³¨ `mut`ï¼Œå› ä¸ºå®ƒä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨å®Œæˆ

æ€»ä¹‹ï¼Œ`next` æ–¹æ³•å¯¹**è¿­ä»£å™¨çš„éå†æ˜¯æ¶ˆè€—æ€§çš„**ï¼Œæ¯æ¬¡æ¶ˆè€—å®ƒä¸€ä¸ªå…ƒç´ ï¼Œæœ€ç»ˆè¿­ä»£å™¨ä¸­å°†æ²¡æœ‰ä»»ä½•å…ƒç´ ï¼Œåªèƒ½è¿”å› `None`ã€‚

#### ä¾‹å­ï¼šæ¨¡æ‹Ÿå®ç° for å¾ªç¯

å› ä¸º `for` å¾ªç¯æ˜¯è¿­ä»£å™¨çš„è¯­æ³•ç³–ï¼Œå› æ­¤æˆ‘ä»¬å®Œå…¨å¯ä»¥é€šè¿‡è¿­ä»£å™¨æ¥æ¨¡æ‹Ÿå®ç°å®ƒï¼š

```rust
let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter => loop {
            match iter.next() {
                Some(x) => { println!("{}", x); },
                None => break,
            }
        },
    };
    result
}
```

`IntoIterator::into_iter` æ˜¯ä½¿ç”¨[å®Œå…¨é™å®š](https://course.rs/basic/trait/advance-trait.html#å®Œå…¨é™å®šè¯­æ³•)çš„æ–¹å¼å»è°ƒç”¨ `into_iter` æ–¹æ³•ï¼Œè¿™ç§è°ƒç”¨æ–¹å¼è·Ÿ `values.into_iter()` æ˜¯ç­‰ä»·çš„ã€‚

åŒæ—¶æˆ‘ä»¬ä½¿ç”¨äº† `loop` å¾ªç¯é…åˆ `next` æ–¹æ³•æ¥éå†è¿­ä»£å™¨ä¸­çš„å…ƒç´ ï¼Œå½“è¿­ä»£å™¨è¿”å› `None` æ—¶ï¼Œè·³å‡ºå¾ªç¯ã€‚

## IntoIterator ç‰¹å¾

å…¶å®æœ‰ä¸€ä¸ªç»†èŠ‚ï¼Œç”±äº `Vec` åŠ¨æ€æ•°ç»„å®ç°äº† `IntoIterator` ç‰¹å¾ï¼Œå› æ­¤å¯ä»¥é€šè¿‡ `into_iter` å°†å…¶è½¬æ¢ä¸ºè¿­ä»£å™¨ï¼Œé‚£å¦‚æœæœ¬èº«å°±æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿå®é™…ä¸Šï¼Œè¿­ä»£å™¨è‡ªèº«ä¹Ÿå®ç°äº† `IntoIterator`ï¼Œæ ‡å‡†åº“æ—©å°±å¸®æˆ‘ä»¬è€ƒè™‘å¥½äº†ï¼š

```rust
impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    #[inline]
    fn into_iter(self) -> I {
        self
    }
}
```

æœ€ç»ˆä½ å®Œå…¨å¯ä»¥å†™å‡ºè¿™æ ·çš„å¥‡æ€ªä»£ç ï¼š

```rust
fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter().into_iter().into_iter() {
        println!("{}",v)
    }
}
```

#### into_iter, iter, iter_mut

åœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨äº† `into_iter` çš„æ–¹å¼å°†æ•°ç»„è½¬åŒ–ä¸ºè¿­ä»£å™¨ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ `iter` å’Œ `iter_mut`ï¼Œèªæ˜çš„è¯»è€…åº”è¯¥å¤§æ¦‚èƒ½çŒœåˆ°è¿™ä¸‰è€…çš„åŒºåˆ«ï¼š

- `into_iter` ä¼šå¤ºèµ°æ‰€æœ‰æƒ
- `iter` æ˜¯å€Ÿç”¨
- `iter_mut` æ˜¯å¯å˜å€Ÿç”¨

å…¶å®å¦‚æœä»¥åè§å¤šè¯†å¹¿äº†ï¼Œä½ ä¼šå‘ç°è¿™ç§é—®é¢˜ä¸€çœ¼å°±èƒ½çœ‹ç©¿ï¼Œ`into_` ä¹‹ç±»çš„ï¼Œéƒ½æ˜¯æ‹¿èµ°æ‰€æœ‰æƒï¼Œ`_mut` ä¹‹ç±»çš„éƒ½æ˜¯å¯å˜å€Ÿç”¨ï¼Œå‰©ä¸‹çš„å°±æ˜¯ä¸å¯å˜å€Ÿç”¨ã€‚

ä½¿ç”¨ä¸€æ®µä»£ç æ¥è§£é‡Šä¸‹ï¼š

```rust
fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter() {
        println!("{}", v)
    }

    // ä¸‹é¢çš„ä»£ç å°†æŠ¥é”™ï¼Œå› ä¸º values çš„æ‰€æœ‰æƒåœ¨ä¸Šé¢ `for` å¾ªç¯ä¸­å·²ç»è¢«è½¬ç§»èµ°
    // println!("{:?}",values);

    let values = vec![1, 2, 3];
    let _values_iter = values.iter();

    // ä¸ä¼šæŠ¥é”™ï¼Œå› ä¸º values_iter åªæ˜¯å€Ÿç”¨äº† values ä¸­çš„å…ƒç´ 
    println!("{:?}", values);

    let mut values = vec![1, 2, 3];
    // å¯¹ values ä¸­çš„å…ƒç´ è¿›è¡Œå¯å˜å€Ÿç”¨
    let mut values_iter_mut = values.iter_mut();

    // å–å‡ºç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä¿®æ”¹ä¸º0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }

    // è¾“å‡º[0, 2, 3]
    println!("{:?}", values);
}
```

å…·ä½“è§£é‡Šåœ¨ä»£ç æ³¨é‡Šä¸­ï¼Œå°±ä¸å†èµ˜è¿°ï¼Œä¸è¿‡æœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼š

- `.iter()` æ–¹æ³•å®ç°çš„è¿­ä»£å™¨ï¼Œè°ƒç”¨ `next` æ–¹æ³•è¿”å›çš„ç±»å‹æ˜¯ `Some(&T)`
- `.iter_mut()` æ–¹æ³•å®ç°çš„è¿­ä»£å™¨ï¼Œè°ƒç”¨ `next` æ–¹æ³•è¿”å›çš„ç±»å‹æ˜¯ `Some(&mut T)`ï¼Œå› æ­¤åœ¨ `if let Some(v) = values_iter_mut.next()` ä¸­ï¼Œ`v` çš„ç±»å‹æ˜¯ `&mut i32`ï¼Œæœ€ç»ˆæˆ‘ä»¬å¯ä»¥é€šè¿‡ `*v = 0` çš„æ–¹å¼ä¿®æ”¹å…¶å€¼

#### Iterator å’Œ IntoIterator çš„åŒºåˆ«

è¿™ä¸¤ä¸ªå…¶å®è¿˜è›®å®¹æ˜“ææ··çš„ï¼Œä½†æˆ‘ä»¬åªéœ€è¦è®°ä½ï¼Œ`Iterator` å°±æ˜¯è¿­ä»£å™¨ç‰¹å¾ï¼Œåªæœ‰å®ç°äº†å®ƒæ‰èƒ½ç§°ä¸ºè¿­ä»£å™¨ï¼Œæ‰èƒ½è°ƒç”¨ `next`ã€‚

è€Œ `IntoIterator` å¼ºè°ƒçš„æ˜¯æŸä¸€ä¸ªç±»å‹å¦‚æœå®ç°äº†è¯¥ç‰¹å¾ï¼Œå®ƒå¯ä»¥é€šè¿‡ `into_iter`ï¼Œ`iter` ç­‰æ–¹æ³•å˜æˆä¸€ä¸ªè¿­ä»£å™¨ã€‚

## æ¶ˆè´¹è€…ä¸é€‚é…å™¨

æ¶ˆè´¹è€…æ˜¯è¿­ä»£å™¨ä¸Šçš„æ–¹æ³•ï¼Œå®ƒä¼šæ¶ˆè´¹æ‰è¿­ä»£å™¨ä¸­çš„å…ƒç´ ï¼Œç„¶åè¿”å›å…¶ç±»å‹çš„å€¼ï¼Œè¿™äº›æ¶ˆè´¹è€…éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç‰¹ç‚¹ï¼šåœ¨å®ƒä»¬çš„å®šä¹‰ä¸­ï¼Œéƒ½ä¾èµ– `next` æ–¹æ³•æ¥æ¶ˆè´¹å…ƒç´ ï¼Œå› æ­¤è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¿­ä»£å™¨è¦å®ç° `Iterator` ç‰¹å¾ï¼Œè€Œè¯¥ç‰¹å¾å¿…é¡»è¦å®ç° `next` æ–¹æ³•çš„åŸå› ã€‚

#### æ¶ˆè´¹è€…é€‚é…å™¨

åªè¦è¿­ä»£å™¨ä¸Šçš„æŸä¸ªæ–¹æ³• `A` åœ¨å…¶å†…éƒ¨è°ƒç”¨äº† `next` æ–¹æ³•ï¼Œé‚£ä¹ˆ `A` å°±è¢«ç§°ä¸º**æ¶ˆè´¹è€…é€‚é…å™¨**ï¼šå› ä¸º `next` æ–¹æ³•ä¼šæ¶ˆè€—æ‰è¿­ä»£å™¨ä¸Šçš„å…ƒç´ ï¼Œæ‰€ä»¥æ–¹æ³• `A` çš„è°ƒç”¨ä¹Ÿä¼šæ¶ˆè€—æ‰è¿­ä»£å™¨ä¸Šçš„å…ƒç´ ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­æ˜¯ `sum` æ–¹æ³•ï¼Œå®ƒä¼šæ‹¿èµ°è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼Œç„¶åé€šè¿‡ä¸æ–­è°ƒç”¨ `next` æ–¹æ³•å¯¹é‡Œé¢çš„å…ƒç´ è¿›è¡Œæ±‚å’Œï¼š

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter æ˜¯å€Ÿç”¨äº† v1ï¼Œå› æ­¤ v1 å¯ä»¥ç…§å¸¸ä½¿ç”¨
    println!("{:?}",v1);

    // ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸º `sum` æ‹¿åˆ°äº†è¿­ä»£å™¨ `v1_iter` çš„æ‰€æœ‰æƒ
    // println!("{:?}",v1_iter);
}
```

å¦‚ä»£ç æ³¨é‡Šä¸­æ‰€è¯´æ˜çš„ï¼šåœ¨ä½¿ç”¨ `sum` æ–¹æ³•åï¼Œæˆ‘ä»¬å°†æ— æ³•å†ä½¿ç”¨ `v1_iter`ï¼Œå› ä¸º `sum` æ‹¿èµ°äº†è¯¥è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼š

```rust
fn sum<S>(self) -> S
    where
        Self: Sized,
        S: Sum<Self::Item>,
    {
        Sum::sum(self)
    }

```

ä» `sum` æºç ä¸­ä¹Ÿå¯ä»¥æ¸…æ™°çœ‹å‡ºï¼Œ`self` ç±»å‹çš„æ–¹æ³•å‚æ•°æ‹¿èµ°äº†æ‰€æœ‰æƒã€‚

#### è¿­ä»£å™¨é€‚é…å™¨

æ—¢ç„¶æ¶ˆè´¹è€…é€‚é…å™¨æ˜¯æ¶ˆè´¹æ‰è¿­ä»£å™¨ï¼Œç„¶åè¿”å›ä¸€ä¸ªå€¼ã€‚é‚£ä¹ˆè¿­ä»£å™¨é€‚é…å™¨ï¼Œé¡¾åæ€ä¹‰ï¼Œä¼šè¿”å›ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œè¿™æ˜¯å®ç°é“¾å¼æ–¹æ³•è°ƒç”¨çš„å…³é”®ï¼š`v.iter().map().filter()...`ã€‚

ä¸æ¶ˆè´¹è€…é€‚é…å™¨ä¸åŒï¼Œè¿­ä»£å™¨é€‚é…å™¨æ˜¯æƒ°æ€§çš„ï¼Œæ„å‘³ç€ä½ **éœ€è¦ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨æ¥æ”¶å°¾ï¼Œæœ€ç»ˆå°†è¿­ä»£å™¨è½¬æ¢æˆä¸€ä¸ªå…·ä½“çš„å€¼**ï¼š

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

è¿è¡Œåè¾“å‡º:

```console
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // è¿­ä»£å™¨ map æ˜¯æƒ°æ€§çš„ï¼Œè¿™é‡Œä¸äº§ç”Ÿä»»ä½•æ•ˆæœ
```

å¦‚ä¸Šè¿°ä¸­æ–‡æ³¨é‡Šæ‰€è¯´ï¼Œè¿™é‡Œçš„ `map` æ–¹æ³•æ˜¯ä¸€ä¸ªè¿­ä»£è€…é€‚é…å™¨ï¼Œå®ƒæ˜¯æƒ°æ€§çš„ï¼Œä¸äº§ç”Ÿä»»ä½•è¡Œä¸ºï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨è¿›è¡Œæ”¶å°¾ï¼š

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

#### collect

ä¸Šé¢ä»£ç ä¸­ï¼Œä½¿ç”¨äº† `collect` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°±æ˜¯ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨ï¼Œä½¿ç”¨å®ƒå¯ä»¥å°†ä¸€ä¸ªè¿­ä»£å™¨ä¸­çš„å…ƒç´ æ”¶é›†åˆ°æŒ‡å®šç±»å‹ä¸­ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸º `v2` æ ‡æ³¨äº† `Vec<_>` ç±»å‹ï¼Œå°±æ˜¯ä¸ºäº†å‘Šè¯‰ `collect`ï¼šè¯·æŠŠè¿­ä»£å™¨ä¸­çš„å…ƒç´ æ¶ˆè´¹æ‰ï¼Œç„¶åæŠŠå€¼æ”¶é›†æˆ `Vec<_>` ç±»å‹ï¼Œè‡³äºä¸ºä½•ä½¿ç”¨ `_`ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨æ¨å¯¼ã€‚

ä¸ºä½• `collect` åœ¨æ¶ˆè´¹æ—¶è¦æŒ‡å®šç±»å‹ï¼Ÿæ˜¯å› ä¸ºè¯¥æ–¹æ³•å…¶å®å¾ˆå¼ºå¤§ï¼Œå¯ä»¥æ”¶é›†æˆå¤šç§ä¸åŒçš„é›†åˆç±»å‹ï¼Œ`Vec<T>` ä»…ä»…æ˜¯å…¶ä¸­ä¹‹ä¸€ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»æ˜¾å¼çš„å‘Šè¯‰ç¼–è¯‘å™¨æˆ‘ä»¬æƒ³è¦æ”¶é›†æˆçš„é›†åˆç±»å‹ã€‚

è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„ï¼Œ`map` ä¼šå¯¹è¿­ä»£å™¨ä¸­çš„æ¯ä¸€ä¸ªå€¼è¿›è¡Œä¸€ç³»åˆ—æ“ä½œï¼Œç„¶åæŠŠè¯¥å€¼è½¬æ¢æˆå¦å¤–ä¸€ä¸ªæ–°å€¼ï¼Œè¯¥æ“ä½œæ˜¯é€šè¿‡é—­åŒ… `|x| x + 1` æ¥å®Œæˆï¼šæœ€ç»ˆè¿­ä»£å™¨ä¸­çš„æ¯ä¸ªå€¼éƒ½å¢åŠ äº† `1`ï¼Œä» `[1, 2, 3]` å˜ä¸º `[2, 3, 4]`ã€‚

å†æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ `collect` æ”¶é›†æˆ `HashMap` é›†åˆï¼š

```rust
use std::collections::HashMap;
fn main() {
    let names = ["sunface", "sunfei"];
    let ages = [18, 18];
    let folks: HashMap<_, _> = names.into_iter().zip(ages.into_iter()).collect();

    println!("{:?}",folks);
}
```

`zip` æ˜¯ä¸€ä¸ªè¿­ä»£å™¨é€‚é…å™¨ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å°†ä¸¤ä¸ªè¿­ä»£å™¨çš„å†…å®¹å‹ç¼©åˆ°ä¸€èµ·ï¼Œå½¢æˆ `Iterator<Item=(ValueFromA, ValueFromB)>` è¿™æ ·çš„æ–°çš„è¿­ä»£å™¨ï¼Œåœ¨æ­¤å¤„å°±æ˜¯å½¢å¦‚ `[(name1, age1), (name2, age2)]` çš„è¿­ä»£å™¨ã€‚

ç„¶åå†é€šè¿‡ `collect` å°†æ–°è¿­ä»£å™¨ä¸­`(K, V)` å½¢å¼çš„å€¼æ”¶é›†æˆ `HashMap<K, V>`ï¼ŒåŒæ ·çš„ï¼Œè¿™é‡Œå¿…é¡»æ˜¾å¼å£°æ˜ç±»å‹ï¼Œç„¶å `HashMap` å†…éƒ¨çš„ `KV` ç±»å‹å¯ä»¥äº¤ç»™ç¼–è¯‘å™¨å»æ¨å¯¼ï¼Œæœ€ç»ˆç¼–è¯‘å™¨ä¼šæ¨å¯¼å‡º `HashMap<&str, i32>`ï¼Œå®Œå…¨æ­£ç¡®ï¼

#### é—­åŒ…ä½œä¸ºé€‚é…å™¨å‚æ•°

ä¹‹å‰çš„ `map` æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é—­åŒ…æ¥ä½œä¸ºè¿­ä»£å™¨é€‚é…å™¨çš„å‚æ•°ï¼Œå®ƒæœ€å¤§çš„å¥½å¤„ä¸ä»…åœ¨äºå¯ä»¥å°±åœ°å®ç°è¿­ä»£å™¨ä¸­å…ƒç´ çš„å¤„ç†ï¼Œè¿˜åœ¨äºå¯ä»¥æ•è·ç¯å¢ƒå€¼ï¼š

```rust
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
```

`filter` æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼Œç”¨äºå¯¹è¿­ä»£å™¨ä¸­çš„æ¯ä¸ªå€¼è¿›è¡Œè¿‡æ»¤ã€‚ å®ƒä½¿ç”¨é—­åŒ…ä½œä¸ºå‚æ•°ï¼Œè¯¥é—­åŒ…çš„å‚æ•° `s` æ˜¯æ¥è‡ªè¿­ä»£å™¨ä¸­çš„å€¼ï¼Œç„¶åä½¿ç”¨ `s` è·Ÿå¤–éƒ¨ç¯å¢ƒä¸­çš„ `shoe_size` è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™åœ¨è¿­ä»£å™¨ä¸­ä¿ç•™ `s` å€¼ï¼Œè‹¥ä¸ç›¸ç­‰ï¼Œåˆ™ä»è¿­ä»£å™¨ä¸­å‰”é™¤ `s` å€¼ï¼Œæœ€ç»ˆé€šè¿‡ `collect` æ”¶é›†ä¸º `Vec<Shoe>` ç±»å‹ã€‚

## å®ç° Iterator ç‰¹å¾

ä¹‹å‰çš„å†…å®¹æˆ‘ä»¬ä¸€ç›´åŸºäºæ•°ç»„æ¥åˆ›å»ºè¿­ä»£å™¨ï¼Œå®é™…ä¸Šï¼Œä¸ä»…ä»…æ˜¯æ•°ç»„ï¼ŒåŸºäºå…¶å®ƒé›†åˆç±»å‹ä¸€æ ·å¯ä»¥åˆ›å»ºè¿­ä»£å™¨ï¼Œä¾‹å¦‚ `HashMap`ã€‚ ä½ ä¹Ÿå¯ä»¥åˆ›å»ºè‡ªå·±çš„è¿­ä»£å™¨ â€”â€” åªè¦ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `Iterator` ç‰¹å¾å³å¯ã€‚

é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªè®¡æ•°å™¨ï¼š

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```

æˆ‘ä»¬ä¸ºè®¡æ•°å™¨ `Counter` å®ç°äº†ä¸€ä¸ªå…³è”å‡½æ•° `new`ï¼Œç”¨äºåˆ›å»ºæ–°çš„è®¡æ•°å™¨å®ä¾‹ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­ä¸ºè®¡æ•°å™¨å®ç° `Iterator` ç‰¹å¾ï¼š

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```

é¦–å…ˆï¼Œå°†è¯¥ç‰¹å¾çš„å…³è”ç±»å‹è®¾ç½®ä¸º `u32`ï¼Œç”±äºæˆ‘ä»¬çš„è®¡æ•°å™¨ä¿å­˜çš„ `count` å­—æ®µå°±æ˜¯ `u32` ç±»å‹ï¼Œ å› æ­¤åœ¨ `next` æ–¹æ³•ä¸­ï¼Œæœ€åè¿”å›çš„æ˜¯å®é™…ä¸Šæ˜¯ `Option<u32>` ç±»å‹ã€‚

æ¯æ¬¡è°ƒç”¨ `next` æ–¹æ³•ï¼Œéƒ½ä¼šè®©è®¡æ•°å™¨çš„å€¼åŠ ä¸€ï¼Œç„¶åè¿”å›æœ€æ–°çš„è®¡æ•°å€¼ï¼Œä¸€æ—¦è®¡æ•°å¤§äº 5ï¼Œå°±è¿”å› `None`ã€‚

æœ€åï¼Œä½¿ç”¨æˆ‘ä»¬æ–°å»ºçš„ `Counter` è¿›è¡Œè¿­ä»£ï¼š

```rust
 let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
```

#### å®ç° Iterator ç‰¹å¾çš„å…¶å®ƒæ–¹æ³•

å¯ä»¥çœ‹å‡ºï¼Œå®ç°è‡ªå·±çš„è¿­ä»£å™¨éå¸¸ç®€å•ï¼Œä½†æ˜¯ `Iterator` ç‰¹å¾ä¸­ï¼Œä¸ä»…ä»…æ˜¯åªæœ‰ `next` ä¸€ä¸ªæ–¹æ³•ï¼Œé‚£ä¸ºä»€ä¹ˆæˆ‘ä»¬åªéœ€è¦å®ç°å®ƒå‘¢ï¼Ÿå› ä¸ºå…¶å®ƒæ–¹æ³•éƒ½å…·æœ‰[é»˜è®¤å®ç°](https://course.rs/basic/trait/trait.html#é»˜è®¤å®ç°)ï¼Œæ‰€ä»¥æ— éœ€åƒ `next` è¿™æ ·æ‰‹åŠ¨å»å®ç°ï¼Œè€Œä¸”è¿™äº›é»˜è®¤å®ç°çš„æ–¹æ³•å…¶å®éƒ½æ˜¯åŸºäº `next` æ–¹æ³•å®ç°çš„ã€‚

ä¸‹é¢çš„ä»£ç æ¼”ç¤ºäº†éƒ¨åˆ†æ–¹æ³•çš„ä½¿ç”¨ï¼š

```rust
let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
```

å…¶ä¸­ `zip`ï¼Œ`map`ï¼Œ`filter` æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼š

- `zip` æŠŠä¸¤ä¸ªè¿­ä»£å™¨åˆå¹¶æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œæ–°è¿­ä»£å™¨ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œç”±ä¹‹å‰ä¸¤ä¸ªè¿­ä»£å™¨çš„å…ƒç´ ç»„æˆã€‚ä¾‹å¦‚å°†**å½¢å¦‚** `[1, 2, 3, 4, 5]` å’Œ `[2, 3, 4, 5]` çš„è¿­ä»£å™¨åˆå¹¶åï¼Œæ–°çš„è¿­ä»£å™¨å½¢å¦‚ `[(1, 2),(2, 3),(3, 4),(4, 5)]`
- `map` æ˜¯å°†è¿­ä»£å™¨ä¸­çš„å€¼ç»è¿‡æ˜ å°„åï¼Œè½¬æ¢æˆæ–°çš„å€¼`[2, 6, 12, 20]`
- `filter` å¯¹è¿­ä»£å™¨ä¸­çš„å…ƒç´ è¿›è¡Œè¿‡æ»¤ï¼Œè‹¥é—­åŒ…è¿”å› `true` åˆ™ä¿ç•™å…ƒç´ ï¼Œåä¹‹å‰”é™¤ã€‚è¿‡æ»¤åçš„è¿­ä»£å™¨å½¢å¦‚`[6, 12]`

è€Œ `sum` æ˜¯æ¶ˆè´¹è€…é€‚é…å™¨ï¼Œå¯¹è¿­ä»£å™¨ä¸­çš„æ‰€æœ‰å…ƒç´ æ±‚å’Œï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ª `u32` å€¼ `18`ã€‚

##### enumerate

åœ¨ä¹‹å‰çš„æµç¨‹æ§åˆ¶ç« èŠ‚ï¼Œé’ˆå¯¹ `for` å¾ªç¯ï¼Œæˆ‘ä»¬æä¾›äº†ä¸€ç§æ–¹æ³•å¯ä»¥è·å–è¿­ä»£æ—¶çš„ç´¢å¼•ï¼š

```rust
let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!("ç¬¬{}ä¸ªå€¼æ˜¯{}",i,v)
}
```

ç›¸ä¿¡å½“æ—¶ï¼Œå¾ˆå¤šè¯»è€…è¿˜æ˜¯å¾ˆè¿·èŒ«çš„ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå¤æ‚æ‰èƒ½è·å–åˆ°ç´¢å¼•ï¼Œå­¦ä¹ æœ¬ç« èŠ‚åï¼Œç›¸ä¿¡ä½ æœ‰äº†å…¨æ–°çš„ç†è§£ï¼Œé¦–å…ˆ `v.iter()` åˆ›å»ºè¿­ä»£å™¨ï¼Œå…¶æ¬¡
è°ƒç”¨ `Iterator` ç‰¹å¾ä¸Šçš„æ–¹æ³• `enumerate`ï¼Œè¯¥æ–¹æ³•äº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ å‡æ˜¯å…ƒç»„ `(ç´¢å¼•ï¼Œå€¼)`ã€‚

å› ä¸º `enumerate` æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¯¹å®ƒè¿”å›çš„è¿­ä»£å™¨è°ƒç”¨å…¶å®ƒ `Iterator` ç‰¹å¾æ–¹æ³•ï¼š

```rust
let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // æ¯ä¸¤ä¸ªå…ƒç´ å‰”é™¤ä¸€ä¸ª
    // [1, 3, 5]
    .filter(|&(idx, _)| idx % 2 == 0)
    .map(|(_, val)| val)
    // ç´¯åŠ  1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!("{}", val);
```

## è¿­ä»£å™¨çš„æ€§èƒ½

å‰é¢æåˆ°ï¼Œè¦å®Œæˆé›†åˆéå†ï¼Œæ—¢å¯ä»¥ä½¿ç”¨ `for` å¾ªç¯ä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£å™¨ï¼Œé‚£ä¹ˆäºŒè€…ä¹‹é—´è¯¥æ€ä¹ˆé€‰æ‹©å‘¢ï¼Œæ€§èƒ½æœ‰å¤šå¤§å·®è·å‘¢ï¼Ÿ

ç†è®ºåˆ†æä¸ä¼šæœ‰ç»“æœï¼Œç›´æ¥æµ‹è¯•æœ€ä¸ºé è°±ï¼š

```rust
#![feature(test)]

extern crate rand;
extern crate test;

fn sum_for(x: &[f64]) -> f64 {
    let mut result: f64 = 0.0;
    for i in 0..x.len() {
        result += x[i];
    }
    result
}

fn sum_iter(x: &[f64]) -> f64 {
    x.iter().sum::<f64>()
}

#[cfg(test)]
mod bench {
    use test::Bencher;
    use rand::{Rng,thread_rng};
    use super::*;

    const LEN: usize = 1024*1024;

    fn rand_array(cnt: u32) -> Vec<f64> {
        let mut rng = thread_rng();
        (0..cnt).map(|_| rng.gen::<f64>()).collect()
    }

    #[bench]
    fn bench_for(b: &mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_for(&samples)
        })
    }

    #[bench]
    fn bench_iter(b: &mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_iter(&samples)
        })
    }
}
```

ä¸Šé¢çš„ä»£ç å¯¹æ¯”äº† `for` å¾ªç¯å’Œè¿­ä»£å™¨ `iterator` å®ŒæˆåŒæ ·çš„æ±‚å’Œä»»åŠ¡çš„æ€§èƒ½å¯¹æ¯”ï¼Œå¯ä»¥çœ‹åˆ°è¿­ä»£å™¨è¿˜è¦æ›´å¿«ä¸€ç‚¹ã€‚

```console
test bench::bench_for  ... bench:     998,331 ns/iter (+/- 36,250)
test bench::bench_iter ... bench:     983,858 ns/iter (+/- 44,673)
```

è¿­ä»£å™¨æ˜¯ Rust çš„ **é›¶æˆæœ¬æŠ½è±¡**ï¼ˆzero-cost abstractionsï¼‰ä¹‹ä¸€ï¼Œæ„å‘³ç€æŠ½è±¡å¹¶ä¸ä¼šå¼•å…¥è¿è¡Œæ—¶å¼€é”€ï¼Œè¿™ä¸ `Bjarne Stroustrup`ï¼ˆC++ çš„è®¾è®¡å’Œå®ç°è€…ï¼‰åœ¨ `Foundations of C++ï¼ˆ2012ï¼‰` ä¸­æ‰€å®šä¹‰çš„ **é›¶å¼€é”€**ï¼ˆzero-overheadï¼‰å¦‚å‡ºä¸€è¾™ï¼š

> In general, C++ implementations obey the zero-overhead principle: What you donâ€™t use, you donâ€™t pay for.
> And further: What you do use, you couldnâ€™t hand code any better.
>
> ä¸€èˆ¬æ¥è¯´ï¼ŒC++çš„å®ç°éµå¾ªé›¶å¼€é”€åŸåˆ™ï¼šæ²¡æœ‰ä½¿ç”¨æ—¶ï¼Œä½ ä¸å¿…ä¸ºå…¶ä¹°å•ã€‚
> æ›´è¿›ä¸€æ­¥è¯´ï¼Œéœ€è¦ä½¿ç”¨æ—¶ï¼Œä½ ä¹Ÿæ— æ³•å†™å‡ºæ›´ä¼˜çš„ä»£ç äº†ã€‚
> ï¼ˆç¿»è¯‘ä¸€ä¸‹ï¼šç”¨å°±å®Œäº‹äº†ï¼‰

æ€»ä¹‹ï¼Œè¿­ä»£å™¨æ˜¯ Rust å—å‡½æ•°å¼è¯­è¨€å¯å‘è€Œæä¾›çš„é«˜çº§è¯­è¨€ç‰¹æ€§ï¼Œå¯ä»¥å†™å‡ºæ›´åŠ ç®€æ´ã€é€»è¾‘æ¸…æ™°çš„ä»£ç ã€‚ç¼–è¯‘å™¨è¿˜å¯ä»¥é€šè¿‡å¾ªç¯å±•å¼€ï¼ˆUnrollingï¼‰ã€å‘é‡åŒ–ã€æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ç­‰ä¼˜åŒ–æ‰‹æ®µï¼Œä½¿å¾—è¿­ä»£å™¨å’Œ `for` å¾ªç¯éƒ½æœ‰æä¸ºé«˜æ•ˆçš„æ‰§è¡Œæ•ˆç‡ã€‚

æ‰€ä»¥è¯·æ”¾å¿ƒå¤§èƒ†çš„ä½¿ç”¨è¿­ä»£å™¨ï¼Œåœ¨è·å¾—æ›´é«˜çš„è¡¨è¾¾åŠ›çš„åŒæ—¶ï¼Œä¹Ÿä¸ä¼šå¯¼è‡´è¿è¡Œæ—¶çš„æŸå¤±ï¼Œä½•ä¹è€Œä¸ä¸ºå‘¢ï¼

## å­¦ä¹ å…¶å®ƒæ–¹æ³•

è¿­ä»£å™¨ç”¨çš„å¥½ä¸å¥½ï¼Œå°±åœ¨äºä½ æ˜¯å¦æŒæ¡äº†å®ƒçš„å¸¸ç”¨æ–¹æ³•ï¼Œä¸”èƒ½æ´»å­¦æ´»ç”¨ï¼Œå› æ­¤å¤šå¤šçœ‹çœ‹[æ ‡å‡†åº“](https://doc.rust-lang.org/std/iter/trait.Iterator.html)æ˜¯æœ‰å¥½å¤„çš„ï¼Œåªæœ‰çŸ¥é“æœ‰ä»€ä¹ˆæ–¹æ³•ï¼Œåœ¨éœ€è¦çš„æ—¶å€™ä½ æ‰èƒ½çŸ¥é“è¯¥ç”¨ä»€ä¹ˆï¼Œå°±å’Œç®—æ³•å­¦ä¹ ä¸€æ ·ã€‚

åŒæ—¶ï¼Œæœ¬ä¹¦åœ¨åç»­ç« èŠ‚è¿˜æä¾›äº†å¯¹è¿­ä»£å™¨å¸¸ç”¨æ–¹æ³•çš„[æ·±å…¥è®²è§£](https://course.rs/std/iterator)ï¼Œæ–¹ä¾¿å¤§å®¶å­¦ä¹ å’ŒæŸ¥é˜…ã€‚



================================================
FILE: src/advance/into-types/converse.md
================================================
# ç±»å‹è½¬æ¢


Rust æ˜¯ç±»å‹å®‰å…¨çš„è¯­è¨€ï¼Œå› æ­¤åœ¨ Rust ä¸­åšç±»å‹è½¬æ¢ä¸æ˜¯ä¸€ä»¶ç®€å•çš„äº‹ï¼Œè¿™ä¸€ç« èŠ‚æˆ‘ä»¬å°†å¯¹ Rust ä¸­çš„ç±»å‹è½¬æ¢è¿›è¡Œè¯¦å°½è®²è§£ã€‚

> é«˜èƒ½é¢„è­¦ï¼šæœ¬ç« èŠ‚æœ‰äº›éš¾ï¼Œå¯ä»¥è€ƒè™‘å­¦äº†è¿›é˜¶åå›å¤´å†çœ‹

## `as`è½¬æ¢

å…ˆæ¥çœ‹ä¸€æ®µä»£ç ï¼š

```rust
fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  if a < b {
    println!("Ten is less than one hundred.");
  }
}
```

èƒ½è·Ÿç€è¿™æœ¬ä¹¦ä¸€ç›´å­¦ä¹ åˆ°è¿™é‡Œï¼Œè¯´æ˜ä½ å¯¹ Rust å·²ç»æœ‰äº†ä¸€å®šçš„ç†è§£ï¼Œé‚£ä¹ˆä¸€çœ¼å°±èƒ½çœ‹å‡ºè¿™æ®µä»£ç æ³¨å®šä¼šæŠ¥é”™ï¼Œå› ä¸º `a` å’Œ `b` æ‹¥æœ‰ä¸åŒçš„ç±»å‹ï¼ŒRust ä¸å…è®¸ä¸¤ç§ä¸åŒçš„ç±»å‹è¿›è¡Œæ¯”è¾ƒã€‚

è§£å†³åŠæ³•å¾ˆç®€å•ï¼Œåªè¦æŠŠ `b` è½¬æ¢æˆ `i32` ç±»å‹å³å¯ï¼ŒRust ä¸­å†…ç½®äº†ä¸€äº›åŸºæœ¬ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œè¿™é‡Œä½¿ç”¨ `as` æ“ä½œç¬¦æ¥å®Œæˆï¼š `if a < (b as i32) {...}`ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆä¸æŠŠ `a` è½¬æ¢æˆ `u16` ç±»å‹å‘¢ï¼Ÿ

å› ä¸ºæ¯ä¸ªç±»å‹èƒ½è¡¨è¾¾çš„æ•°æ®èŒƒå›´ä¸åŒï¼Œå¦‚æœæŠŠèŒƒå›´è¾ƒå¤§çš„ç±»å‹è½¬æ¢æˆè¾ƒå°çš„ç±»å‹ï¼Œä¼šé€ æˆé”™è¯¯ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æŠŠèŒƒå›´è¾ƒå°çš„ç±»å‹è½¬æ¢æˆè¾ƒå¤§çš„ç±»å‹ï¼Œæ¥é¿å…è¿™äº›é—®é¢˜çš„å‘ç”Ÿã€‚

> ä½¿ç”¨ç±»å‹è½¬æ¢éœ€è¦å°å¿ƒï¼Œå› ä¸ºå¦‚æœæ‰§è¡Œä»¥ä¸‹æ“ä½œ `300_i32 as i8`ï¼Œä½ å°†è·å¾— `44` è¿™ä¸ªå€¼ï¼Œè€Œä¸æ˜¯ `300`ï¼Œå› ä¸º `i8` ç±»å‹èƒ½è¡¨è¾¾çš„çš„æœ€å¤§å€¼ä¸º `2^7 - 1`ï¼Œä½¿ç”¨ä»¥ä¸‹ä»£ç å¯ä»¥æŸ¥çœ‹ `i8` çš„æœ€å¤§å€¼ï¼š

```rust
let a = i8::MAX;
println!("{}",a);
```

ä¸‹é¢åˆ—å‡ºäº†å¸¸ç”¨çš„è½¬æ¢å½¢å¼ï¼š

```rust
fn main() {
   let a = 3.1 as i8;
   let b = 100_i8 as i32;
   let c = 'a' as u8; // å°†å­—ç¬¦'a'è½¬æ¢ä¸ºæ•´æ•°ï¼Œ97

   println!("{},{},{}",a,b,c)
}
```

#### å†…å­˜åœ°å€è½¬æ¢ä¸ºæŒ‡é’ˆ

```rust
let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize; // å°†p1å†…å­˜åœ°å€è½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°
let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()ï¼Œi32ç±»å‹å ç”¨4ä¸ªå­—èŠ‚ï¼Œå› æ­¤å°†å†…å­˜åœ°å€ + 4
let p2 = second_address as *mut i32; // è®¿é—®è¯¥åœ°å€æŒ‡å‘çš„ä¸‹ä¸€ä¸ªæ•´æ•°p2
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
```

#### å¼ºåˆ¶ç±»å‹è½¬æ¢çš„è¾¹è§’çŸ¥è¯†

1. è½¬æ¢ä¸å…·æœ‰ä¼ é€’æ€§
   å°±ç®— `e as U1 as U2` æ˜¯åˆæ³•çš„ï¼Œä¹Ÿä¸èƒ½è¯´æ˜ `e as U2` æ˜¯åˆæ³•çš„ï¼ˆ`e` ä¸èƒ½ç›´æ¥è½¬æ¢æˆ `U2`ï¼‰ã€‚

## TryInto è½¬æ¢

åœ¨ä¸€äº›åœºæ™¯ä¸­ï¼Œä½¿ç”¨ `as` å…³é”®å­—ä¼šæœ‰æ¯”è¾ƒå¤§çš„é™åˆ¶ã€‚å¦‚æœä½ æƒ³è¦åœ¨ç±»å‹è½¬æ¢ä¸Šæ‹¥æœ‰å®Œå…¨çš„æ§åˆ¶è€Œä¸ä¾èµ–å†…ç½®çš„è½¬æ¢ï¼Œä¾‹å¦‚å¤„ç†è½¬æ¢é”™è¯¯ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ `TryInto` ï¼š

```rust
use std::convert::TryInto;

fn main() {
   let a: u8 = 10;
   let b: u16 = 1500;

   let b_: u8 = b.try_into().unwrap();

   if a < b_ {
     println!("Ten is less than one hundred.");
   }
}
```

ä¸Šé¢ä»£ç ä¸­å¼•å…¥äº† `std::convert::TryInto` ç‰¹å¾ï¼Œä½†æ˜¯å´æ²¡æœ‰ä½¿ç”¨å®ƒï¼Œå¯èƒ½æœ‰äº›åŒå­¦ä¼šä¸ºæ­¤å›°æƒ‘ï¼Œä¸»è¦åŸå› åœ¨äº**å¦‚æœä½ è¦ä½¿ç”¨ä¸€ä¸ªç‰¹å¾çš„æ–¹æ³•ï¼Œé‚£ä¹ˆä½ éœ€è¦å¼•å…¥è¯¥ç‰¹å¾åˆ°å½“å‰çš„ä½œç”¨åŸŸä¸­**ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢ç”¨åˆ°äº† `try_into` æ–¹æ³•ï¼Œå› æ­¤éœ€è¦å¼•å…¥å¯¹åº”çš„ç‰¹å¾ã€‚ä½†æ˜¯ Rust åˆæä¾›äº†ä¸€ä¸ªéå¸¸ä¾¿åˆ©çš„åŠæ³•ï¼ŒæŠŠæœ€å¸¸ç”¨çš„æ ‡å‡†åº“ä¸­çš„ç‰¹å¾é€šè¿‡[`std::prelude`](https://course.rs/appendix/prelude.html)æ¨¡å—æå‰å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œå…¶ä¸­åŒ…æ‹¬äº† `std::convert::TryInto`ï¼Œä½ å¯ä»¥å°è¯•åˆ é™¤ç¬¬ä¸€è¡Œçš„ä»£ç  `use ...`ï¼Œçœ‹çœ‹æ˜¯å¦ä¼šæŠ¥é”™ã€‚

`try_into` ä¼šå°è¯•è¿›è¡Œä¸€æ¬¡è½¬æ¢ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Result`ï¼Œæ­¤æ—¶å°±å¯ä»¥å¯¹å…¶è¿›è¡Œç›¸åº”çš„é”™è¯¯å¤„ç†ã€‚ç”±äºæˆ‘ä»¬çš„ä¾‹å­åªæ˜¯ä¸ºäº†å¿«é€Ÿæµ‹è¯•ï¼Œå› æ­¤ä½¿ç”¨äº† `unwrap` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨å‘ç°é”™è¯¯æ—¶ï¼Œä¼šç›´æ¥è°ƒç”¨ `panic` å¯¼è‡´ç¨‹åºçš„å´©æºƒé€€å‡ºï¼Œåœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¯·ä¸è¦è¿™ä¹ˆä½¿ç”¨ï¼Œå…·ä½“è§[panic](https://course.rs/basic/result-error/panic.html#è°ƒç”¨-panic)éƒ¨åˆ†ã€‚

æœ€ä¸»è¦çš„æ˜¯ `try_into` è½¬æ¢ä¼šæ•è·å¤§ç±»å‹å‘å°ç±»å‹è½¬æ¢æ—¶å¯¼è‡´çš„æº¢å‡ºé”™è¯¯ï¼š

```rust
fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) => b1,
        Err(e) => {
            println!("{:?}", e.to_string());
            0
        }
    };
}
```

è¿è¡Œåè¾“å‡ºå¦‚ä¸‹ `"out of range integral type conversion attempted"`ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ç¨‹åºæ•è·äº†é”™è¯¯ï¼Œç¼–è¯‘å™¨å‘Šè¯‰æˆ‘ä»¬ç±»å‹èŒƒå›´è¶…å‡ºçš„è½¬æ¢æ˜¯ä¸è¢«å…è®¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬è¯•å›¾æŠŠ `1500_i16` è½¬æ¢ä¸º `u8` ç±»å‹ï¼Œåè€…æ˜æ˜¾ä¸è¶³ä»¥æ‰¿è½½è¿™ä¹ˆå¤§çš„å€¼ã€‚

## é€šç”¨ç±»å‹è½¬æ¢

è™½ç„¶ `as` å’Œ `TryInto` å¾ˆå¼ºå¤§ï¼Œä½†æ˜¯åªèƒ½åº”ç”¨åœ¨æ•°å€¼ç±»å‹ä¸Šï¼Œå¯æ˜¯ Rust æœ‰å¦‚æ­¤å¤šçš„ç±»å‹ï¼Œæƒ³è¦ä¸ºè¿™äº›ç±»å‹å®ç°è½¬æ¢ï¼Œæˆ‘ä»¬éœ€è¦å¦è°‹å‡ºè·¯ï¼Œå…ˆæ¥çœ‹çœ‹åœ¨ä¸€ä¸ªç¬¨åŠæ³•ï¼Œå°†ä¸€ä¸ªç»“æ„ä½“è½¬æ¢ä¸ºå¦å¤–ä¸€ä¸ªç»“æ„ä½“ï¼š

```rust
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```

ç®€å•ç²—æš´ï¼Œä½†æ˜¯ä»å¦å¤–ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œä¹ŸæŒºå•°å—¦çš„ï¼Œå¥½åœ¨ Rust ä¸ºæˆ‘ä»¬æä¾›äº†æ›´é€šç”¨çš„æ–¹å¼æ¥å®Œæˆè¿™ä¸ªç›®çš„ã€‚

#### å¼ºåˆ¶ç±»å‹è½¬æ¢

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç±»å‹æ˜¯å¯ä»¥è¿›è¡Œéšå¼å¼ºåˆ¶è½¬æ¢çš„ï¼Œè™½ç„¶è¿™äº›è½¬æ¢å¼±åŒ–äº† Rust çš„ç±»å‹ç³»ç»Ÿï¼Œä½†æ˜¯å®ƒä»¬çš„å­˜åœ¨æ˜¯ä¸ºäº†è®© Rust åœ¨å¤§å¤šæ•°åœºæ™¯å¯ä»¥å·¥ä½œ(è¯´ç™½äº†ï¼Œå¸®åŠ©ç”¨æˆ·çœäº‹)ï¼Œè€Œä¸æ˜¯æŠ¥å„ç§ç±»å‹ä¸Šçš„ç¼–è¯‘é”™è¯¯ã€‚

é¦–å…ˆï¼Œåœ¨åŒ¹é…ç‰¹å¾æ—¶ï¼Œä¸ä¼šåšä»»ä½•å¼ºåˆ¶è½¬æ¢(é™¤äº†æ–¹æ³•)ã€‚ä¸€ä¸ªç±»å‹ `T` å¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸º `U`ï¼Œä¸ä»£è¡¨ `impl T` å¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸º `impl U`ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç å°±æ— æ³•é€šè¿‡ç¼–è¯‘æ£€æŸ¥ï¼š

```rust
trait Trait {}

fn foo<X: Trait>(t: X) {}

impl<'a> Trait for &'a i32 {}

fn main() {
    let t: &mut i32 = &mut 0;
    foo(t);
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0277]: the trait bound `&mut i32: Trait` is not satisfied
--> src/main.rs:9:9
|
9 |     foo(t);
|         ^ the trait `Trait` is not implemented for `&mut i32`
|
= help: the following implementations were found:
        <&'a i32 as Trait>
= note: `Trait` is implemented for `&i32`, but not for `&mut i32`
```

`&i32` å®ç°äº†ç‰¹å¾ `Trait`ï¼Œ `&mut i32` å¯ä»¥è½¬æ¢ä¸º `&i32`ï¼Œä½†æ˜¯ `&mut i32` ä¾ç„¶æ— æ³•ä½œä¸º `Trait` æ¥ä½¿ç”¨ã€‚<!-- è¿™ä¸€æ®µæ²¡è¯»æ‡‚ï¼Œä»£ç ä¸­çš„ä¾‹å­å¥½åƒå’Œä¸Šé¢çš„æ–‡å­—æè¿°å…³ç³»ä¸å¤§ -->

#### ç‚¹æ“ä½œç¬¦

æ–¹æ³•è°ƒç”¨çš„ç‚¹æ“ä½œç¬¦çœ‹èµ·æ¥ç®€å•ï¼Œå®é™…ä¸Šéå¸¸ä¸ç®€å•ï¼Œå®ƒåœ¨è°ƒç”¨æ—¶ï¼Œä¼šå‘ç”Ÿå¾ˆå¤šé­”æ³•èˆ¬çš„ç±»å‹è½¬æ¢ï¼Œä¾‹å¦‚ï¼šè‡ªåŠ¨å¼•ç”¨ã€è‡ªåŠ¨è§£å¼•ç”¨ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ç›´åˆ°ç±»å‹èƒ½åŒ¹é…ç­‰ã€‚

å‡è®¾æœ‰ä¸€ä¸ªæ–¹æ³• `foo`ï¼Œå®ƒæœ‰ä¸€ä¸ªæ¥æ”¶å™¨(æ¥æ”¶å™¨å°±æ˜¯ `self`ã€`&self`ã€`&mut self` å‚æ•°)ã€‚å¦‚æœè°ƒç”¨ `value.foo()`ï¼Œç¼–è¯‘å™¨åœ¨è°ƒç”¨ `foo` ä¹‹å‰ï¼Œéœ€è¦å†³å®šåˆ°åº•ä½¿ç”¨å“ªä¸ª `Self` ç±»å‹æ¥è°ƒç”¨ã€‚ç°åœ¨å‡è®¾ `value` æ‹¥æœ‰ç±»å‹ `T`ã€‚

å†è¿›ä¸€æ­¥ï¼Œæˆ‘ä»¬ä½¿ç”¨[å®Œå…¨é™å®šè¯­æ³•](https://course.rs/basic/trait/advance-trait.html#å®Œå…¨é™å®šè¯­æ³•)æ¥è¿›è¡Œå‡†ç¡®çš„å‡½æ•°è°ƒç”¨:

1. é¦–å…ˆï¼Œç¼–è¯‘å™¨æ£€æŸ¥å®ƒæ˜¯å¦å¯ä»¥ç›´æ¥è°ƒç”¨ `T::foo(value)`ï¼Œç§°ä¹‹ä¸º**å€¼æ–¹æ³•è°ƒç”¨**
2. å¦‚æœä¸Šä¸€æ­¥è°ƒç”¨æ— æ³•å®Œæˆ(ä¾‹å¦‚æ–¹æ³•ç±»å‹é”™è¯¯æˆ–è€…ç‰¹å¾æ²¡æœ‰é’ˆå¯¹ `Self` è¿›è¡Œå®ç°ï¼Œä¸Šæ–‡æåˆ°è¿‡ç‰¹å¾ä¸èƒ½è¿›è¡Œå¼ºåˆ¶è½¬æ¢)ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šå°è¯•å¢åŠ è‡ªåŠ¨å¼•ç”¨ï¼Œä¾‹å¦‚ä¼šå°è¯•ä»¥ä¸‹è°ƒç”¨ï¼š `<&T>::foo(value)` å’Œ `<&mut T>::foo(value)`ï¼Œç§°ä¹‹ä¸º**å¼•ç”¨æ–¹æ³•è°ƒç”¨**
3. è‹¥ä¸Šé¢ä¸¤ä¸ªæ–¹æ³•ä¾ç„¶ä¸å·¥ä½œï¼Œç¼–è¯‘å™¨ä¼šè¯•ç€è§£å¼•ç”¨ `T` ï¼Œç„¶åå†è¿›è¡Œå°è¯•ã€‚è¿™é‡Œä½¿ç”¨äº† `Deref` ç‰¹å¾ â€”â€” è‹¥ `T: Deref<Target = U>` (`T` å¯ä»¥è¢«è§£å¼•ç”¨ä¸º `U`)ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šä½¿ç”¨ `U` ç±»å‹è¿›è¡Œå°è¯•ï¼Œç§°ä¹‹ä¸º**è§£å¼•ç”¨æ–¹æ³•è°ƒç”¨**
4. è‹¥ `T` ä¸èƒ½è¢«è§£å¼•ç”¨ï¼Œä¸” `T` æ˜¯ä¸€ä¸ªå®šé•¿ç±»å‹(åœ¨ç¼–è¯‘æœŸç±»å‹é•¿åº¦æ˜¯å·²çŸ¥çš„)ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¹Ÿä¼šå°è¯•å°† `T` ä»å®šé•¿ç±»å‹è½¬ä¸ºä¸å®šé•¿ç±»å‹ï¼Œä¾‹å¦‚å°† `[i32; 2]` è½¬ä¸º `[i32]`
5. è‹¥è¿˜æ˜¯ä¸è¡Œï¼Œé‚£...æ²¡æœ‰é‚£äº†ï¼Œæœ€åç¼–è¯‘å™¨å¤§å–Šä¸€å£°ï¼šæ±æ¬ºæˆ‘ç”šï¼Œä¸å¹²äº†ï¼

ä¸‹é¢æˆ‘ä»¬æ¥ç”¨ä¸€ä¸ªä¾‹å­æ¥è§£é‡Šä¸Šé¢çš„æ–¹æ³•æŸ¥æ‰¾ç®—æ³•:

```rust
let array: Rc<Box<[T; 3]>> = ...;
let first_entry = array[0];
```

`array` æ•°ç»„çš„åº•å±‚æ•°æ®éšè—åœ¨äº†é‡é‡å°é”ä¹‹åï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å¦‚ä½•ä½¿ç”¨ `array[0]` è¿™ç§æ•°ç»„åŸç”Ÿè®¿é—®è¯­æ³•é€šè¿‡é‡é‡å°é”ï¼Œå‡†ç¡®çš„è®¿é—®åˆ°æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Ÿ

1. é¦–å…ˆï¼Œ `array[0]` åªæ˜¯[`Index`](https://doc.rust-lang.org/std/ops/trait.Index.html)ç‰¹å¾çš„è¯­æ³•ç³–ï¼šç¼–è¯‘å™¨ä¼šå°† `array[0]` è½¬æ¢ä¸º `array.index(0)` è°ƒç”¨ï¼Œå½“ç„¶åœ¨è°ƒç”¨ä¹‹å‰ï¼Œç¼–è¯‘å™¨ä¼šå…ˆæ£€æŸ¥ `array` æ˜¯å¦å®ç°äº† `Index` ç‰¹å¾ã€‚
2. æ¥ç€ï¼Œç¼–è¯‘å™¨æ£€æŸ¥ `Rc<Box<[T; 3]>>` æ˜¯å¦æœ‰å®ç° `Index` ç‰¹å¾ï¼Œç»“æœæ˜¯å¦ï¼Œä¸ä»…å¦‚æ­¤ï¼Œ`&Rc<Box<[T; 3]>>` ä¸ `&mut Rc<Box<[T; 3]>>` ä¹Ÿæ²¡æœ‰å®ç°ã€‚
3. ä¸Šé¢çš„éƒ½ä¸èƒ½å·¥ä½œï¼Œç¼–è¯‘å™¨å¼€å§‹å¯¹ `Rc<Box<[T; 3]>>` è¿›è¡Œè§£å¼•ç”¨ï¼ŒæŠŠå®ƒè½¬å˜æˆ `Box<[T; 3]>`
4. æ­¤æ—¶ç»§ç»­å¯¹ `Box<[T; 3]>` è¿›è¡Œä¸Šé¢çš„æ“ä½œ ï¼š`Box<[T; 3]>`ï¼Œ `&Box<[T; 3]>`ï¼Œå’Œ `&mut Box<[T; 3]>` éƒ½æ²¡æœ‰å®ç° `Index` ç‰¹å¾ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¼€å§‹å¯¹ `Box<[T; 3]>` è¿›è¡Œè§£å¼•ç”¨ï¼Œç„¶åæˆ‘ä»¬å¾—åˆ°äº† `[T; 3]`
5. `[T; 3]` ä»¥åŠå®ƒçš„å„ç§å¼•ç”¨éƒ½æ²¡æœ‰å®ç° `Index` ç´¢å¼•(æ˜¯ä¸æ˜¯å¾ˆåç›´è§‰:Dï¼Œåœ¨ç›´è§‰ä¸­ï¼Œæ•°ç»„éƒ½å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®ï¼Œå®é™…ä¸Šåªæœ‰æ•°ç»„åˆ‡ç‰‡æ‰å¯ä»¥!)ï¼Œå®ƒä¹Ÿä¸èƒ½å†è¿›è¡Œè§£å¼•ç”¨ï¼Œå› æ­¤ç¼–è¯‘å™¨åªèƒ½ç¥­å‡ºæœ€åçš„å¤§æ€å™¨ï¼šå°†å®šé•¿è½¬ä¸ºä¸å®šé•¿ï¼Œå› æ­¤ `[T; 3]` è¢«è½¬æ¢æˆ `[T]`ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„åˆ‡ç‰‡ï¼Œå®ƒå®ç°äº† `Index` ç‰¹å¾ï¼Œå› æ­¤æœ€ç»ˆæˆ‘ä»¬å¯ä»¥é€šè¿‡ `index` æ–¹æ³•è®¿é—®åˆ°å¯¹åº”çš„å…ƒç´ ã€‚

è¿‡ç¨‹çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œä½†æ˜¯ä¹Ÿè¿˜å¥½ï¼ŒæŒºå¥½ç†è§£ï¼Œå¦‚æœä½ ç°åœ¨ä¸èƒ½å½»åº•ç†è§£ï¼Œä¹Ÿä¸è¦ç´§ï¼Œç­‰ä»¥åå¯¹ Rust ç†è§£æ›´æ·±äº†ï¼ŒåŒæ—¶éœ€è¦æ·±å…¥ç†è§£ç±»å‹è½¬æ¢æ—¶ï¼Œå†æ¥ç»†ç»†å“è¯»æœ¬ç« ã€‚

å†æ¥çœ‹çœ‹ä»¥ä¸‹æ›´å¤æ‚çš„ä¾‹å­ï¼š

```rust
fn do_stuff<T: Clone>(value: &T) {
    let cloned = value.clone();
}
```

ä¸Šé¢ä¾‹å­ä¸­ `cloned` çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿé¦–å…ˆç¼–è¯‘å™¨æ£€æŸ¥èƒ½ä¸èƒ½è¿›è¡Œ**å€¼æ–¹æ³•è°ƒç”¨**ï¼Œ `value` çš„ç±»å‹æ˜¯ `&T`ï¼ŒåŒæ—¶ `clone` æ–¹æ³•çš„ç­¾åä¹Ÿæ˜¯ `&T` ï¼š `fn clone(&T) -> T`ï¼Œå› æ­¤å¯ä»¥è¿›è¡Œå€¼æ–¹æ³•è°ƒç”¨ï¼Œå†åŠ ä¸Šç¼–è¯‘å™¨çŸ¥é“äº† `T` å®ç°äº† `Clone`ï¼Œå› æ­¤ `cloned` çš„ç±»å‹æ˜¯ `T`ã€‚

å¦‚æœ `T: Clone` çš„ç‰¹å¾çº¦æŸè¢«ç§»é™¤å‘¢ï¼Ÿ

```rust
fn do_stuff<T>(value: &T) {
    let cloned = value.clone();
}
```

é¦–å…ˆï¼Œä»ç›´è§‰ä¸Šæ¥è¯´ï¼Œè¯¥æ–¹æ³•ä¼šæŠ¥é”™ï¼Œå› ä¸º `T` æ²¡æœ‰å®ç° `Clone` ç‰¹å¾ï¼Œä½†æ˜¯çœŸå®æƒ…å†µæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

æˆ‘ä»¬å…ˆæ¥æ¨å¯¼ä¸€ç•ªã€‚ é¦–å…ˆé€šè¿‡å€¼æ–¹æ³•è°ƒç”¨å°±ä¸å†å¯è¡Œï¼Œå› ä¸º `T` æ²¡æœ‰å®ç° `Clone` ç‰¹å¾ï¼Œä¹Ÿå°±æ— æ³•è°ƒç”¨ `T` çš„ `clone` æ–¹æ³•ã€‚æ¥ç€ç¼–è¯‘å™¨å°è¯•**å¼•ç”¨æ–¹æ³•è°ƒç”¨**ï¼Œæ­¤æ—¶ `T` å˜æˆ `&T`ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ `clone` æ–¹æ³•çš„ç­¾åå¦‚ä¸‹ï¼š `fn clone(&&T) -> &T`ï¼Œæ¥ç€æˆ‘ä»¬ç°åœ¨å¯¹ `value` è¿›è¡Œäº†å¼•ç”¨ã€‚ ç¼–è¯‘å™¨å‘ç° `&T` å®ç°äº† `Clone` ç±»å‹(æ‰€æœ‰çš„å¼•ç”¨ç±»å‹éƒ½å¯ä»¥è¢«å¤åˆ¶ï¼Œå› ä¸ºå…¶å®å°±æ˜¯å¤åˆ¶ä¸€ä»½åœ°å€)ï¼Œå› æ­¤å¯ä»¥æ¨å‡º `cloned` ä¹Ÿæ˜¯ `&T` ç±»å‹ã€‚

æœ€ç»ˆï¼Œæˆ‘ä»¬å¤åˆ¶å‡ºä¸€ä»½å¼•ç”¨æŒ‡é’ˆï¼Œè¿™å¾ˆåˆç†ï¼Œå› ä¸ºå€¼ç±»å‹ `T` æ²¡æœ‰å®ç° `Clone`ï¼Œåªèƒ½å»å¤åˆ¶ä¸€ä¸ªæŒ‡é’ˆäº†ã€‚

ä¸‹é¢çš„ä¾‹å­ä¹Ÿæ˜¯è‡ªåŠ¨å¼•ç”¨ç”Ÿæ•ˆçš„åœ°æ–¹ï¼š

```rust
#[derive(Clone)]
struct Container<T>(Arc<T>);

fn clone_containers<T>(foo: &Container<i32>, bar: &Container<T>) {
    let foo_cloned = foo.clone();
    let bar_cloned = bar.clone();
}
```

æ¨æ–­ä¸‹ä¸Šé¢çš„ `foo_cloned` å’Œ `bar_cloned` æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿæç¤º: å…³é”®åœ¨ `Container` çš„æ³›å‹å‚æ•°ï¼Œä¸€ä¸ªæ˜¯ `i32` çš„å…·ä½“ç±»å‹ï¼Œä¸€ä¸ªæ˜¯æ³›å‹ç±»å‹ï¼Œå…¶ä¸­ `i32` å®ç°äº† `Clone`ï¼Œä½†æ˜¯ `T` å¹¶æ²¡æœ‰ã€‚

é¦–å…ˆè¦å¤ä¹ ä¸€ä¸‹å¤æ‚ç±»å‹æ´¾ç”Ÿ `Clone` çš„è§„åˆ™ï¼šä¸€ä¸ªå¤æ‚ç±»å‹èƒ½å¦æ´¾ç”Ÿ `Clone`ï¼Œéœ€è¦å®ƒå†…éƒ¨çš„æ‰€æœ‰å­ç±»å‹éƒ½èƒ½è¿›è¡Œ `Clone`ã€‚å› æ­¤ `Container<T>(Arc<T>)` æ˜¯å¦å®ç° `Clone` çš„å…³é”®åœ¨äº `T` ç±»å‹æ˜¯å¦å®ç°äº† `Clone` ç‰¹å¾ã€‚

ä¸Šé¢ä»£ç ä¸­ï¼Œ`Container<i32>` å®ç°äº† `Clone` ç‰¹å¾ï¼Œå› æ­¤ç¼–è¯‘å™¨å¯ä»¥ç›´æ¥è¿›è¡Œå€¼æ–¹æ³•è°ƒç”¨ï¼Œæ­¤æ—¶ç›¸å½“äºç›´æ¥è°ƒç”¨ `foo.clone`ï¼Œå…¶ä¸­ `clone` çš„å‡½æ•°ç­¾åæ˜¯ `fn clone(&T) -> T`ï¼Œç”±æ­¤å¯ä»¥çœ‹å‡º `foo_cloned` çš„ç±»å‹æ˜¯ `Container<i32>`ã€‚

ç„¶è€Œï¼Œ`bar_cloned` çš„ç±»å‹å´æ˜¯ `&Container<T>`ï¼Œè¿™ä¸ªä¸åˆç†å•Šï¼Œæ˜æ˜æˆ‘ä»¬ä¸º `Container<T>` æ´¾ç”Ÿäº† `Clone` ç‰¹å¾ï¼Œå› æ­¤å®ƒä¹Ÿåº”è¯¥æ˜¯ `Container<T>` ç±»å‹æ‰å¯¹ã€‚ä¸‡äº‹çš†æœ‰å› ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ `derive` å®æœ€ç»ˆç”Ÿæˆçš„ä»£ç å¤§æ¦‚æ˜¯å•¥æ ·çš„ï¼š

```rust
impl<T> Clone for Container<T> where T: Clone {
    fn clone(&self) -> Self {
        Self(Arc::clone(&self.0))
    }
}
```

ä»ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œæ´¾ç”Ÿ `Clone` èƒ½å®ç°çš„æ ¹æœ¬æ˜¯ `T` å®ç°äº†[`Clone`ç‰¹å¾](https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable)ï¼š`where T: Clone`ï¼Œ å› æ­¤ `Container<T>` å°±æ²¡æœ‰å®ç° `Clone` ç‰¹å¾ã€‚

ç¼–è¯‘å™¨æ¥ç€ä¼šå»å°è¯•å¼•ç”¨æ–¹æ³•è°ƒç”¨ï¼Œæ­¤æ—¶ `&Container<T>` å¼•ç”¨å®ç°äº† `Clone`ï¼Œæœ€ç»ˆå¯ä»¥å¾—å‡º `bar_cloned` çš„ç±»å‹æ˜¯ `&Container<T>`ã€‚

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä¸º `Container<T>` æ‰‹åŠ¨å®ç° `Clone` ç‰¹å¾ï¼š

```rust
impl<T> Clone for Container<T> {
    fn clone(&self) -> Self {
        Self(Arc::clone(&self.0))
    }
}
```

æ­¤æ—¶ï¼Œç¼–è¯‘å™¨é¦–æ¬¡å°è¯•å€¼æ–¹æ³•è°ƒç”¨å³å¯é€šè¿‡ï¼Œå› æ­¤ `bar_cloned` çš„ç±»å‹å˜æˆ `Container<T>`ã€‚

è¿™ä¸€å—å„¿å†…å®¹çœŸçš„æŒºå¤æ‚ï¼Œæ¯ä¸€ä¸ªåšæŒçœ‹å®Œçš„è¯»è€…éƒ½æ˜¯çœŸæ­£çš„å‹‡å£«ï¼Œæˆ‘ä¹Ÿæ˜¯ï¼šä¸ºäº†å†™å¥½è¿™å—å„¿å†…å®¹ï¼Œä½œè€…è¶³è¶³èŠ±äº† **4** ä¸ªå°æ—¶ï¼

#### å˜å½¢è®°(Transmutes)

å‰æ–¹å±é™©ï¼Œæ•¬è¯·ç»•è¡Œï¼

ç±»å‹ç³»ç»Ÿï¼Œä½ è®©å¼€ï¼æˆ‘è¦è‡ªå·±è½¬æ¢è¿™äº›ç±»å‹ï¼Œä¸æˆåŠŸä¾¿æˆä»ï¼è™½ç„¶æœ¬ä¹¦å¤§å¤šæ˜¯å…³äºå®‰å…¨çš„å†…å®¹ï¼Œæˆ‘è¿˜æ˜¯å¸Œæœ›ä½ èƒ½ä»”ç»†è€ƒè™‘é¿å…ä½¿ç”¨æœ¬ç« è®²åˆ°çš„å†…å®¹ã€‚è¿™æ˜¯ä½ åœ¨ Rust ä¸­æ‰€èƒ½åšåˆ°çš„çœŸçœŸæ­£æ­£ã€å½»å½»åº•åº•ã€æœ€æœ€å¯æ€•çš„éå®‰å…¨è¡Œä¸ºï¼Œåœ¨è¿™é‡Œï¼Œæ‰€æœ‰çš„ä¿æŠ¤æœºåˆ¶éƒ½å½¢åŒè™šè®¾ã€‚

å…ˆè®©ä½ çœ‹çœ‹æ·±æ¸Šé•¿ä»€ä¹ˆæ ·ï¼Œå¼€å¼€çœ¼ï¼Œç„¶åä½ å†å†³å®šæ˜¯å¦æ·±å…¥ï¼š `mem::transmute<T, U>` å°†ç±»å‹ `T` ç›´æ¥è½¬æˆç±»å‹ `U`ï¼Œå”¯ä¸€çš„è¦æ±‚å°±æ˜¯ï¼Œè¿™ä¸¤ä¸ªç±»å‹å ç”¨åŒæ ·å¤§å°çš„å­—èŠ‚æ•°ï¼æˆ‘çš„å¤©ï¼Œè¿™ä¹Ÿç®—é™åˆ¶ï¼Ÿè¿™ç®€ç›´å°±æ˜¯æ— åº•çº¿çš„è½¬æ¢å¥½å§ï¼Ÿçœ‹çœ‹ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼š

1. é¦–å…ˆä¹Ÿæ˜¯æœ€é‡è¦çš„ï¼Œè½¬æ¢ååˆ›å»ºä¸€ä¸ªä»»æ„ç±»å‹çš„å®ä¾‹ä¼šé€ æˆæ— æ³•æƒ³è±¡çš„æ··ä¹±ï¼Œè€Œä¸”æ ¹æœ¬æ— æ³•é¢„æµ‹ã€‚ä¸è¦æŠŠ `3` è½¬æ¢æˆ `bool` ç±»å‹ï¼Œå°±ç®—ä½ æ ¹æœ¬ä¸ä¼šå»ä½¿ç”¨è¯¥ `bool` ç±»å‹ï¼Œä¹Ÿä¸è¦å»è¿™æ ·è½¬æ¢
2. å˜å½¢åä¼šæœ‰ä¸€ä¸ªé‡è½½çš„è¿”å›ç±»å‹ï¼Œå³ä½¿ä½ æ²¡æœ‰æŒ‡å®šè¿”å›ç±»å‹ï¼Œä¸ºäº†æ»¡è¶³ç±»å‹æ¨å¯¼çš„éœ€æ±‚ï¼Œä¾ç„¶ä¼šäº§ç”Ÿåƒå¥‡ç™¾æ€ªçš„ç±»å‹
3. å°† `&` å˜å½¢ä¸º `&mut` æ˜¯æœªå®šä¹‰çš„è¡Œä¸º
   - è¿™ç§è½¬æ¢æ°¸è¿œéƒ½æ˜¯æœªå®šä¹‰çš„
   - ä¸ï¼Œä½ ä¸èƒ½è¿™ä¹ˆåš
   - ä¸è¦å¤šæƒ³ï¼Œä½ æ²¡æœ‰é‚£ç§å¹¸è¿
4. å˜å½¢ä¸ºä¸€ä¸ªæœªæŒ‡å®šç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ä¼šå¯¼è‡´[æ— ç•Œç”Ÿå‘½å‘¨æœŸ](https://course.rs/advance/lifetime/advance.html)
5. åœ¨å¤åˆç±»å‹ä¹‹é—´äº’ç›¸å˜æ¢æ—¶ï¼Œä½ éœ€è¦ä¿è¯å®ƒä»¬çš„æ’åˆ—å¸ƒå±€æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼ä¸€æ—¦ä¸ä¸€æ ·ï¼Œé‚£ä¹ˆå­—æ®µå°±ä¼šå¾—åˆ°ä¸å¯é¢„æœŸçš„å€¼ï¼Œè¿™ä¹Ÿæ˜¯æœªå®šä¹‰çš„è¡Œä¸ºï¼Œè‡³äºä½ ä¼šä¸ä¼šå› æ­¤æ„¤æ€’ï¼Œ **WHO CARES** ï¼Œä½ éƒ½ç”¨äº†å˜å½¢äº†ï¼Œè€å…„ï¼

å¯¹äºç¬¬ 5 æ¡ï¼Œä½ è¯¥å¦‚ä½•çŸ¥é“å†…å­˜çš„æ’åˆ—å¸ƒå±€æ˜¯ä¸€æ ·çš„å‘¢ï¼Ÿå¯¹äº `repr(C)` ç±»å‹å’Œ `repr(transparent)` ç±»å‹æ¥è¯´ï¼Œå®ƒä»¬çš„å¸ƒå±€æ˜¯æœ‰ç€ç²¾ç¡®å®šä¹‰çš„ã€‚ä½†æ˜¯å¯¹äºä½ è‡ªå·±çš„"æ™®é€šå´è‡ªä¿¡"çš„ Rust ç±»å‹ `repr(Rust)` æ¥è¯´ï¼Œå®ƒå¯ä¸æ˜¯æœ‰ç€ç²¾ç¡®å®šä¹‰çš„ã€‚ç”šè‡³åŒä¸€ä¸ªæ³›å‹ç±»å‹çš„ä¸åŒå®ä¾‹éƒ½å¯ä»¥æœ‰ä¸åŒçš„å†…å­˜å¸ƒå±€ã€‚ `Vec<i32>` å’Œ `Vec<u32>` å®ƒä»¬çš„å­—æ®µå¯èƒ½æœ‰ç€ç›¸åŒçš„é¡ºåºï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚å¯¹äºæ•°æ®æ’åˆ—å¸ƒå±€æ¥è¯´ï¼Œ**ä»€ä¹ˆèƒ½ä¿è¯ï¼Œä»€ä¹ˆä¸èƒ½ä¿è¯**ç›®å‰è¿˜åœ¨ Rust å¼€å‘ç»„çš„[å·¥ä½œä»»åŠ¡](https://rust-lang.github.io/unsafe-code-guidelines/layout.html)ä¸­å‘¢ã€‚

ä½ ä»¥ä¸ºä½ ä¹‹å‰å‡è§†çš„æ˜¯æ·±æ¸Šå—ï¼Ÿä¸ï¼Œä½ å‡è§†çš„åªæ˜¯æ·±æ¸Šçš„å¤§é—¨ã€‚ `mem::transmute_copy<T, U>` æ‰æ˜¯çœŸæ­£çš„æ·±æ¸Šï¼Œå®ƒæ¯”ä¹‹å‰çš„è¿˜è¦æ›´åŠ å±é™©å’Œä¸å®‰å…¨ã€‚å®ƒä» `T` ç±»å‹ä¸­æ‹·è´å‡º `U` ç±»å‹æ‰€éœ€çš„å­—èŠ‚æ•°ï¼Œç„¶åè½¬æ¢æˆ `U`ã€‚ `mem::transmute` å°šæœ‰å¤§å°æ£€æŸ¥ï¼Œèƒ½ä¿è¯ä¸¤ä¸ªæ•°æ®çš„å†…å­˜å¤§å°ä¸€è‡´ï¼Œç°åœ¨è¿™å“¥ä»¬å¹²è„†è¿è¿™ä¸ªä¹Ÿä¸¢äº†ï¼Œåªä¸è¿‡ `U` çš„å°ºå¯¸è‹¥æ˜¯æ¯” `T` å¤§ï¼Œä¼šæ˜¯ä¸€ä¸ªæœªå®šä¹‰è¡Œä¸ºã€‚

å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡è£¸æŒ‡é’ˆè½¬æ¢å’Œ `unions` (todo!)è·å¾—æ‰€æœ‰çš„è¿™äº›åŠŸèƒ½ï¼Œä½†æ˜¯ä½ å°†æ— æ³•è·å¾—ä»»ä½•ç¼–è¯‘æç¤ºæˆ–è€…æ£€æŸ¥ã€‚è£¸æŒ‡é’ˆè½¬æ¢å’Œ `unions` ä¹Ÿä¸æ˜¯é­”æ³•ï¼Œæ— æ³•é€ƒé¿ä¸Šé¢è¯´çš„è§„åˆ™ã€‚

`transmute` è™½ç„¶å±é™©ï¼Œä½†ä½œä¸ºä¸€æœ¬å·¥å…·ä¹¦ï¼ŒçŸ¥è¯†å½“ç„¶è¦å…¨é¢ï¼Œä¸‹é¢åˆ—ä¸¾ä¸¤ä¸ªæœ‰ç”¨çš„ `transmute` åº”ç”¨åœºæ™¯ :)ã€‚

- å°†è£¸æŒ‡é’ˆå˜æˆå‡½æ•°æŒ‡é’ˆï¼š

```rust
fn foo() -> i32 {
    0
}

let pointer = foo as *const ();
let function = unsafe { 
    // å°†è£¸æŒ‡é’ˆè½¬æ¢ä¸ºå‡½æ•°æŒ‡é’ˆ
    std::mem::transmute::<*const (), fn() -> i32>(pointer) 
};
assert_eq!(function(), 0);
```

- å»¶é•¿ç”Ÿå‘½å‘¨æœŸï¼Œæˆ–è€…ç¼©çŸ­ä¸€ä¸ªé™æ€ç”Ÿå‘½å‘¨æœŸå¯¿å‘½ï¼š

```rust
struct R<'a>(&'a i32);

// å°† 'b ç”Ÿå‘½å‘¨æœŸå»¶é•¿è‡³ 'static ç”Ÿå‘½å‘¨æœŸ
unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {
    std::mem::transmute::<R<'b>, R<'static>>(r)
}

// å°† 'static ç”Ÿå‘½å‘¨æœŸç¼©çŸ­è‡³ 'c ç”Ÿå‘½å‘¨æœŸ
unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>) -> &'b mut R<'c> {
    std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)
}
```

ä»¥ä¸Šä¾‹å­éå¸¸å…ˆè¿›ï¼ä½†æ˜¯æ˜¯éå¸¸ä¸å®‰å…¨çš„ Rust è¡Œä¸ºï¼

## è¯¾åç»ƒä¹ 
> Rust By Practiceï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„ä¹ é¢˜è§£ç­”ã€‚
> - [as](https://practice-zh.course.rs/type-conversions/as.html)
>    - [ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/as.md)
> - [From/Into](https://practice-zh.course.rs/type-conversions/from-into.html)
>    - [ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/from-into.md)
> - [å…¶å®ƒè½¬æ¢](https://practice-zh.course.rs/type-conversions/others.html)
>    - [ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/others.md)


================================================
FILE: src/advance/into-types/custom-type.md
================================================
[Binary file]


================================================
FILE: src/advance/into-types/enum-int.md
================================================
# æ•´æ•°è½¬æ¢ä¸ºæšä¸¾

åœ¨ Rust ä¸­ï¼Œä»æšä¸¾åˆ°æ•´æ•°çš„è½¬æ¢å¾ˆå®¹æ˜“ï¼Œä½†æ˜¯åè¿‡æ¥ï¼Œå°±æ²¡é‚£ä¹ˆå®¹æ˜“ï¼Œç”šè‡³éƒ¨åˆ†å®ç°è¿˜æŒºé‚ªæ¶, ä¾‹å¦‚ä½¿ç”¨`transmute`ã€‚

## ä¸€ä¸ªçœŸå®åœºæ™¯çš„éœ€æ±‚

åœ¨å®é™…åœºæ™¯ä¸­ï¼Œä»æ•´æ•°åˆ°æšä¸¾çš„è½¬æ¢æœ‰æ—¶è¿˜æ˜¯éå¸¸éœ€è¦çš„ï¼Œä¾‹å¦‚ä½ æœ‰ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œç„¶åéœ€è¦ä»å¤–é¢ä¼ å…¥ä¸€ä¸ªæ•´æ•°ï¼Œç”¨äºæ§åˆ¶åç»­çš„æµç¨‹èµ°å‘ï¼Œæ­¤æ—¶å°±éœ€è¦ç”¨æ•´æ•°å»åŒ¹é…ç›¸åº”çš„æšä¸¾(ä½ ä¹Ÿå¯ä»¥ç”¨æ•´æ•°åŒ¹é…æ•´æ•°-, -ï¼Œçœ‹çœ‹ä¼šä¸ä¼šè¢«å–·)ã€‚

æ—¢ç„¶æœ‰äº†éœ€æ±‚ï¼Œå‰©ä¸‹çš„å°±æ˜¯çœ‹çœ‹è¯¥å¦‚ä½•å®ç°ï¼Œè¿™ç¯‡æ–‡ç« çš„æ°´è¿œæ¯”ä½ æƒ³è±¡çš„è¦æ·±ï¼Œä¸”çœ‹å…«ä»™è¿‡æµ·å„æ˜¾ç¥é€šã€‚

## C è¯­è¨€çš„å®ç°

å¯¹äº C è¯­è¨€æ¥è¯´ï¼Œä¸‡ç‰©çš†é‚ªæ¶ï¼Œå› æ­¤æˆ‘ä»¬ä¸è®¨è®ºå®‰å…¨ï¼Œåªçœ‹å®ç°ï¼Œä¸å¾—ä¸è¯´å¾ˆç®€æ´ï¼š

```C
#include <stdio.h>

enum atomic_number {
    HYDROGEN = 1,
    HELIUM = 2,
    // ...
    IRON = 26,
};

int main(void)
{
    enum atomic_number element = 26;

    if (element == IRON) {
        printf("Beware of Rust!\n");
    }

    return 0;
}
```

ä½†æ˜¯åœ¨ Rust ä¸­ï¼Œä»¥ä¸‹ä»£ç ï¼š

```rust
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    // å°†æšä¸¾è½¬æ¢æˆæ•´æ•°ï¼Œé¡ºåˆ©é€šè¿‡
    let x = MyEnum::C as i32;

    // å°†æ•´æ•°è½¬æ¢ä¸ºæšä¸¾ï¼Œå¤±è´¥
    match x {
        MyEnum::A => {}
        MyEnum::B => {}
        MyEnum::C => {}
        _ => {}
    }
}
```

å°±ä¼šæŠ¥é”™: `MyEnum::A => {} mismatched types, expected i32, found enum MyEnum`ã€‚

## ä½¿ç”¨ä¸‰æ–¹åº“

é¦–å…ˆå¯ä»¥æƒ³åˆ°çš„è‚¯å®šæ˜¯ä¸‰æ–¹åº“ï¼Œæ¯•ç«Ÿ Rust çš„ç”Ÿæ€ç›®å‰å·²ç»å‘å±•çš„å¾ˆä¸é”™ï¼Œç±»ä¼¼çš„éœ€æ±‚æ€»æ˜¯æœ‰çš„ï¼Œè¿™é‡Œæˆ‘ä»¬å…ˆä½¿ç”¨`num-traits`å’Œ`num-derive`æ¥è¯•è¯•ã€‚

åœ¨`Cargo.toml`ä¸­å¼•å…¥ï¼š

```toml
[dependencies]
num-traits = "0.2.14"
num-derive = "0.3.3"
```

ä»£ç å¦‚ä¸‹:

```rust
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;

#[derive(FromPrimitive)]
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    let x = 2;

    match FromPrimitive::from_i32(x) {
        Some(MyEnum::A) => println!("Got A"),
        Some(MyEnum::B) => println!("Got B"),
        Some(MyEnum::C) => println!("Got C"),
        None            => println!("Couldn't convert {}", x),
    }
}
```

é™¤äº†ä¸Šé¢çš„åº“ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ä¸€ä¸ªè¾ƒæ–°çš„åº“: [`num_enums`](https://github.com/illicitonion/num_enum)ã€‚

## TryFrom + å®

åœ¨ Rust 1.34 åï¼Œå¯ä»¥å®ç°`TryFrom`ç‰¹å¾æ¥åšè½¬æ¢:

```rust
use std::convert::TryFrom;

impl TryFrom<i32> for MyEnum {
    type Error = ();

    fn try_from(v: i32) -> Result<Self, Self::Error> {
        match v {
            x if x == MyEnum::A as i32 => Ok(MyEnum::A),
            x if x == MyEnum::B as i32 => Ok(MyEnum::B),
            x if x == MyEnum::C as i32 => Ok(MyEnum::C),
            _ => Err(()),
        }
    }
}
```

ä»¥ä¸Šä»£ç å®šä¹‰äº†ä»`i32`åˆ°`MyEnum`çš„è½¬æ¢ï¼Œæ¥ç€å°±å¯ä»¥ä½¿ç”¨`TryInto`æ¥å®ç°è½¬æ¢ï¼š

```rust
use std::convert::TryInto;

fn main() {
    let x = MyEnum::C as i32;

    match x.try_into() {
        Ok(MyEnum::A) => println!("a"),
        Ok(MyEnum::B) => println!("b"),
        Ok(MyEnum::C) => println!("c"),
        Err(_) => eprintln!("unknown number"),
    }
}
```

ä½†æ˜¯ä¸Šé¢çš„ä»£ç æœ‰ä¸ªé—®é¢˜ï¼Œä½ éœ€è¦ä¸ºæ¯ä¸ªæšä¸¾æˆå‘˜éƒ½å®ç°ä¸€ä¸ªè½¬æ¢åˆ†æ”¯ï¼Œéå¸¸éº»çƒ¦ã€‚å¥½åœ¨å¯ä»¥ä½¿ç”¨å®æ¥ç®€åŒ–ï¼Œè‡ªåŠ¨æ ¹æ®æšä¸¾çš„å®šä¹‰æ¥å®ç°`TryFrom`ç‰¹å¾:

```rust
#[macro_export]
macro_rules! back_to_enum {
    ($(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }) => {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }

        impl std::convert::TryFrom<i32> for $name {
            type Error = ();

            fn try_from(v: i32) -> Result<Self, Self::Error> {
                match v {
                    $(x if x == $name::$vname as i32 => Ok($name::$vname),)*
                    _ => Err(()),
                }
            }
        }
    }
}

back_to_enum! {
    enum MyEnum {
        A = 1,
        B,
        C,
    }
}
```

## é‚ªæ¶ä¹‹ç‹ std::mem::transmute

**è¿™ä¸ªæ–¹æ³•åŸåˆ™ä¸Šå¹¶ä¸æ¨èï¼Œä½†æ˜¯æœ‰å…¶å­˜åœ¨çš„æ„ä¹‰ï¼Œå¦‚æœè¦ä½¿ç”¨ï¼Œä½ éœ€è¦æ¸…æ™°çš„çŸ¥é“è‡ªå·±ä¸ºä»€ä¹ˆä½¿ç”¨**ã€‚

åœ¨ä¹‹å‰çš„ç±»å‹è½¬æ¢ç« èŠ‚ï¼Œæˆ‘ä»¬æåˆ°è¿‡éå¸¸é‚ªæ¶çš„[`transmute`è½¬æ¢](https://course.rs/advance/into-types/converse.html#å˜å½¢è®°transmutes)ï¼Œå…¶å®ï¼Œå½“ä½ çŸ¥é“æ•°å€¼ä¸€å®šä¸ä¼šè¶…è¿‡æšä¸¾çš„èŒƒå›´æ—¶(ä¾‹å¦‚æšä¸¾æˆå‘˜å¯¹åº” 1ï¼Œ2ï¼Œ3ï¼Œä¼ å…¥çš„æ•´æ•°ä¹Ÿåœ¨è¿™ä¸ªèŒƒå›´å†…)ï¼Œå°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ–¹æ³•å®Œæˆå˜å½¢ã€‚

> æœ€å¥½ä½¿ç”¨#[repr(..)]æ¥æ§åˆ¶åº•å±‚ç±»å‹çš„å¤§å°ï¼Œå…å¾—æœ¬æ¥éœ€è¦ i32ï¼Œç»“æœä¼ å…¥ i64ï¼Œæœ€ç»ˆå†…å­˜æ— æ³•å¯¹é½ï¼Œäº§ç”Ÿå¥‡æ€ªçš„ç»“æœ

```rust
#[repr(i32)]
enum MyEnum {
    A = 1, B, C
}

fn main() {
    let x = MyEnum::C;
    let y = x as i32;
    let z: MyEnum = unsafe { std::mem::transmute(y) };

    // match the enum that came from an int
    match z {
        MyEnum::A => { println!("Found A"); }
        MyEnum::B => { println!("Found B"); }
        MyEnum::C => { println!("Found C"); }
    }
}
```

æ—¢ç„¶æ˜¯é‚ªæ¶ä¹‹ç‹ï¼Œå½“ç„¶å¾—æœ‰çœŸæœ¬äº‹ï¼Œæ— éœ€æ ‡å‡†åº“ã€ä¹Ÿæ— éœ€ unstable çš„ Rust ç‰ˆæœ¬ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†è½¬æ¢ï¼awesome!??

## æ€»ç»“

æœ¬æ–‡åˆ—ä¸¾äº†å¸¸ç”¨(å…¶å®å·®ä¸å¤šä¹Ÿæ˜¯å…¨éƒ¨äº†ï¼Œè¿˜æœ‰ä¸€ä¸ª unstable ç‰¹æ€§æ²¡æåˆ°)çš„ä»æ•´æ•°è½¬æ¢ä¸ºæšä¸¾çš„æ–¹å¼ï¼Œæ¨èåº¦æŒ‰ç…§å‡ºç°çš„å…ˆåé¡ºåºé€’å‡ã€‚

ä½†æ˜¯æ¨èåº¦æœ€ä½ï¼Œä¸ä»£è¡¨å®ƒå°±æ²¡æœ‰å‡ºåœºçš„æœºä¼šï¼Œåªè¦ä½¿ç”¨è¾¹ç•Œæ¸…æ™°ï¼Œä¸€æ ·å¯ä»¥å¤§æ”¾å…‰å½©ï¼Œä¾‹å¦‚æœ€åçš„`transmute`å‡½æ•°.




================================================
FILE: src/advance/into-types/intro.md
================================================
# æ·±å…¥ç±»å‹

Rust æ˜¯å¼ºç±»å‹è¯­è¨€ï¼ŒåŒæ—¶ä¹Ÿæ˜¯å¼ºå®‰å…¨è¯­è¨€ï¼Œè¿™äº›ç‰¹æ€§å¯¼è‡´äº† Rust çš„ç±»å‹æ³¨å®šæ¯”ä¸€èˆ¬è¯­è¨€è¦æ›´æ·±å…¥ä¹Ÿæ›´å›°éš¾ã€‚

æœ¬ç« å°†æ·±å…¥è®²è§£ä¸€äº›è¿›é˜¶çš„ Rust ç±»å‹ä»¥åŠç±»å‹è½¬æ¢ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢ã€‚




================================================
FILE: src/advance/into-types/sized.md
================================================
[Binary file]


================================================
FILE: src/advance/lifetime/advance.md
================================================
[Binary file]


================================================
FILE: src/advance/lifetime/intro.md
================================================
# ç”Ÿå‘½å‘¨æœŸ

ä½•ä¸ºé«˜é˜¶ï¼Ÿä¸€ä¸ªå­—ï¼šéš¾ï¼ŒäºŒä¸ªå­—ï¼šå¾ˆéš¾ï¼Œä¸ƒä¸ªå­—ï¼šå…¶å®ä¹Ÿæ²¡é‚£ä¹ˆéš¾ã€‚è‡³äºåˆ°åº•éš¾ä¸éš¾ï¼Œè¿˜æ˜¯äº¤ç»™å„ä½çœ‹å®˜è¯„åˆ¤å§ :D 

å¤§å®¶éƒ½çŸ¥é“ï¼Œç”Ÿå‘½å‘¨æœŸåœ¨ Rust ä¸­æ˜¯æœ€éš¾çš„éƒ¨åˆ†ä¹‹ä¸€ï¼Œå› æ­¤ç›¸å…³å†…å®¹è¢«åˆ†æˆäº†ä¸¤ä¸ªç« èŠ‚ï¼šåŸºç¡€å’Œè¿›é˜¶ï¼Œå…¶ä¸­åŸºç¡€éƒ¨åˆ†å·²ç»åœ¨ä¹‹å‰å­¦ä¹ è¿‡ï¼Œä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹çœŸæ­£çš„`éš¾`å­—æ€ä¹ˆå†™ã€‚





================================================
FILE: src/advance/lifetime/misconceptions.md
================================================
# ä¸€äº›å…³äºç”Ÿå‘½å‘¨æœŸçš„è¯¯è§£

https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md


================================================
FILE: src/advance/lifetime/static.md
================================================
# &'static å’Œ T: 'static

Rust çš„éš¾ç‚¹ä¹‹ä¸€å°±åœ¨äºå®ƒæœ‰ä¸å°‘å®¹æ˜“æ··æ·†çš„æ¦‚å¿µï¼Œä¾‹å¦‚ `&str` ã€`str` ä¸ `String`ï¼Œ å†æ¯”å¦‚æœ¬æ–‡æ ‡é¢˜é‚£ä¸¤ä½ã€‚ä¸è¿‡ä¸å­—ç¬¦ä¸²ä¹Ÿæœ‰ä¸åŒï¼Œè¿™ä¸¤ä½å¯¹äºæ™®é€šç”¨æˆ·æ¥è¯´å¾€å¾€æ˜¯æ— éœ€è¿›è¡ŒåŒºåˆ†çš„ï¼Œä½†æ˜¯å½“å¤§å®¶æƒ³è¦æ·±å…¥å­¦ä¹ æˆ–ä½¿ç”¨ Rust æ—¶ï¼Œå®ƒä»¬å°±ä¼šæˆä¸ºæˆåŠŸè·¯ä¸Šçš„æ‹¦è·¯è™äº†ã€‚

ä¸ç”Ÿå‘½å‘¨æœŸçš„å…¶å®ƒç« èŠ‚ä¸åŒï¼Œæœ¬æ–‡çŸ­å°ç²¾æ‚ï¼Œé˜…è¯»è¿‡ç¨‹å¯è°“ç›¸å½“è½»æ¾æ„‰å¿«ï¼Œè¯ä¸å¤šè¯´ï¼Œlet's goã€‚

`'static` åœ¨ Rust ä¸­æ˜¯ç›¸å½“å¸¸è§çš„ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²å­—é¢å€¼å°±å…·æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸ:

```rust
fn main() {
  let mark_twain: &str = "Samuel Clemens";
  print_author(mark_twain);
}
fn print_author(author: &'static str) {
  println!("{}", author);
}
```

é™¤æ­¤ä¹‹å¤–ï¼Œç‰¹å¾å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯ `'static`ï¼Œä¾‹å¦‚[è¿™é‡Œ](https://course.rs/compiler/fight-with-compiler/lifetime/closure-with-static.html#ç‰¹å¾å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ)æ‰€æåˆ°çš„ã€‚

é™¤äº† `&'static` çš„ç”¨æ³•å¤–ï¼Œæˆ‘ä»¬åœ¨å¦å¤–ä¸€ç§åœºæ™¯ä¸­ä¹Ÿå¯ä»¥è§åˆ° `'static` çš„ä½¿ç”¨:

```rust
use std::fmt::Display;
fn main() {
    let mark_twain = "Samuel Clemens";
    print(&mark_twain);
}

fn print<T: Display + 'static>(message: &T) {
    println!("{}", message);
}
```

åœ¨è¿™é‡Œï¼Œå¾ˆæ˜æ˜¾ `'static` æ˜¯ä½œä¸ºç”Ÿå‘½å‘¨æœŸçº¦æŸæ¥ä½¿ç”¨äº†ã€‚ **é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œ `&'static` å’Œ `T: 'static` çš„ç”¨æ³•åˆ°åº•æœ‰ä½•åŒºåˆ«ï¼Ÿ**

## `&'static`

`&'static` å¯¹äºç”Ÿå‘½å‘¨æœŸæœ‰ç€éå¸¸å¼ºçš„è¦æ±‚ï¼šä¸€ä¸ªå¼•ç”¨å¿…é¡»è¦æ´»å¾—è·Ÿå‰©ä¸‹çš„ç¨‹åºä¸€æ ·ä¹…ï¼Œæ‰èƒ½è¢«æ ‡æ³¨ä¸º `&'static`ã€‚

å¯¹äºå­—ç¬¦ä¸²å­—é¢é‡æ¥è¯´ï¼Œå®ƒç›´æ¥è¢«æ‰“åŒ…åˆ°äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œæ°¸è¿œä¸ä¼šè¢« `drop`ï¼Œå› æ­¤å®ƒèƒ½è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œè‡ªç„¶å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`ã€‚

ä½†æ˜¯ï¼Œ**`&'static` ç”Ÿå‘½å‘¨æœŸé’ˆå¯¹çš„ä»…ä»…æ˜¯å¼•ç”¨ï¼Œè€Œä¸æ˜¯æŒæœ‰è¯¥å¼•ç”¨çš„å˜é‡ï¼Œå¯¹äºå˜é‡æ¥è¯´ï¼Œè¿˜æ˜¯è¦éµå¾ªç›¸åº”çš„ä½œç”¨åŸŸè§„åˆ™** :

```rust
use std::{slice::from_raw_parts, str::from_utf8_unchecked};

fn get_memory_location() -> (usize, usize) {
  // â€œHello Worldâ€ æ˜¯å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå› æ­¤å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`.
  // ä½†æŒæœ‰å®ƒçš„å˜é‡ `string` çš„ç”Ÿå‘½å‘¨æœŸå°±ä¸ä¸€æ ·äº†ï¼Œå®ƒå®Œå…¨å–å†³äºå˜é‡ä½œç”¨åŸŸï¼Œå¯¹äºè¯¥ä¾‹å­æ¥è¯´ï¼Œä¹Ÿå°±æ˜¯å½“å‰çš„å‡½æ•°èŒƒå›´
  let string = "Hello World!";
  let pointer = string.as_ptr() as usize;
  let length = string.len();
  (pointer, length)
  // `string` åœ¨è¿™é‡Œè¢« drop é‡Šæ”¾
  // è™½ç„¶å˜é‡è¢«é‡Šæ”¾ï¼Œæ— æ³•å†è¢«è®¿é—®ï¼Œä½†æ˜¯æ•°æ®ä¾ç„¶è¿˜ä¼šç»§ç»­å­˜æ´»
}

fn get_str_at_location(pointer: usize, length: usize) -> &'static str {
  // ä½¿ç”¨è£¸æŒ‡é’ˆéœ€è¦ `unsafe{}` è¯­å¥å—
  unsafe { from_utf8_unchecked(from_raw_parts(pointer as *const u8, length)) }
}

fn main() {
  let (pointer, length) = get_memory_location();
  let message = get_str_at_location(pointer, length);
  println!(
    "The {} bytes at 0x{:X} stored: {}",
    length, pointer, message
  );
  // å¦‚æœå¤§å®¶æƒ³çŸ¥é“ä¸ºä½•å¤„ç†è£¸æŒ‡é’ˆéœ€è¦ `unsafe`ï¼Œå¯ä»¥è¯•ç€åæ³¨é‡Šä»¥ä¸‹ä»£ç 
  // let message = get_str_at_location(1000, 10);
}
```

ä¸Šé¢ä»£ç æœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„ï¼š

- `&'static` çš„å¼•ç”¨ç¡®å®å¯ä»¥å’Œç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› ä¸ºæˆ‘ä»¬é€šè¿‡ `get_str_at_location` å‡½æ•°ç›´æ¥å–åˆ°äº†å¯¹åº”çš„å­—ç¬¦ä¸²
- æŒæœ‰ `&'static` å¼•ç”¨çš„å˜é‡ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸå—åˆ°ä½œç”¨åŸŸçš„é™åˆ¶ï¼Œå¤§å®¶åŠ¡å¿…ä¸è¦ææ··äº†

## `T: 'static`

ç›¸æ¯”èµ·æ¥ï¼Œè¿™ç§å½¢å¼çš„çº¦æŸå°±æœ‰äº›å¤æ‚äº†ã€‚

é¦–å…ˆï¼Œåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹ï¼Œ`T: 'static` ä¸ `&'static` æœ‰ç›¸åŒçš„çº¦æŸï¼š`T` å¿…é¡»æ´»å¾—å’Œç¨‹åºä¸€æ ·ä¹…ã€‚

```rust
use std::fmt::Debug;

fn print_it<T: Debug + 'static>( input: T) {
    println!( "'static value passed in is: {:?}", input );
}

fn print_it1( input: impl Debug + 'static ) {
    println!( "'static value passed in is: {:?}", input );
}



fn main() {
    let i = 5;

    print_it(&i);
    print_it1(&i);
}
```

ä»¥ä¸Šä»£ç ä¼šæŠ¥é”™ï¼ŒåŸå› å¾ˆç®€å•: `&i` çš„ç”Ÿå‘½å‘¨æœŸæ— æ³•æ»¡è¶³ `'static` çš„çº¦æŸï¼Œå¦‚æœå¤§å®¶å°† `i` ä¿®æ”¹ä¸ºå¸¸é‡ï¼Œé‚£è‡ªç„¶ä¸€åˆ‡ OKã€‚

è§è¯å¥‡è¿¹çš„æ—¶å€™ï¼Œè¯·ä¸è¦çœ¨çœ¼ï¼Œç°åœ¨æˆ‘ä»¬æ¥ç¨å¾®ä¿®æ”¹ä¸‹ `print_it` å‡½æ•°:
```rust
use std::fmt::Debug;

fn print_it<T: Debug + 'static>( input: &T) {
    println!( "'static value passed in is: {:?}", input );
}

fn main() {
    let i = 5;

    print_it(&i);
}
```

è¿™æ®µä»£ç ç«Ÿç„¶ä¸æŠ¥é”™äº†ï¼åŸå› åœ¨äºæˆ‘ä»¬çº¦æŸçš„æ˜¯ `T`ï¼Œä½†æ˜¯ä½¿ç”¨çš„å´æ˜¯å®ƒçš„å¼•ç”¨ `&T`ï¼Œæ¢è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰ç›´æ¥ä½¿ç”¨ `T`ï¼Œå› æ­¤ç¼–è¯‘å™¨å°±æ²¡æœ‰å»æ£€æŸ¥ `T` çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼å®ƒåªè¦ç¡®ä¿ `&T` çš„ç”Ÿå‘½å‘¨æœŸç¬¦åˆè§„åˆ™å³å¯ï¼Œåœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œå®ƒè‡ªç„¶æ˜¯ç¬¦åˆçš„ã€‚

å†æ¥çœ‹ä¸€ä¸ªä¾‹å­:

```rust
use std::fmt::Display;

fn main() {
  let r1;
  let r2;
  {
    static STATIC_EXAMPLE: i32 = 42;
    r1 = &STATIC_EXAMPLE;
    let x = "&'static str";
    r2 = x;
    // r1 å’Œ r2 æŒæœ‰çš„æ•°æ®éƒ½æ˜¯ 'static çš„ï¼Œå› æ­¤åœ¨èŠ±æ‹¬å·ç»“æŸåï¼Œå¹¶ä¸ä¼šè¢«é‡Šæ”¾
  }

  println!("&'static i32: {}", r1); // -> 42
  println!("&'static str: {}", r2); // -> &'static str

  let r3: &str;

  {
    let s1 = "String".to_string();

    // s1 è™½ç„¶æ²¡æœ‰ 'static ç”Ÿå‘½å‘¨æœŸï¼Œä½†æ˜¯å®ƒä¾ç„¶å¯ä»¥æ»¡è¶³ T: 'static çš„çº¦æŸ
    // å……åˆ†è¯´æ˜è¿™ä¸ªçº¦æŸæ˜¯å¤šä¹ˆçš„å¼±ã€‚ã€‚
    static_bound(&s1);

    // s1 æ˜¯ String ç±»å‹ï¼Œæ²¡æœ‰ 'static çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤ä¸‹é¢ä»£ç ä¼šæŠ¥é”™
    r3 = &s1;

    // s1 åœ¨è¿™é‡Œè¢« drop
  }
  println!("{}", r3);
}

fn static_bound<T: Display + 'static>(t: &T) {
  println!("{}", t);
}
```

## static åˆ°åº•é’ˆå¯¹è°ï¼Ÿ
å¤§å®¶æœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œåˆ°åº•æ˜¯ `&'static` è¿™ä¸ªå¼•ç”¨è¿˜æ˜¯è¯¥å¼•ç”¨æŒ‡å‘çš„æ•°æ®æ´»å¾—è·Ÿç¨‹åºä¸€æ ·ä¹…å‘¢ï¼Ÿ

**ç­”æ¡ˆæ˜¯å¼•ç”¨æŒ‡å‘çš„æ•°æ®**ï¼Œè€Œå¼•ç”¨æœ¬èº«æ˜¯è¦éµå¾ªå…¶ä½œç”¨åŸŸèŒƒå›´çš„ï¼Œæˆ‘ä»¬æ¥ç®€å•éªŒè¯ä¸‹ï¼š
```rust
fn main() {
    {
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // å½“ `static_string` è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œè¯¥å¼•ç”¨ä¸èƒ½å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯æ•°æ®ä¾ç„¶ä¼šå­˜åœ¨äº binary æ‰€å ç”¨çš„å†…å­˜ä¸­
    }

    println!("static_string reference remains alive: {}", static_string);
}
```

ä»¥ä¸Šä»£ç ä¸å‡ºæ‰€æ–™ä¼šæŠ¥é”™ï¼ŒåŸå› åœ¨äºè™½ç„¶å­—ç¬¦ä¸²å­—é¢é‡ "I'm in read-only memory" çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`ï¼Œä½†æ˜¯æŒæœ‰å®ƒçš„å¼•ç”¨å¹¶ä¸æ˜¯ï¼Œå®ƒçš„ä½œç”¨åŸŸåœ¨å†…éƒ¨èŠ±æ‹¬å· `}` å¤„å°±ç»“æŸäº†ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/lifetime/static.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„ä¹ é¢˜è§£ç­”ã€‚ï¼ˆæœ¬èŠ‚æš‚æ— ä¹ é¢˜è§£ç­”ï¼‰


## æ€»ç»“

æ€»ä¹‹ï¼Œ `&'static` å’Œ `T: 'static` å¤§ä½“ä¸Šç›¸ä¼¼ï¼Œç›¸æ¯”èµ·æ¥ï¼Œåè€…çš„ä½¿ç”¨å½¢å¼ä¼šæ›´åŠ å¤æ‚ä¸€äº›ã€‚

è‡³æ­¤ï¼Œç›¸ä¿¡å¤§å®¶å¯¹äº `'static` å’Œ `T: 'static` ä¹Ÿæœ‰äº†æ¸…æ™°çš„ç†è§£ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å¦‚ä½•ä½¿ç”¨å®ƒä»¬å‘¢ï¼Ÿ

ä½œä¸ºç»éªŒä¹‹è°ˆï¼Œå¯ä»¥è¿™ä¹ˆæ¥:

- å¦‚æœä½ éœ€è¦æ·»åŠ  `&'static` æ¥è®©ä»£ç å·¥ä½œï¼Œé‚£å¾ˆå¯èƒ½æ˜¯è®¾è®¡ä¸Šå‡ºé—®é¢˜äº†
- å¦‚æœä½ å¸Œæœ›æ»¡è¶³å’Œå–æ‚¦ç¼–è¯‘å™¨ï¼Œé‚£å°±ä½¿ç”¨ `T: 'static`ï¼Œå¾ˆå¤šæ—¶å€™å®ƒéƒ½èƒ½è§£å†³é—®é¢˜

> ä¸€ä¸ªå°çŸ¥è¯†ï¼Œåœ¨ Rust æ ‡å‡†åº“ä¸­ï¼Œæœ‰ 48 å¤„ç”¨åˆ°äº† &'static ï¼Œ112 å¤„ç”¨åˆ°äº† `T: 'static` ï¼Œçœ‹æ¥å–æ‚¦ç¼–è¯‘å™¨ä¸ä»…ä»…æ˜¯èœé¸Ÿéœ€è¦çš„ï¼Œé«˜æ‰‹ä¹Ÿç»å¸¸ç”¨åˆ° :)




================================================
FILE: src/advance/smart-pointer/box.md
================================================
# `Box<T>` å †å¯¹è±¡åˆ†é…

å…³äºä½œè€…å¸…ä¸å¸…ï¼Œä¼°è®¡äº‰è®®è¿˜æŒºå¤šçš„ï¼Œä½†æ˜¯å¦‚æœè¯´ `Box<T>` æ˜¯ä¸æ˜¯ Rust ä¸­æœ€å¸¸è§çš„æ™ºèƒ½æŒ‡é’ˆï¼Œé‚£ä¼°è®¡æ²¡æœ‰ä»»ä½•äº‰è®®ã€‚å› ä¸º `Box<T>` å…è®¸ä½ å°†ä¸€ä¸ªå€¼åˆ†é…åˆ°å †ä¸Šï¼Œç„¶ååœ¨æ ˆä¸Šä¿ç•™ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘å †ä¸Šçš„æ•°æ®ã€‚

ä¹‹å‰æˆ‘ä»¬åœ¨[æ‰€æœ‰æƒç« èŠ‚](https://course.rs/basic/ownership/ownership.html#æ ˆstackä¸å †heap)ç®€å•è®²è¿‡å †æ ˆçš„æ¦‚å¿µï¼Œè¿™é‡Œå†è¡¥å……ä¸€äº›ã€‚

## Rust ä¸­çš„å †æ ˆ

é«˜çº§è¯­è¨€ Python/Java ç­‰å¾€å¾€ä¼šå¼±åŒ–å †æ ˆçš„æ¦‚å¿µï¼Œä½†æ˜¯è¦ç”¨å¥½ C/C++/Rustï¼Œå°±å¿…é¡»å¯¹å †æ ˆæœ‰æ·±å…¥çš„äº†è§£ï¼ŒåŸå› æ˜¯ä¸¤è€…çš„å†…å­˜ç®¡ç†æ–¹å¼ä¸åŒï¼šå‰è€…æœ‰ GC åƒåœ¾å›æ”¶æœºåˆ¶ï¼Œå› æ­¤æ— éœ€ä½ å»å…³å¿ƒå†…å­˜çš„ç»†èŠ‚ã€‚

æ ˆå†…å­˜ä»é«˜ä½åœ°å€å‘ä¸‹å¢é•¿ï¼Œä¸”æ ˆå†…å­˜æ˜¯è¿ç»­åˆ†é…çš„ï¼Œä¸€èˆ¬æ¥è¯´**æ“ä½œç³»ç»Ÿå¯¹æ ˆå†…å­˜çš„å¤§å°éƒ½æœ‰é™åˆ¶**ï¼Œå› æ­¤ C è¯­è¨€ä¸­æ— æ³•åˆ›å»ºä»»æ„é•¿åº¦çš„æ•°ç»„ã€‚åœ¨ Rust ä¸­ï¼Œ`main` çº¿ç¨‹çš„[æ ˆå¤§å°æ˜¯ `8MB`](https://course.rs/compiler/pitfalls/stack-overflow.html)ï¼Œæ™®é€šçº¿ç¨‹æ˜¯ `2MB`ï¼Œåœ¨å‡½æ•°è°ƒç”¨æ—¶ä¼šåœ¨å…¶ä¸­åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ ˆç©ºé—´ï¼Œè°ƒç”¨ç»“æŸå Rust ä¼šè®©è¿™ä¸ªæ ˆç©ºé—´é‡Œçš„å¯¹è±¡è‡ªåŠ¨è¿›å…¥ `Drop` æµç¨‹ï¼Œæœ€åæ ˆé¡¶æŒ‡é’ˆè‡ªåŠ¨ç§»åŠ¨åˆ°ä¸Šä¸€ä¸ªè°ƒç”¨æ ˆé¡¶ï¼Œæ— éœ€ç¨‹åºå‘˜æ‰‹åŠ¨å¹²é¢„ï¼Œå› è€Œæ ˆå†…å­˜ç”³è¯·å’Œé‡Šæ”¾æ˜¯éå¸¸é«˜æ•ˆçš„ã€‚

ä¸æ ˆç›¸åï¼Œå †ä¸Šå†…å­˜åˆ™æ˜¯ä»ä½ä½åœ°å€å‘ä¸Šå¢é•¿ï¼Œ**å †å†…å­˜é€šå¸¸åªå—ç‰©ç†å†…å­˜é™åˆ¶**ï¼Œè€Œä¸”é€šå¸¸æ˜¯ä¸è¿ç»­çš„ï¼Œå› æ­¤ä»æ€§èƒ½çš„è§’åº¦çœ‹ï¼Œæ ˆå¾€å¾€æ¯”å †æ›´é«˜ã€‚

ç›¸æ¯”å…¶å®ƒè¯­è¨€ï¼ŒRust å †ä¸Šå¯¹è±¡è¿˜æœ‰ä¸€ä¸ªç‰¹æ®Šä¹‹å¤„ï¼Œå®ƒä»¬éƒ½æ‹¥æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå› æ­¤å—æ‰€æœ‰æƒè§„åˆ™çš„é™åˆ¶ï¼šå½“èµ‹å€¼æ—¶ï¼Œå‘ç”Ÿçš„æ˜¯æ‰€æœ‰æƒçš„è½¬ç§»ï¼ˆåªéœ€æµ…æ‹·è´æ ˆä¸Šçš„å¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆå³å¯ï¼‰ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç ï¼š

```rust
fn main() {
    let b = foo("world");
    println!("{}", b);
}

fn foo(x: &str) -> String {
    let a = "Hello, ".to_string() + x;
    a
}
```

åœ¨ `foo` å‡½æ•°ä¸­ï¼Œ`a` æ˜¯ `String` ç±»å‹ï¼Œå®ƒå…¶å®æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“ï¼Œè¯¥æ™ºèƒ½æŒ‡é’ˆå­˜å‚¨åœ¨å‡½æ•°æ ˆä¸­ï¼ŒæŒ‡å‘å †ä¸Šçš„å­—ç¬¦ä¸²æ•°æ®ã€‚å½“è¢«ä» `foo` å‡½æ•°è½¬ç§»ç»™ `main` ä¸­çš„ `b` å˜é‡æ—¶ï¼Œæ ˆä¸Šçš„æ™ºèƒ½æŒ‡é’ˆè¢«å¤åˆ¶ä¸€ä»½èµ‹äºˆç»™ `b`ï¼Œè€Œåº•å±‚æ•°æ®æ— éœ€å‘ç”Ÿæ”¹å˜ï¼Œè¿™æ ·å°±å®Œæˆäº†æ‰€æœ‰æƒä» `foo` å‡½æ•°å†…éƒ¨åˆ° `b` çš„è½¬ç§»ã€‚

#### å †æ ˆçš„æ€§èƒ½

å¾ˆå¤šäººå¯èƒ½ä¼šè§‰å¾—æ ˆçš„æ€§èƒ½è‚¯å®šæ¯”å †é«˜ï¼Œå…¶å®æœªå¿…ã€‚ ç”±äºæˆ‘ä»¬åœ¨åé¢çš„æ€§èƒ½ä¸“é¢˜ä¼šä¸“é—¨è®²è§£å †æ ˆçš„æ€§èƒ½é—®é¢˜ï¼Œå› æ­¤è¿™é‡Œå°±å¤§æ¦‚ç»™å‡ºç»“è®ºï¼š

- å°å‹æ•°æ®ï¼Œåœ¨æ ˆä¸Šçš„åˆ†é…æ€§èƒ½å’Œè¯»å–æ€§èƒ½éƒ½è¦æ¯”å †ä¸Šé«˜
- ä¸­å‹æ•°æ®ï¼Œæ ˆä¸Šåˆ†é…æ€§èƒ½é«˜ï¼Œä½†æ˜¯è¯»å–æ€§èƒ½å’Œå †ä¸Šå¹¶æ— åŒºåˆ«ï¼Œå› ä¸ºæ— æ³•åˆ©ç”¨å¯„å­˜å™¨æˆ– CPU é«˜é€Ÿç¼“å­˜ï¼Œæœ€ç»ˆè¿˜æ˜¯è¦ç»è¿‡ä¸€æ¬¡å†…å­˜å¯»å€
- å¤§å‹æ•°æ®ï¼Œåªå»ºè®®åœ¨å †ä¸Šåˆ†é…å’Œä½¿ç”¨

æ€»ä¹‹ï¼Œæ ˆçš„åˆ†é…é€Ÿåº¦è‚¯å®šæ¯”å †ä¸Šå¿«ï¼Œä½†æ˜¯è¯»å–é€Ÿåº¦å¾€å¾€å–å†³äºä½ çš„æ•°æ®èƒ½ä¸èƒ½æ”¾å…¥å¯„å­˜å™¨æˆ– CPU é«˜é€Ÿç¼“å­˜ã€‚ å› æ­¤ä¸è¦ä»…ä»…å› ä¸ºå †ä¸Šæ€§èƒ½ä¸å¦‚æ ˆè¿™ä¸ªå°è±¡ï¼Œå°±æ€»æ˜¯ä¼˜å…ˆé€‰æ‹©æ ˆï¼Œå¯¼è‡´ä»£ç æ›´å¤æ‚çš„å®ç°ã€‚

## Box çš„ä½¿ç”¨åœºæ™¯

ç”±äº `Box` æ˜¯ç®€å•çš„å°è£…ï¼Œé™¤äº†å°†å€¼å­˜å‚¨åœ¨å †ä¸Šå¤–ï¼Œå¹¶æ²¡æœ‰å…¶å®ƒæ€§èƒ½ä¸Šçš„æŸè€—ã€‚è€Œæ€§èƒ½å’ŒåŠŸèƒ½å¾€å¾€æ˜¯é±¼å’Œç†ŠæŒï¼Œå› æ­¤ `Box` ç›¸æ¯”å…¶å®ƒæ™ºèƒ½æŒ‡é’ˆï¼ŒåŠŸèƒ½è¾ƒä¸ºå•ä¸€ï¼Œå¯ä»¥åœ¨ä»¥ä¸‹åœºæ™¯ä¸­ä½¿ç”¨å®ƒï¼š

- ç‰¹æ„çš„å°†æ•°æ®åˆ†é…åœ¨å †ä¸Š
- æ•°æ®è¾ƒå¤§æ—¶ï¼Œåˆä¸æƒ³åœ¨è½¬ç§»æ‰€æœ‰æƒæ—¶è¿›è¡Œæ•°æ®æ‹·è´
- ç±»å‹çš„å¤§å°åœ¨ç¼–è¯‘æœŸæ— æ³•ç¡®å®šï¼Œä½†æ˜¯æˆ‘ä»¬åˆéœ€è¦å›ºå®šå¤§å°çš„ç±»å‹æ—¶
- ç‰¹å¾å¯¹è±¡ï¼Œç”¨äºè¯´æ˜å¯¹è±¡å®ç°äº†ä¸€ä¸ªç‰¹å¾ï¼Œè€Œä¸æ˜¯æŸä¸ªç‰¹å®šçš„ç±»å‹

ä»¥ä¸Šåœºæ™¯ï¼Œæˆ‘ä»¬åœ¨æœ¬ç« å°†ä¸€ä¸€è®²è§£ï¼Œåé¢è½¦é€Ÿè¾ƒå¿«ï¼Œè¯·ç³»å¥½å®‰å…¨å¸¦ã€‚

#### ä½¿ç”¨ `Box<T>` å°†æ•°æ®å­˜å‚¨åœ¨å †ä¸Š

å¦‚æœä¸€ä¸ªå˜é‡æ‹¥æœ‰ä¸€ä¸ªæ•°å€¼ `let a = 3`ï¼Œé‚£å˜é‡ `a` å¿…ç„¶æ˜¯å­˜å‚¨åœ¨æ ˆä¸Šçš„ï¼Œé‚£å¦‚æœæˆ‘ä»¬æƒ³è¦ `a` çš„å€¼å­˜å‚¨åœ¨å †ä¸Šå°±éœ€è¦ä½¿ç”¨ `Box<T>`ï¼š

```rust
fn main() {
    let a = Box::new(3);
    println!("a = {}", a); // a = 3

    // ä¸‹é¢ä¸€è¡Œä»£ç å°†æŠ¥é”™
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```

è¿™æ ·å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘äº†å­˜å‚¨åœ¨å †ä¸Šçš„ `3`ï¼Œå¹¶ä¸” `a` æŒæœ‰äº†è¯¥æŒ‡é’ˆã€‚åœ¨æœ¬ç« çš„å¼•è¨€ä¸­ï¼Œæˆ‘ä»¬æåˆ°äº†æ™ºèƒ½æŒ‡é’ˆå¾€å¾€éƒ½å®ç°äº† `Deref` å’Œ `Drop` ç‰¹å¾ï¼Œå› æ­¤ï¼š

- `println!` å¯ä»¥æ­£å¸¸æ‰“å°å‡º `a` çš„å€¼ï¼Œæ˜¯å› ä¸ºå®ƒéšå¼åœ°è°ƒç”¨äº† `Deref` å¯¹æ™ºèƒ½æŒ‡é’ˆ `a` è¿›è¡Œäº†è§£å¼•ç”¨
- æœ€åä¸€è¡Œä»£ç  ` let b = a + 1` æŠ¥é”™ï¼Œæ˜¯å› ä¸ºåœ¨è¡¨è¾¾å¼ä¸­ï¼Œæˆ‘ä»¬æ— æ³•è‡ªåŠ¨éšå¼åœ°æ‰§è¡Œ `Deref` è§£å¼•ç”¨æ“ä½œï¼Œä½ éœ€è¦ä½¿ç”¨ `*` æ“ä½œç¬¦ `let b = *a + 1`ï¼Œæ¥æ˜¾å¼çš„è¿›è¡Œè§£å¼•ç”¨
- `a` æŒæœ‰çš„æ™ºèƒ½æŒ‡é’ˆå°†åœ¨ä½œç”¨åŸŸç»“æŸï¼ˆ`main` å‡½æ•°ç»“æŸï¼‰æ—¶ï¼Œè¢«é‡Šæ”¾æ‰ï¼Œè¿™æ˜¯å› ä¸º `Box<T>` å®ç°äº† `Drop` ç‰¹å¾

ä»¥ä¸Šçš„ä¾‹å­åœ¨å®é™…ä»£ç ä¸­å…¶å®å¾ˆå°‘ä¼šå­˜åœ¨ï¼Œå› ä¸ºå°†ä¸€ä¸ªç®€å•çš„å€¼åˆ†é…åˆ°å †ä¸Šå¹¶æ²¡æœ‰å¤ªå¤§çš„æ„ä¹‰ã€‚å°†å…¶åˆ†é…åœ¨æ ˆä¸Šï¼Œç”±äºå¯„å­˜å™¨ã€CPU ç¼“å­˜çš„åŸå› ï¼Œå®ƒçš„æ€§èƒ½å°†æ›´å¥½ï¼Œè€Œä¸”ä»£ç å¯è¯»æ€§ä¹Ÿæ›´å¥½ã€‚

#### é¿å…æ ˆä¸Šæ•°æ®çš„æ‹·è´

å½“æ ˆä¸Šæ•°æ®è½¬ç§»æ‰€æœ‰æƒæ—¶ï¼Œå®é™…ä¸Šæ˜¯æŠŠæ•°æ®æ‹·è´äº†ä¸€ä»½ï¼Œæœ€ç»ˆæ–°æ—§å˜é‡å„è‡ªæ‹¥æœ‰ä¸åŒçš„æ•°æ®ï¼Œå› æ­¤æ‰€æœ‰æƒå¹¶æœªè½¬ç§»ã€‚

è€Œå †ä¸Šåˆ™ä¸ç„¶ï¼Œåº•å±‚æ•°æ®å¹¶ä¸ä¼šè¢«æ‹·è´ï¼Œè½¬ç§»æ‰€æœ‰æƒä»…ä»…æ˜¯å¤åˆ¶ä¸€ä»½æ ˆä¸­çš„æŒ‡é’ˆï¼Œå†å°†æ–°çš„æŒ‡é’ˆèµ‹äºˆæ–°çš„å˜é‡ï¼Œç„¶åè®©æ‹¥æœ‰æ—§æŒ‡é’ˆçš„å˜é‡å¤±æ•ˆï¼Œæœ€ç»ˆå®Œæˆäº†æ‰€æœ‰æƒçš„è½¬ç§»ï¼š

```rust
fn main() {
    // åœ¨æ ˆä¸Šåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º1000çš„æ•°ç»„
    let arr = [0;1000];
    // å°†arræ‰€æœ‰æƒè½¬ç§»arr1ï¼Œç”±äº `arr` åˆ†é…åœ¨æ ˆä¸Šï¼Œå› æ­¤è¿™é‡Œå®é™…ä¸Šæ˜¯ç›´æ¥é‡æ–°æ·±æ‹·è´äº†ä¸€ä»½æ•°æ®
    let arr1 = arr;

    // arr å’Œ arr1 éƒ½æ‹¥æœ‰å„è‡ªçš„æ ˆä¸Šæ•°ç»„ï¼Œå› æ­¤ä¸ä¼šæŠ¥é”™
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // åœ¨å †ä¸Šåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º1000çš„æ•°ç»„ï¼Œç„¶åä½¿ç”¨ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘å®ƒ
    let arr = Box::new([0;1000]);
    // å°†å †ä¸Šæ•°ç»„çš„æ‰€æœ‰æƒè½¬ç§»ç»™ arr1ï¼Œç”±äºæ•°æ®åœ¨å †ä¸Šï¼Œå› æ­¤ä»…ä»…æ‹·è´äº†æ™ºèƒ½æŒ‡é’ˆçš„ç»“æ„ä½“ï¼Œåº•å±‚æ•°æ®å¹¶æ²¡æœ‰è¢«æ‹·è´
    // æ‰€æœ‰æƒé¡ºåˆ©è½¬ç§»ç»™ arr1ï¼Œarr ä¸å†æ‹¥æœ‰æ‰€æœ‰æƒ
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // ç”±äº arr ä¸å†æ‹¥æœ‰åº•å±‚æ•°ç»„çš„æ‰€æœ‰æƒï¼Œå› æ­¤ä¸‹é¢ä»£ç å°†æŠ¥é”™
    // println!("{:?}", arr.len());
}
```

ä»ä»¥ä¸Šä»£ç ï¼Œå¯ä»¥æ¸…æ™°çœ‹å‡ºå¤§å—çš„æ•°æ®ä¸ºä½•åº”è¯¥æ”¾å…¥å †ä¸­ï¼Œæ­¤æ—¶ `Box` å°±æˆä¸ºäº†æˆ‘ä»¬æœ€å¥½çš„å¸®æ‰‹ã€‚

#### å°†åŠ¨æ€å¤§å°ç±»å‹å˜ä¸º Sized å›ºå®šå¤§å°ç±»å‹

Rust éœ€è¦åœ¨ç¼–è¯‘æ—¶çŸ¥é“ç±»å‹å ç”¨å¤šå°‘ç©ºé—´ï¼Œå¦‚æœä¸€ç§ç±»å‹åœ¨ç¼–è¯‘æ—¶æ— æ³•çŸ¥é“å…·ä½“çš„å¤§å°ï¼Œé‚£ä¹ˆè¢«ç§°ä¸ºåŠ¨æ€å¤§å°ç±»å‹ DSTã€‚

å…¶ä¸­ä¸€ç§æ— æ³•åœ¨ç¼–è¯‘æ—¶çŸ¥é“å¤§å°çš„ç±»å‹æ˜¯**é€’å½’ç±»å‹**ï¼šåœ¨ç±»å‹å®šä¹‰ä¸­åˆä½¿ç”¨åˆ°äº†è‡ªèº«ï¼Œæˆ–è€…è¯´è¯¥ç±»å‹çš„å€¼çš„ä¸€éƒ¨åˆ†å¯ä»¥æ˜¯ç›¸åŒç±»å‹çš„å…¶å®ƒå€¼ï¼Œè¿™ç§å€¼çš„åµŒå¥—ç†è®ºä¸Šå¯ä»¥æ— é™è¿›è¡Œä¸‹å»ï¼Œæ‰€ä»¥ Rust ä¸çŸ¥é“é€’å½’ç±»å‹éœ€è¦å¤šå°‘ç©ºé—´ï¼š

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

ä»¥ä¸Šå°±æ˜¯å‡½æ•°å¼è¯­è¨€ä¸­å¸¸è§çš„ `Cons List`ï¼Œå®ƒçš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ª `i32` å€¼ï¼Œè¿˜åŒ…å«äº†ä¸€ä¸ªæ–°çš„ `List`ï¼Œå› æ­¤è¿™ç§åµŒå¥—å¯ä»¥æ— é™è¿›è¡Œä¸‹å»ï¼ŒRust è®¤ä¸ºè¯¥ç±»å‹æ˜¯ä¸€ä¸ª DST ç±»å‹ï¼Œå¹¶ç»™äºˆæŠ¥é”™ï¼š

```console
error[E0072]: recursive type `List` has infinite size //é€’å½’ç±»å‹ `List` æ‹¥æœ‰æ— é™é•¿çš„å¤§å°
 --> src/main.rs:3:1
  |
3 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
4 |     Cons(i32, List),
  |               ---- recursive without indirection
```

æ­¤æ—¶è‹¥æƒ³è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±å¯ä»¥ä½¿ç”¨æˆ‘ä»¬çš„ `Box<T>`ï¼š

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

åªéœ€è¦å°† `List` å­˜å‚¨åˆ°å †ä¸Šï¼Œç„¶åä½¿ç”¨ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘å®ƒï¼Œå³å¯å®Œæˆä» DST åˆ° Sized ç±»å‹(å›ºå®šå¤§å°ç±»å‹)çš„åä¸½è½¬å˜ã€‚

#### ç‰¹å¾å¯¹è±¡

åœ¨ Rust ä¸­ï¼Œæƒ³å®ç°ä¸åŒç±»å‹ç»„æˆçš„æ•°ç»„åªæœ‰ä¸¤ä¸ªåŠæ³•ï¼šæšä¸¾å’Œç‰¹å¾å¯¹è±¡ï¼Œå‰è€…é™åˆ¶è¾ƒå¤šï¼Œå› æ­¤åè€…å¾€å¾€æ˜¯æœ€å¸¸ç”¨çš„è§£å†³åŠæ³•ã€‚

```rust
trait Draw {
    fn draw(&self);
}

struct Button {
    id: u32,
}
impl Draw for Button {
    fn draw(&self) {
        println!("è¿™æ˜¯å±å¹•ä¸Šç¬¬{}å·æŒ‰é’®", self.id)
    }
}

struct Select {
    id: u32,
}

impl Draw for Select {
    fn draw(&self) {
        println!("è¿™ä¸ªé€‰æ‹©æ¡†è´¼éš¾ç”¨{}", self.id)
    }
}

fn main() {
    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];

    for e in elems {
        e.draw()
    }
}
```

ä»¥ä¸Šä»£ç å°†ä¸åŒç±»å‹çš„ `Button` å’Œ `Select` åŒ…è£…æˆ `Draw` ç‰¹å¾çš„ç‰¹å¾å¯¹è±¡ï¼Œæ”¾å…¥ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œ`Box<dyn Draw>` å°±æ˜¯ç‰¹å¾å¯¹è±¡ã€‚

å…¶å®ï¼Œç‰¹å¾ä¹Ÿæ˜¯ DST ç±»å‹ï¼Œè€Œç‰¹å¾å¯¹è±¡åœ¨åšçš„å°±æ˜¯å°† DST ç±»å‹è½¬æ¢ä¸ºå›ºå®šå¤§å°ç±»å‹ã€‚

## Box å†…å­˜å¸ƒå±€

å…ˆæ¥çœ‹çœ‹ `Vec<i32>` çš„å†…å­˜å¸ƒå±€ï¼š

```rust
(stack)    (heap)
â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”
â”‚ vec1 â”‚â”€â”€â†’â”‚ 1 â”‚
â””â”€â”€â”€â”€â”€â”€â”˜   â”œâ”€â”€â”€â”¤
           â”‚ 2 â”‚
           â”œâ”€â”€â”€â”¤
           â”‚ 3 â”‚
           â”œâ”€â”€â”€â”¤
           â”‚ 4 â”‚
           â””â”€â”€â”€â”˜
```

ä¹‹å‰æåˆ°è¿‡ `Vec` å’Œ `String` éƒ½æ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Œä»ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼Œè¯¥æ™ºèƒ½æŒ‡é’ˆå­˜å‚¨åœ¨æ ˆä¸­ï¼Œç„¶åæŒ‡å‘å †ä¸Šçš„æ•°ç»„æ•°æ®ã€‚

é‚£å¦‚æœæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª `Box` å¯¹è±¡å‘¢ï¼Ÿæ¥çœ‹çœ‹ `Vec<Box<i32>>` çš„å†…å­˜å¸ƒå±€ï¼š

```rust
                    (heap)
(stack)    (heap)   â”Œâ”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â” â”Œâ”€â†’â”‚ 1 â”‚
â”‚ vec2 â”‚â”€â”€â†’â”‚B1 â”‚â”€â”˜  â””â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”˜   â”œâ”€â”€â”€â”¤    â”Œâ”€â”€â”€â”
           â”‚B2 â”‚â”€â”€â”€â†’â”‚ 2 â”‚
           â”œâ”€â”€â”€â”¤    â””â”€â”€â”€â”˜
           â”‚B3 â”‚â”€â”  â”Œâ”€â”€â”€â”
           â”œâ”€â”€â”€â”¤ â””â”€â†’â”‚ 3 â”‚
           â”‚B4 â”‚â”€â”  â””â”€â”€â”€â”˜
           â””â”€â”€â”€â”˜ â”‚  â”Œâ”€â”€â”€â”
                 â””â”€â†’â”‚ 4 â”‚
                    â””â”€â”€â”€â”˜
```

ä¸Šé¢çš„ `B1` ä»£è¡¨è¢« `Box` åˆ†é…åˆ°å †ä¸Šçš„å€¼ `1`ã€‚

å¯ä»¥çœ‹å‡ºæ™ºèƒ½æŒ‡é’ˆ `vec2` ä¾ç„¶æ˜¯å­˜å‚¨åœ¨æ ˆä¸Šï¼Œç„¶åæŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªå †ä¸Šçš„æ•°ç»„ï¼Œè¯¥æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª `Box` æ™ºèƒ½æŒ‡é’ˆï¼Œæœ€ç»ˆ `Box` æ™ºèƒ½æŒ‡é’ˆåˆæŒ‡å‘äº†å­˜å‚¨åœ¨å †ä¸Šçš„å®é™…å€¼ã€‚

å› æ­¤å½“æˆ‘ä»¬ä»æ•°ç»„ä¸­å–å‡ºæŸä¸ªå…ƒç´ æ—¶ï¼Œå–åˆ°çš„æ˜¯å¯¹åº”çš„æ™ºèƒ½æŒ‡é’ˆ `Box`ï¼Œéœ€è¦å¯¹è¯¥æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨ï¼Œæ‰èƒ½å–å‡ºæœ€ç»ˆçš„å€¼ï¼š

```rust
fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let (first, second) = (&arr[0], &arr[1]);
    let sum = **first + **second;
}
```

ä»¥ä¸Šä»£ç æœ‰å‡ ä¸ªå€¼å¾—æ³¨æ„çš„ç‚¹ï¼š

- ä½¿ç”¨ `&` å€Ÿç”¨æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå¦åˆ™ä¼šæŠ¥æ‰€æœ‰æƒé”™è¯¯
- è¡¨è¾¾å¼ä¸èƒ½éšå¼çš„è§£å¼•ç”¨ï¼Œå› æ­¤å¿…é¡»ä½¿ç”¨ `**` åšä¸¤æ¬¡è§£å¼•ç”¨ï¼Œç¬¬ä¸€æ¬¡å°† `&Box<i32>` ç±»å‹è½¬æˆ `Box<i32>`ï¼Œç¬¬äºŒæ¬¡å°† `Box<i32>` è½¬æˆ `i32`

## Box::leak

`Box` ä¸­è¿˜æä¾›äº†ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å…³è”å‡½æ•°ï¼š`Box::leak`ï¼Œå®ƒå¯ä»¥æ¶ˆè´¹æ‰ `Box` å¹¶ä¸”å¼ºåˆ¶ç›®æ ‡å€¼ä»å†…å­˜ä¸­æ³„æ¼ï¼Œè¯»è€…å¯èƒ½ä¼šè§‰å¾—ï¼Œè¿™æœ‰å•¥ç”¨å•Šï¼Ÿ

å…¶å®è¿˜çœŸæœ‰ç‚¹ç”¨ï¼Œä¾‹å¦‚ï¼Œä½ å¯ä»¥æŠŠä¸€ä¸ª `String` ç±»å‹ï¼Œå˜æˆä¸€ä¸ª `'static` ç”Ÿå‘½å‘¨æœŸçš„ `&str` ç±»å‹ï¼š

```rust
fn main() {
   let s = gen_static_str();
   println!("{}", s);
}

fn gen_static_str() -> &'static str{
    let mut s = String::new();
    s.push_str("hello, world");

    Box::leak(s.into_boxed_str())
}
```

åœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œå¦‚æœ `String` åˆ›å»ºäºå‡½æ•°ä¸­ï¼Œé‚£ä¹ˆè¿”å›å®ƒçš„å”¯ä¸€æ–¹æ³•å°±æ˜¯è½¬ç§»æ‰€æœ‰æƒç»™è°ƒç”¨è€… `fn move_str() -> String`ï¼Œè€Œé€šè¿‡ `Box::leak` æˆ‘ä»¬ä¸ä»…è¿”å›äº†ä¸€ä¸ª `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå®ƒè¿˜æ˜¯ `'static` ç”Ÿå‘½å‘¨æœŸçš„ï¼

è¦çŸ¥é“çœŸæ­£å…·æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¾€å¾€éƒ½æ˜¯ç¼–è¯‘æœŸå°±åˆ›å»ºçš„å€¼ï¼Œä¾‹å¦‚ `let v = "hello, world"`ï¼Œè¿™é‡Œ `v` æ˜¯ç›´æ¥æ‰“åŒ…åˆ°äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ï¼Œå› æ­¤è¯¥å­—ç¬¦ä¸²å…·æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸï¼Œå†æ¯”å¦‚ `const` å¸¸é‡ã€‚

åˆæœ‰è¯»è€…è¦é—®äº†ï¼Œæˆ‘è¿˜å¯ä»¥æ‰‹åŠ¨ä¸ºå˜é‡æ ‡æ³¨ `'static` å•Šã€‚å…¶å®ä½ æ ‡æ³¨çš„ `'static` åªæ˜¯ç”¨æ¥å¿½æ‚ ç¼–è¯‘å™¨çš„ï¼Œä½†æ˜¯è¶…å‡ºä½œç”¨åŸŸï¼Œä¸€æ ·è¢«é‡Šæ”¾å›æ”¶ã€‚è€Œä½¿ç”¨ `Box::leak` å°±å¯ä»¥å°†ä¸€ä¸ªè¿è¡ŒæœŸçš„å€¼è½¬ä¸º `'static`ã€‚

#### ä½¿ç”¨åœºæ™¯

å…‰çœ‹ä¸Šé¢çš„æè¿°ï¼Œå¤§å®¶å¯èƒ½è¿˜æ˜¯äº‘é‡Œé›¾é‡Œã€ä¸€å¤´é›¾æ°´ã€‚

é‚£ä¹ˆæˆ‘è¯´ä¸€ä¸ªç®€å•çš„åœºæ™¯ï¼Œ**ä½ éœ€è¦ä¸€ä¸ªåœ¨è¿è¡ŒæœŸåˆå§‹åŒ–çš„å€¼ï¼Œä½†æ˜¯å¯ä»¥å…¨å±€æœ‰æ•ˆï¼Œä¹Ÿå°±æ˜¯å’Œæ•´ä¸ªç¨‹åºæ´»å¾—ä¸€æ ·ä¹…**ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨ `Box::leak`ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ªå­˜å‚¨é…ç½®çš„ç»“æ„ä½“å®ä¾‹ï¼Œå®ƒæ˜¯åœ¨è¿è¡ŒæœŸåŠ¨æ€æ’å…¥å†…å®¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥å°†å…¶è½¬ä¸ºå…¨å±€æœ‰æ•ˆï¼Œè™½ç„¶ `Rc/Arc` ä¹Ÿå¯ä»¥å®ç°æ­¤åŠŸèƒ½ï¼Œä½†æ˜¯ `Box::leak` æ˜¯æ€§èƒ½æœ€é«˜çš„ã€‚

## æ€»ç»“

`Box` èƒŒåæ˜¯è°ƒç”¨ `jemalloc` æ¥åšå†…å­˜ç®¡ç†ï¼Œæ‰€ä»¥å †ä¸Šçš„ç©ºé—´æ— éœ€æˆ‘ä»¬çš„æ‰‹åŠ¨ç®¡ç†ã€‚ä¸æ­¤ç±»ä¼¼ï¼Œå¸¦ GC çš„è¯­è¨€ä¸­çš„å¯¹è±¡ä¹Ÿæ˜¯å€ŸåŠ©äº `Box` æ¦‚å¿µæ¥å®ç°çš„ï¼Œ**ä¸€åˆ‡çš†å¯¹è±¡ = ä¸€åˆ‡çš† Box**ï¼Œ åªä¸è¿‡æˆ‘ä»¬æ— éœ€è‡ªå·±å» `Box` ç½¢äº†ã€‚

å…¶å®å¾ˆå¤šæ—¶å€™ï¼Œç¼–è¯‘å™¨çš„é­ç¬å¯ä»¥åŠ©æˆ‘ä»¬æ›´å¿«çš„æˆé•¿ï¼Œä¾‹å¦‚æ‰€æœ‰æƒè§„åˆ™é‡Œçš„å€Ÿç”¨ã€moveã€ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ç¼–è¯‘å™¨åœ¨æ•™æˆ‘ä»¬åšäººï¼Œå“¦ä¸æ˜¯ï¼Œæ˜¯æ•™æˆ‘ä»¬æ·±åˆ»ç†è§£å †æ ˆã€å†…å­˜å¸ƒå±€ã€ä½œç”¨åŸŸç­‰ç­‰ä½ åœ¨å…¶å®ƒ GC è¯­è¨€æ— éœ€å»å…³æ³¨çš„ä¸œè¥¿ã€‚åˆšå¼€å§‹æ˜¯å¾ˆç—›è‹¦ï¼Œä½†æ˜¯ä¸€æ—¦ç†Ÿæ‚‰äº†è¿™å¥—è§„åˆ™ï¼Œå†™ä»£ç çš„æ•ˆç‡å’Œä»£ç æœ¬èº«çš„è´¨é‡å°†é£é€Ÿä¸Šå‡ï¼Œç›´åˆ°ä½ å¯ä»¥ç”¨ Java å¼€å‘çš„æ•ˆç‡å†™å‡º Java ä»£ç ä¸å¯ä¼åŠçš„æ€§èƒ½å’Œå®‰å…¨æ€§ï¼Œæœ€ç»ˆ Rust è¯­è¨€æ‰€è°“çš„å¼€å‘æ•ˆç‡ä½ã€å¿ƒæ™ºè´Ÿæ‹…é«˜ï¼Œå¯¹ä½ æ¥è¯´ç»ˆç©¶ä¸æ˜¯ä¸ªäº‹ã€‚

å› æ­¤ï¼Œä¸è¦æ€ª Rustï¼Œ**å®ƒåªæ˜¯åœ¨å¸®æˆ‘ä»¬æˆä¸ºé‚£ä¸ªæ›´å¥½çš„ç¨‹åºå‘˜ï¼Œè€Œè¿™äº›è‹¦éš¾ç»ˆç©¶æˆä¸ºæˆ‘ä»¬èµ°å‘ä¼˜ç§€çš„å«è„šçŸ³**ã€‚



================================================
FILE: src/advance/smart-pointer/cell-refcell.md
================================================
# Cell å’Œ RefCell

Rust çš„ç¼–è¯‘å™¨ä¹‹ä¸¥æ ¼ï¼Œå¯ä»¥è¯´æ˜¯ä¸¾ä¸–æ— åŒã€‚ç‰¹åˆ«æ˜¯åœ¨æ‰€æœ‰æƒæ–¹é¢ï¼ŒRust é€šè¿‡ä¸¥æ ¼çš„è§„åˆ™æ¥ä¿è¯æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„æ­£ç¡®æ€§ï¼Œæœ€ç»ˆä¸ºç¨‹åºçš„å®‰å…¨ä¿é©¾æŠ¤èˆªã€‚

ä½†æ˜¯ä¸¥æ ¼æ˜¯ä¸€æŠŠåŒåˆƒå‰‘ï¼Œå¸¦æ¥å®‰å…¨æå‡çš„åŒæ—¶ï¼ŒæŸå¤±äº†çµæ´»æ€§ï¼Œæœ‰æ—¶ç”šè‡³ä¼šè®©ç”¨æˆ·ç—›è‹¦ä¸å ªã€æ€¨å£°è½½é“ã€‚å› æ­¤ Rust æä¾›äº† `Cell` å’Œ `RefCell` ç”¨äºå†…éƒ¨å¯å˜æ€§ï¼Œç®€è€Œè¨€ä¹‹ï¼Œå¯ä»¥åœ¨æ‹¥æœ‰ä¸å¯å˜å¼•ç”¨çš„åŒæ—¶ä¿®æ”¹ç›®æ ‡æ•°æ®ï¼Œå¯¹äºæ­£å¸¸çš„ä»£ç å®ç°æ¥è¯´ï¼Œè¿™ä¸ªæ˜¯ä¸å¯èƒ½åšåˆ°çš„ï¼ˆè¦ä¹ˆä¸€ä¸ªå¯å˜å€Ÿç”¨ï¼Œè¦ä¹ˆå¤šä¸ªä¸å¯å˜å€Ÿç”¨ï¼‰ã€‚

> å†…éƒ¨å¯å˜æ€§çš„å®ç°æ˜¯å› ä¸º Rust ä½¿ç”¨äº† `unsafe` æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½†æ˜¯å¯¹äºä½¿ç”¨è€…æ¥è¯´ï¼Œè¿™äº›éƒ½æ˜¯é€æ˜çš„ï¼Œå› ä¸ºè¿™äº›ä¸å®‰å…¨ä»£ç éƒ½è¢«å°è£…åˆ°äº†å®‰å…¨çš„ API ä¸­

## Cell

`Cell` å’Œ `RefCell` åœ¨åŠŸèƒ½ä¸Šæ²¡æœ‰åŒºåˆ«ï¼ŒåŒºåˆ«åœ¨äº `Cell<T>` é€‚ç”¨äº `T` å®ç° `Copy` çš„æƒ…å†µï¼š

```rust
use std::cell::Cell;
fn main() {
  let c = Cell::new("asdf");
  let one = c.get();
  c.set("qwer");
  let two = c.get();
  println!("{},{}", one, two);
}
```

ä»¥ä¸Šä»£ç å±•ç¤ºäº† `Cell` çš„åŸºæœ¬ç”¨æ³•ï¼Œæœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- "asdf" æ˜¯ `&str` ç±»å‹ï¼Œå®ƒå®ç°äº† `Copy` ç‰¹å¾
- `c.get` ç”¨æ¥å–å€¼ï¼Œ`c.set` ç”¨æ¥è®¾ç½®æ–°å€¼

å–åˆ°å€¼ä¿å­˜åœ¨ `one` å˜é‡åï¼Œè¿˜èƒ½åŒæ—¶è¿›è¡Œä¿®æ”¹ï¼Œè¿™ä¸ªè¿èƒŒäº† Rust çš„å€Ÿç”¨è§„åˆ™ï¼Œä½†æ˜¯ç”±äº `Cell` çš„å­˜åœ¨ï¼Œæˆ‘ä»¬å¾ˆä¼˜é›…åœ°åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œä½†æ˜¯å¦‚æœä½ å°è¯•åœ¨ `Cell` ä¸­å­˜æ”¾`String`ï¼š

```rust
 let c = Cell::new(String::from("asdf"));
```

ç¼–è¯‘å™¨ä¼šç«‹åˆ»æŠ¥é”™ï¼Œå› ä¸º `String` æ²¡æœ‰å®ç° `Copy` ç‰¹å¾ï¼š

```console
| pub struct String {
| ----------------- doesn't satisfy `String: Copy`
|
= note: the following trait bounds were not satisfied:
        `String: Copy`
```

## RefCell

ç”±äº `Cell` ç±»å‹é’ˆå¯¹çš„æ˜¯å®ç°äº† `Copy` ç‰¹å¾çš„å€¼ç±»å‹ï¼Œå› æ­¤åœ¨å®é™…å¼€å‘ä¸­ï¼Œ`Cell` ä½¿ç”¨çš„å¹¶ä¸å¤šï¼Œå› ä¸ºæˆ‘ä»¬è¦è§£å†³çš„å¾€å¾€æ˜¯å¯å˜ã€ä¸å¯å˜å¼•ç”¨å…±å­˜å¯¼è‡´çš„é—®é¢˜ï¼Œæ­¤æ—¶å°±éœ€è¦å€ŸåŠ©äº `RefCell` æ¥è¾¾æˆç›®çš„ã€‚

æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æƒã€å€Ÿç”¨è§„åˆ™ä¸è¿™äº›æ™ºèƒ½æŒ‡é’ˆåšä¸€ä¸ªå¯¹æ¯”ï¼š

| Rust è§„åˆ™                            | æ™ºèƒ½æŒ‡é’ˆå¸¦æ¥çš„é¢å¤–è§„åˆ™                  |
| ------------------------------------ | --------------------------------------- |
| ä¸€ä¸ªæ•°æ®åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…               | `Rc/Arc`è®©ä¸€ä¸ªæ•°æ®å¯ä»¥æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…    |
| è¦ä¹ˆå¤šä¸ªä¸å¯å˜å€Ÿç”¨ï¼Œè¦ä¹ˆä¸€ä¸ªå¯å˜å€Ÿç”¨ | `RefCell`å®ç°ç¼–è¯‘æœŸå¯å˜ã€ä¸å¯å˜å¼•ç”¨å…±å­˜ |
| è¿èƒŒè§„åˆ™å¯¼è‡´**ç¼–è¯‘é”™è¯¯**             | è¿èƒŒè§„åˆ™å¯¼è‡´**è¿è¡Œæ—¶`panic`**           |

å¯ä»¥çœ‹å‡ºï¼Œ`Rc/Arc` å’Œ `RefCell` åˆåœ¨ä¸€èµ·ï¼Œè§£å†³äº† Rust ä¸­ä¸¥è‹›çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™å¸¦æ¥çš„æŸäº›åœºæ™¯ä¸‹éš¾ä½¿ç”¨çš„é—®é¢˜ã€‚ä½†æ˜¯å®ƒä»¬å¹¶ä¸æ˜¯é“¶å¼¹ï¼Œä¾‹å¦‚ `RefCell` å®é™…ä¸Šå¹¶æ²¡æœ‰è§£å†³å¯å˜å¼•ç”¨å’Œå¼•ç”¨å¯ä»¥å…±å­˜çš„é—®é¢˜ï¼Œåªæ˜¯å°†æŠ¥é”™ä»ç¼–è¯‘æœŸæ¨è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œä»ç¼–è¯‘å™¨é”™è¯¯å˜æˆäº† `panic` å¼‚å¸¸ï¼š

```rust
use std::cell::RefCell;

fn main() {
    let s = RefCell::new(String::from("hello, world"));
    let s1 = s.borrow();
    let s2 = s.borrow_mut();

    println!("{},{}", s1, s2);
}
```

ä¸Šé¢ä»£ç åœ¨ç¼–è¯‘æœŸä¸ä¼šæŠ¥ä»»ä½•é”™è¯¯ï¼Œä½ å¯ä»¥é¡ºåˆ©è¿è¡Œç¨‹åºï¼š

```console
thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:6:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

ä½†æ˜¯ä¾ç„¶ä¼šå› ä¸ºè¿èƒŒäº†å€Ÿç”¨è§„åˆ™å¯¼è‡´äº†è¿è¡ŒæœŸ `panic`ï¼Œè¿™éå¸¸åƒä¸­å›½çš„å¤©ç½‘ï¼Œå®ƒä¹Ÿè®¸ä¼šè¢«ç½ªçŠ¯è’™è”½ä¸€æ—¶ï¼Œä½†æ˜¯å¹¶ä¸ä¼šè¢«è’™è”½ä¸€ä¸–ï¼Œä»»ä½•å¯¼è‡´å®‰å…¨é£é™©çš„å­˜åœ¨éƒ½å°†ä¸èƒ½è¢«å®¹å¿ï¼Œæ³•ç½‘æ¢æ¢ï¼Œç–è€Œä¸æ¼ã€‚

#### RefCell ä¸ºä½•å­˜åœ¨

ç›¸ä¿¡è‚¯å®šæœ‰è¯»è€…æœ‰ç–‘é—®äº†ï¼Œè¿™ä¹ˆåšæœ‰ä»»ä½•æ„ä¹‰å—ï¼Ÿè¿˜ä¸å¦‚åœ¨ç¼–è¯‘æœŸæŠ¥é”™ï¼Œè‡³å°‘èƒ½æå‰å‘ç°é—®é¢˜ï¼Œè€Œä¸”æ€§èƒ½è¿˜æ›´å¥½ã€‚

å­˜åœ¨å³åˆç†ï¼Œç©¶å…¶æ ¹å› ï¼Œåœ¨äº Rust ç¼–è¯‘æœŸçš„**å®å¯é”™æ€ï¼Œç»ä¸æ”¾è¿‡**çš„åŸåˆ™ï¼Œå½“ç¼–è¯‘å™¨ä¸èƒ½ç¡®å®šä½ çš„ä»£ç æ˜¯å¦æ­£ç¡®æ—¶ï¼Œå°±ç»Ÿç»Ÿä¼šåˆ¤å®šä¸ºé”™è¯¯ï¼Œå› æ­¤éš¾å…ä¼šå¯¼è‡´ä¸€äº›è¯¯æŠ¥ã€‚

è€Œ `RefCell` æ­£æ˜¯**ç”¨äºä½ ç¡®ä¿¡ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œè€Œç¼–è¯‘å™¨å´å‘ç”Ÿäº†è¯¯åˆ¤æ—¶**ã€‚

å¯¹äºå¤§å‹çš„å¤æ‚ç¨‹åºï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä½¿ç”¨ `RefCell` æ¥è®©äº‹æƒ…ç®€åŒ–ã€‚ä¾‹å¦‚åœ¨ Rust ç¼–è¯‘å™¨çš„[`ctxtç»“æ„ä½“`](https://github.com/rust-lang/rust/blob/620d1ee5346bee10ba7ce129b2e20d6e59f0377d/src/librustc/middle/ty.rs#L803-L987)ä¸­æœ‰å¤§é‡çš„ `RefCell` ç±»å‹çš„ `map` å­—æ®µï¼Œä¸»è¦çš„åŸå› æ˜¯ï¼šè¿™äº› `map` ä¼šè¢«åˆ†æ•£åœ¨å„ä¸ªåœ°æ–¹çš„ä»£ç ç‰‡æ®µæ‰€å¹¿æ³›ä½¿ç”¨æˆ–ä¿®æ”¹ã€‚ç”±äºè¿™ç§åˆ†æ•£åœ¨å„å¤„çš„ä½¿ç”¨æ–¹å¼ï¼Œå¯¼è‡´äº†ç®¡ç†å¯å˜å’Œä¸å¯å˜æˆä¸ºä¸€ä»¶éå¸¸å¤æ‚çš„ä»»åŠ¡ï¼ˆç”šè‡³ä¸å¯èƒ½ï¼‰ï¼Œä½ å¾ˆå®¹æ˜“å°±ç¢°åˆ°ç¼–è¯‘å™¨æŠ›å‡ºæ¥çš„å„ç§é”™è¯¯ã€‚è€Œä¸” `RefCell` çš„è¿è¡Œæ—¶é”™è¯¯åœ¨è¿™ç§æƒ…å†µä¸‹ä¹Ÿå˜å¾—éå¸¸å¯çˆ±ï¼šä¸€æ—¦æœ‰äººåšäº†ä¸æ­£ç¡®çš„ä½¿ç”¨ï¼Œä»£ç ä¼š `panic`ï¼Œç„¶åå‘Šè¯‰æˆ‘ä»¬å“ªäº›å€Ÿç”¨å†²çªäº†ã€‚

æ€»ä¹‹ï¼Œå½“ä½ ç¡®ä¿¡ç¼–è¯‘å™¨è¯¯æŠ¥ä½†ä¸çŸ¥é“è¯¥å¦‚ä½•è§£å†³æ—¶ï¼Œæˆ–è€…ä½ æœ‰ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼Œéœ€è¦è¢«å››å¤„ä½¿ç”¨å’Œä¿®æ”¹ç„¶åå¯¼è‡´å€Ÿç”¨å…³ç³»éš¾ä»¥ç®¡ç†æ—¶ï¼Œéƒ½å¯ä»¥ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨ `RefCell`ã€‚

#### RefCell ç®€å•æ€»ç»“

- ä¸ `Cell` ç”¨äºå¯ `Copy` çš„å€¼ä¸åŒï¼Œ`RefCell` ç”¨äºå¼•ç”¨
- `RefCell` åªæ˜¯å°†å€Ÿç”¨è§„åˆ™ä»ç¼–è¯‘æœŸæ¨è¿Ÿåˆ°ç¨‹åºè¿è¡ŒæœŸï¼Œå¹¶ä¸èƒ½å¸®ä½ ç»•è¿‡è¿™ä¸ªè§„åˆ™
- `RefCell` é€‚ç”¨äºç¼–è¯‘æœŸè¯¯æŠ¥æˆ–è€…ä¸€ä¸ªå¼•ç”¨è¢«åœ¨å¤šå¤„ä»£ç ä½¿ç”¨ã€ä¿®æ”¹ä»¥è‡³äºéš¾äºç®¡ç†å€Ÿç”¨å…³ç³»æ—¶
- ä½¿ç”¨ `RefCell` æ—¶ï¼Œè¿èƒŒå€Ÿç”¨è§„åˆ™ä¼šå¯¼è‡´è¿è¡ŒæœŸçš„ `panic`

## é€‰æ‹© `Cell` è¿˜æ˜¯ `RefCell`

æ ¹æ®æœ¬æ–‡çš„å†…å®¹ï¼Œæˆ‘ä»¬å¯ä»¥å¤§æ¦‚æ€»ç»“ä¸‹ä¸¤è€…çš„åŒºåˆ«ï¼š

- `Cell` åªé€‚ç”¨äº `Copy` ç±»å‹ï¼Œç”¨äºæä¾›å€¼ï¼Œè€Œ `RefCell` ç”¨äºæä¾›å¼•ç”¨
- `Cell` ä¸ä¼š `panic`ï¼Œè€Œ `RefCell` ä¼š

#### æ€§èƒ½æ¯”è¾ƒ

`Cell` æ²¡æœ‰é¢å¤–çš„æ€§èƒ½æŸè€—ï¼Œä¾‹å¦‚ä»¥ä¸‹ä¸¤æ®µä»£ç çš„æ€§èƒ½å…¶å®æ˜¯ä¸€è‡´çš„ï¼š

```rust
// code snipet 1
let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());

// code snipet 2
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

è™½ç„¶æ€§èƒ½ä¸€è‡´ï¼Œä½†ä»£ç  `1` æ‹¥æœ‰ä»£ç  `2` ä¸å…·æœ‰çš„ä¼˜åŠ¿ï¼šå®ƒèƒ½ç¼–è¯‘æˆåŠŸ:)

ä¸ `Cell` çš„ `zero cost` ä¸åŒï¼Œ`RefCell` å…¶å®æ˜¯æœ‰ä¸€ç‚¹è¿è¡ŒæœŸå¼€é”€çš„ï¼ŒåŸå› æ˜¯å®ƒåŒ…å«äº†ä¸€ä¸ªå­—èŠ‚å¤§å°çš„â€œå€Ÿç”¨çŠ¶æ€â€æŒ‡ç¤ºå™¨ï¼Œè¯¥æŒ‡ç¤ºå™¨åœ¨æ¯æ¬¡è¿è¡Œæ—¶å€Ÿç”¨æ—¶éƒ½ä¼šè¢«ä¿®æ”¹ï¼Œè¿›è€Œäº§ç”Ÿä¸€ç‚¹å¼€é”€ã€‚

æ€»ä¹‹ï¼Œå½“éè¦ä½¿ç”¨å†…éƒ¨å¯å˜æ€§æ—¶ï¼Œé¦–é€‰ `Cell`ï¼Œåªæœ‰ä½ çš„ç±»å‹æ²¡æœ‰å®ç° `Copy` æ—¶ï¼Œæ‰å»é€‰æ‹© `RefCell`ã€‚

## å†…éƒ¨å¯å˜æ€§

ä¹‹å‰æˆ‘ä»¬æåˆ° `RefCell` å…·æœ‰å†…éƒ¨å¯å˜æ€§ï¼Œä½•ä¸ºå†…éƒ¨å¯å˜æ€§ï¼Ÿç®€å•æ¥è¯´ï¼Œå¯¹ä¸€ä¸ªä¸å¯å˜çš„å€¼è¿›è¡Œå¯å˜å€Ÿç”¨ï¼Œä½†è¿™ä¸ªå¹¶ä¸ç¬¦åˆ Rust çš„åŸºæœ¬å€Ÿç”¨è§„åˆ™ï¼š

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

ä¸Šé¢çš„ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½å¯¹ä¸€ä¸ªä¸å¯å˜çš„å€¼è¿›è¡Œå¯å˜å€Ÿç”¨ï¼Œè¿™ä¼šç ´å Rust çš„å®‰å…¨æ€§ä¿è¯ï¼Œç›¸åï¼Œä½ å¯ä»¥å¯¹ä¸€ä¸ªå¯å˜å€¼è¿›è¡Œä¸å¯å˜å€Ÿç”¨ã€‚åŸå› æ˜¯ï¼šå½“å€¼ä¸å¯å˜æ—¶ï¼Œå¯èƒ½ä¼šæœ‰å¤šä¸ªä¸å¯å˜çš„å¼•ç”¨æŒ‡å‘å®ƒï¼Œæ­¤æ—¶è‹¥å°†å…¶ä¸­ä¸€ä¸ªä¿®æ”¹ä¸ºå¯å˜çš„ï¼Œä¼šé€ æˆå¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨å…±å­˜çš„æƒ…å†µï¼›è€Œå½“å€¼å¯å˜æ—¶ï¼Œæœ€å¤šåªä¼šæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨æŒ‡å‘å®ƒï¼Œå°†å…¶ä¿®æ”¹ä¸ºä¸å¯å˜ï¼Œé‚£ä¹ˆæœ€ç»ˆä¾ç„¶æ˜¯åªæœ‰ä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨æŒ‡å‘å®ƒã€‚

è™½ç„¶åŸºæœ¬å€Ÿç”¨è§„åˆ™æ˜¯ Rust çš„åŸºçŸ³ï¼Œç„¶è€Œåœ¨æŸäº›åœºæ™¯ä¸­ï¼Œä¸€ä¸ªå€¼å¯ä»¥åœ¨å…¶æ–¹æ³•å†…éƒ¨è¢«ä¿®æ”¹ï¼ŒåŒæ—¶å¯¹äºå…¶å®ƒä»£ç ä¸å¯å˜ï¼Œæ˜¯å¾ˆæœ‰ç”¨çš„ï¼š

```rust
// å®šä¹‰åœ¨å¤–éƒ¨åº“ä¸­çš„ç‰¹å¾
pub trait Messenger {
    fn send(&self, msg: String);
}

// --------------------------
// æˆ‘ä»¬çš„ä»£ç ä¸­çš„æ•°æ®ç»“æ„å’Œå®ç°
struct MsgQueue {
    msg_cache: Vec<String>,
}

impl Messenger for MsgQueue {
    fn send(&self, msg: String) {
        self.msg_cache.push(msg)
    }
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå¤–éƒ¨åº“ä¸­å®šä¹‰äº†ä¸€ä¸ªæ¶ˆæ¯å‘é€å™¨ç‰¹å¾ `Messenger`ï¼Œå®ƒåªæœ‰ä¸€ä¸ªå‘é€æ¶ˆæ¯çš„åŠŸèƒ½ï¼š`fn send(&self, msg: String)`ï¼Œå› ä¸ºå‘é€æ¶ˆæ¯ä¸éœ€è¦ä¿®æ”¹è‡ªèº«ï¼Œå› æ­¤åŸä½œè€…åœ¨å®šä¹‰æ—¶ï¼Œä½¿ç”¨äº† `&self` çš„ä¸å¯å˜å€Ÿç”¨ï¼Œè¿™ä¸ªæ— å¯åšéã€‚

æˆ‘ä»¬è¦åœ¨è‡ªå·±çš„ä»£ç ä¸­ä½¿ç”¨è¯¥ç‰¹å¾å®ç°ä¸€ä¸ªå¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå‡ºäºæ€§èƒ½çš„è€ƒè™‘ï¼Œæ¶ˆæ¯å…ˆå†™åˆ°æœ¬åœ°ç¼“å­˜(å†…å­˜)ä¸­ï¼Œç„¶åæ‰¹é‡å‘é€å‡ºå»ï¼Œå› æ­¤åœ¨ `send` æ–¹æ³•ä¸­ï¼Œéœ€è¦å°†æ¶ˆæ¯å…ˆè¡Œæ’å…¥åˆ°æœ¬åœ°ç¼“å­˜ `msg_cache` ä¸­ã€‚ä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œè¯¥ `send` æ–¹æ³•çš„ç­¾åæ˜¯ `&self`ï¼Œå› æ­¤ä¸Šè¿°ä»£ç ä¼šæŠ¥é”™ï¼š

```console
error[E0596]: cannot borrow `self.msg_cache` as mutable, as it is behind a `&` reference
  --> src/main.rs:11:9
   |
2  |     fn send(&self, msg: String);
   |             ----- help: consider changing that to be a mutable reference: `&mut self`
...
11 |         self.msg_cache.push(msg)
   |         ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable
```

åœ¨æŠ¥é”™çš„åŒæ—¶ï¼Œç¼–è¯‘å™¨å¤§èªæ˜è¿˜å–„æ„åœ°ç»™å‡ºäº†æç¤ºï¼šå°† `&self` ä¿®æ”¹ä¸º `&mut self`ï¼Œä½†æ˜¯ã€‚ã€‚ã€‚æˆ‘ä»¬å®ç°çš„ç‰¹å¾æ˜¯å®šä¹‰åœ¨å¤–éƒ¨åº“ä¸­ï¼Œå› æ­¤è¯¥ç­¾åæ ¹æœ¬ä¸èƒ½ä¿®æ”¹ã€‚å€¼æ­¤å±æ€¥å…³å¤´ï¼Œ `RefCell` é—ªäº®ç™»åœºï¼š

```rust
use std::cell::RefCell;
pub trait Messenger {
    fn send(&self, msg: String);
}

pub struct MsgQueue {
    msg_cache: RefCell<Vec<String>>,
}

impl Messenger for MsgQueue {
    fn send(&self, msg: String) {
        self.msg_cache.borrow_mut().push(msg)
    }
}

fn main() {
    let mq = MsgQueue {
        msg_cache: RefCell::new(Vec::new()),
    };
    mq.send("hello, world".to_string());
}
```

è¿™ä¸ª MQ åŠŸèƒ½å¾ˆå¼±ï¼Œä½†æ˜¯å¹¶ä¸å¦¨ç¢æˆ‘ä»¬æ¼”ç¤ºå†…éƒ¨å¯å˜æ€§çš„æ ¸å¿ƒç”¨æ³•ï¼šé€šè¿‡åŒ…è£¹ä¸€å±‚ `RefCell`ï¼ŒæˆåŠŸçš„è®© `&self` ä¸­çš„ `msg_cache` æˆä¸ºä¸€ä¸ªå¯å˜å€¼ï¼Œç„¶åå®ç°å¯¹å…¶çš„ä¿®æ”¹ã€‚

## Rc + RefCell ç»„åˆä½¿ç”¨

åœ¨ Rust ä¸­ï¼Œä¸€ä¸ªå¸¸è§çš„ç»„åˆå°±æ˜¯ `Rc` å’Œ `RefCell` åœ¨ä¸€èµ·ä½¿ç”¨ï¼Œå‰è€…å¯ä»¥å®ç°ä¸€ä¸ªæ•°æ®æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œåè€…å¯ä»¥å®ç°æ•°æ®çš„å¯å˜æ€§ï¼š

```rust
use std::cell::RefCell;
use std::rc::Rc;
fn main() {
    let s = Rc::new(RefCell::new("æˆ‘å¾ˆå–„å˜ï¼Œè¿˜æ‹¥æœ‰å¤šä¸ªä¸»äºº".to_string()));

    let s1 = s.clone();
    let s2 = s.clone();
    // let mut s2 = s.borrow_mut();
    s2.borrow_mut().push_str(", oh yeah!");

    println!("{:?}\n{:?}\n{:?}", s, s1, s2);
}

```

ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `RefCell<String>` åŒ…è£¹ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒåŒæ—¶é€šè¿‡ `Rc` åˆ›å»ºäº†å®ƒçš„ä¸‰ä¸ªæ‰€æœ‰è€…ï¼š`s`ã€`s1`å’Œ`s2`ï¼Œå¹¶ä¸”é€šè¿‡å…¶ä¸­ä¸€ä¸ªæ‰€æœ‰è€… `s2` å¯¹å­—ç¬¦ä¸²å†…å®¹è¿›è¡Œäº†ä¿®æ”¹ã€‚

ç”±äº `Rc` çš„æ‰€æœ‰è€…ä»¬å…±äº«åŒä¸€ä¸ªåº•å±‚çš„æ•°æ®ï¼Œå› æ­¤å½“ä¸€ä¸ªæ‰€æœ‰è€…ä¿®æ”¹äº†æ•°æ®æ—¶ï¼Œä¼šå¯¼è‡´å…¨éƒ¨æ‰€æœ‰è€…æŒæœ‰çš„æ•°æ®éƒ½å‘ç”Ÿäº†å˜åŒ–ã€‚

ç¨‹åºçš„è¿è¡Œç»“æœä¹Ÿåœ¨é¢„æ–™ä¹‹ä¸­ï¼š

```console
RefCell { value: "æˆ‘å¾ˆå–„å˜ï¼Œè¿˜æ‹¥æœ‰å¤šä¸ªä¸»äºº, oh yeah!" }
RefCell { value: "æˆ‘å¾ˆå–„å˜ï¼Œè¿˜æ‹¥æœ‰å¤šä¸ªä¸»äºº, oh yeah!" }
RefCell { value: "æˆ‘å¾ˆå–„å˜ï¼Œè¿˜æ‹¥æœ‰å¤šä¸ªä¸»äºº, oh yeah!" }
```

#### æ€§èƒ½æŸè€—

ç›¸ä¿¡è¿™ä¸¤è€…ç»„åˆåœ¨ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå¾ˆå¤šäººä¼šå¥½å¥‡åˆ°åº•æ€§èƒ½å¦‚ä½•ï¼Œä¸‹é¢æˆ‘ä»¬æ¥ç®€å•åˆ†æä¸‹ã€‚

é¦–å…ˆç»™å‡ºä¸€ä¸ªå¤§æ¦‚çš„ç»“è®ºï¼Œè¿™ä¸¤è€…ç»“åˆåœ¨ä¸€èµ·ä½¿ç”¨çš„æ€§èƒ½å…¶å®éå¸¸é«˜ï¼Œå¤§è‡´ç›¸å½“äºæ²¡æœ‰çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„ C++ `std::shared_ptr` æŒ‡é’ˆï¼Œäº‹å®ä¸Šï¼ŒC++ è¿™ä¸ªæŒ‡é’ˆçš„ä¸»è¦å¼€é”€ä¹Ÿåœ¨äºåŸå­æ€§è¿™ä¸ªå¹¶å‘åŸè¯­ä¸Šï¼Œæ¯•ç«Ÿçº¿ç¨‹å®‰å…¨åœ¨å“ªä¸ªè¯­è¨€ä¸­å¼€é”€éƒ½ä¸å°ã€‚

#### å†…å­˜æŸè€—

ä¸¤è€…ç»“åˆçš„æ•°æ®ç»“æ„ä¸ä¸‹é¢ç±»ä¼¼ï¼š

```rust
struct Wrapper<T> {
    // Rc
    strong_count: usize,
    weak_count: usize,

    // Refcell
    borrow_count: isize,

    // åŒ…è£¹çš„æ•°æ®
    item: T,
}
```

ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œä»å¯¹å†…å­˜çš„å½±å“æ¥çœ‹ï¼Œä»…ä»…å¤šåˆ†é…äº†ä¸‰ä¸ª`usize/isize`ï¼Œå¹¶æ²¡æœ‰å…¶å®ƒé¢å¤–çš„è´Ÿæ‹…ã€‚

#### CPU æŸè€—

ä» CPU æ¥çœ‹ï¼ŒæŸè€—å¦‚ä¸‹ï¼š

- å¯¹ `Rc<T>` è§£å¼•ç”¨æ˜¯å…è´¹çš„ï¼ˆç¼–è¯‘æœŸï¼‰ï¼Œä½†æ˜¯ `*` å¸¦æ¥çš„é—´æ¥å–å€¼å¹¶ä¸å…è´¹
- å…‹éš† `Rc<T>` éœ€è¦å°†å½“å‰çš„å¼•ç”¨è®¡æ•°è·Ÿ `0` å’Œ `usize::Max` è¿›è¡Œä¸€æ¬¡æ¯”è¾ƒï¼Œç„¶åå°†è®¡æ•°å€¼åŠ  1
- é‡Šæ”¾ï¼ˆdropï¼‰ `Rc<T>` éœ€è¦å°†è®¡æ•°å€¼å‡ 1ï¼Œ ç„¶åè·Ÿ `0` è¿›è¡Œä¸€æ¬¡æ¯”è¾ƒ
- å¯¹ `RefCell` è¿›è¡Œä¸å¯å˜å€Ÿç”¨ï¼Œéœ€è¦å°† `isize` ç±»å‹çš„å€Ÿç”¨è®¡æ•°åŠ  1ï¼Œç„¶åè·Ÿ `0` è¿›è¡Œæ¯”è¾ƒ
- å¯¹ `RefCell `çš„ä¸å¯å˜å€Ÿç”¨è¿›è¡Œé‡Šæ”¾ï¼Œéœ€è¦å°† `isize` å‡ 1
- å¯¹ `RefCell` çš„å¯å˜å€Ÿç”¨å¤§è‡´æµç¨‹è·Ÿä¸Šé¢å·®ä¸å¤šï¼Œä½†æ˜¯éœ€è¦å…ˆè·Ÿ `0` æ¯”è¾ƒï¼Œç„¶åå†å‡ 1
- å¯¹ `RefCell` çš„å¯å˜å€Ÿç”¨è¿›è¡Œé‡Šæ”¾ï¼Œéœ€è¦å°† `isize` åŠ  1

å…¶å®è¿™äº›ç»†èŠ‚ä¸å¿…è¿‡äºå…³æ³¨ï¼Œåªè¦çŸ¥é“ CPU æ¶ˆè€—ä¹Ÿéå¸¸ä½ï¼Œç”šè‡³ç¼–è¯‘å™¨è¿˜ä¼šå¯¹æ­¤è¿›è¡Œè¿›ä¸€æ­¥ä¼˜åŒ–ï¼

#### CPU ç¼“å­˜ Miss

å”¯ä¸€éœ€è¦æ‹…å¿ƒçš„å¯èƒ½å°±æ˜¯è¿™ç§ç»„åˆæ•°æ®ç»“æ„å¯¹äº CPU ç¼“å­˜æ˜¯å¦äº²å’Œï¼Œè¿™ä¸ªæˆ‘ä»¬æ— æ³•è¯æ˜ï¼Œåªèƒ½æå‡ºæ¥å­˜åœ¨è¿™ä¸ªå¯èƒ½æ€§ï¼Œæœ€ç»ˆçš„æ€§èƒ½å½±å“è¿˜éœ€è¦åœ¨å®é™…åœºæ™¯ä¸­è¿›è¡Œæµ‹è¯•ã€‚

æ€»ä¹‹ï¼Œåˆ†æè¿™ä¸¤è€…ç»„åˆçš„æ€§èƒ½è¿˜æŒºå¤æ‚çš„ï¼Œå¤§æ¦‚æ€»ç»“ä¸‹ï¼š

- ä»è¡¨é¢æ¥çœ‹ï¼Œå®ƒä»¬å¸¦æ¥çš„å†…å­˜å’Œ CPU æŸè€—éƒ½ä¸å¤§
- ä½†æ˜¯ç”±äº `Rc` é¢å¤–çš„å¼•å…¥äº†ä¸€æ¬¡é—´æ¥å–å€¼ï¼ˆ`*`ï¼‰ï¼Œåœ¨å°‘æ•°åœºæ™¯ä¸‹å¯èƒ½ä¼šé€ æˆæ€§èƒ½ä¸Šçš„æ˜¾è‘—æŸå¤±
- CPU ç¼“å­˜å¯èƒ½ä¹Ÿä¸å¤Ÿäº²å’Œ

## é€šè¿‡ `Cell::from_mut` è§£å†³å€Ÿç”¨å†²çª

åœ¨ Rust 1.37 ç‰ˆæœ¬ä¸­æ–°å¢äº†ä¸¤ä¸ªéå¸¸å®ç”¨çš„æ–¹æ³•ï¼š

- Cell::from_mutï¼Œè¯¥æ–¹æ³•å°† `&mut T` è½¬ä¸º `&Cell<T>`
- Cell::as_slice_of_cellsï¼Œè¯¥æ–¹æ³•å°† `&Cell<[T]>` è½¬ä¸º `&[Cell<T>]`

è¿™é‡Œæˆ‘ä»¬ä¸åšæ·±å…¥çš„ä»‹ç»ï¼Œä½†æ˜¯æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨è¿™ä¸¤ä¸ªæ–¹æ³•æ¥è§£å†³ä¸€ä¸ªå¸¸è§çš„å€Ÿç”¨å†²çªé—®é¢˜ï¼š

```rust
fn is_even(i: i32) -> bool {
    i % 2 == 0
}

fn retain_even(nums: &mut Vec<i32>) {
    let mut i = 0;
    for num in nums.iter().filter(|&num| is_even(*num)) {
        nums[i] = *num;
        i += 1;
    }
    nums.truncate(i);
}
```

ä»¥ä¸Šä»£ç ä¼šæŠ¥é”™ï¼š

```console
error[E0502]: cannot borrow `*nums` as mutable because it is also borrowed as immutable
 --> src/main.rs:8:9
  |
7 |     for num in nums.iter().filter(|&num| is_even(*num)) {
  |                ----------------------------------------
  |                |
  |                immutable borrow occurs here
  |                immutable borrow later used here
8 |         nums[i] = *num;
  |         ^^^^ mutable borrow occurs here
```

å¾ˆæ˜æ˜¾ï¼ŒæŠ¥é”™æ˜¯å› ä¸ºåŒæ—¶å€Ÿç”¨äº†ä¸å¯å˜ä¸å¯å˜å¼•ç”¨ï¼Œä½ å¯ä»¥é€šè¿‡ç´¢å¼•çš„æ–¹å¼æ¥é¿å…è¿™ä¸ªé—®é¢˜ï¼š

```rust
fn retain_even(nums: &mut Vec<i32>) {
    let mut i = 0;
    for j in 0..nums.len() {
        if is_even(nums[j]) {
            nums[i] = nums[j];
            i += 1;
        }
    }
    nums.truncate(i);
}
```

ä½†æ˜¯è¿™æ ·å°±è¿èƒŒæˆ‘ä»¬çš„åˆè¡·äº†ï¼Œæ¯•ç«Ÿè¿­ä»£å™¨ä¼šè®©ä»£ç æ›´åŠ ç®€æ´ï¼Œé‚£ä¹ˆè¿˜æœ‰å…¶å®ƒçš„åŠæ³•å—ï¼Ÿ

è¿™æ—¶å°±å¯ä»¥ä½¿ç”¨ `Cell` æ–°å¢çš„è¿™ä¸¤ä¸ªæ–¹æ³•ï¼š

```rust
use std::cell::Cell;

fn retain_even(nums: &mut Vec<i32>) {
    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])
        .as_slice_of_cells();

    let mut i = 0;
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[i].set(num.get());
        i += 1;
    }

    nums.truncate(i);
}
```

æ­¤æ—¶ä»£ç å°†ä¸ä¼šæŠ¥é”™ï¼Œå› ä¸º `Cell` ä¸Šçš„ `set` æ–¹æ³•è·å–çš„æ˜¯ä¸å¯å˜å¼•ç”¨ `pub fn set(&self, val: T)`ã€‚

å½“ç„¶ï¼Œä»¥ä¸Šä»£ç çš„æœ¬è´¨è¿˜æ˜¯å¯¹ `Cell` çš„è¿ç”¨ï¼Œåªä¸è¿‡è¿™ä¸¤ä¸ªæ–¹æ³•å¯ä»¥å¾ˆæ–¹ä¾¿çš„å¸®æˆ‘ä»¬æŠŠ `&mut [T]` ç±»å‹è½¬æ¢æˆ `&[Cell<T>]` ç±»å‹ã€‚

## æ€»ç»“

`Cell` å’Œ `RefCell` éƒ½ä¸ºæˆ‘ä»¬å¸¦æ¥äº†å†…éƒ¨å¯å˜æ€§è¿™ä¸ªé‡è¦ç‰¹æ€§ï¼ŒåŒæ—¶è¿˜å°†å€Ÿç”¨è§„åˆ™çš„æ£€æŸ¥ä»ç¼–è¯‘æœŸæ¨è¿Ÿåˆ°è¿è¡ŒæœŸï¼Œä½†æ˜¯è¿™ä¸ªæ£€æŸ¥å¹¶ä¸èƒ½è¢«ç»•è¿‡ï¼Œè¯¥æ¥æ—©æ™šè¿˜æ˜¯ä¼šæ¥ï¼Œ`RefCell` åœ¨è¿è¡ŒæœŸçš„æŠ¥é”™ä¼šé€ æˆ `panic`ã€‚

`RefCell` é€‚ç”¨äºç¼–è¯‘å™¨è¯¯æŠ¥æˆ–è€…ä¸€ä¸ªå¼•ç”¨è¢«åœ¨å¤šä¸ªä»£ç ä¸­ä½¿ç”¨ã€ä¿®æ”¹ä»¥è‡³äºéš¾äºç®¡ç†å€Ÿç”¨å…³ç³»æ—¶ï¼Œè¿˜æœ‰å°±æ˜¯éœ€è¦å†…éƒ¨å¯å˜æ€§æ—¶ã€‚

ä»æ€§èƒ½ä¸Šçœ‹ï¼Œ`RefCell` ç”±äºæ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œå› æ­¤æ— éœ€ä¿è¯åŸå­æ€§ï¼Œæ€§èƒ½è™½ç„¶æœ‰ä¸€ç‚¹æŸè€—ï¼Œä½†æ˜¯ä¾ç„¶éå¸¸å¥½ï¼Œè€Œ `Cell` åˆ™å®Œå…¨ä¸å­˜åœ¨ä»»ä½•é¢å¤–çš„æ€§èƒ½æŸè€—ã€‚

`Rc` è·Ÿ `RefCell` ç»“åˆä½¿ç”¨å¯ä»¥å®ç°å¤šä¸ªæ‰€æœ‰è€…å…±äº«åŒä¸€ä»½æ•°æ®ï¼Œéå¸¸å¥½ç”¨ï¼Œä½†æ˜¯æ½œåœ¨çš„æ€§èƒ½æŸè€—ä¹Ÿè¦è€ƒè™‘è¿›å»ï¼Œå»ºè®®å¯¹äºçƒ­ç‚¹ä»£ç ä½¿ç”¨æ—¶ï¼Œåšå¥½ `benchmark`ã€‚



================================================
FILE: src/advance/smart-pointer/deref.md
================================================
# Deref è§£å¼•ç”¨
åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€æ®µä»£ç ï¼š
```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

impl Person {
    fn new(name: String, age: u8) -> Self {
        Person { name, age}
    }

    fn display(self: &mut Person, age: u8) {
        let Person{name, age} = &self;
    }
}
```

ä»¥ä¸Šä»£ç æœ‰ä¸€ä¸ªå¾ˆå¥‡æ€ªçš„åœ°æ–¹ï¼šåœ¨ `display` æ–¹æ³•ä¸­ï¼Œ`self` æ˜¯ `&mut Person` çš„ç±»å‹ï¼Œæ¥ç€æˆ‘ä»¬å¯¹å…¶å–äº†ä¸€æ¬¡å¼•ç”¨ `&self`ï¼Œæ­¤æ—¶ `&self` çš„ç±»å‹æ˜¯ `&&mut Person`ï¼Œç„¶åæˆ‘ä»¬åˆå°†å…¶å’Œ `Person` ç±»å‹è¿›è¡ŒåŒ¹é…ï¼Œå–å‡ºå…¶ä¸­çš„å€¼ã€‚

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼ŒRust ä¸æ˜¯å·ç§°å®‰å…¨çš„è¯­è¨€å—ï¼Ÿä¸ºä½•å…è®¸å°† `&&mut Person` è·Ÿ `Person` è¿›è¡ŒåŒ¹é…å‘¢ï¼Ÿç­”æ¡ˆå°±åœ¨æœ¬ç« èŠ‚ä¸­ï¼Œç­‰å¤§å®¶å­¦å®Œåï¼Œå†å›å¤´è‡ªå·±æ¥è§£å†³è¿™ä¸ªé—®é¢˜ :) ä¸‹é¢æ­£å¼å¼€å§‹å’±ä»¬çš„æ–°ç« èŠ‚å­¦ä¹ ã€‚

ä½•ä¸ºæ™ºèƒ½æŒ‡é’ˆï¼Ÿèƒ½ä¸è®©ä½ å†™å‡º `****s` å½¢å¼çš„è§£å¼•ç”¨ï¼Œæˆ‘è®¤ä¸ºå°±æ˜¯æ™ºèƒ½: )ï¼Œæ™ºèƒ½æŒ‡é’ˆçš„åç§°æ¥æºï¼Œä¸»è¦å°±åœ¨äºå®ƒå®ç°äº† `Deref` å’Œ `Drop` ç‰¹å¾ï¼Œè¿™ä¸¤ä¸ªç‰¹å¾å¯ä»¥æ™ºèƒ½åœ°å¸®åŠ©æˆ‘ä»¬èŠ‚çœä½¿ç”¨ä¸Šçš„è´Ÿæ‹…ï¼š

- `Deref` å¯ä»¥è®©æ™ºèƒ½æŒ‡é’ˆåƒå¼•ç”¨é‚£æ ·å·¥ä½œï¼Œè¿™æ ·ä½ å°±å¯ä»¥å†™å‡ºåŒæ—¶æ”¯æŒæ™ºèƒ½æŒ‡é’ˆå’Œå¼•ç”¨çš„ä»£ç ï¼Œä¾‹å¦‚ `*T`
- `Drop` å…è®¸ä½ æŒ‡å®šæ™ºèƒ½æŒ‡é’ˆè¶…å‡ºä½œç”¨åŸŸåè‡ªåŠ¨æ‰§è¡Œçš„ä»£ç ï¼Œä¾‹å¦‚åšä¸€äº›æ•°æ®æ¸…é™¤ç­‰æ”¶å°¾å·¥ä½œ

å…ˆæ¥çœ‹çœ‹ `Deref` ç‰¹å¾æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚

## é€šè¿‡ `*` è·å–å¼•ç”¨èƒŒåçš„å€¼

åœ¨æ­£å¼è®²è§£ `Deref` ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹å¸¸è§„å¼•ç”¨çš„è§£å¼•ç”¨ã€‚


å¸¸è§„å¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼ŒåŒ…å«äº†ç›®æ ‡æ•°æ®å­˜å‚¨çš„å†…å­˜åœ°å€ã€‚å¯¹å¸¸è§„å¼•ç”¨ä½¿ç”¨ `*` æ“ä½œç¬¦ï¼Œå°±å¯ä»¥é€šè¿‡è§£å¼•ç”¨çš„æ–¹å¼è·å–åˆ°å†…å­˜åœ°å€å¯¹åº”çš„æ•°æ®å€¼ï¼š

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

è¿™é‡Œ `y` å°±æ˜¯ä¸€ä¸ªå¸¸è§„å¼•ç”¨ï¼ŒåŒ…å«äº†å€¼ `5` æ‰€åœ¨çš„å†…å­˜åœ°å€ï¼Œç„¶åé€šè¿‡è§£å¼•ç”¨ `*y`ï¼Œæˆ‘ä»¬è·å–åˆ°äº†å€¼ `5`ã€‚å¦‚æœä½ è¯•å›¾æ‰§è¡Œ `assert_eq!(5, y);`ï¼Œä»£ç å°±ä¼šæ— æƒ…æŠ¥é”™ï¼Œå› ä¸ºä½ æ— æ³•å°†ä¸€ä¸ªå¼•ç”¨ä¸ä¸€ä¸ªæ•°å€¼åšæ¯”è¾ƒï¼š

```console
error[E0277]: can't compare `{integer}` with `&{integer}` //æ— æ³•å°†{integer} ä¸&{integer}è¿›è¡Œæ¯”è¾ƒ
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
                    // ä½ éœ€è¦ä¸º{integer}å®ç°ç”¨äºæ¯”è¾ƒçš„ç‰¹å¾PartialEq<&{integer}>
```

## æ™ºèƒ½æŒ‡é’ˆè§£å¼•ç”¨

ä¸Šé¢æ‰€è¯´çš„è§£å¼•ç”¨æ–¹å¼å’Œå…¶å®ƒå¤§å¤šæ•°è¯­è¨€å¹¶æ— åŒºåˆ«ï¼Œä½†æ˜¯ Rust ä¸­å°†è§£å¼•ç”¨æå‡åˆ°äº†ä¸€ä¸ªæ–°é«˜åº¦ã€‚è€ƒè™‘ä¸€ä¸‹æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªç»“æ„ä½“ç±»å‹ï¼Œå¦‚æœä½ ç›´æ¥å¯¹å®ƒè¿›è¡Œ `*myStruct`ï¼Œæ˜¾ç„¶ç¼–è¯‘å™¨ä¸çŸ¥é“è¯¥å¦‚ä½•åŠï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ºæ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ç° `Deref` ç‰¹å¾ã€‚

å®ç° `Deref` åçš„æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“ï¼Œå°±å¯ä»¥åƒæ™®é€šå¼•ç”¨ä¸€æ ·ï¼Œé€šè¿‡ `*` è¿›è¡Œè§£å¼•ç”¨ï¼Œä¾‹å¦‚ `Box<T>` æ™ºèƒ½æŒ‡é’ˆï¼š

```rust
fn main() {
    let x = Box::new(1);
    let sum = *x + 1;
}
```

æ™ºèƒ½æŒ‡é’ˆ `x` è¢« `*` è§£å¼•ç”¨ä¸º `i32` ç±»å‹çš„å€¼ `1`ï¼Œç„¶åå†è¿›è¡Œæ±‚å’Œã€‚

#### å®šä¹‰è‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆ

ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¥å®ç°ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼ŒåŠŸèƒ½ä¸Šç±»ä¼¼ `Box<T>`ã€‚ç”±äº `Box<T>` æœ¬èº«å¾ˆç®€å•ï¼Œå¹¶æ²¡æœ‰åŒ…å«ç±»å¦‚é•¿åº¦ã€æœ€å¤§é•¿åº¦ç­‰ä¿¡æ¯ï¼Œå› æ­¤ç”¨ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“å³å¯ã€‚

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

è·Ÿ `Box<T>` ä¸€æ ·ï¼Œæˆ‘ä»¬çš„æ™ºèƒ½æŒ‡é’ˆä¹ŸæŒæœ‰ä¸€ä¸ª `T` ç±»å‹çš„å€¼ï¼Œç„¶åä½¿ç”¨å…³è”å‡½æ•° `MyBox::new` æ¥åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆã€‚ç”±äºè¿˜æœªå®ç° `Deref` ç‰¹å¾ï¼Œæ­¤æ—¶ä½¿ç”¨ `*` è‚¯å®šä¼šæŠ¥é”™ï¼š

```rust
fn main() {
    let y = MyBox::new(5);

    assert_eq!(5, *y);
}
```

è¿è¡Œåï¼ŒæŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:12:19
   |
12 |     assert_eq!(5, *y);
   |                   ^^
```

##### ä¸ºæ™ºèƒ½æŒ‡é’ˆå®ç° Deref ç‰¹å¾

ç°åœ¨æ¥ä¸º `MyBox` å®ç° `Deref` ç‰¹å¾ï¼Œä»¥æ”¯æŒ `*` è§£å¼•ç”¨æ“ä½œç¬¦ï¼š

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

å¾ˆç®€å•ï¼Œå½“è§£å¼•ç”¨ `MyBox` æ™ºèƒ½æŒ‡é’ˆæ—¶ï¼Œè¿”å›å…ƒç»„ç»“æ„ä½“ä¸­çš„å…ƒç´  `&self.0`ï¼Œæœ‰å‡ ç‚¹è¦æ³¨æ„çš„ï¼š

- åœ¨ `Deref` ç‰¹å¾ä¸­å£°æ˜äº†å…³è”ç±»å‹ `Target`ï¼Œåœ¨ä¹‹å‰ç« èŠ‚ä¸­ä»‹ç»è¿‡ï¼Œå…³è”ç±»å‹ä¸»è¦æ˜¯ä¸ºäº†æå‡ä»£ç å¯è¯»æ€§
- `deref` è¿”å›çš„æ˜¯ä¸€ä¸ªå¸¸è§„å¼•ç”¨ï¼Œå¯ä»¥è¢« `*` è¿›è¡Œè§£å¼•ç”¨

ä¹‹å‰æŠ¥é”™çš„ä»£ç æ­¤æ—¶å·²èƒ½é¡ºåˆ©ç¼–è¯‘é€šè¿‡ã€‚å½“ç„¶ï¼Œæ ‡å‡†åº“å®ç°çš„æ™ºèƒ½æŒ‡é’ˆè¦è€ƒè™‘å¾ˆå¤šè¾¹è¾¹è§’è§’æƒ…å†µï¼Œè‚¯å®šæ¯”æˆ‘ä»¬çš„å®ç°è¦å¤æ‚ã€‚

## `*` èƒŒåçš„åŸç†

å½“æˆ‘ä»¬å¯¹æ™ºèƒ½æŒ‡é’ˆ `Box` è¿›è¡Œè§£å¼•ç”¨æ—¶ï¼Œå®é™…ä¸Š Rust ä¸ºæˆ‘ä»¬è°ƒç”¨äº†ä»¥ä¸‹æ–¹æ³•ï¼š

```rust
*(y.deref())
```

é¦–å…ˆè°ƒç”¨ `deref` æ–¹æ³•è¿”å›å€¼çš„å¸¸è§„å¼•ç”¨ï¼Œç„¶åé€šè¿‡ `*` å¯¹å¸¸è§„å¼•ç”¨è¿›è¡Œè§£å¼•ç”¨ï¼Œæœ€ç»ˆè·å–åˆ°ç›®æ ‡å€¼ã€‚

è‡³äº Rust ä¸ºä½•è¦ä½¿ç”¨è¿™ä¸ªæœ‰ç‚¹å•°å—¦çš„æ–¹å¼å®ç°ï¼ŒåŸå› åœ¨äºæ‰€æœ‰æƒç³»ç»Ÿçš„å­˜åœ¨ã€‚å¦‚æœ `deref` æ–¹æ³•ç›´æ¥è¿”å›ä¸€ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å¼•ç”¨ï¼Œé‚£ä¹ˆè¯¥å€¼çš„æ‰€æœ‰æƒå°†è¢«è½¬ç§»ç»™è°ƒç”¨è€…ï¼Œè€Œæˆ‘ä»¬ä¸å¸Œæœ›è°ƒç”¨è€…ä»…ä»…åªæ˜¯ `*T` ä¸€ä¸‹ï¼Œå°±æ‹¿èµ°äº†æ™ºèƒ½æŒ‡é’ˆä¸­åŒ…å«çš„å€¼ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`*` ä¸ä¼šæ— é™é€’å½’æ›¿æ¢ï¼Œä» `*y` åˆ° `*(y.deref())` åªä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œè€Œä¸ä¼šç»§ç»­è¿›è¡Œæ›¿æ¢ç„¶åäº§ç”Ÿå½¢å¦‚ `*((y.deref()).deref())` çš„æ€ªç‰©ã€‚

## å‡½æ•°å’Œæ–¹æ³•ä¸­çš„éšå¼ Deref è½¬æ¢

å¯¹äºå‡½æ•°å’Œæ–¹æ³•çš„ä¼ å‚ï¼ŒRust æä¾›äº†ä¸€ä¸ªæå…¶æœ‰ç”¨çš„éšå¼è½¬æ¢ï¼š`Deref `è½¬æ¢ã€‚è‹¥ä¸€ä¸ªç±»å‹å®ç°äº† `Deref` ç‰¹å¾ï¼Œé‚£å®ƒçš„å¼•ç”¨åœ¨ä¼ ç»™å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œä¼šæ ¹æ®å‚æ•°ç­¾åæ¥å†³å®šæ˜¯å¦è¿›è¡Œéšå¼çš„ `Deref` è½¬æ¢ï¼Œä¾‹å¦‚ï¼š

```rust
fn main() {
    let s = String::from("hello world");
    display(&s)
}

fn display(s: &str) {
    println!("{}",s);
}
```

ä»¥ä¸Šä»£ç æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- `String` å®ç°äº† `Deref` ç‰¹å¾ï¼Œå¯ä»¥åœ¨éœ€è¦æ—¶è‡ªåŠ¨è¢«è½¬æ¢ä¸º `&str` ç±»å‹
- `&s` æ˜¯ä¸€ä¸ª `&String` ç±»å‹ï¼Œå½“å®ƒè¢«ä¼ ç»™ `display` å‡½æ•°æ—¶ï¼Œè‡ªåŠ¨é€šè¿‡ `Deref` è½¬æ¢æˆäº† `&str`
- å¿…é¡»ä½¿ç”¨ `&s` çš„æ–¹å¼æ¥è§¦å‘ `Deref`(ä»…å¼•ç”¨ç±»å‹çš„å®å‚æ‰ä¼šè§¦å‘è‡ªåŠ¨è§£å¼•ç”¨)

#### è¿ç»­çš„éšå¼ Deref è½¬æ¢

å¦‚æœä½ ä»¥ä¸º `Deref` ä»…ä»…è¿™ç‚¹ä½œç”¨ï¼Œé‚£å°±å¤§é”™ç‰¹é”™äº†ã€‚`Deref` å¯ä»¥æ”¯æŒè¿ç»­çš„éšå¼è½¬æ¢ï¼Œç›´åˆ°æ‰¾åˆ°é€‚åˆçš„å½¢å¼ä¸ºæ­¢ï¼š

```rust
fn main() {
    let s = MyBox::new(String::from("hello world"));
    display(&s)
}

fn display(s: &str) {
    println!("{}",s);
}
```

è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¹‹å‰è‡ªå®šä¹‰çš„æ™ºèƒ½æŒ‡é’ˆ `MyBox`ï¼Œå¹¶å°†å…¶é€šè¿‡è¿ç»­çš„éšå¼è½¬æ¢å˜æˆ `&str` ç±»å‹ï¼šé¦–å…ˆ `MyBox` è¢« `Deref` æˆ `String` ç±»å‹ï¼Œç»“æœå¹¶ä¸èƒ½æ»¡è¶³ `display` å‡½æ•°å‚æ•°çš„è¦æ±‚ï¼Œç¼–è¯‘å™¨å‘ç° `String` è¿˜å¯ä»¥ç»§ç»­ `Deref` æˆ `&str`ï¼Œæœ€ç»ˆæˆåŠŸçš„åŒ¹é…äº†å‡½æ•°å‚æ•°ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œå‡å¦‚ `Rust` æ²¡æœ‰æä¾›è¿™ç§éšå¼è½¬æ¢ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•è°ƒç”¨ `display` å‡½æ•°ï¼Ÿ

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    display(&(*m)[..]);
}
```

ç»“æœä¸è¨€è€Œå–»ï¼Œè‚¯å®šæ˜¯ `&s` çš„æ–¹å¼ä¼˜ç§€å¾—å¤šã€‚æ€»ä¹‹ï¼Œå½“å‚ä¸å…¶ä¸­çš„ç±»å‹å®šä¹‰äº† `Deref` ç‰¹å¾æ—¶ï¼ŒRust ä¼šåˆ†æè¯¥ç±»å‹å¹¶ä¸”è¿ç»­ä½¿ç”¨ `Deref` ç›´åˆ°æœ€ç»ˆè·å¾—ä¸€ä¸ªå¼•ç”¨æ¥åŒ¹é…å‡½æ•°æˆ–è€…æ–¹æ³•çš„å‚æ•°ç±»å‹ï¼Œè¿™ç§è¡Œä¸ºå®Œå…¨ä¸ä¼šé€ æˆä»»ä½•çš„æ€§èƒ½æŸè€—ï¼Œå› ä¸ºå®Œå…¨æ˜¯åœ¨ç¼–è¯‘æœŸå®Œæˆã€‚

ä½†æ˜¯ `Deref` å¹¶ä¸æ˜¯æ²¡æœ‰ç¼ºç‚¹ï¼Œç¼ºç‚¹å°±æ˜¯ï¼šå¦‚æœä½ ä¸çŸ¥é“æŸä¸ªç±»å‹æ˜¯å¦å®ç°äº† `Deref` ç‰¹å¾ï¼Œé‚£ä¹ˆåœ¨çœ‹åˆ°æŸæ®µä»£ç æ—¶ï¼Œå¹¶ä¸èƒ½åœ¨ç¬¬ä¸€æ—¶é—´ååº”è¿‡æ¥è¯¥ä»£ç å‘ç”Ÿäº†éšå¼çš„ `Deref` è½¬æ¢ã€‚äº‹å®ä¸Šï¼Œä¸ä»…ä»…æ˜¯ `Deref`ï¼Œåœ¨ Rust ä¸­è¿˜æœ‰å„ç§ `From/Into` ç­‰ç­‰ä¼šç»™é˜…è¯»ä»£ç å¸¦æ¥ä¸€å®šè´Ÿæ‹…çš„ç‰¹å¾ã€‚è¿˜æ˜¯é‚£å¥è¯ï¼Œä¸€åˆ‡é€‰æ‹©éƒ½æ˜¯æƒè¡¡ï¼Œæœ‰å¾—å¿…æœ‰å¤±ï¼Œå¾—äº†ä»£ç çš„ç®€æ´æ€§ï¼Œå¾€å¾€å°±å¤±å»äº†å¯è¯»æ€§ï¼ŒGo è¯­è¨€å°±æ˜¯ä¸€ä¸ªåˆšå¥½ç›¸åçš„ä¾‹å­ã€‚

å†æ¥çœ‹ä¸€ä¸‹åœ¨æ–¹æ³•ã€èµ‹å€¼ä¸­è‡ªåŠ¨åº”ç”¨ `Deref` çš„ä¾‹å­ï¼š

```rust
fn main() {
    let s = MyBox::new(String::from("hello, world"));
    let s1: &str = &s;
    let s2: String = s.to_string();
}
```

å¯¹äº `s1`ï¼Œæˆ‘ä»¬é€šè¿‡ä¸¤æ¬¡ `Deref` å°† `&str` ç±»å‹çš„å€¼èµ‹ç»™äº†å®ƒï¼ˆ**èµ‹å€¼æ“ä½œéœ€è¦æ‰‹åŠ¨è§£å¼•ç”¨**ï¼‰ï¼›è€Œå¯¹äº `s2`ï¼Œæˆ‘ä»¬åœ¨å…¶ä¸Šç›´æ¥è°ƒç”¨æ–¹æ³• `to_string`ï¼Œå®é™…ä¸Š `MyBox` æ ¹æœ¬æ²¡æœ‰æ²¡æœ‰å®ç°è¯¥æ–¹æ³•ï¼Œèƒ½è°ƒç”¨ `to_string`ï¼Œå®Œå…¨æ˜¯å› ä¸ºç¼–è¯‘å™¨å¯¹ `MyBox` åº”ç”¨äº† `Deref` çš„ç»“æœï¼ˆ**æ–¹æ³•è°ƒç”¨ä¼šè‡ªåŠ¨è§£å¼•ç”¨**ï¼‰ã€‚

## Deref è§„åˆ™æ€»ç»“

åœ¨ä¸Šé¢ï¼Œæˆ‘ä»¬é›¶ç¢çš„ä»‹ç»äº†ä¸å°‘å…³äº `Deref` ç‰¹å¾çš„çŸ¥è¯†ï¼Œä¸‹é¢æ¥é€šè¿‡è¾ƒä¸ºæ­£å¼çš„æ–¹å¼æ¥å¯¹å…¶è§„åˆ™è¿›è¡Œä¸‹æ€»ç»“ã€‚

ä¸€ä¸ªç±»å‹ä¸º `T` çš„å¯¹è±¡ `foo`ï¼Œå¦‚æœ `T: Deref<Target=U>`ï¼Œé‚£ä¹ˆï¼Œç›¸å…³ `foo` çš„å¼•ç”¨ `&foo` åœ¨åº”ç”¨çš„æ—¶å€™ä¼šè‡ªåŠ¨è½¬æ¢ä¸º `&U`ã€‚

ç²—çœ‹è¿™æ¡è§„åˆ™ï¼Œè²Œä¼¼æœ‰ç‚¹ç±»ä¼¼äº `AsRef`ï¼Œè€Œè·Ÿ `è§£å¼•ç”¨` ä¼¼ä¹é£é©¬ç‰›ä¸ç›¸åŠï¼Œå®é™…é‡Œé¢æœ‰äº›ç„å¦™ä¹‹å¤„ã€‚

#### å¼•ç”¨å½’ä¸€åŒ–

Rust ç¼–è¯‘å™¨å®é™…ä¸Šåªèƒ½å¯¹ `&v` å½¢å¼çš„å¼•ç”¨è¿›è¡Œè§£å¼•ç”¨æ“ä½œï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæˆ–è€… `&&&&v` ç±»å‹çš„å‘¢ï¼Ÿ è¯¥å¦‚ä½•å¯¹è¿™ä¸¤ä¸ªè¿›è¡Œè§£å¼•ç”¨ï¼Ÿ

ç­”æ¡ˆæ˜¯ï¼šRust ä¼šåœ¨è§£å¼•ç”¨æ—¶è‡ªåŠ¨æŠŠæ™ºèƒ½æŒ‡é’ˆå’Œ `&&&&v` åšå¼•ç”¨å½’ä¸€åŒ–æ“ä½œï¼Œè½¬æ¢æˆ `&v` å½¢å¼ï¼Œæœ€ç»ˆå†å¯¹ `&v` è¿›è¡Œè§£å¼•ç”¨ï¼š

- æŠŠæ™ºèƒ½æŒ‡é’ˆï¼ˆæ¯”å¦‚åœ¨åº“ä¸­å®šä¹‰çš„ï¼ŒBoxã€Rcã€Arcã€Cow ç­‰ï¼‰ä»ç»“æ„ä½“è„±å£³ä¸ºå†…éƒ¨çš„å¼•ç”¨ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è½¬æˆç»“æ„ä½“å†…éƒ¨çš„ `&v`
- æŠŠå¤šé‡`&`ï¼Œä¾‹å¦‚ `&&&&&&&v`ï¼Œå½’ä¸€æˆ `&v`

å…³äºç¬¬äºŒç§æƒ…å†µï¼Œè¿™ä¹ˆå¹²å·´å·´çš„è¯´ï¼Œä¹Ÿè®¸å¤§å®¶ä¼šè¿·è¿·ç³Šç³Šçš„ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€æ®µæ ‡å‡†åº“æºç ï¼š

```rust
impl<T: ?Sized> Deref for &T {
    type Target = T;

    fn deref(&self) -> &T {
        *self
    }
}
```

åœ¨è¿™æ®µæºç ä¸­ï¼Œ`&T` è¢«è‡ªåŠ¨è§£å¼•ç”¨ä¸º `T`ï¼Œä¹Ÿå°±æ˜¯ `&T: Deref<Target=T>` ã€‚ æŒ‰ç…§è¿™ä¸ªä»£ç ï¼Œ`&&&&T` ä¼šè¢«è‡ªåŠ¨è§£å¼•ç”¨ä¸º `&&&T`ï¼Œç„¶åå†è‡ªåŠ¨è§£å¼•ç”¨ä¸º `&&T`ï¼Œä»¥æ­¤ç±»æ¨ï¼Œ ç›´åˆ°æœ€ç»ˆå˜æˆ `&T`ã€‚

PS: ä»¥ä¸‹æ˜¯ `LLVM` ç¼–è¯‘åçš„éƒ¨åˆ†ä¸­é—´å±‚ä»£ç ï¼š

```rust
// Rust ä»£ç 
let mut _2: &i32;
let _3: &&&&i32;

bb0: {
    _2 = (*(*(*_3)))
}
```

#### å‡ ä¸ªä¾‹å­

```rust
    fn foo(s: &str) {}

    // ç”±äº String å®ç°äº† Deref<Target=str>
    let owned = "Hello".to_string();

    // å› æ­¤ä¸‹é¢çš„å‡½æ•°å¯ä»¥æ­£å¸¸è¿è¡Œï¼š
    foo(&owned);
```

```rust
    use std::rc::Rc;

    fn foo(s: &str) {}

    // String å®ç°äº† Deref<Target=str>
    let owned = "Hello".to_string();
    // ä¸” Rc æ™ºèƒ½æŒ‡é’ˆå¯ä»¥è¢«è‡ªåŠ¨è„±å£³ä¸ºå†…éƒ¨çš„ `owned` å¼•ç”¨ï¼š &String ï¼Œç„¶å &String å†è‡ªåŠ¨è§£å¼•ç”¨ä¸º &str
    let counted = Rc::new(owned);

    // å› æ­¤ä¸‹é¢çš„å‡½æ•°å¯ä»¥æ­£å¸¸è¿è¡Œ:
    foo(&counted);
```

```rust
    struct Foo;

    impl Foo {
        fn foo(&self) { println!("Foo"); }
    }

    let f = &&Foo;

    f.foo();
    (&f).foo();
    (&&f).foo();
    (&&&&&&&&f).foo();
```

## ä¸‰ç§ Deref è½¬æ¢

åœ¨ä¹‹å‰ï¼Œæˆ‘ä»¬è®²çš„éƒ½æ˜¯ä¸å¯å˜çš„ `Deref` è½¬æ¢ï¼Œå®é™…ä¸Š Rust è¿˜æ”¯æŒå°†ä¸€ä¸ªå¯å˜çš„å¼•ç”¨è½¬æ¢æˆå¦ä¸€ä¸ªå¯å˜çš„å¼•ç”¨ä»¥åŠå°†ä¸€ä¸ªå¯å˜å¼•ç”¨è½¬æ¢æˆä¸å¯å˜çš„å¼•ç”¨ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š

- å½“ `T: Deref<Target=U>`ï¼Œå¯ä»¥å°† `&T` è½¬æ¢æˆ `&U`ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ä¾‹å­
- å½“ `T: DerefMut<Target=U>`ï¼Œå¯ä»¥å°† `&mut T` è½¬æ¢æˆ `&mut U`
- å½“ `T: Deref<Target=U>`ï¼Œå¯ä»¥å°† `&mut T` è½¬æ¢æˆ `&U`

æ¥çœ‹ä¸€ä¸ªå…³äº `DerefMut` çš„ä¾‹å­ï¼š

```rust
struct MyBox<T> {
    v: T,
}

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox { v: x }
    }
}

use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.v
    }
}

use std::ops::DerefMut;

impl<T> DerefMut for MyBox<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.v
    }
}

fn main() {
    let mut s = MyBox::new(String::from("hello, "));
    display(&mut s)
}

fn display(s: &mut String) {
    s.push_str("world");
    println!("{}", s);
}
```

ä»¥ä¸Šä»£ç æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„:

- è¦å®ç° `DerefMut` å¿…é¡»è¦å…ˆå®ç° `Deref` ç‰¹å¾ï¼š`pub trait DerefMut: Deref`
- `T: DerefMut<Target=U>` è§£è¯»ï¼šå°† `&mut T` ç±»å‹é€šè¿‡ `DerefMut` ç‰¹å¾çš„æ–¹æ³•è½¬æ¢ä¸º `&mut U` ç±»å‹ï¼Œå¯¹åº”ä¸Šä¾‹ä¸­ï¼Œå°±æ˜¯å°† `&mut MyBox<String>` è½¬æ¢ä¸º `&mut String`

å¯¹äºä¸Šè¿°ä¸‰æ¡è§„åˆ™ä¸­çš„ç¬¬ä¸‰æ¡ï¼Œå®ƒæ¯”å¦å¤–ä¸¤æ¡ç¨å¾®å¤æ‚äº†ç‚¹ï¼šRust å¯ä»¥æŠŠå¯å˜å¼•ç”¨éšå¼çš„è½¬æ¢æˆä¸å¯å˜å¼•ç”¨ï¼Œä½†åä¹‹åˆ™ä¸è¡Œã€‚

å¦‚æœä» Rust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™çš„è§’åº¦è€ƒè™‘ï¼Œå½“ä½ æ‹¥æœ‰ä¸€ä¸ªå¯å˜çš„å¼•ç”¨ï¼Œé‚£è¯¥å¼•ç”¨è‚¯å®šæ˜¯å¯¹åº”æ•°æ®çš„å”¯ä¸€å€Ÿç”¨ï¼Œé‚£ä¹ˆæ­¤æ—¶å°†å¯å˜å¼•ç”¨å˜æˆä¸å¯å˜å¼•ç”¨å¹¶ä¸ä¼šç ´åå€Ÿç”¨è§„åˆ™ï¼›ä½†æ˜¯å¦‚æœä½ æ‹¥æœ‰ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œé‚£åŒæ—¶å¯èƒ½è¿˜å­˜åœ¨å…¶å®ƒå‡ ä¸ªä¸å¯å˜çš„å¼•ç”¨ï¼Œå¦‚æœæ­¤æ—¶å°†å…¶ä¸­ä¸€ä¸ªä¸å¯å˜å¼•ç”¨è½¬æ¢æˆå¯å˜å¼•ç”¨ï¼Œå°±å˜æˆäº†å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨çš„å…±å­˜ï¼Œæœ€ç»ˆç ´åäº†å€Ÿç”¨è§„åˆ™ã€‚

## æ€»ç»“

`Deref` å¯ä»¥è¯´æ˜¯ Rust ä¸­æœ€å¸¸è§çš„éšå¼ç±»å‹è½¬æ¢ï¼Œè€Œä¸”å®ƒå¯ä»¥è¿ç»­çš„å®ç°å¦‚ `Box<String> -> String -> &str` çš„éšå¼è½¬æ¢ï¼Œåªè¦é“¾æ¡ä¸Šçš„ç±»å‹å®ç°äº† `Deref` ç‰¹å¾ã€‚

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºè‡ªå·±çš„ç±»å‹å®ç° `Deref` ç‰¹å¾ï¼Œä½†æ˜¯åŸåˆ™ä¸Šæ¥è¯´ï¼Œåªåº”è¯¥ä¸ºè‡ªå®šä¹‰çš„æ™ºèƒ½æŒ‡é’ˆå®ç° `Deref`ã€‚ä¾‹å¦‚ï¼Œè™½ç„¶ä½ å¯ä»¥ä¸ºè‡ªå·±çš„è‡ªå®šä¹‰æ•°ç»„ç±»å‹å®ç° `Deref` ä»¥é¿å… `myArr.0[0]` çš„ä½¿ç”¨å½¢å¼ï¼Œä½†æ˜¯ Rust å®˜æ–¹å¹¶ä¸æ¨èè¿™ä¹ˆåšï¼Œç‰¹åˆ«æ˜¯åœ¨ä½ å¼€å‘ä¸‰æ–¹åº“æ—¶ã€‚



================================================
FILE: src/advance/smart-pointer/drop.md
================================================
# Drop é‡Šæ”¾èµ„æº

åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬ä¹‹æ‰€ä»¥å¯ä»¥ä¸€æ‹³æ‰“è·‘ GC çš„åŒæ—¶ä¸€è„šè¸¢ç¿»æ‰‹åŠ¨èµ„æºå›æ”¶ï¼Œä¸»è¦å°±å½’åŠŸäº `Drop` ç‰¹å¾ï¼ŒåŒæ—¶å®ƒä¹Ÿæ˜¯æ™ºèƒ½æŒ‡é’ˆçš„å¿…å¤‡ç‰¹å¾ä¹‹ä¸€ã€‚

## å­¦ä¹ ç›®æ ‡

å¦‚ä½•è‡ªåŠ¨å’Œæ‰‹åŠ¨é‡Šæ”¾èµ„æºåŠæ‰§è¡ŒæŒ‡å®šçš„æ”¶å°¾å·¥ä½œ

## Rust ä¸­çš„èµ„æºå›æ”¶

åœ¨ä¸€äº›æ—  GC è¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜åœ¨ä¸€ä¸ªå˜é‡æ— éœ€å†è¢«ä½¿ç”¨æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨é‡Šæ”¾å®ƒå ç”¨çš„å†…å­˜èµ„æºï¼Œå¦‚æœå¿˜è®°äº†ï¼Œé‚£ä¹ˆå°±ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œæœ€ç»ˆè‡­åæ˜­è‘—çš„ `OOM` é—®é¢˜å¯èƒ½å°±ä¼šå‘ç”Ÿã€‚

è€Œåœ¨ Rust ä¸­ï¼Œä½ å¯ä»¥æŒ‡å®šåœ¨ä¸€ä¸ªå˜é‡è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œæ‰§è¡Œä¸€æ®µç‰¹å®šçš„ä»£ç ï¼Œæœ€ç»ˆç¼–è¯‘å™¨å°†å¸®ä½ è‡ªåŠ¨æ’å…¥è¿™æ®µæ”¶å°¾ä»£ç ã€‚è¿™æ ·ï¼Œå°±æ— éœ€åœ¨æ¯ä¸€ä¸ªä½¿ç”¨è¯¥å˜é‡çš„åœ°æ–¹ï¼Œéƒ½å†™ä¸€æ®µä»£ç æ¥è¿›è¡Œæ”¶å°¾å·¥ä½œå’Œèµ„æºé‡Šæ”¾ã€‚ä¸ç¦è®©äººæ„Ÿå¹ï¼ŒRust çš„å¤§è…¿çœŸç²—ï¼Œé¦™ï¼

æ²¡é”™ï¼ŒæŒ‡å®šè¿™æ ·ä¸€æ®µæ”¶å°¾å·¥ä½œé çš„å°±æ˜¯å’±è¿™ç« çš„ä¸»è§’ - `Drop` ç‰¹å¾ã€‚

## ä¸€ä¸ªä¸é‚£ä¹ˆç®€å•çš„ Drop ä¾‹å­

```rust
struct HasDrop1;
struct HasDrop2;
impl Drop for HasDrop1 {
    fn drop(&mut self) {
        println!("Dropping HasDrop1!");
    }
}
impl Drop for HasDrop2 {
    fn drop(&mut self) {
        println!("Dropping HasDrop2!");
    }
}
struct HasTwoDrops {
    one: HasDrop1,
    two: HasDrop2,
}
impl Drop for HasTwoDrops {
    fn drop(&mut self) {
        println!("Dropping HasTwoDrops!");
    }
}

struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let _x = HasTwoDrops {
        two: HasDrop2,
        one: HasDrop1,
    };
    let _foo = Foo;
    println!("Running!");
}
```

ä¸Šé¢ä»£ç è™½ç„¶é•¿ï¼Œä½†æ˜¯ç›®çš„å…¶å®å¾ˆå•çº¯ï¼Œå°±æ˜¯ä¸ºäº†è§‚å¯Ÿä¸åŒæƒ…å†µä¸‹å˜é‡çº§åˆ«çš„ã€ç»“æ„ä½“å†…éƒ¨å­—æ®µçš„ `Drop`ï¼Œæœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- `Drop` ç‰¹å¾ä¸­çš„ `drop` æ–¹æ³•å€Ÿç”¨äº†ç›®æ ‡çš„å¯å˜å¼•ç”¨ï¼Œè€Œä¸æ˜¯æ‹¿èµ°äº†æ‰€æœ‰æƒï¼Œè¿™é‡Œå…ˆè®¾ç½®ä¸€ä¸ªæ‚¬å¿µï¼Œåè¾¹ä¼šè®²
- ç»“æ„ä½“ä¸­æ¯ä¸ªå­—æ®µéƒ½æœ‰è‡ªå·±çš„ `Drop`

æ¥çœ‹çœ‹è¾“å‡ºï¼š

```console
Running!
Dropping Foo!
Dropping HasTwoDrops!
Dropping HasDrop1!
Dropping HasDrop2!
```

å—¯ï¼Œç»“æœç¬¦åˆé¢„æœŸï¼Œæ¯ä¸ªèµ„æºéƒ½æˆåŠŸçš„æ‰§è¡Œäº†æ”¶å°¾å·¥ä½œï¼Œè™½ç„¶ `println!` è¿™ç§æ”¶å°¾å·¥ä½œæ¯«æ— æ„ä¹‰ =,=

#### Drop çš„é¡ºåº

è§‚å¯Ÿä»¥ä¸Šè¾“å‡ºï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä»¥ä¸‹å…³äº `Drop` é¡ºåºçš„ç»“è®º

- **å˜é‡çº§åˆ«ï¼ŒæŒ‰ç…§é€†åºçš„æ–¹å¼**ï¼Œ`_x` åœ¨ `_foo` ä¹‹å‰åˆ›å»ºï¼Œå› æ­¤ `_x` åœ¨ `_foo` ä¹‹åè¢« `drop`
- **ç»“æ„ä½“å†…éƒ¨ï¼ŒæŒ‰ç…§é¡ºåºçš„æ–¹å¼**ï¼Œç»“æ„ä½“ `_x` ä¸­çš„å­—æ®µæŒ‰ç…§å®šä¹‰ä¸­çš„é¡ºåºä¾æ¬¡ `drop`

#### æ²¡æœ‰å®ç° Drop çš„ç»“æ„ä½“

å®é™…ä¸Šï¼Œå°±ç®—ä½ ä¸ä¸º `_x` ç»“æ„ä½“å®ç° `Drop` ç‰¹å¾ï¼Œå®ƒå†…éƒ¨çš„ä¸¤ä¸ªå­—æ®µä¾ç„¶ä¼šè°ƒç”¨ `drop`ï¼Œç§»é™¤ä»¥ä¸‹ä»£ç ï¼Œå¹¶è§‚å¯Ÿè¾“å‡ºï¼š

```rust
impl Drop for HasTwoDrops {
    fn drop(&mut self) {
        println!("Dropping HasTwoDrops!");
    }
}
```

åŸå› åœ¨äºï¼ŒRust è‡ªåŠ¨ä¸ºå‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å®ç°äº† `Drop` ç‰¹å¾ï¼Œå› æ­¤å°±ç®—ä½ ä¸æ‰‹åŠ¨ä¸ºç»“æ„ä½“å®ç° `Drop`ï¼Œå®ƒä¾ç„¶ä¼šè°ƒç”¨é»˜è®¤å®ç°çš„ `drop` å‡½æ•°ï¼ŒåŒæ—¶å†è°ƒç”¨æ¯ä¸ªå­—æ®µçš„ `drop` æ–¹æ³•ï¼Œæœ€ç»ˆæ‰“å°å‡ºï¼š

```cnosole
Dropping HasDrop1!
Dropping HasDrop2!
```

## æ‰‹åŠ¨å›æ”¶

å½“ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ¥ç®¡ç†é”çš„æ—¶å€™ï¼Œä½ å¯èƒ½å¸Œæœ›æå‰é‡Šæ”¾è¿™ä¸ªé”ï¼Œç„¶åè®©å…¶å®ƒä»£ç èƒ½åŠæ—¶è·å¾—é”ï¼Œæ­¤æ—¶å°±éœ€è¦æå‰å»æ‰‹åŠ¨ `drop`ã€‚
ä½†æ˜¯åœ¨ä¹‹å‰æˆ‘ä»¬æåˆ°ä¸€ä¸ªæ‚¬å¿µï¼Œ`Drop::drop` åªæ˜¯å€Ÿç”¨äº†ç›®æ ‡å€¼çš„å¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥ï¼Œå°±ç®—ä½ æå‰è°ƒç”¨äº† `drop`ï¼Œåé¢çš„ä»£ç ä¾ç„¶å¯ä»¥ä½¿ç”¨ç›®æ ‡å€¼ï¼Œä½†æ˜¯è¿™å°±ä¼šè®¿é—®ä¸€ä¸ªå¹¶ä¸å­˜åœ¨çš„å€¼ï¼Œéå¸¸ä¸å®‰å…¨ï¼Œå¥½åœ¨ Rust ä¼šé˜»æ­¢ä½ ï¼š

```rust
#[derive(Debug)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let foo = Foo;
    foo.drop();
    println!("Running!:{:?}", foo);
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0040]: explicit use of destructor method
  --> src/main.rs:37:9
   |
37 |     foo.drop();
   |     ----^^^^--
   |     |   |
   |     |   explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(foo)`
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œç¼–è¯‘å™¨ç›´æ¥é˜»æ­¢äº†æˆ‘ä»¬è°ƒç”¨ `Drop` ç‰¹å¾çš„ `drop` æ–¹æ³•ï¼ŒåŸå› æ˜¯å¯¹äº Rust è€Œè¨€ï¼Œä¸å…è®¸æ˜¾å¼åœ°è°ƒç”¨ææ„å‡½æ•°ï¼ˆè¿™æ˜¯ä¸€ä¸ªç”¨æ¥æ¸…ç†å®ä¾‹çš„é€šç”¨ç¼–ç¨‹æ¦‚å¿µï¼‰ã€‚å¥½åœ¨åœ¨æŠ¥é”™çš„åŒæ—¶ï¼Œç¼–è¯‘å™¨è¿˜ç»™å‡ºäº†ä¸€ä¸ªæç¤ºï¼šä½¿ç”¨ `drop` å‡½æ•°ã€‚

é’ˆå¯¹ç¼–è¯‘å™¨æç¤ºçš„ `drop` å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å¤§èƒ†æ¨æµ‹ä¸‹ï¼šå®ƒèƒ½å¤Ÿæ‹¿èµ°ç›®æ ‡å€¼çš„æ‰€æœ‰æƒã€‚ç°åœ¨æ¥çœ‹çœ‹è¿™ä¸ªçŒœæµ‹æ­£ç¡®ä¸å¦ï¼Œä»¥ä¸‹æ˜¯ `std::mem::drop` å‡½æ•°çš„ç­¾åï¼š

```rust
pub fn drop<T>(_x: T)
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œ`drop` å‡½æ•°ç¡®å®æ‹¿èµ°äº†ç›®æ ‡å€¼çš„æ‰€æœ‰æƒï¼Œæ¥éªŒè¯ä¸‹ï¼š

```rust
fn main() {
    let foo = Foo;
    drop(foo);
    // ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ï¼šå€Ÿç”¨äº†æ‰€æœ‰æƒè¢«è½¬ç§»çš„å€¼
    // println!("Running!:{:?}", foo);
}
```

Bingoï¼Œå®Œç¾æ‹¿èµ°äº†æ‰€æœ‰æƒï¼Œè€Œä¸”è¿™ç§å®ç°ä¿è¯äº†åç»­çš„ä½¿ç”¨å¿…å®šä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› æ­¤éå¸¸å®‰å…¨ï¼

ç»†å¿ƒçš„åŒå­¦å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œè¿™é‡Œç›´æ¥è°ƒç”¨äº† `drop` å‡½æ•°ï¼Œå¹¶æ²¡æœ‰å¼•å…¥ä»»ä½•æ¨¡å—ä¿¡æ¯ï¼ŒåŸå› æ˜¯è¯¥å‡½æ•°åœ¨[`std::prelude`](https://course.rs/appendix/prelude.html)é‡Œã€‚

> äº‹å®ä¸Šï¼Œèƒ½è¢«æ˜¾å¼è°ƒç”¨çš„drop(_x)å‡½æ•°åªæ˜¯ä¸ªç©ºå‡½æ•°ï¼Œåœ¨æ‹¿èµ°ç›®æ ‡å€¼çš„æ‰€æœ‰æƒåæ²¡æœ‰ä»»ä½•æ“ä½œã€‚è€Œç”±äºå…¶æŒæœ‰ç›®æ ‡å€¼çš„æ‰€æœ‰æƒï¼Œåœ¨drop(_x)å‡½æ•°ç»“æŸä¹‹é™…ï¼Œç¼–è¯‘å™¨ä¼šæ‰§è¡Œ_xçœŸæ­£çš„ææ„å‡½æ•°ï¼Œä»è€Œå®Œæˆé‡Šæ”¾èµ„æºçš„æ“ä½œã€‚æ¢å¥è¯è¯´ï¼Œdrop(_x)å‡½æ•°åªæ˜¯å¸®åŠ©ç›®æ ‡å€¼çš„æ‰€æœ‰è€…æå‰ç¦»å¼€äº†ä½œç”¨åŸŸã€‚https://doc.rust-lang.org/std/mem/fn.drop.html

## Drop ä½¿ç”¨åœºæ™¯

å¯¹äº Drop è€Œè¨€ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼š

- å›æ”¶å†…å­˜èµ„æº
- æ‰§è¡Œä¸€äº›æ”¶å°¾å·¥ä½œ

å¯¹äºç¬¬äºŒç‚¹ï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬å·²ç»è¯¦ç»†ä»‹ç»è¿‡ï¼Œå› æ­¤è¿™é‡Œä¸»è¦å¯¹ç¬¬ä¸€ç‚¹è¿›è¡Œä¸‹ç®€å•è¯´æ˜ã€‚

åœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éƒ½æ— éœ€æ‰‹åŠ¨å» `drop` ä»¥å›æ”¶å†…å­˜èµ„æºï¼Œå› ä¸º Rust ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬å®Œæˆè¿™äº›å·¥ä½œï¼Œå®ƒç”šè‡³ä¼šå¯¹å¤æ‚ç±»å‹çš„æ¯ä¸ªå­—æ®µéƒ½å•ç‹¬çš„è°ƒç”¨ `drop` è¿›è¡Œå›æ”¶ï¼ä½†æ˜¯ç¡®å®æœ‰æå°‘æ•°æƒ…å†µï¼Œéœ€è¦ä½ è‡ªå·±æ¥å›æ”¶èµ„æºçš„ï¼Œä¾‹å¦‚æ–‡ä»¶æè¿°ç¬¦ã€ç½‘ç»œ socket ç­‰ï¼Œå½“è¿™äº›å€¼è¶…å‡ºä½œç”¨åŸŸä¸å†ä½¿ç”¨æ—¶ï¼Œå°±éœ€è¦è¿›è¡Œå…³é—­ä»¥é‡Šæ”¾ç›¸å…³çš„èµ„æºï¼Œåœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå°±éœ€è¦ä½¿ç”¨è€…è‡ªå·±æ¥è§£å†³ `Drop` çš„é—®é¢˜ã€‚

## äº’æ–¥çš„ Copy å’Œ Drop

æˆ‘ä»¬æ— æ³•ä¸ºä¸€ä¸ªç±»å‹åŒæ—¶å®ç° `Copy` å’Œ `Drop` ç‰¹å¾ã€‚å› ä¸ºå®ç°äº† `Copy` ç‰¹å¾çš„ç±»å‹ä¼šè¢«ç¼–è¯‘å™¨éšå¼çš„å¤åˆ¶ï¼Œå› æ­¤éå¸¸éš¾ä»¥é¢„æµ‹ææ„å‡½æ•°æ‰§è¡Œçš„æ—¶é—´å’Œé¢‘ç‡ã€‚å› æ­¤è¿™äº›å®ç°äº† `Copy` çš„ç±»å‹æ— æ³•æ‹¥æœ‰ææ„å‡½æ•°ã€‚

```rust
#[derive(Copy)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}
```

ä»¥ä¸Šä»£ç æŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
  --> src/main.rs:24:10
   |
24 | #[derive(Copy)]
   |          ^^^^ Copy not allowed on types with destructors
```

## æ€»ç»“

`Drop` å¯ä»¥ç”¨äºè®¸å¤šæ–¹é¢ï¼Œæ¥ä½¿å¾—èµ„æºæ¸…ç†åŠæ”¶å°¾å·¥ä½œå˜å¾—æ–¹ä¾¿å’Œå®‰å…¨ï¼Œç”šè‡³å¯ä»¥ç”¨å…¶åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„å†…å­˜åˆ†é…å™¨ï¼é€šè¿‡ `Drop` ç‰¹å¾å’Œ Rust æ‰€æœ‰æƒç³»ç»Ÿï¼Œä½ æ— éœ€æ‹…å¿ƒä¹‹åçš„ä»£ç æ¸…ç†ï¼ŒRust ä¼šè‡ªåŠ¨è€ƒè™‘è¿™äº›é—®é¢˜ã€‚

æˆ‘ä»¬ä¹Ÿæ— éœ€æ‹…å¿ƒæ„å¤–çš„æ¸…ç†æ‰ä»åœ¨ä½¿ç”¨çš„å€¼ï¼Œè¿™ä¼šé€ æˆç¼–è¯‘å™¨é”™è¯¯ï¼šæ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä¹Ÿä¼šç¡®ä¿ `drop` åªä¼šåœ¨å€¼ä¸å†è¢«ä½¿ç”¨æ—¶è¢«è°ƒç”¨ä¸€æ¬¡ã€‚



================================================
FILE: src/advance/smart-pointer/intro.md
================================================
# æ™ºèƒ½æŒ‡é’ˆ

åœ¨å„ä¸ªç¼–ç¨‹è¯­è¨€ä¸­ï¼ŒæŒ‡é’ˆçš„æ¦‚å¿µå‡ ä¹éƒ½æ˜¯ç›¸åŒçš„ï¼š**æŒ‡é’ˆæ˜¯ä¸€ä¸ªåŒ…å«äº†å†…å­˜åœ°å€çš„å˜é‡ï¼Œè¯¥å†…å­˜åœ°å€å¼•ç”¨æˆ–è€…æŒ‡å‘äº†å¦å¤–çš„æ•°æ®**ã€‚

åœ¨ Rust ä¸­ï¼Œæœ€å¸¸è§çš„æŒ‡é’ˆç±»å‹æ˜¯å¼•ç”¨ï¼Œå¼•ç”¨é€šè¿‡ `&` ç¬¦å·è¡¨ç¤ºã€‚ä¸åŒäºå…¶å®ƒè¯­è¨€ï¼Œå¼•ç”¨åœ¨ Rust ä¸­è¢«èµ‹äºˆäº†æ›´æ·±å±‚æ¬¡çš„å«ä¹‰ï¼Œé‚£å°±æ˜¯ï¼šå€Ÿç”¨å…¶å®ƒå˜é‡çš„å€¼ã€‚å¼•ç”¨æœ¬èº«å¾ˆç®€å•ï¼Œé™¤äº†æŒ‡å‘æŸä¸ªå€¼å¤–å¹¶æ²¡æœ‰å…¶å®ƒçš„åŠŸèƒ½ï¼Œä¹Ÿä¸ä¼šé€ æˆæ€§èƒ½ä¸Šçš„é¢å¤–æŸè€—ï¼Œå› æ­¤æ˜¯ Rust ä¸­ä½¿ç”¨æœ€å¤šçš„æŒ‡é’ˆç±»å‹ã€‚

è€Œæ™ºèƒ½æŒ‡é’ˆåˆ™ä¸ç„¶ï¼Œå®ƒè™½ç„¶ä¹Ÿå·ç§°æŒ‡é’ˆï¼Œä½†æ˜¯å®ƒæ˜¯ä¸€ä¸ªå¤æ‚çš„å®¶ä¼™ï¼šé€šè¿‡æ¯”å¼•ç”¨æ›´å¤æ‚çš„æ•°æ®ç»“æ„ï¼ŒåŒ…å«æ¯”å¼•ç”¨æ›´å¤šçš„ä¿¡æ¯ï¼Œä¾‹å¦‚å…ƒæ•°æ®ï¼Œå½“å‰é•¿åº¦ï¼Œæœ€å¤§å¯ç”¨é•¿åº¦ç­‰ã€‚æ€»ä¹‹ï¼ŒRust çš„æ™ºèƒ½æŒ‡é’ˆå¹¶ä¸æ˜¯ç‹¬åˆ›ï¼Œåœ¨ C++ æˆ–è€…å…¶ä»–è¯­è¨€ä¸­ä¹Ÿå­˜åœ¨ç›¸ä¼¼çš„æ¦‚å¿µã€‚

Rust æ ‡å‡†åº“ä¸­å®šä¹‰çš„é‚£äº›æ™ºèƒ½æŒ‡é’ˆï¼Œè™½é‡ä½†å¼ºï¼Œå¯ä»¥æä¾›æ¯”å¼•ç”¨æ›´å¤šçš„åŠŸèƒ½ç‰¹æ€§ï¼Œä¾‹å¦‚æœ¬ç« å°†è®¨è®ºçš„å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆã€‚è¯¥æ™ºèƒ½æŒ‡é’ˆå…è®¸ä½ åŒæ—¶æ‹¥æœ‰åŒä¸€ä¸ªæ•°æ®çš„å¤šä¸ªæ‰€æœ‰æƒï¼Œå®ƒä¼šè·Ÿè¸ªæ¯ä¸€ä¸ªæ‰€æœ‰è€…å¹¶è¿›è¡Œè®¡æ•°ï¼Œå½“æ‰€æœ‰çš„æ‰€æœ‰è€…éƒ½å½’è¿˜åï¼Œè¯¥æ™ºèƒ½æŒ‡é’ˆåŠæŒ‡å‘çš„æ•°æ®å°†è‡ªåŠ¨è¢«æ¸…ç†é‡Šæ”¾ã€‚

å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„å¦ä¸€ä¸ªä¸åŒåœ¨äºå‰è€…ä»…ä»…æ˜¯å€Ÿç”¨äº†æ•°æ®ï¼Œè€Œåè€…å¾€å¾€å¯ä»¥æ‹¥æœ‰å®ƒä»¬æŒ‡å‘çš„æ•°æ®ï¼Œç„¶åå†ä¸ºå…¶å®ƒäººæä¾›æœåŠ¡ã€‚

åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œå®é™…ä¸Šæˆ‘ä»¬å·²ç»è§è¯†è¿‡å¤šç§æ™ºèƒ½æŒ‡é’ˆï¼Œä¾‹å¦‚åŠ¨æ€å­—ç¬¦ä¸² `String` å’ŒåŠ¨æ€æ•°ç»„ `Vec`ï¼Œå®ƒä»¬çš„æ•°æ®ç»“æ„ä¸­ä¸ä»…ä»…åŒ…å«äº†æŒ‡å‘åº•å±‚æ•°æ®çš„æŒ‡é’ˆï¼Œè¿˜åŒ…å«äº†å½“å‰é•¿åº¦ã€æœ€å¤§é•¿åº¦ç­‰ä¿¡æ¯ï¼Œå…¶ä¸­ `String` æ™ºèƒ½æŒ‡é’ˆè¿˜æä¾›äº†ä¸€ç§æ‹…ä¿ä¿¡æ¯ï¼šæ‰€æœ‰çš„æ•°æ®éƒ½æ˜¯åˆæ³•çš„ `UTF-8` æ ¼å¼ã€‚

æ™ºèƒ½æŒ‡é’ˆå¾€å¾€æ˜¯åŸºäºç»“æ„ä½“å®ç°ï¼Œå®ƒä¸æˆ‘ä»¬è‡ªå®šä¹‰çš„ç»“æ„ä½“æœ€å¤§çš„åŒºåˆ«åœ¨äºå®ƒå®ç°äº† `Deref` å’Œ `Drop` ç‰¹å¾ï¼š

- `Deref` å¯ä»¥è®©æ™ºèƒ½æŒ‡é’ˆåƒå¼•ç”¨é‚£æ ·å·¥ä½œï¼Œè¿™æ ·ä½ å°±å¯ä»¥å†™å‡ºåŒæ—¶æ”¯æŒæ™ºèƒ½æŒ‡é’ˆå’Œå¼•ç”¨çš„ä»£ç ï¼Œä¾‹å¦‚ `*T`
- `Drop` å…è®¸ä½ æŒ‡å®šæ™ºèƒ½æŒ‡é’ˆè¶…å‡ºä½œç”¨åŸŸåè‡ªåŠ¨æ‰§è¡Œçš„ä»£ç ï¼Œä¾‹å¦‚åšä¸€äº›æ•°æ®æ¸…é™¤ç­‰æ”¶å°¾å·¥ä½œ

æ™ºèƒ½æŒ‡é’ˆåœ¨ Rust ä¸­å¾ˆå¸¸è§ï¼Œæˆ‘ä»¬åœ¨æœ¬ç« ä¸ä¼šå…¨éƒ¨è®²è§£ï¼Œè€Œæ˜¯æŒ‘é€‰å‡ ä¸ªæœ€å¸¸ç”¨ã€æœ€æœ‰ä»£è¡¨æ€§çš„è¿›è¡Œè®²è§£ï¼š

- `Box<T>`ï¼Œå¯ä»¥å°†å€¼åˆ†é…åˆ°å †ä¸Š
- `Rc<T>`ï¼Œå¼•ç”¨è®¡æ•°ç±»å‹ï¼Œå…è®¸å¤šæ‰€æœ‰æƒå­˜åœ¨
- `Ref<T>` å’Œ `RefMut<T>`ï¼Œå…è®¸å°†å€Ÿç”¨è§„åˆ™æ£€æŸ¥ä»ç¼–è¯‘æœŸç§»åŠ¨åˆ°è¿è¡ŒæœŸè¿›è¡Œ



================================================
FILE: src/advance/smart-pointer/rc-arc.md
================================================
# Rc ä¸ Arc

Rust æ‰€æœ‰æƒæœºåˆ¶è¦æ±‚ä¸€ä¸ªå€¼åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œéƒ½æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯è€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼š

- åœ¨å›¾æ•°æ®ç»“æ„ä¸­ï¼Œå¤šä¸ªè¾¹å¯èƒ½ä¼šæ‹¥æœ‰åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹ç›´åˆ°æ²¡æœ‰è¾¹æŒ‡å‘å®ƒæ—¶ï¼Œæ‰åº”è¯¥è¢«é‡Šæ”¾æ¸…ç†
- åœ¨å¤šçº¿ç¨‹ä¸­ï¼Œå¤šä¸ªçº¿ç¨‹å¯èƒ½ä¼šæŒæœ‰åŒä¸€ä¸ªæ•°æ®ï¼Œä½†æ˜¯ä½ å—é™äº Rust çš„å®‰å…¨æœºåˆ¶ï¼Œæ— æ³•åŒæ—¶è·å–è¯¥æ•°æ®çš„å¯å˜å¼•ç”¨

ä»¥ä¸Šåœºæ™¯ä¸æ˜¯å¾ˆå¸¸è§ï¼Œä½†æ˜¯ä¸€æ—¦é‡åˆ°ï¼Œå°±éå¸¸æ£˜æ‰‹ï¼Œä¸ºäº†è§£å†³æ­¤ç±»é—®é¢˜ï¼ŒRust åœ¨æ‰€æœ‰æƒæœºåˆ¶ä¹‹å¤–åˆå¼•å…¥äº†é¢å¤–çš„æªæ–½æ¥ç®€åŒ–ç›¸åº”çš„å®ç°ï¼šé€šè¿‡å¼•ç”¨è®¡æ•°çš„æ–¹å¼ï¼Œå…è®¸ä¸€ä¸ªæ•°æ®èµ„æºåœ¨åŒä¸€æ—¶åˆ»æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚

è¿™ç§å®ç°æœºåˆ¶å°±æ˜¯ `Rc` å’Œ `Arc`ï¼Œå‰è€…é€‚ç”¨äºå•çº¿ç¨‹ï¼Œåè€…é€‚ç”¨äºå¤šçº¿ç¨‹ã€‚ç”±äºäºŒè€…å¤§éƒ¨åˆ†æƒ…å†µä¸‹éƒ½ç›¸åŒï¼Œå› æ­¤æœ¬ç« å°†ä»¥ `Rc` ä½œä¸ºè®²è§£ä¸»ä½“ï¼Œå¯¹äº `Arc` çš„ä¸åŒä¹‹å¤„ï¼Œå¦å¤–è¿›è¡Œå•ç‹¬è®²è§£ã€‚

## `Rc<T>`

å¼•ç”¨è®¡æ•°(reference counting)ï¼Œé¡¾åæ€ä¹‰ï¼Œé€šè¿‡è®°å½•ä¸€ä¸ªæ•°æ®è¢«å¼•ç”¨çš„æ¬¡æ•°æ¥ç¡®å®šè¯¥æ•°æ®æ˜¯å¦æ­£åœ¨è¢«ä½¿ç”¨ã€‚å½“å¼•ç”¨æ¬¡æ•°å½’é›¶æ—¶ï¼Œå°±ä»£è¡¨è¯¥æ•°æ®ä¸å†è¢«ä½¿ç”¨ï¼Œå› æ­¤å¯ä»¥è¢«æ¸…ç†é‡Šæ”¾ã€‚

è€Œ `Rc` æ­£æ˜¯å¼•ç”¨è®¡æ•°çš„è‹±æ–‡ç¼©å†™ã€‚å½“æˆ‘ä»¬**å¸Œæœ›åœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªå¯¹è±¡ä¾›ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†ä½¿ç”¨ä¸”æ— æ³•ç¡®å®šå“ªä¸ªéƒ¨åˆ†æœ€åä¸€ä¸ªç»“æŸæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `Rc` æˆä¸ºæ•°æ®å€¼çš„æ‰€æœ‰è€…**ï¼Œä¾‹å¦‚ä¹‹å‰æåˆ°çš„å¤šçº¿ç¨‹åœºæ™¯å°±éå¸¸é€‚åˆã€‚

ä¸‹é¢æ˜¯ç»å…¸çš„æ‰€æœ‰æƒè¢«è½¬ç§»å¯¼è‡´æŠ¥é”™çš„ä¾‹å­ï¼š

```rust
fn main() {
    let s = String::from("hello, world");
    // såœ¨è¿™é‡Œè¢«è½¬ç§»ç»™a
    let a = Box::new(s);
    // æŠ¥é”™ï¼æ­¤å¤„ç»§ç»­å°è¯•å°† s è½¬ç§»ç»™ b
    let b = Box::new(s);
}
```

ä½¿ç”¨ `Rc` å°±å¯ä»¥è½»æ˜“è§£å†³ï¼š

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("hello, world"));
    let b = Rc::clone(&a);

    assert_eq!(2, Rc::strong_count(&a));
    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))
}
```

ä»¥ä¸Šä»£ç æˆ‘ä»¬ä½¿ç”¨ `Rc::new` åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ `Rc<String>` æ™ºèƒ½æŒ‡é’ˆå¹¶èµ‹ç»™å˜é‡ `a`ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘åº•å±‚çš„å­—ç¬¦ä¸²æ•°æ®ã€‚

æ™ºèƒ½æŒ‡é’ˆ `Rc<T>` åœ¨åˆ›å»ºæ—¶ï¼Œè¿˜ä¼šå°†å¼•ç”¨è®¡æ•°åŠ  1ï¼Œæ­¤æ—¶è·å–å¼•ç”¨è®¡æ•°çš„å…³è”å‡½æ•° `Rc::strong_count` è¿”å›çš„å€¼å°†æ˜¯ `1`ã€‚

#### Rc::clone

æ¥ç€ï¼Œæˆ‘ä»¬åˆä½¿ç”¨ `Rc::clone` å…‹éš†äº†ä¸€ä»½æ™ºèƒ½æŒ‡é’ˆ `Rc<String>`ï¼Œå¹¶å°†è¯¥æ™ºèƒ½æŒ‡é’ˆçš„å¼•ç”¨è®¡æ•°å¢åŠ åˆ° `2`ã€‚

ç”±äº `a` å’Œ `b` æ˜¯åŒä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆçš„ä¸¤ä¸ªå‰¯æœ¬ï¼Œå› æ­¤é€šè¿‡å®ƒä»¬ä¸¤ä¸ªè·å–å¼•ç”¨è®¡æ•°çš„ç»“æœéƒ½æ˜¯ `2`ã€‚

ä¸è¦è¢« `clone` å­—æ ·æ‰€è¿·æƒ‘ï¼Œä»¥ä¸ºæ‰€æœ‰çš„ `clone` éƒ½æ˜¯æ·±æ‹·è´ã€‚è¿™é‡Œçš„ `clone` **ä»…ä»…å¤åˆ¶äº†æ™ºèƒ½æŒ‡é’ˆå¹¶å¢åŠ äº†å¼•ç”¨è®¡æ•°ï¼Œå¹¶æ²¡æœ‰å…‹éš†åº•å±‚æ•°æ®**ï¼Œå› æ­¤ `a` å’Œ `b` æ˜¯å…±äº«äº†åº•å±‚çš„å­—ç¬¦ä¸² `s`ï¼Œè¿™ç§**å¤åˆ¶æ•ˆç‡æ˜¯éå¸¸é«˜**çš„ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ `a.clone()` çš„æ–¹å¼æ¥å…‹éš†ï¼Œä½†æ˜¯ä»å¯è¯»æ€§è§’åº¦ï¼Œæˆ‘ä»¬æ›´åŠ æ¨è `Rc::clone` çš„æ–¹å¼ã€‚

å®é™…ä¸Šåœ¨ Rust ä¸­ï¼Œè¿˜æœ‰ä¸å°‘ `clone` éƒ½æ˜¯æµ…æ‹·è´ï¼Œä¾‹å¦‚[è¿­ä»£å™¨çš„å…‹éš†](https://course.rs/compiler/pitfalls/iterator-everywhere.html)ã€‚

#### è§‚å¯Ÿå¼•ç”¨è®¡æ•°çš„å˜åŒ–

ä½¿ç”¨å…³è”å‡½æ•° `Rc::strong_count` å¯ä»¥è·å–å½“å‰å¼•ç”¨è®¡æ•°çš„å€¼ï¼Œæˆ‘ä»¬æ¥è§‚å¯Ÿä¸‹å¼•ç”¨è®¡æ•°å¦‚ä½•éšç€å˜é‡å£°æ˜ã€é‡Šæ”¾è€Œå˜åŒ–ï¼š

```rust
use std::rc::Rc;
fn main() {
        let a = Rc::new(String::from("test ref counting"));
        println!("count after creating a = {}", Rc::strong_count(&a));
        let b =  Rc::clone(&a);
        println!("count after creating b = {}", Rc::strong_count(&a));
        {
            let c =  Rc::clone(&a);
            println!("count after creating c = {}", Rc::strong_count(&c));
        }
        println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- ç”±äºå˜é‡ `c` åœ¨è¯­å¥å—å†…éƒ¨å£°æ˜ï¼Œå½“ç¦»å¼€è¯­å¥å—æ—¶å®ƒä¼šå› ä¸ºè¶…å‡ºä½œç”¨åŸŸè€Œè¢«é‡Šæ”¾ï¼Œæ‰€ä»¥å¼•ç”¨è®¡æ•°ä¼šå‡å°‘ 1ï¼Œäº‹å®ä¸Šè¿™ä¸ªå¾—ç›Šäº `Rc<T>` å®ç°äº† `Drop` ç‰¹å¾
- `a`ã€`b`ã€`c` ä¸‰ä¸ªæ™ºèƒ½æŒ‡é’ˆå¼•ç”¨è®¡æ•°éƒ½æ˜¯åŒæ ·çš„ï¼Œå¹¶ä¸”å…±äº«åº•å±‚çš„æ•°æ®ï¼Œå› æ­¤æ‰“å°è®¡æ•°æ—¶ç”¨å“ªä¸ªéƒ½è¡Œ
- æ— æ³•çœ‹åˆ°çš„æ˜¯ï¼šå½“ `a`ã€`b` è¶…å‡ºä½œç”¨åŸŸåï¼Œå¼•ç”¨è®¡æ•°ä¼šå˜æˆ 0ï¼Œæœ€ç»ˆæ™ºèƒ½æŒ‡é’ˆå’Œå®ƒæŒ‡å‘çš„åº•å±‚å­—ç¬¦ä¸²éƒ½ä¼šè¢«æ¸…ç†é‡Šæ”¾

#### ä¸å¯å˜å¼•ç”¨

äº‹å®ä¸Šï¼Œ`Rc<T>` æ˜¯æŒ‡å‘åº•å±‚æ•°æ®çš„ä¸å¯å˜çš„å¼•ç”¨ï¼Œå› æ­¤ä½ æ— æ³•é€šè¿‡å®ƒæ¥ä¿®æ”¹æ•°æ®ï¼Œè¿™ä¹Ÿç¬¦åˆ Rust çš„å€Ÿç”¨è§„åˆ™ï¼šè¦ä¹ˆå­˜åœ¨å¤šä¸ªä¸å¯å˜å€Ÿç”¨ï¼Œè¦ä¹ˆåªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚

ä½†æ˜¯å®é™…å¼€å‘ä¸­æˆ‘ä»¬å¾€å¾€éœ€è¦å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹ï¼Œè¿™æ—¶å•ç‹¬ä½¿ç”¨ `Rc<T>` æ— æ³•æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œéœ€è¦é…åˆå…¶å®ƒæ•°æ®ç±»å‹æ¥ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚å†…éƒ¨å¯å˜æ€§çš„ `RefCell<T>` ç±»å‹ä»¥åŠäº’æ–¥é” `Mutex<T>`ã€‚äº‹å®ä¸Šï¼Œåœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œ`Arc` è·Ÿ `Mutex` é”çš„ç»„åˆä½¿ç”¨éå¸¸å¸¸è§ï¼Œå®ƒä»¬æ—¢å¯ä»¥è®©æˆ‘ä»¬åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­å…±äº«æ•°æ®ï¼Œåˆå…è®¸åœ¨å„ä¸ªçº¿ç¨‹ä¸­å¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚

#### ä¸€ä¸ªç»¼åˆä¾‹å­

è€ƒè™‘ä¸€ä¸ªåœºæ™¯ï¼Œæœ‰å¾ˆå¤šå°å·¥å…·ï¼Œæ¯ä¸ªå·¥å…·éƒ½æœ‰è‡ªå·±çš„ä¸»äººï¼Œä½†æ˜¯å­˜åœ¨å¤šä¸ªå·¥å…·å±äºåŒä¸€ä¸ªä¸»äººçš„æƒ…å†µï¼Œæ­¤æ—¶ä½¿ç”¨ `Rc<T>` å°±éå¸¸é€‚åˆï¼š

```rust
use std::rc::Rc;

struct Owner {
    name: String,
    // ...å…¶å®ƒå­—æ®µ
}

struct Gadget {
    id: i32,
    owner: Rc<Owner>,
    // ...å…¶å®ƒå­—æ®µ
}

fn main() {
    // åˆ›å»ºä¸€ä¸ªåŸºäºå¼•ç”¨è®¡æ•°çš„ `Owner`.
    let gadget_owner: Rc<Owner> = Rc::new(Owner {
        name: "Gadget Man".to_string(),
    });

    // åˆ›å»ºä¸¤ä¸ªä¸åŒçš„å·¥å…·ï¼Œå®ƒä»¬å±äºåŒä¸€ä¸ªä¸»äºº
    let gadget1 = Gadget {
        id: 1,
        owner: Rc::clone(&gadget_owner),
    };
    let gadget2 = Gadget {
        id: 2,
        owner: Rc::clone(&gadget_owner),
    };

    // é‡Šæ”¾æ‰ç¬¬ä¸€ä¸ª `Rc<Owner>`
    drop(gadget_owner);

    // å°½ç®¡åœ¨ä¸Šé¢æˆ‘ä»¬é‡Šæ”¾äº† gadget_ownerï¼Œä½†æ˜¯ä¾ç„¶å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ owner çš„ä¿¡æ¯
    // åŸå› æ˜¯åœ¨ drop ä¹‹å‰ï¼Œå­˜åœ¨ä¸‰ä¸ªæŒ‡å‘ Gadget Man çš„æ™ºèƒ½æŒ‡é’ˆå¼•ç”¨ï¼Œä¸Šé¢ä»…ä»…
    // drop æ‰å…¶ä¸­ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆå¼•ç”¨ï¼Œè€Œä¸æ˜¯ drop æ‰ owner æ•°æ®ï¼Œå¤–é¢è¿˜æœ‰ä¸¤ä¸ª
    // å¼•ç”¨æŒ‡å‘åº•å±‚çš„ owner æ•°æ®ï¼Œå¼•ç”¨è®¡æ•°å°šæœªæ¸…é›¶
    // å› æ­¤ owner æ•°æ®ä¾ç„¶å¯ä»¥è¢«ä½¿ç”¨
    println!("Gadget {} owned by {}", gadget1.id, gadget1.owner.name);
    println!("Gadget {} owned by {}", gadget2.id, gadget2.owner.name);

    // åœ¨å‡½æ•°æœ€åï¼Œ`gadget1` å’Œ `gadget2` ä¹Ÿè¢«é‡Šæ”¾ï¼Œæœ€ç»ˆå¼•ç”¨è®¡æ•°å½’é›¶ï¼Œéšååº•å±‚
    // æ•°æ®ä¹Ÿè¢«æ¸…ç†é‡Šæ”¾
}
```

ä»¥ä¸Šä»£ç å¾ˆå¥½çš„å±•ç¤ºäº† `Rc<T>` çš„ç”¨é€”ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥ç”¨å€Ÿç”¨çš„æ–¹å¼ï¼Œä½†æ˜¯å®ç°èµ·æ¥å°±ä¼šå¤æ‚å¾—å¤šï¼Œè€Œä¸”éšç€ `Gadget` åœ¨ä»£ç çš„å„ä¸ªåœ°æ–¹ä½¿ç”¨ï¼Œå¼•ç”¨ç”Ÿå‘½å‘¨æœŸä¹Ÿå°†å˜å¾—æ›´åŠ å¤æ‚ï¼Œæ¯•ç«Ÿç»“æ„ä½“ä¸­çš„å¼•ç”¨ç±»å‹ï¼Œæ€»æ˜¯ä»¤äººä¸é‚£ä¹ˆæ„‰å¿«ï¼Œå¯¹ä¸ï¼Ÿ

#### Rc ç®€å•æ€»ç»“

- `Rc/Arc` æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œä½ æ— æ³•ä¿®æ”¹å®ƒæŒ‡å‘çš„å€¼ï¼Œåªèƒ½è¿›è¡Œè¯»å–ï¼Œå¦‚æœè¦ä¿®æ”¹ï¼Œéœ€è¦é…åˆåé¢ç« èŠ‚çš„å†…éƒ¨å¯å˜æ€§ `RefCell` æˆ–äº’æ–¥é” `Mutex`
- ä¸€æ—¦æœ€åä¸€ä¸ªæ‹¥æœ‰è€…æ¶ˆå¤±ï¼Œåˆ™èµ„æºä¼šè‡ªåŠ¨è¢«å›æ”¶ï¼Œè¿™ä¸ªç”Ÿå‘½å‘¨æœŸæ˜¯åœ¨ç¼–è¯‘æœŸå°±ç¡®å®šä¸‹æ¥çš„
- `Rc` åªèƒ½ç”¨äºåŒä¸€çº¿ç¨‹å†…éƒ¨ï¼Œæƒ³è¦ç”¨äºçº¿ç¨‹ä¹‹é—´çš„å¯¹è±¡å…±äº«ï¼Œä½ éœ€è¦ä½¿ç”¨ `Arc`
- `Rc<T>` æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ç°äº† `Deref` ç‰¹å¾ï¼Œå› æ­¤ä½ æ— éœ€å…ˆè§£å¼€ `Rc` æŒ‡é’ˆï¼Œå†ä½¿ç”¨é‡Œé¢çš„ `T`ï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥ä½¿ç”¨ `T`ï¼Œä¾‹å¦‚ä¸Šä¾‹ä¸­çš„ `gadget1.owner.name`

## å¤šçº¿ç¨‹æ— åŠ›çš„ `Rc<T>`

æ¥çœ‹çœ‹åœ¨å¤šçº¿ç¨‹åœºæ™¯ä½¿ç”¨ `Rc<T>` ä¼šå¦‚ä½•ï¼š

```rust
use std::rc::Rc;
use std::thread;

fn main() {
    let s = Rc::new(String::from("å¤šçº¿ç¨‹æ¼«æ¸¸è€…"));
    for _ in 0..10 {
        let s = Rc::clone(&s);
        let handle = thread::spawn(move || {
           println!("{}", s)
        });
    }
}
```

ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰å­¦ä¹ å¤šçº¿ç¨‹çš„ç« èŠ‚ï¼Œä¸Šé¢çš„ä¾‹å­å°±ç‰¹åœ°ç®€åŒ–äº†ç›¸å…³çš„å®ç°ã€‚é¦–å…ˆé€šè¿‡ `thread::spawn` åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åä½¿ç”¨ `move` å…³é”®å­—æŠŠå…‹éš†å‡ºçš„ `s` çš„æ‰€æœ‰æƒè½¬ç§»åˆ°çº¿ç¨‹ä¸­ã€‚

èƒ½å¤Ÿå®ç°è¿™ä¸€ç‚¹ï¼Œå®Œå…¨å¾—ç›Šäº `Rc` å¸¦æ¥çš„å¤šæ‰€æœ‰æƒæœºåˆ¶ï¼Œä½†æ˜¯ä»¥ä¸Šä»£ç ä¼šæŠ¥é”™ï¼š

```console
error[E0277]: `Rc<String>` cannot be sent between threads safely
```

è¡¨é¢åŸå› æ˜¯ `Rc<T>` ä¸èƒ½åœ¨çº¿ç¨‹é—´å®‰å…¨çš„ä¼ é€’ï¼Œå®é™…ä¸Šæ˜¯å› ä¸ºå®ƒæ²¡æœ‰å®ç° `Send` ç‰¹å¾ï¼Œè€Œè¯¥ç‰¹å¾æ˜¯æ°æ°æ˜¯å¤šçº¿ç¨‹é—´ä¼ é€’æ•°æ®çš„å…³é”®ï¼Œæˆ‘ä»¬ä¼šåœ¨å¤šçº¿ç¨‹ç« èŠ‚ä¸­è¿›è¡Œè®²è§£ã€‚

å½“ç„¶ï¼Œè¿˜æœ‰æ›´æ·±å±‚çš„åŸå› ï¼šç”±äº `Rc<T>` éœ€è¦ç®¡ç†å¼•ç”¨è®¡æ•°ï¼Œä½†æ˜¯è¯¥è®¡æ•°å™¨å¹¶æ²¡æœ‰ä½¿ç”¨ä»»ä½•å¹¶å‘åŸè¯­ï¼Œå› æ­¤æ— æ³•å®ç°åŸå­åŒ–çš„è®¡æ•°æ“ä½œï¼Œæœ€ç»ˆä¼šå¯¼è‡´è®¡æ•°é”™è¯¯ã€‚

å¥½åœ¨å¤©æ— ç»äººä¹‹è·¯ï¼Œä¸€èµ·æ¥çœ‹çœ‹ Rust ä¸ºæˆ‘ä»¬æä¾›çš„åŠŸèƒ½ç±»ä¼¼ä½†æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ `Arc`ã€‚

## Arc

`Arc` æ˜¯ `Atomic Rc` çš„ç¼©å†™ï¼Œé¡¾åæ€ä¹‰ï¼šåŸå­åŒ–çš„ `Rc<T>` æ™ºèƒ½æŒ‡é’ˆã€‚åŸå­åŒ–æ˜¯ä¸€ç§å¹¶å‘åŸè¯­ï¼Œæˆ‘ä»¬åœ¨åç»­ç« èŠ‚ä¼šè¿›è¡Œæ·±å…¥è®²è§£ï¼Œè¿™é‡Œä½ åªè¦çŸ¥é“å®ƒèƒ½ä¿è¯æˆ‘ä»¬çš„æ•°æ®èƒ½å¤Ÿå®‰å…¨çš„åœ¨çº¿ç¨‹é—´å…±äº«å³å¯ã€‚

#### Arc çš„æ€§èƒ½æŸè€—

ä½ å¯èƒ½å¥½å¥‡ï¼Œä¸ºä½•ä¸ç›´æ¥ä½¿ç”¨ `Arc`ï¼Œè¿˜è¦ç”»è›‡æ·»è¶³å¼„ä¸€ä¸ª `Rc`ï¼Œè¿˜æœ‰ Rust çš„åŸºæœ¬æ•°æ®ç±»å‹ã€æ ‡å‡†åº“æ•°æ®ç±»å‹ä¸ºä»€ä¹ˆä¸è‡ªåŠ¨å®ç°åŸå­åŒ–æ“ä½œï¼Ÿè¿™æ ·å°±ä¸å­˜åœ¨çº¿ç¨‹ä¸å®‰å…¨çš„é—®é¢˜äº†ã€‚

åŸå› åœ¨äºåŸå­åŒ–æˆ–è€…å…¶å®ƒé”è™½ç„¶å¯ä»¥å¸¦æ¥çš„çº¿ç¨‹å®‰å…¨ï¼Œä½†æ˜¯éƒ½ä¼šä¼´éšç€æ€§èƒ½æŸè€—ï¼Œè€Œä¸”è¿™ç§æ€§èƒ½æŸè€—è¿˜ä¸å°ã€‚å› æ­¤ Rust æŠŠè¿™ç§é€‰æ‹©æƒäº¤ç»™ä½ ï¼Œæ¯•ç«Ÿéœ€è¦çº¿ç¨‹å®‰å…¨çš„ä»£ç å…¶å®å æ¯”å¹¶ä¸é«˜ï¼Œå¤§éƒ¨åˆ†æ—¶å€™æˆ‘ä»¬å¼€å‘çš„ç¨‹åºéƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹å†…ã€‚

`Arc` å’Œ `Rc` æ‹¥æœ‰å®Œå…¨ä¸€æ ·çš„ APIï¼Œä¿®æ”¹èµ·æ¥å¾ˆç®€å•ï¼š

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let s = Arc::new(String::from("å¤šçº¿ç¨‹æ¼«æ¸¸è€…"));
    for _ in 0..10 {
        let s = Arc::clone(&s);
        let handle = thread::spawn(move || {
           println!("{}", s)
        });
    }
}
```

å¯¹äº†ï¼Œä¸¤è€…è¿˜æœ‰ä¸€ç‚¹åŒºåˆ«ï¼š`Arc` å’Œ `Rc` å¹¶æ²¡æœ‰å®šä¹‰åœ¨åŒä¸€ä¸ªæ¨¡å—ï¼Œå‰è€…é€šè¿‡ `use std::sync::Arc` æ¥å¼•å…¥ï¼Œåè€…é€šè¿‡ `use std::rc::Rc`ã€‚

## æ€»ç»“

åœ¨ Rust ä¸­ï¼Œæ‰€æœ‰æƒæœºåˆ¶ä¿è¯äº†ä¸€ä¸ªæ•°æ®åªä¼šæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œä½†å¦‚æœä½ æƒ³è¦åœ¨å›¾æ•°æ®ç»“æ„ã€å¤šçº¿ç¨‹ç­‰åœºæ™¯ä¸­å…±äº«æ•°æ®ï¼Œè¿™ç§æœºåˆ¶ä¼šæˆä¸ºæå¤§çš„é˜»ç¢ã€‚å¥½åœ¨ Rust ä¸ºæˆ‘ä»¬æä¾›äº†æ™ºèƒ½æŒ‡é’ˆ `Rc` å’Œ `Arc`ï¼Œä½¿ç”¨å®ƒä»¬å°±èƒ½å®ç°å¤šä¸ªæ‰€æœ‰è€…å…±äº«ä¸€ä¸ªæ•°æ®çš„åŠŸèƒ½ã€‚

`Rc` å’Œ `Arc` çš„åŒºåˆ«åœ¨äºï¼Œåè€…æ˜¯åŸå­åŒ–å®ç°çš„å¼•ç”¨è®¡æ•°ï¼Œå› æ­¤æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯ä»¥ç”¨äºå¤šçº¿ç¨‹ä¸­å…±äº«æ•°æ®ã€‚

è¿™ä¸¤è€…éƒ½æ˜¯åªè¯»çš„ï¼Œå¦‚æœæƒ³è¦å®ç°å†…éƒ¨æ•°æ®å¯ä¿®æ”¹ï¼Œå¿…é¡»é…åˆå†…éƒ¨å¯å˜æ€§ `RefCell` æˆ–è€…äº’æ–¥é” `Mutex` æ¥ä¸€èµ·ä½¿ç”¨ã€‚



================================================
FILE: src/advance/unsafe/inline-asm.md
================================================
# å†…è”æ±‡ç¼–

> æœ¬ç« å†…å®¹å¯¹äºå­¦ä¹  Rust ä¸æ˜¯å¿…é¡»çš„ï¼Œè€Œä¸”éš¾åº¦å¾ˆé«˜ï¼Œå¤§å®¶ç®€å•çŸ¥é“æœ‰è¿™å›äº‹å°±å¥½ï¼Œä¸å¿…éè¦å­¦ä¼š :D

Rust æä¾›äº† `asm!` å®ï¼Œå¯ä»¥è®©å¤§å®¶åœ¨ Rust ä»£ç ä¸­åµŒå…¥æ±‡ç¼–ä»£ç ï¼Œå¯¹äºä¸€äº›æè‡´é«˜æ€§èƒ½æˆ–è€…åº•å±‚çš„åœºæ™¯è¿˜æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä¾‹å¦‚æ“ä½œç³»ç»Ÿå†…æ ¸å¼€å‘ã€‚ä½†é€šå¸¸æ¥è¯´ï¼Œå¤§å®¶å¹¶ä¸åº”è¯¥åœ¨è‡ªå·±çš„é¡¹ç›®ä¸­ä½¿ç”¨åˆ°è¯¥é¡¹æŠ€æœ¯ï¼Œå®ƒä¸ºæå®¢è€Œç”Ÿï¼

æœ¬ç« çš„ä¾‹å­æ˜¯åŸºäº `x86/x86-64` æ±‡ç¼–çš„ï¼Œä½†æ˜¯å…¶å®ƒæ¶æ„ä¹Ÿæ˜¯æ”¯æŒçš„ï¼Œç›®å‰æ”¯æŒçš„åŒ…æ‹¬ï¼š

- x86 å’Œ x86-64
- ARM
- AArch64
- RISC-V

å½“ä½¿ç”¨åœ¨ä¸æ”¯æŒçš„å¹³å°ä¸Šæ—¶ï¼Œç¼–è¯‘å™¨ä¼šç»™å‡ºæŠ¥é”™ã€‚



## åŸºæœ¬ç”¨æ³•

å…ˆä»ä¸€ä¸ªç®€å•ä¾‹å­å¼€å§‹ï¼š

```rust
use std::arch::asm;

unsafe {
    asm!("nop");
}
```

æ³¨æ„ `unsafe` è¯­å¥å—ä¾ç„¶æ˜¯å¿…ä¸å¯å°‘çš„ï¼Œå› ä¸ºå¯èƒ½åœ¨é‡Œé¢æ’å…¥å±é™©çš„æŒ‡ä»¤ï¼Œæœ€ç»ˆç ´åä»£ç çš„å®‰å…¨æ€§ã€‚

ä¸Šé¢ä»£ç å°†æ’å…¥ä¸€ä¸ª `NOP` æŒ‡ä»¤( ç©ºæ“ä½œ ) åˆ°ç¼–è¯‘å™¨ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ä¸­ï¼Œå…¶ä¸­æŒ‡ä»¤ä½œä¸º `asm!` çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ å…¥ã€‚

## è¾“å…¥å’Œè¾“å‡º

ä¸Šé¢çš„ä»£ç æœ‰å¤Ÿæ— èŠçš„ï¼Œæ¥ç‚¹å®é™…çš„:

```rust
use std::arch::asm;

let x: u64;
unsafe {
    asm!("mov {}, 5", out(reg) x);
}
assert_eq!(x, 5);
```

è¿™æ®µä»£ç å°† `5` èµ‹ç»™ `u64` ç±»å‹çš„å˜é‡ `x`ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ `asm!` çš„æŒ‡ä»¤å‚æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚è‡³äºä¼ ç»™æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„å‚æ•°ï¼Œçœ‹èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒé™Œç”Ÿçš„:

- é¦–å…ˆï¼Œéœ€è¦è¯´æ˜ç›®æ ‡å˜é‡æ˜¯ä½œä¸ºå†…è”æ±‡ç¼–çš„è¾“å…¥è¿˜æ˜¯è¾“å‡ºï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œæ˜¯ä¸€ä¸ªè¾“å‡º `out`
- æœ€åï¼Œè¦æŒ‡å®šå˜é‡å°†è¦ä½¿ç”¨çš„å¯„å­˜å™¨ï¼Œæœ¬ä¾‹ä¸­ä½¿ç”¨é€šç”¨å¯„å­˜å™¨ `reg`ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„å¯„å­˜å™¨

```rust
use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        "mov {0}, {1}",
        "add {0}, 5",
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
```

ä¸Šé¢çš„ä»£ç ä¸­è¿›ä¸€æ­¥ä½¿ç”¨äº†è¾“å…¥ `in`ï¼Œå°† `5` åŠ åˆ°è¾“å…¥çš„å˜é‡ `i` ä¸Šï¼Œç„¶åå°†ç»“æœå†™åˆ°è¾“å‡ºå˜é‡ `o`ã€‚å®é™…çš„æ“ä½œæ–¹å¼æ˜¯é¦–å…ˆå°† `i` çš„å€¼æ‹·è´åˆ°è¾“å‡ºï¼Œç„¶åå†åŠ ä¸Š `5`ã€‚

ä¸Šä¾‹è¿˜èƒ½çœ‹å‡ºå‡ ç‚¹ï¼š

- `asm!` å…è®¸ä½¿ç”¨å¤šä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæ¯ä¸€ä¸ªä½œä¸ºå•ç‹¬ä¸€è¡Œæ±‡ç¼–ä»£ç å­˜åœ¨ï¼Œçœ‹èµ·æ¥è·Ÿé˜…è¯»çœŸå®çš„æ±‡ç¼–ä»£ç ç±»ä¼¼
- è¾“å…¥å˜é‡é€šè¿‡ `in` æ¥å£°æ˜
- å’Œä»¥å‰è§è¿‡çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªå‚æ•°ï¼Œé€šè¿‡ {0}, {1} æ¥æŒ‡å®šï¼Œè¿™ç§æ–¹å¼ç‰¹åˆ«æœ‰ç”¨ï¼Œæ¯•ç«Ÿåœ¨ä»£ç ä¸­ï¼Œå˜é‡æ˜¯ç»å¸¸å¤ç”¨çš„ï¼Œè€Œè¿™ç§å‚æ•°çš„æŒ‡å®šæ–¹å¼åˆšå¥½å¯ä»¥å¤ç”¨

äº‹å®ä¸Šï¼Œè¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ä»£ç ï¼Œå»æ‰ `mov` æŒ‡ä»¤:

```rust
use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!("add {0}, 5", inout(reg) x);
}
assert_eq!(x, 8);
```

åˆå¤šå‡ºä¸€ä¸ª `inout` å…³é”®å­—ï¼Œä½†æ˜¯ä¸éš¾çŒœï¼Œå®ƒè¯´æ˜ `x` å³æ˜¯è¾“å…¥åˆæ˜¯è¾“å‡ºã€‚ä¸ä¹‹å‰çš„åˆ†ç¦»æ–¹å¼è¿˜æœ‰ä¸€ç‚¹å¾ˆå¤§çš„åŒºåˆ«ï¼Œè¿™ç§æ–¹å¼å¯ä»¥ä¿è¯ä½¿ç”¨åŒä¸€ä¸ªå¯„å­˜å™¨æ¥å®Œæˆä»»åŠ¡ã€‚

å½“ç„¶ï¼Œä½ å¯ä»¥åœ¨ä½¿ç”¨ `inout` çš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šä¸åŒçš„è¾“å…¥å’Œè¾“å‡º:

```rust
use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!("add {0}, 5", inout(reg) x => y);
}
assert_eq!(y, 8);
```

## å»¶è¿Ÿè¾“å‡ºæ“ä½œæ•°

Rust ç¼–è¯‘å™¨å¯¹äºæ“ä½œæ•°åˆ†é…æ˜¯è¾ƒä¸ºä¿å®ˆçš„ï¼Œå®ƒä¼šå‡è®¾ `out` å¯ä»¥åœ¨ä»»ä½•æ—¶é—´è¢«å†™å…¥ï¼Œå› æ­¤ `out` ä¸ä¼šè·Ÿå…¶å®ƒå‚æ•°å…±äº«å®ƒçš„ä½ç½®ã€‚ç„¶è€Œä¸ºäº†ä¿è¯æœ€ä½³æ€§èƒ½ï¼Œä½¿ç”¨å°½é‡å°‘çš„å¯„å­˜å™¨æ˜¯æœ‰å¿…è¦çš„ï¼Œè¿™æ ·å®ƒä»¬ä¸å¿…åœ¨å†…è”æ±‡ç¼–çš„ä»£ç å—å†…ä¿å­˜å’Œé‡åŠ è½½ã€‚

ä¸ºäº†è¾¾æˆè¿™ä¸ªç›®æ ‡( å…±äº«ä½ç½®æˆ–è€…è¯´å¯„å­˜å™¨ï¼Œä»¥å®ç°å‡å°‘å¯„å­˜å™¨ä½¿ç”¨çš„æ€§èƒ½ä¼˜åŒ– )ï¼ŒRust æä¾›ä¸€ä¸ª `lateout` å…³é”®å­—ï¼Œå¯ä»¥ç”¨äºä»»ä½•åªåœ¨æ‰€æœ‰è¾“å…¥è¢«æ¶ˆè´¹åæ‰è¢«å†™å…¥çš„è¾“å‡ºï¼Œä¸ä¹‹ç±»ä¼¼çš„è¿˜æœ‰ä¸€ä¸ª `inlateout`ã€‚

ä½†æ˜¯ `inlateout` åœ¨æŸäº›åœºæ™¯ä¸­æ˜¯æ— æ³•ä½¿ç”¨çš„ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š

```rust
use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        "add {0}, {2}",
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
```

ä¸€æ—¦ç”¨äº† `inlateout` åï¼Œä¸Šé¢çš„ä»£ç å°±åªèƒ½è¿è¡Œåœ¨ `Debug` æ¨¡å¼ä¸‹ï¼ŒåŸå› æ˜¯ `Debug` å¹¶æ²¡æœ‰åšä»»ä½•ä¼˜åŒ–ï¼Œä½†æ˜¯ `release` å‘å¸ƒä¸åŒï¼Œä¸ºäº†æ€§èƒ½æ˜¯è¦åšå¾ˆå¤šç¼–è¯‘ä¼˜åŒ–çš„ã€‚

åœ¨ç¼–è¯‘ä¼˜åŒ–æ—¶ï¼Œç¼–è¯‘å™¨å¯ä»¥å¾ˆå®¹æ˜“çš„ä¸ºè¾“å…¥ `b` å’Œ `c` åˆ†é…åŒæ ·çš„æ˜¯å¯„å­˜å™¨ï¼Œå› ä¸ºå®ƒçŸ¥é“å®ƒä»¬æœ‰åŒæ ·çš„å€¼ã€‚å¦‚æœè¿™é‡Œä½¿ç”¨ `inlateout`ï¼Œ é‚£ä¹ˆ `a` å’Œ `c` å°±å¯ä»¥è¢«åˆ†é…åˆ°ç›¸åŒçš„å¯„å­˜å™¨ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¬¬ä¸€æ¡æŒ‡ä»¤å°†è¦†ç›–æ‰ `c` çš„å€¼ï¼Œæœ€ç»ˆå¯¼è‡´æ±‡ç¼–ä»£ç äº§ç”Ÿé”™è¯¯çš„ç»“æœã€‚

å› æ­¤è¿™é‡Œä½¿ç”¨ `inout`ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¼šä¸º `a` åˆ†é…ä¸€ä¸ªç‹¬ç«‹çš„å¯„å­˜å™¨.

ä½†æ˜¯ä¸‹é¢çš„ä»£ç åˆä¸åŒï¼Œå®ƒæ˜¯å¯ä»¥ä½¿ç”¨ `inlateout` çš„ï¼š

```rust
use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!("add {0}, {1}", inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
```

åŸå› åœ¨äºè¾“å‡ºåªæœ‰åœ¨æ‰€æœ‰å¯„å­˜å™¨éƒ½è¢«è¯»å–åï¼Œæ‰è¢«ä¿®æ”¹ã€‚å› æ­¤ï¼Œå³ä½¿ `a` å’Œ `b` è¢«åˆ†é…äº†åŒæ ·çš„å¯„å­˜å™¨ï¼Œä»£ç ä¹Ÿä¼šæ­£å¸¸å·¥ä½œï¼Œä¸å­˜åœ¨ä¹‹å‰çš„è¦†ç›–é—®é¢˜ã€‚

## æ˜¾å¼æŒ‡å®šå¯„å­˜å™¨

ä¸€äº›æŒ‡ä»¤ä¼šè¦æ±‚æ“ä½œæ•°åªèƒ½å­˜åœ¨ç‰¹å®šçš„å¯„å­˜å™¨ä¸­ï¼Œå› æ­¤ Rust çš„å†…è”æ±‡ç¼–æä¾›äº†ä¸€äº›é™åˆ¶æ“ä½œç¬¦ã€‚

å¤§å®¶åº”è¯¥è®°å¾—ä¹‹å‰å‡ºç°è¿‡çš„ `reg` æ˜¯é€‚ç”¨äºä»»ä½•æ¶æ„çš„é€šç”¨å¯„å­˜å™¨ï¼Œæ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥è‡ªå·±é€‰æ‹©åˆé€‚çš„å¯„å­˜å™¨ï¼Œä½†æ˜¯å½“ä½ éœ€è¦æ˜¾å¼åœ°æŒ‡å®šå¯„å­˜å™¨æ—¶ï¼Œå¾ˆå¯èƒ½ä¼šå˜æˆå¹³å°ç›¸å…³çš„ä»£ç ï¼Œé€‚ç”¨ç§»æ¤æ€§ä¼šå·®å¾ˆå¤šã€‚ä¾‹å¦‚ `x86` ä¸‹çš„å¯„å­˜å™¨ï¼š`eax`, `ebx`, `ecx`, `ebp`, `esi` ç­‰ç­‰ã€‚

```rust
use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!("out 0x64, eax", in("eax") cmd);
}
```

ä¸Šé¢çš„ä¾‹å­è°ƒç”¨ `out` æŒ‡ä»¤å°† `cmd` å˜é‡çš„å€¼è¾“å‡ºåˆ° `0x64` å†…å­˜åœ°å€ä¸­ã€‚ç”±äº `out` æŒ‡ä»¤åªæ¥æ”¶ `eax` å’Œå®ƒçš„å­å¯„å­˜å™¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ `eax` æ¥æŒ‡å®šç‰¹å®šçš„å¯„å­˜å™¨ã€‚

> æ˜¾å¼å¯„å­˜å™¨æ“ä½œæ•°æ— æ³•ç”¨äºæ ¼å¼åŒ–å­—ç¬¦ä¸²ä¸­ï¼Œä¾‹å¦‚æˆ‘ä»¬ä¹‹å‰ä½¿ç”¨çš„ {}ï¼Œåªèƒ½ç›´æ¥åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ `eax`ã€‚åŒæ—¶ï¼Œè¯¥æ“ä½œæ•°åªèƒ½å‡ºç°åœ¨æœ€åï¼Œä¹Ÿå°±æ˜¯åœ¨å…¶å®ƒæ“ä½œæ•°åé¢å‡ºç°

```rust
use std::arch::asm;

fn mul(a: u64, b: u64) -> u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            "mul {}",
            in(reg) a,
            inlateout("rax") b => lo,
            lateout("rdx") hi
        );
    }

    ((hi as u128) << 64) + lo as u128
}
```

è¿™æ®µä»£ç ä½¿ç”¨äº† `mul` æŒ‡ä»¤ï¼Œå°†ä¸¤ä¸ª 64 ä½çš„è¾“å…¥ç›¸ä¹˜ï¼Œç”Ÿæˆä¸€ä¸ª 128 ä½çš„ç»“æœã€‚

é¦–å…ˆå°†å˜é‡ `a` çš„å€¼å­˜åˆ°å¯„å­˜å™¨ `reg` ä¸­ï¼Œå…¶æ¬¡æ˜¾å¼ä½¿ç”¨å¯„å­˜å™¨ `rax`ï¼Œå®ƒçš„å€¼æ¥æºäºå˜é‡ `b`ã€‚ç»“æœçš„ä½ 64 ä½å­˜å‚¨åœ¨ `rax` ä¸­ï¼Œç„¶åèµ‹ç»™å˜é‡ `lo` ï¼Œè€Œç»“æœçš„é«˜ 64 ä½åˆ™å­˜åœ¨ `rdx` ä¸­ï¼Œæœ€åèµ‹ç»™ `hi`ã€‚

## Clobbered å¯„å­˜å™¨

åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæ— éœ€ä½œä¸ºè¾“å‡ºçš„çŠ¶æ€éƒ½ä¼šè¢«å†…è”æ±‡ç¼–ä¿®æ”¹ï¼Œè¿™ä¸ªçŠ¶æ€è¢«ç§°ä¹‹ä¸º "clobbered"ã€‚

æˆ‘ä»¬éœ€è¦å‘Šè¯‰ç¼–è¯‘å™¨ç›¸å…³çš„æƒ…å†µï¼Œå› ä¸ºç¼–è¯‘å™¨éœ€è¦åœ¨å†…è”æ±‡ç¼–è¯­å¥å—çš„é™„è¿‘å­˜å‚¨å’Œæ¢å¤è¿™ç§çŠ¶æ€ã€‚

```rust
use std::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, the asm needs to preserve the value of it.
    // So we push and pop it around the main asm.
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            "push rbx",
            "cpuid",
            "mov [rdi], ebx",
            "mov [rdi + 4], edx",
            "mov [rdi + 8], ecx",
            "pop rbx",
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out("ecx") val`
            // The *pointer itself* is only an input even though it's written behind
            in("rdi") name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout("eax") 0 => _,
            // cpuid clobbers these registers too
            out("ecx") _,
            out("edx") _,
        );
    }

    let name = core::str::from_utf8(&name_buf).unwrap();
    println!("CPU Manufacturer ID: {}", name);
}
```

ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`cpuid` æŒ‡ä»¤ã€‚è¿™ä¸ªæŒ‡ä»¤ä¼šå°†CPUçš„æœ€å¤§cpuidå‚æ•°å†™å…¥`eax`ä¸­ï¼ŒåŒæ—¶å°†CPUçš„ç”Ÿå‚å•†IDä»¥ASCIIå­—ç¬¦çš„å½¢å¼å†™å…¥åˆ° `ebx` ã€`edx` å’Œ `ecx` ä¸­ã€‚

å³ä½¿ `eax` ä»æ²¡æœ‰è¢«è¯»å–ï¼Œæˆ‘ä»¬ä¾ç„¶éœ€è¦å‘ŠçŸ¥ç¼–è¯‘å™¨è¿™ä¸ªå¯„å­˜å™¨è¢«ä¿®æ”¹è¿‡ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±å¯ä»¥åœ¨æ‰§è¡Œæ±‡ç¼–ä¹‹å‰å­˜å‚¨å¯„å­˜å™¨ä¸­çš„å€¼ã€‚è¿™ä¸ªéœ€è¦é€šè¿‡å°†è¾“å‡ºå£°æ˜ä¸º `_` è€Œä¸æ˜¯ä¸€ä¸ªå…·ä½“çš„å˜é‡åï¼Œä»£è¡¨ç€è¯¥è¾“å‡ºå€¼è¢«ä¸¢å¼ƒã€‚

è¿™æ®µä»£ç ä¹Ÿä¼šç»•è¿‡ä¸€ä¸ªé™åˆ¶ï¼š `ebx` æ˜¯ä¸€ä¸ª LLVM ä¿ç•™å¯„å­˜å™¨ï¼Œæ„å‘³ç€ LLVM ä¼šå‡è®¾å®ƒæ‹¥æœ‰å¯„å­˜å™¨çš„å…¨éƒ¨æ§åˆ¶æƒï¼Œå¹¶åœ¨æ±‡ç¼–ä»£ç å—ç»“æŸæ—¶å°†å¯„å­˜å™¨çš„çŠ¶æ€æ¢å¤åˆ°æœ€å¼€å§‹çš„çŠ¶æ€ã€‚ç”±äºè¿™ä¸ªé™åˆ¶ï¼Œè¯¥å¯„å­˜å™¨æ— æ³•è¢«ç”¨äºè¾“å…¥æˆ–è€…è¾“å‡ºï¼Œé™¤éç¼–è¯‘å™¨ä½¿ç”¨è¯¥å¯„å­˜å™¨çš„æ»¡è¶³ä¸€ä¸ªé€šç”¨å¯„å­˜å™¨çš„éœ€æ±‚(ä¾‹å¦‚ `in(reg)` )ã€‚ ä½†è¿™æ ·ä½¿ç”¨åï¼Œ `reg` æ“ä½œæ•°å°±åœ¨ä½¿ç”¨ä¿ç•™å¯„å­˜å™¨æ—¶å˜å¾—å±é™©èµ·æ¥ï¼ŒåŸå› æ˜¯æˆ‘ä»¬å¯èƒ½ä¼šæ— æ„è¯†çš„ç ´åè¾“å…¥æˆ–è€…è¾“å‡ºï¼Œæ¯•ç«Ÿå®ƒä»¬å…±äº«åŒä¸€ä¸ªå¯„å­˜å™¨ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä½¿ç”¨ `rdi` æ¥å­˜å‚¨æŒ‡å‘è¾“å‡ºæ•°ç»„çš„æŒ‡é’ˆï¼Œé€šè¿‡ `push` çš„æ–¹å¼å­˜å‚¨ `ebx`ï¼šåœ¨æ±‡ç¼–ä»£ç å—çš„å†…éƒ¨è¯»å– `ebx` çš„å€¼ï¼Œç„¶åå†™å…¥åˆ°è¾“å‡ºæ•°ç»„ã€‚åé¢å†å¯ä»¥é€šè¿‡ `pop` çš„æ–¹å¼æ¥å›å¤ `ebx` åˆ°åˆå§‹çš„çŠ¶æ€ã€‚

`push` å’Œ `pop` ä½¿ç”¨å®Œæˆçš„ 64 ä½ `rbx` å¯„å­˜å™¨ï¼Œæ¥ç¡®ä¿æ•´ä¸ªå¯„å­˜å™¨çš„å†…å®¹éƒ½è¢«ä¿å­˜ã€‚å¦‚æœæ˜¯åœ¨ 32 ä½æœºå™¨ä¸Šï¼Œä»£ç å°†ä½¿ç”¨ `ebx` æ›¿ä»£ã€‚

è¿˜å¯ä»¥åœ¨æ±‡ç¼–ä»£ç å†…éƒ¨ä½¿ç”¨é€šç”¨å¯„å­˜å™¨:

```rust
use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
```


## æ€»ç»“

ç”±äºè¿™å—å„¿å†…å®¹è¿‡äºä¸“ä¸šï¼Œæœ¬ä¹¦æ¯•ç«Ÿæ˜¯é€šç”¨çš„ Rust å­¦ä¹ ä¹¦ç±ï¼Œå› æ­¤å…³äºå†…è”æ±‡ç¼–å°±ä¸å†èµ˜è¿°ã€‚äº‹å®ä¸Šï¼Œå¦‚æœä½ è¦çœŸçš„å†™å‡ºå¯ç”¨çš„æ±‡ç¼–ä»£ç ï¼Œè¦å­¦ä¹ çš„è¿˜å¾ˆå¤š...

æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥çœ‹çœ‹å¦‚ä¸‹è‹±æ–‡èµ„æ–™: [Rust Reference](https://doc.rust-lang.org/reference/inline-assembly.html) å’Œ [Rust By Example](https://doc.rust-lang.org/rust-by-example/unsafe/asm.html#clobbered-registers)ã€‚



================================================
FILE: src/advance/unsafe/intro.md
================================================
[Binary file]


================================================
FILE: src/advance/unsafe/superpowers.md
================================================
[Binary file]


================================================
FILE: src/advance/unsafe/ub.md
================================================
# é‚£äº›ä¼šå¯¼è‡´UBçš„ä»£ç 

https://www.reddit.com/r/rust/comments/rp44u5/request_for_unsafe_review/


================================================
FILE: src/advance-practice/async.md
================================================
# æ·±å…¥ Tokio èƒŒåçš„å¼‚æ­¥åŸç†

åœ¨ç»è¿‡å¤šä¸ªç« èŠ‚çš„æ·±å…¥å­¦ä¹ åï¼ŒTokio å¯¹æˆ‘ä»¬æ¥è¯´ä¸å†æ˜¯ä¸€åº§éšäºäº‘é›¾ä¸­çš„é«˜å±±ï¼Œå®ƒå…¶å®è›®ç®€å•å¥½ç”¨çš„ï¼Œç”šè‡³è¿˜æœ‰ä¸€ä¸ä¸çš„å¯çˆ±!?

ä½†ä»ç°åœ¨å¼€å§‹ï¼Œå¦‚æœæƒ³è¦è¿›ä¸€æ­¥çš„æ·±å…¥ Tokio ï¼Œé¦–å…ˆéœ€è¦æ·±å…¥ç†è§£ `async` çš„åŸç†ï¼Œå…¶å®æˆ‘ä»¬åœ¨[ä¹‹å‰çš„ç« èŠ‚](https://course.rs/async/intro.html)å·²ç»æ·±å…¥å­¦ä¹ è¿‡ï¼Œè¿™é‡Œç»“åˆ Tokio å†æ¥å›é¡¾ä¸‹ã€‚

## Future

å…ˆæ¥å›é¡¾ä¸€ä¸‹ `async fn` å¼‚æ­¥å‡½æ•° :

```rust
use tokio::net::TcpStream;

async fn my_async_fn() {
    println!("hello from async");
    // é€šè¿‡ .await åˆ›å»º socket è¿æ¥
    let _socket = TcpStream::connect("127.0.0.1:3000").await.unwrap();
    println!("async TCP operation complete");
    // å…³é—­socket
}
```

æ¥ç€å¯¹å®ƒè¿›è¡Œè°ƒç”¨è·å–ä¸€ä¸ªè¿”å›å€¼ï¼Œå†åœ¨è¿”å›å€¼ä¸Šè°ƒç”¨ `.await`ï¼š

```rust
#[tokio::main]
async fn main() {
    let what_is_this = my_async_fn();
    // ä¸Šé¢çš„è°ƒç”¨ä¸ä¼šäº§ç”Ÿä»»ä½•æ•ˆæœ

    // ... æ‰§è¡Œä¸€äº›å…¶å®ƒä»£ç 


    what_is_this.await;
    // ç›´åˆ° .await åï¼Œæ–‡æœ¬æ‰è¢«æ‰“å°ï¼Œsocket è¿æ¥ä¹Ÿè¢«åˆ›å»ºå’Œå…³é—­
}
```

åœ¨ä¸Šé¢ä»£ç ä¸­ `my_async_fn` å‡½æ•°ä¸ºä½•å¯ä»¥æƒ°æ€§æ‰§è¡Œ( ç›´åˆ° .await è°ƒç”¨æ—¶æ‰æ‰§è¡Œ)ï¼Ÿç§˜å¯†å°±åœ¨äº `async fn` å£°æ˜çš„å‡½æ•°è¿”å›ä¸€ä¸ª `Future`ã€‚

`Future` æ˜¯ä¸€ä¸ªå®ç°äº† [`std::future::Future`](https://doc.rust-lang.org/std/future/trait.Future.html) ç‰¹å¾çš„å€¼ï¼Œè¯¥å€¼åŒ…å«äº†ä¸€ç³»åˆ—å¼‚æ­¥è®¡ç®—è¿‡ç¨‹ï¼Œè€Œè¿™ä¸ªè¿‡ç¨‹ç›´åˆ° `.await` è°ƒç”¨æ—¶æ‰ä¼šè¢«æ‰§è¡Œã€‚

`std::future::Future` çš„å®šä¹‰å¦‚ä¸‹æ‰€ç¤º:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context)
        -> Poll<Self::Output>;
}
```

ä»£ç ä¸­æœ‰å‡ ä¸ªå…³é”®ç‚¹ï¼š

- [å…³è”ç±»å‹](https://course.rs/basic/trait/advance-trait.html#å…³è”ç±»å‹) `Output` æ˜¯ `Future` æ‰§è¡Œå®Œæˆåè¿”å›çš„å€¼çš„ç±»å‹
- `Pin` ç±»å‹æ˜¯åœ¨å¼‚æ­¥å‡½æ•°ä¸­è¿›è¡Œå€Ÿç”¨çš„å…³é”®ï¼Œåœ¨[è¿™é‡Œ](https://course.rs/advance/async/pin-unpin.html)æœ‰éå¸¸è¯¦ç»†çš„ä»‹ç»

å’Œå…¶å®ƒè¯­è¨€ä¸åŒï¼ŒRust ä¸­çš„ `Future` ä¸ä»£è¡¨ä¸€ä¸ªå‘ç”Ÿåœ¨åå°çš„è®¡ç®—ï¼Œè€Œæ˜¯ `Future` å°±ä»£è¡¨äº†è®¡ç®—æœ¬èº«ï¼Œå› æ­¤
`Future` çš„æ‰€æœ‰è€…æœ‰è´£ä»»å»æ¨è¿›è¯¥è®¡ç®—è¿‡ç¨‹çš„æ‰§è¡Œï¼Œä¾‹å¦‚é€šè¿‡ `Future::poll` å‡½æ•°ã€‚å¬ä¸Šå»å¥½åƒè¿˜æŒºå¤æ‚ï¼Ÿä½†æ˜¯å¤§å®¶ä¸å¿…æ‹…å¿ƒï¼Œå› ä¸ºè¿™äº›éƒ½åœ¨ Tokio ä¸­å¸®ä½ è‡ªåŠ¨å®Œæˆäº† :)

#### å®ç° Future

ä¸‹é¢æ¥ä¸€èµ·å®ç°ä¸ªäº”è„ä¿±å…¨çš„ `Future`ï¼Œå®ƒå°†ï¼š1. ç­‰å¾…æŸä¸ªç‰¹å®šæ—¶é—´ç‚¹çš„åˆ°æ¥ 2. åœ¨æ ‡å‡†è¾“å‡ºæ‰“å°æ–‡æœ¬ 3. ç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
}

// ä¸ºæˆ‘ä»¬çš„ Delay ç±»å‹å®ç° Future ç‰¹å¾
impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            // æ—¶é—´åˆ°äº†ï¼ŒFuture å¯ä»¥ç»“æŸ
            println!("Hello world");
            // Future æ‰§è¡Œç»“æŸå¹¶è¿”å› "done" å­—ç¬¦ä¸²
            Poll::Ready("done")
        } else {
            // ç›®å‰å…ˆå¿½ç•¥ä¸‹é¢è¿™è¡Œä»£ç 
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let future = Delay { when };

    // è¿è¡Œå¹¶ç­‰å¾… Future çš„å®Œæˆ
    let out = future.await;

    // åˆ¤æ–­ Future è¿”å›çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ "done"
    assert_eq!(out, "done");
}
```

ä»¥ä¸Šä»£ç å¾ˆæ¸…æ™°çš„è§£é‡Šäº†å¦‚ä½•è‡ªå®šä¹‰ä¸€ä¸ª `Future`ï¼Œå¹¶æŒ‡å®šå®ƒå¦‚ä½•é€šè¿‡ `poll` ä¸€æ­¥ä¸€æ­¥æ‰§è¡Œï¼Œç›´åˆ°æœ€ç»ˆå®Œæˆè¿”å› `"done"` å­—ç¬¦ä¸²ã€‚

#### async fn ä½œä¸º Future

å¤§å®¶æœ‰æ²¡æœ‰æ³¨æ„åˆ°ï¼Œä¸Šé¢ä»£ç æˆ‘ä»¬åœ¨ `main` å‡½æ•°ä¸­åˆå§‹åŒ–ä¸€ä¸ª `Future` å¹¶ä½¿ç”¨ `.await` å¯¹å…¶è¿›è¡Œè°ƒç”¨æ‰§è¡Œï¼Œå¦‚æœä½ æ˜¯åœ¨ `fn main` ä¸­è¿™ä¹ˆåšï¼Œæ˜¯ä¼šæŠ¥é”™çš„ã€‚

åŸå› æ˜¯ `.await` åªèƒ½ç”¨äº `async fn` å‡½æ•°ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å°† `main` å‡½æ•°å£°æ˜æˆ `async fn main` åŒæ—¶ä½¿ç”¨ `#[tokio::main]` è¿›è¡Œäº†æ ‡æ³¨ï¼Œæ­¤æ—¶ `async fn main` ç”Ÿæˆçš„ä»£ç ç±»ä¼¼ä¸‹é¢ï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

enum MainFuture {
    // åˆå§‹åŒ–ï¼Œä½†æ°¸è¿œä¸ä¼šè¢« poll
    State0,
    // ç­‰å¾… `Delay` è¿è¡Œï¼Œä¾‹å¦‚ `future.await` ä»£ç è¡Œ
    State1(Delay),
    // Future æ‰§è¡Œå®Œæˆ
    Terminated,
}

impl Future for MainFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<()>
    {
        use MainFuture::*;

        loop {
            match *self {
                State0 => {
                    let when = Instant::now() +
                        Duration::from_millis(10);
                    let future = Delay { when };
                    *self = State1(future);
                }
                State1(ref mut my_future) => {
                    match Pin::new(my_future).poll(cx) {
                        Poll::Ready(out) => {
                            assert_eq!(out, "done");
                            *self = Terminated;
                            return Poll::Ready(());
                        }
                        Poll::Pending => {
                            return Poll::Pending;
                        }
                    }
                }
                Terminated => {
                    panic!("future polled after completion")
                }
            }
        }
    }
}
```

å¯ä»¥çœ‹å‡ºï¼Œç¼–è¯‘å™¨ä¼šå°† `Future` å˜æˆçŠ¶æ€æœºï¼Œ å…¶ä¸­ `MainFuture` åŒ…å«äº† `Future` å¯èƒ½å¤„äºçš„çŠ¶æ€ï¼šä» `State0` çŠ¶æ€å¼€å§‹ï¼Œå½“ `poll` è¢«è°ƒç”¨æ—¶ï¼Œ `Future` ä¼šå°è¯•å»å°½å¯èƒ½çš„æ¨è¿›å†…éƒ¨çš„çŠ¶æ€ï¼Œè‹¥å®ƒå¯ä»¥è¢«å®Œæˆæ—¶ï¼Œå°±ä¼šè¿”å› `Poll::Ready`ï¼Œå…¶ä¸­è¿˜ä¼šåŒ…å«æœ€ç»ˆçš„è¾“å‡ºç»“æœã€‚

è‹¥ `Future` æ— æ³•è¢«å®Œæˆï¼Œä¾‹å¦‚å®ƒæ‰€ç­‰å¾…çš„èµ„æºè¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œæ­¤æ—¶å°±ä¼šè¿”å› `Poll::Pending`ï¼Œè¯¥è¿”å›å€¼ä¼šé€šçŸ¥è°ƒç”¨è€…ï¼š `Future` ä¼šåœ¨ç¨åæ‰èƒ½å®Œæˆã€‚

åŒæ—¶å¯ä»¥çœ‹åˆ°ï¼šå½“ä¸€ä¸ª `Future` ç”±å…¶å®ƒ `Future` ç»„æˆæ—¶ï¼Œè°ƒç”¨å¤–å±‚ `Future` çš„ `poll` å‡½æ•°ä¼šåŒæ—¶è°ƒç”¨ä¸€æ¬¡å†…éƒ¨ `Future` çš„ `poll` å‡½æ•°ã€‚

## æ‰§è¡Œå™¨( Excecutor )

`async fn` è¿”å› `Future` ï¼Œè€Œåè€…éœ€è¦é€šè¿‡è¢«ä¸æ–­çš„ `poll` æ‰èƒ½å¾€å‰æ¨è¿›çŠ¶æ€ï¼ŒåŒæ—¶è¯¥ `Future` è¿˜èƒ½åŒ…å«å…¶å®ƒ `Future` ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†è°æ¥è´Ÿè´£è°ƒç”¨æœ€å¤–å±‚ `Future` çš„ `poll` å‡½æ•°ï¼Ÿ

å›ä¸€ä¸‹ä¹‹å‰çš„å†…å®¹ï¼Œä¸ºäº†è¿è¡Œä¸€ä¸ªå¼‚æ­¥å‡½æ•°ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ `tokio::spawn` æˆ– é€šè¿‡ `#[tokio::main]` æ ‡æ³¨çš„ `async fn main` å‡½æ•°ã€‚å®ƒä»¬æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„ä½œç”¨ï¼šå°†æœ€å¤–å±‚ `Future` æäº¤ç»™ Tokio çš„æ‰§è¡Œå™¨ã€‚è¯¥æ‰§è¡Œå™¨è´Ÿè´£è°ƒç”¨ `poll` å‡½æ•°ï¼Œç„¶åæ¨åŠ¨ `Future` çš„æ‰§è¡Œï¼Œæœ€ç»ˆç›´è‡³å®Œæˆã€‚

#### mini tokio

ä¸ºäº†æ›´å¥½ç†è§£ç›¸å…³çš„å†…å®¹ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥å®ç°ä¸€ä¸ªè¿·ä½ ç‰ˆæœ¬çš„ Tokioï¼Œå®Œæ•´çš„ä»£ç è§[è¿™é‡Œ](https://github.com/tokio-rs/website/blob/master/tutorial-code/mini-tokio/src/main.rs)ã€‚

å…ˆæ¥çœ‹ä¸€æ®µåŸºç¡€ä»£ç :

```rust
use std::collections::VecDeque;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use futures::task;

fn main() {
    let mut mini_tokio = MiniTokio::new();

    mini_tokio.spawn(async {
        let when = Instant::now() + Duration::from_millis(10);
        let future = Delay { when };

        let out = future.await;
        assert_eq!(out, "done");
    });

    mini_tokio.run();
}

struct MiniTokio {
    tasks: VecDeque<Task>,
}

type Task = Pin<Box<dyn Future<Output = ()> + Send>>;

impl MiniTokio {
    fn new() -> MiniTokio {
        MiniTokio {
            tasks: VecDeque::new(),
        }
    }

    /// ç”Ÿæˆä¸€ä¸ª Futureå¹¶æ”¾å…¥ mini-tokio å®ä¾‹çš„ä»»åŠ¡é˜Ÿåˆ—ä¸­
    fn spawn<F>(&mut self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.tasks.push_back(Box::pin(future));
    }

    fn run(&mut self) {
        let waker = task::noop_waker();
        let mut cx = Context::from_waker(&waker);

        while let Some(mut task) = self.tasks.pop_front() {
            if task.as_mut().poll(&mut cx).is_pending() {
                self.tasks.push_back(task);
            }
        }
    }
}
```

ä»¥ä¸Šä»£ç è¿è¡Œäº†ä¸€ä¸ª `async` è¯­å¥å— `mini_tokio.spawn(async {...})`ï¼Œ è¿˜åˆ›å»ºäº†ä¸€ä¸ª `Delay` å®ä¾‹ç”¨äºç­‰å¾…æ‰€éœ€çš„æ—¶é—´ã€‚çœ‹ä¸Šå»ç›¸å½“ä¸é”™ï¼Œä½†è¿™ä¸ªå®ç°æœ‰ä¸€ä¸ª **é‡å¤§ç¼ºé™·**ï¼šæˆ‘ä»¬çš„æ‰§è¡Œå™¨æ°¸è¿œä¹Ÿä¸ä¼šä¼‘çœ ã€‚æ‰§è¡Œå™¨ä¼šæŒç»­çš„å¾ªç¯éå†æ‰€æœ‰çš„ `Future` ï¼Œç„¶åä¸åœçš„ `poll` å®ƒä»¬ï¼Œä½†æ˜¯äº‹å®ä¸Šï¼Œå¤§å¤šæ•° `poll` éƒ½æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œå› ä¸ºæ­¤æ—¶ `Future` å¹¶æ²¡æœ‰å‡†å¤‡å¥½ï¼Œå› æ­¤ä¼šç»§ç»­è¿”å› `Poll::Pending` ï¼Œæœ€ç»ˆè¿™ä¸ªå¾ªç¯éå†ä¼šè®©ä½ çš„ CPU ç–²äºå¥”å‘½ï¼ŒçœŸæ‰“å·¥äººï¼

é‰´äºæ­¤ï¼Œæˆ‘ä»¬çš„ mini-tokio åªåº”è¯¥åœ¨ `Future` å‡†å¤‡å¥½å¯ä»¥è¿›ä¸€æ­¥è¿è¡Œåï¼Œæ‰å» `poll` å®ƒï¼Œä¾‹å¦‚è¯¥ `Future` ä¹‹å‰é˜»å¡ç­‰å¾…çš„**èµ„æº**å·²ç»å‡†å¤‡å¥½å¹¶å¯ä»¥è¢«ä½¿ç”¨äº†ï¼Œå°±å¯ä»¥å¯¹å…¶è¿›è¡Œ `poll`ã€‚å†æ¯”å¦‚ï¼Œå¦‚æœä¸€ä¸ª `Future` ä»»åŠ¡åœ¨é˜»å¡ç­‰å¾…ä» TCP socket ä¸­è¯»å–æ•°æ®ï¼Œé‚£æˆ‘ä»¬åªæƒ³åœ¨ `socket` ä¸­æœ‰æ•°æ®å¯ä»¥è¯»å–åæ‰å» `poll` å®ƒï¼Œè€Œä¸æ˜¯æ²¡äº‹å°± `poll` ç€ç©ã€‚

å›åˆ°ä¸Šé¢çš„ä»£ç ä¸­ï¼Œmini-tokio åªåº”è¯¥å½“ä»»åŠ¡çš„å»¶è¿Ÿæ—¶é—´åˆ°äº†åï¼Œæ‰å» `poll` å®ƒã€‚ ä¸ºäº†å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦ `é€šçŸ¥ -> è¿è¡Œ` æœºåˆ¶ï¼šå½“ä»»åŠ¡å¯ä»¥è¿›ä¸€æ­¥è¢«æ¨è¿›è¿è¡Œæ—¶ï¼Œå®ƒä¼šä¸»åŠ¨é€šçŸ¥æ‰§è¡Œå™¨ï¼Œç„¶åæ‰§è¡Œå™¨å†æ¥ `poll`ã€‚

## Waker

ä¸€åˆ‡çš„ç­”æ¡ˆéƒ½åœ¨ `Waker` ä¸­ï¼Œèµ„æºå¯ä»¥ç”¨å®ƒæ¥é€šçŸ¥æ­£åœ¨ç­‰å¾…çš„ä»»åŠ¡ï¼šè¯¥èµ„æºå·²ç»å‡†å¤‡å¥½ï¼Œå¯ä»¥ç»§ç»­è¿è¡Œäº†ã€‚

å†æ¥çœ‹ä¸‹ `Future::poll` çš„å®šä¹‰ï¼š

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context)
    -> Poll<Self::Output>;
```

`Context` å‚æ•°ä¸­åŒ…å«æœ‰ `waker()`æ–¹æ³•ã€‚è¯¥æ–¹æ³•è¿”å›ä¸€ä¸ªç»‘å®šåˆ°å½“å‰ä»»åŠ¡ä¸Šçš„ `Waker`ï¼Œç„¶å `Waker` ä¸Šå®šä¹‰äº†ä¸€ä¸ª `wake()` æ–¹æ³•ï¼Œç”¨äºé€šçŸ¥æ‰§è¡Œå™¨ç›¸å…³çš„ä»»åŠ¡å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚

å‡†ç¡®æ¥è¯´ï¼Œå½“ `Future` é˜»å¡ç­‰å¾…çš„èµ„æºå·²ç»å‡†å¤‡å¥½æ—¶(ä¾‹å¦‚ socket ä¸­æœ‰äº†å¯è¯»å–çš„æ•°æ®)ï¼Œè¯¥èµ„æºå¯ä»¥è°ƒç”¨ `wake()` æ–¹æ³•ï¼Œæ¥é€šçŸ¥æ‰§è¡Œå™¨å¯ä»¥ç»§ç»­è°ƒç”¨è¯¥ `Future` çš„ `poll` å‡½æ•°æ¥æ¨è¿›ä»»åŠ¡çš„æ‰§è¡Œã€‚

#### å‘é€ wake é€šçŸ¥

ç°åœ¨ï¼Œä¸º `Delay` æ·»åŠ ä¸‹ `Waker` æ”¯æŒï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use std::thread;

struct Delay {
    when: Instant,
}

impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            println!("Hello world");
            Poll::Ready("done")
        } else {
            // ä¸ºå½“å‰ä»»åŠ¡å…‹éš†ä¸€ä¸ª waker çš„å¥æŸ„
            let waker = cx.waker().clone();
            let when = self.when;

            // ç”Ÿæˆä¸€ä¸ªè®¡æ—¶å™¨çº¿ç¨‹
            thread::spawn(move || {
                let now = Instant::now();

                if now < when {
                    thread::sleep(when - now);
                }

                waker.wake();
            });

            Poll::Pending
        }
    }
}
```

æ­¤æ—¶ï¼Œè®¡æ—¶å™¨ç”¨æ¥æ¨¡æ‹Ÿä¸€ä¸ªé˜»å¡ç­‰å¾…çš„èµ„æºï¼Œä¸€æ—¦è®¡æ—¶ç»“æŸ(è¯¥èµ„æºå·²ç»å‡†å¤‡å¥½)ï¼Œèµ„æºä¼šé€šè¿‡ `waker.wake()` è°ƒç”¨é€šçŸ¥æ‰§è¡Œå™¨æˆ‘ä»¬çš„ä»»åŠ¡å†æ¬¡è¢«è°ƒåº¦æ‰§è¡Œäº†ã€‚

å½“ç„¶ï¼Œç°åœ¨çš„å®ç°è¿˜è¾ƒä¸ºç²—ç³™ï¼Œç­‰ä¼šæˆ‘ä»¬ä¼šæ¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹å¦‚ä½•ç›‘å¬è¿™ä¸ª `wake` é€šçŸ¥ã€‚

> å½“ Future ä¼šè¿”å› `Poll::Pending` æ—¶ï¼Œä¸€å®šè¦ç¡®ä¿ `wake` èƒ½è¢«æ­£å¸¸è°ƒç”¨ï¼Œå¦åˆ™ä¼šå¯¼è‡´ä»»åŠ¡æ°¸è¿œè¢«æŒ‚èµ·ï¼Œå†ä¹Ÿä¸ä¼šè¢«æ‰§è¡Œå™¨ `poll`ã€‚
>
> **å¿˜è®°åœ¨è¿”å› `Poll::Pending` æ—¶è°ƒç”¨ `wake` æ˜¯å¾ˆå¤šéš¾ä»¥å‘ç° bug çš„æ½œåœ¨æºå¤´ï¼**

å†å›å¿†ä¸‹æœ€æ—©å®ç°çš„ `Delay` ä»£ç ï¼š

```rust
impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            // æ—¶é—´åˆ°äº†ï¼ŒFuture å¯ä»¥ç»“æŸ
            println!("Hello world");
            // Future æ‰§è¡Œç»“æŸå¹¶è¿”å› "done" å­—ç¬¦ä¸²
            Poll::Ready("done")
        } else {
            // ç›®å‰å…ˆå¿½ç•¥ä¸‹é¢è¿™è¡Œä»£ç 
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}
```

åœ¨è¿”å› `Poll::Pending` ä¹‹å‰ï¼Œå…ˆè°ƒç”¨äº† `cx.waker().wake_by_ref()` ï¼Œç”±äºæ­¤æ—¶æˆ‘ä»¬è¿˜æ²¡æœ‰æ¨¡æ‹Ÿè®¡æ—¶èµ„æºï¼Œå› æ­¤è¿™é‡Œç›´æ¥è°ƒç”¨äº† `wake` è¿›è¡Œé€šçŸ¥ï¼Œè¿™æ ·åšä¼šå¯¼è‡´å½“å‰çš„ `Future` è¢«ç«‹å³å†æ¬¡è°ƒåº¦æ‰§è¡Œã€‚

ç”±æ­¤å¯è§ï¼Œè¿™ç§é€šçŸ¥çš„æ§åˆ¶æƒæ˜¯åœ¨ä½ æ‰‹é‡Œçš„ï¼Œç”šè‡³å¯ä»¥åƒä¸Šé¢ä»£ç è¿™æ ·ï¼Œè¿˜æ²¡å‡†å¤‡å¥½èµ„æºï¼Œå°±ç›´æ¥è¿›è¡Œ `wake` é€šçŸ¥ï¼Œä½†æ˜¯æ€»å½’æ„ä¹‰ä¸å¤§ï¼Œè€Œä¸”æµªè´¹äº† CPUï¼Œå› ä¸ºè¿™ç§ `æ‰§è¡Œ -> ç«‹å³é€šçŸ¥å†è°ƒåº¦ -> æ‰§è¡Œ` çš„æ–¹å¼ä¼šé€ æˆä¸€ä¸ªéå¸¸ç¹å¿™çš„å¾ªç¯ã€‚

#### å¤„ç† wake é€šçŸ¥

ä¸‹é¢ï¼Œè®©æˆ‘ä»¬æ›´æ–° mini-tokio æœåŠ¡ï¼Œè®©å®ƒèƒ½æ¥æ”¶ wake é€šçŸ¥ï¼šå½“ `waker.wake()` è¢«è°ƒç”¨åï¼Œç›¸å…³è”çš„ä»»åŠ¡ä¼šè¢«æ”¾å…¥æ‰§è¡Œå™¨çš„é˜Ÿåˆ—ä¸­ï¼Œç„¶åç­‰å¾…æ‰§è¡Œå™¨çš„è°ƒç”¨æ‰§è¡Œã€‚

ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ¶ˆæ¯é€šé“æ¥æ’é˜Ÿå­˜å‚¨è¿™äº›è¢«å”¤é†’å¹¶ç­‰å¾…è°ƒåº¦çš„ä»»åŠ¡ã€‚æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œä»æ¶ˆæ¯é€šé“æ¥æ”¶æ¶ˆæ¯çš„çº¿ç¨‹(æ‰§è¡Œå™¨æ‰€åœ¨çš„çº¿ç¨‹)å’Œå‘é€æ¶ˆæ¯çš„çº¿ç¨‹ï¼ˆå”¤é†’ä»»åŠ¡æ—¶æ‰€åœ¨çš„çº¿ç¨‹ï¼‰å¯èƒ½æ˜¯ä¸åŒçš„ï¼Œå› æ­¤æ¶ˆæ¯( `Waker` )å¿…é¡»è¦å®ç° `Send`å’Œ `Sync`ï¼Œæ‰èƒ½è·¨çº¿ç¨‹ä½¿ç”¨ã€‚

> å…³äº `Send` å’Œ `Sync` çš„å…·ä½“è®²è§£è§[è¿™é‡Œ](https://course.rs/advance/concurrency-with-threads/send-sync.html)

åŸºäºä»¥ä¸Šç†ç”±ï¼Œé€‰æ‹© `std::sync::mpsc`  é‡æ–°å®ç° `MiniTokio` ç»“æ„ä½“ï¼š

```rust
use std::sync::mpsc;
use std::sync::Arc;

struct MiniTokio {
    scheduled: mpsc::Receiver<Arc<Task>>,
    sender: mpsc::Sender<Arc<Task>>,
}

struct Task {
    // å…ˆç©ºç€ï¼Œåé¢ä¼šå¡«å……ä»£ç 
}
```

`Waker` å®ç°äº† `Sync` ç‰¹å¾ï¼ŒåŒæ—¶è¿˜å¯ä»¥è¢«å…‹éš†ï¼Œå½“ `wake` è¢«è°ƒç”¨æ—¶ï¼Œä»»åŠ¡å°±ä¼šè¢«è°ƒåº¦æ‰§è¡Œã€‚

ä¸ºäº†å®ç°ä¸Šè¿°çš„ç›®çš„ï¼Œæˆ‘ä»¬å¼•å…¥äº†æ¶ˆæ¯é€šé“ï¼Œå½“ `waker.wake()` å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œä»»åŠ¡ä¼šè¢«å‘é€åˆ°è¯¥æ¶ˆæ¯é€šé“ä¸­:

```rust
use std::sync::{Arc, Mutex};

struct Task {
    // `Mutex` æ˜¯ä¸ºäº†è®© `Task` å®ç° `Sync` ç‰¹å¾ï¼Œå®ƒèƒ½ä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—® `Future`ã€‚
    // äº‹å®ä¸Š `Mutex` å¹¶æ²¡æœ‰åœ¨ Tokio ä¸­è¢«ä½¿ç”¨ï¼Œè¿™é‡Œæˆ‘ä»¬åªæ˜¯ä¸ºäº†ç®€åŒ–ï¼š Tokio çš„çœŸå®ä»£ç å®åœ¨å¤ªé•¿äº† :D
    future: Mutex<Pin<Box<dyn Future<Output = ()> + Send>>>,
    executor: mpsc::Sender<Arc<Task>>,
}

impl Task {
    fn schedule(self: &Arc<Self>) {
        self.executor.send(self.clone());
    }
}
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦è®© `std::task::Waker` èƒ½å‡†ç¡®çš„æ‰¾åˆ°æ‰€éœ€çš„è°ƒåº¦å‡½æ•° å…³è”èµ·æ¥ï¼Œå¯¹æ­¤æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªåº•å±‚çš„ API [`std::task::RawWakerVTable`](https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html) å¯ä»¥ç”¨äºæ‰‹åŠ¨çš„è®¿é—® `vtable`ï¼Œè¿™ç§å®ç°æä¾›äº†æœ€å¤§çš„çµæ´»æ€§ï¼Œä½†æ˜¯éœ€è¦å¤§é‡ `unsafe` çš„ä»£ç ã€‚

å› æ­¤æˆ‘ä»¬é€‰æ‹©æ›´åŠ é«˜çº§çš„å®ç°ï¼šç”± `futures` åŒ…æä¾›çš„ [`ArcWake`](https://docs.rs/futures/0.3.19/futures/task/trait.ArcWake.html) ç‰¹å¾ï¼Œåªè¦ç®€å•å®ç°è¯¥ç‰¹å¾ï¼Œå°±å¯ä»¥å°†æˆ‘ä»¬çš„ `Task` è½¬å˜æˆä¸€ä¸ª `waker`ã€‚åœ¨ `Cargo.toml` ä¸­æ·»åŠ ä»¥ä¸‹åŒ…ï¼š

```toml
futures = "0.3"
```

ç„¶åä¸ºæˆ‘ä»¬çš„ä»»åŠ¡ `Task` å®ç° `ArcWake`:

```rust
use futures::task::{self, ArcWake};
use std::sync::Arc;
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        arc_self.schedule();
    }
}
```

å½“ä¹‹å‰çš„è®¡æ—¶å™¨çº¿ç¨‹è°ƒç”¨ `waker.wake()` æ—¶ï¼Œæ‰€åœ¨çš„ä»»åŠ¡ä¼šè¢«æ¨å…¥åˆ°æ¶ˆæ¯é€šé“ä¸­ã€‚å› æ­¤æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å®ç°æ¥æ”¶ç«¯çš„åŠŸèƒ½ï¼Œç„¶å `MiniTokio::run()` å‡½æ•°ä¸­æ‰§è¡Œè¯¥ä»»åŠ¡:

```rust
impl MiniTokio {
    // ä»æ¶ˆæ¯é€šé“ä¸­æ¥æ”¶ä»»åŠ¡ï¼Œç„¶åé€šè¿‡ poll æ¥æ‰§è¡Œ
    fn run(&self) {
        while let Ok(task) = self.scheduled.recv() {
            task.poll();
        }
    }

    /// åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ mini-tokio å®ä¾‹
    fn new() -> MiniTokio {
        let (sender, scheduled) = mpsc::channel();

        MiniTokio { scheduled, sender }
    }


    /// åœ¨ä¸‹é¢å‡½æ•°ä¸­ï¼Œé€šè¿‡å‚æ•°ä¼ å…¥çš„ future è¢« `Task` åŒ…è£¹èµ·æ¥ï¼Œç„¶åä¼šè¢«æ¨å…¥åˆ°è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œå½“ `run` è¢«è°ƒç”¨æ—¶ï¼Œè¯¥ future å°†è¢«æ‰§è¡Œ
    fn spawn<F>(&self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        Task::spawn(future, &self.sender);
    }
}

impl Task {
    fn poll(self: Arc<Self>) {
        // åŸºäº Task å®ä¾‹åˆ›å»ºä¸€ä¸ª waker, å®ƒä½¿ç”¨äº†ä¹‹å‰çš„ `ArcWake`
        let waker = task::waker(self.clone());
        let mut cx = Context::from_waker(&waker);

        // æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨ç«äº‰é”æ—¶ï¼Œæˆ‘ä»¬å°†è·å–åˆ°ç›®æ ‡ future
        let mut future = self.future.try_lock().unwrap();

        // å¯¹ future è¿›è¡Œ poll
        let _ = future.as_mut().poll(&mut cx);
    }

    // ä½¿ç”¨ç»™å®šçš„ future æ¥ç”Ÿæˆæ–°çš„ä»»åŠ¡
    //
    // æ–°çš„ä»»åŠ¡ä¼šè¢«æ¨åˆ° `sender` ä¸­ï¼Œæ¥ç€è¯¥æ¶ˆæ¯é€šé“çš„æ¥æ”¶ç«¯å°±å¯ä»¥è·å–è¯¥ä»»åŠ¡ï¼Œç„¶åæ‰§è¡Œ
    fn spawn<F>(future: F, sender: &mpsc::Sender<Arc<Task>>)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        let task = Arc::new(Task {
            future: Mutex::new(Box::pin(future)),
            executor: sender.clone(),
        });

        let _ = sender.send(task);
    }

}
```

é¦–å…ˆï¼Œæˆ‘ä»¬å®ç°äº† `MiniTokio::run()` å‡½æ•°ï¼Œå®ƒä¼šæŒç»­ä»æ¶ˆæ¯é€šé“ä¸­æ¥æ”¶è¢«å”¤é†’çš„ä»»åŠ¡ï¼Œç„¶åé€šè¿‡ `poll` æ¥æ¨åŠ¨å…¶ç»§ç»­æ‰§è¡Œã€‚

å…¶æ¬¡ï¼Œ`MiniTokio::new()` å’Œ `MiniTokio::spawn()` ä½¿ç”¨äº†æ¶ˆæ¯é€šé“è€Œä¸æ˜¯ä¸€ä¸ª `VecDeque` ã€‚å½“æ–°ä»»åŠ¡ç”Ÿæˆåï¼Œè¿™äº›ä»»åŠ¡ä¸­ä¼šæºå¸¦ä¸Šæ¶ˆæ¯é€šé“çš„å‘é€ç«¯ï¼Œå½“ä»»åŠ¡ä¸­çš„èµ„æºå‡†å¤‡å°±ç»ªæ—¶ï¼Œä¼šä½¿ç”¨è¯¥å‘é€ç«¯å°†è¯¥ä»»åŠ¡æ”¾å…¥æ¶ˆæ¯é€šé“çš„é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…æ‰§è¡Œå™¨ `poll`ã€‚

`Task::poll()` å‡½æ•°ä½¿ç”¨ `futures` åŒ…æä¾›çš„ `ArcWake` åˆ›å»ºäº†ä¸€ä¸ª `waker`ï¼Œåè€…å¯ä»¥ç”¨æ¥åˆ›å»º `task::Context`ï¼Œæœ€ç»ˆè¯¥ `Context` ä¼šè¢«ä¼ ç»™æ‰§è¡Œå™¨è°ƒç”¨çš„ `poll` å‡½æ•°ã€‚

> æ³¨æ„ï¼ŒTask::poll å’Œæ‰§è¡Œå™¨è°ƒç”¨çš„ poll æ˜¯å®Œå…¨ä¸åŒçš„ï¼Œå¤§å®¶åˆ«ææ··äº†

## ä¸€äº›é—ç•™é—®é¢˜

è‡³æ­¤ï¼Œæˆ‘ä»¬çš„ç¨‹åºå·²ç»å·®ä¸å¤šå®Œæˆï¼Œè¿˜å‰©å‡ ä¸ªé—ç•™é—®é¢˜éœ€è¦è§£å†³ä¸‹ã€‚

#### åœ¨å¼‚æ­¥å‡½æ•°ä¸­ç”Ÿæˆå¼‚æ­¥ä»»åŠ¡

ä¹‹å‰å®ç° `Delay Future` æ—¶ï¼Œæˆ‘ä»¬æåˆ°æœ‰å‡ ä¸ªé—®é¢˜éœ€è¦è§£å†³ã€‚Rust çš„å¼‚æ­¥æ¨¡å‹å…è®¸ä¸€ä¸ª Future åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯ä»¥è·¨ä»»åŠ¡è¿ç§»:

```rust
use futures::future::poll_fn;
use std::future::Future;
use std::pin::Pin;

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let mut delay = Some(Delay { when });

    poll_fn(move |cx| {
        let mut delay = delay.take().unwrap();
        let res = Pin::new(&mut delay).poll(cx);
        assert!(res.is_pending());
        tokio::spawn(async move {
            delay.await;
        });

        Poll::Ready(())
    }).await;
}
```

é¦–å…ˆï¼Œ`poll_fn` å‡½æ•°ä½¿ç”¨é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ª `Future`ï¼Œå…¶æ¬¡ï¼Œä¸Šé¢ä»£ç è¿˜åˆ›å»ºä¸€ä¸ª `Delay` å®ä¾‹ï¼Œç„¶ååœ¨é—­åŒ…ä¸­ï¼Œå¯¹å…¶è¿›è¡Œäº†ä¸€æ¬¡ `poll` ï¼Œæ¥ç€å†å°†è¯¥ `Delay` å®ä¾‹å‘é€åˆ°ä¸€ä¸ªæ–°çš„ä»»åŠ¡ï¼Œåœ¨æ­¤ä»»åŠ¡ä¸­ä½¿ç”¨ `.await` è¿›è¡Œäº†æ‰§è¡Œã€‚

åœ¨ä¾‹å­ä¸­ï¼Œ`Delay:poll` è¢«è°ƒç”¨äº†ä¸æ­¢ä¸€æ¬¡ï¼Œä¸”ä½¿ç”¨äº†ä¸åŒçš„ `Waker` å®ä¾‹ï¼Œåœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œä½ å¿…é¡»ç¡®ä¿è°ƒç”¨æœ€è¿‘ä¸€æ¬¡ `poll` å‡½æ•°ä¸­çš„ `Waker` å‚æ•°ä¸­çš„`wake`æ–¹æ³•ã€‚ä¹Ÿå°±æ˜¯è°ƒç”¨æœ€å†…å±‚ `poll` å‡½æ•°å‚æ•°( `Waker` )ä¸Šçš„ `wake` æ–¹æ³•ã€‚

å½“å®ç°ä¸€ä¸ª `Future` æ—¶ï¼Œå¾ˆå…³é”®çš„ä¸€ç‚¹å°±æ˜¯è¦å‡è®¾æ¯æ¬¡ `poll` è°ƒç”¨éƒ½ä¼šåº”ç”¨åˆ°ä¸€ä¸ªä¸åŒçš„ `Waker` å®ä¾‹ä¸Šã€‚å› æ­¤ `poll` å‡½æ•°å¿…é¡»è¦ä½¿ç”¨ä¸€ä¸ªæ–°çš„ `waker` å»æ›´æ–°æ›¿ä»£ä¹‹å‰çš„ `waker`ã€‚

æˆ‘ä»¬ä¹‹å‰çš„ `Delay` å®ç°ä¸­ï¼Œä¼šåœ¨æ¯ä¸€æ¬¡ `poll` è°ƒç”¨æ—¶éƒ½ç”Ÿæˆä¸€ä¸ªæ–°çš„çº¿ç¨‹ã€‚è¿™ä¹ˆåšé—®é¢˜ä¸å¤§ï¼Œä½†æ˜¯å½“ `poll` è°ƒç”¨è¾ƒå¤šæ—¶ä¼šå‡ºç°æ˜æ˜¾çš„æ€§èƒ½é—®é¢˜ï¼ä¸€ä¸ªè§£å†³æ–¹æ³•å°±æ˜¯è®°å½•ä½ æ˜¯å¦å·²ç»ç”Ÿæˆäº†ä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶ååªæœ‰åœ¨æ²¡æœ‰ç”Ÿæˆæ—¶æ‰å»åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ã€‚ä½†æ˜¯ä¸€æ—¦è¿™ä¹ˆåšï¼Œå°±å¿…é¡»ç¡®ä¿çº¿ç¨‹çš„ `Waker` åœ¨åç»­ `poll` è°ƒç”¨ä¸­è¢«æ­£ç¡®æ›´æ–°ï¼Œå¦åˆ™ä½ æ— æ³•å”¤é†’æœ€è¿‘çš„ `Waker` ï¼

è¿™ä¸€æ®µå¤§å®¶å¯èƒ½ä¼šçœ‹å¾—äº‘é‡Œé›¾é‡Œçš„ï¼Œæ²¡åŠæ³•ï¼ŒåŸæ–‡å°±ç»•æ¥ç»•å»ï¼Œå¥½åœ¨ç»ˆäºå¯ä»¥çœ‹ä»£ç äº†ã€‚ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»£ç æ¥è§£å†³ç–‘æƒ‘ï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use std::thread;
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
    // ç”¨äºè¯´æ˜æ˜¯å¦å·²ç»ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹
    // Some ä»£è¡¨å·²ç»ç”Ÿæˆï¼Œ None ä»£è¡¨è¿˜æ²¡æœ‰
    waker: Option<Arc<Mutex<Waker>>>,
}

impl Future for Delay {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        // è‹¥è¿™æ˜¯ Future ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨ï¼Œé‚£ä¹ˆéœ€è¦å…ˆç”Ÿæˆä¸€ä¸ªè®¡æ—¶å™¨çº¿ç¨‹ã€‚
        // è‹¥ä¸æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨(è¯¥çº¿ç¨‹å·²åœ¨è¿è¡Œ)ï¼Œé‚£è¦ç¡®ä¿å·²å­˜å‚¨çš„ `Waker` è·Ÿå½“å‰ä»»åŠ¡çš„ `waker` åŒ¹é…
        if let Some(waker) = &self.waker {
            let mut waker = waker.lock().unwrap();

            // æ£€æŸ¥ä¹‹å‰å­˜å‚¨çš„ `waker` æ˜¯å¦è·Ÿå½“å‰ä»»åŠ¡çš„ `waker` ç›¸åŒ¹é….
            // è¿™æ˜¯å¿…è¦çš„ï¼ŒåŸå› æ˜¯ `Delay Future` çš„å®ä¾‹å¯èƒ½ä¼šåœ¨ä¸¤æ¬¡ `poll` ä¹‹é—´è¢«è½¬ç§»åˆ°å¦ä¸€ä¸ªä»»åŠ¡ä¸­ï¼Œç„¶å
            // å­˜å‚¨çš„ waker è¢«è¯¥ä»»åŠ¡è¿›è¡Œäº†æ›´æ–°ã€‚
            // è¿™ç§æƒ…å†µä¸€æ—¦å‘ç”Ÿï¼Œ`Context` åŒ…å«çš„ `waker` å°†ä¸åŒäºå­˜å‚¨çš„ `waker`ã€‚
            // å› æ­¤æˆ‘ä»¬å¿…é¡»å¯¹å­˜å‚¨çš„ `waker` è¿›è¡Œæ›´æ–°
            if !waker.will_wake(cx.waker()) {
                *waker = cx.waker().clone();
            }
        } else {
            let when = self.when;
            let waker = Arc::new(Mutex::new(cx.waker().clone()));
            self.waker = Some(waker.clone());

            // ç¬¬ä¸€æ¬¡è°ƒç”¨ `poll`ï¼Œç”Ÿæˆè®¡æ—¶å™¨çº¿ç¨‹
            thread::spawn(move || {
                let now = Instant::now();

                if now < when {
                    thread::sleep(when - now);
                }

                // è®¡æ—¶ç»“æŸï¼Œé€šè¿‡è°ƒç”¨ `waker` æ¥é€šçŸ¥æ‰§è¡Œå™¨
                let waker = waker.lock().unwrap();
                waker.wake_by_ref();
            });
        }

        // ä¸€æ—¦ waker è¢«å­˜å‚¨ä¸”è®¡æ—¶å™¨çº¿ç¨‹å·²ç»å¼€å§‹ï¼Œæˆ‘ä»¬å°±éœ€è¦æ£€æŸ¥ `delay` æ˜¯å¦å·²ç»å®Œæˆ
        // è‹¥è®¡æ—¶å·²å®Œæˆï¼Œåˆ™å½“å‰ Future å°±å¯ä»¥å®Œæˆå¹¶è¿”å› `Poll::Ready`
        if Instant::now() >= self.when {
            Poll::Ready(())
        } else {
            // è®¡æ—¶å°šæœªç»“æŸï¼ŒFuture è¿˜æœªå®Œæˆï¼Œå› æ­¤è¿”å› `Poll::Pending`.
            //
            // `Future` ç‰¹å¾è¦æ±‚å½“ `Pending` è¢«è¿”å›æ—¶ï¼Œé‚£æˆ‘ä»¬è¦ç¡®ä¿å½“èµ„æºå‡†å¤‡å¥½æ—¶ï¼Œå¿…é¡»è°ƒç”¨ `waker` ä»¥é€š
            // çŸ¥æ‰§è¡Œå™¨ã€‚ åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œä¼šé€šè¿‡ç”Ÿæˆçš„è®¡æ—¶çº¿ç¨‹æ¥ä¿è¯
            //
            // å¦‚æœå¿˜è®°è°ƒç”¨ wakerï¼Œ é‚£ç­‰å¾…æˆ‘ä»¬çš„å°†æ˜¯æ·±æ¸Šï¼šè¯¥ä»»åŠ¡å°†è¢«æ°¸è¿œçš„æŒ‚èµ·ï¼Œæ— æ³•å†æ‰§è¡Œ
            Poll::Pending
        }
    }
}
```

è¿™ç€å®æœ‰äº›å¤æ‚(åŸæ–‡ã€‚ã€‚)ï¼Œä½†æ˜¯ç®€å•æ¥çœ‹å°±æ˜¯ï¼šåœ¨æ¯æ¬¡ `poll` è°ƒç”¨æ—¶ï¼Œéƒ½ä¼šæ£€æŸ¥ `Context` ä¸­æä¾›çš„ `waker` å’Œæˆ‘ä»¬ä¹‹å‰è®°å½•çš„ `waker` æ˜¯å¦åŒ¹é…ã€‚è‹¥åŒ¹é…ï¼Œå°±ä»€ä¹ˆéƒ½ä¸ç”¨åšï¼Œè‹¥ä¸åŒ¹é…ï¼Œé‚£ä¹‹å‰å­˜å‚¨çš„å°±å¿…é¡»è¿›è¡Œæ›´æ–°ã€‚

#### Notify

æˆ‘ä»¬ä¹‹å‰è¯æ˜äº†å¦‚ä½•ç”¨æ‰‹åŠ¨ç¼–å†™çš„ `waker` æ¥å®ç° `Delay Future`ã€‚ `Waker` æ˜¯ Rust å¼‚æ­¥ç¼–ç¨‹çš„åŸºçŸ³ï¼Œå› æ­¤ç»å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦ç›´æ¥å»ä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œåœ¨ `Delay` çš„ä¾‹å­ä¸­ï¼Œ å¯ä»¥ä½¿ç”¨ [`tokio::sync::Notify`](https://docs.rs/tokio/1.16.0/tokio/sync/struct.Notify.html) å»å®ç°ã€‚

è¯¥ `Notify` æä¾›äº†ä¸€ä¸ªåŸºç¡€çš„ä»»åŠ¡é€šçŸ¥æœºåˆ¶ï¼Œå®ƒä¼šå¤„ç†è¿™äº› `waker` çš„ç»†èŠ‚ï¼ŒåŒ…æ‹¬ç¡®ä¿ä¸¤æ¬¡ `waker` çš„åŒ¹é…:

```rust
use tokio::sync::Notify;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::thread;

async fn delay(dur: Duration) {
    let when = Instant::now() + dur;
    let notify = Arc::new(Notify::new());
    let notify2 = notify.clone();

    thread::spawn(move || {
        let now = Instant::now();

        if now < when {
            thread::sleep(when - now);
        }

        notify2.notify_one();
    });


    notify.notified().await;
}
```

å½“ä½¿ç”¨ `Notify` åï¼Œæˆ‘ä»¬å°±å¯ä»¥è½»æ¾çš„å®ç°å¦‚ä¸Šçš„ `delay` å‡½æ•°ã€‚

## æ€»ç»“

åœ¨çœ‹å®Œè¿™ä¹ˆé•¿çš„æ–‡ç« åï¼Œæˆ‘ä»¬æ¥æ€»ç»“ä¸‹ï¼Œå¦åˆ™å¤§å®¶å¯èƒ½è¿˜ä¼šé—å¿˜:

- åœ¨ Rust ä¸­ï¼Œ`async` æ˜¯æƒ°æ€§çš„ï¼Œç›´åˆ°æ‰§è¡Œå™¨ `poll` å®ƒä»¬æ—¶ï¼Œæ‰ä¼šå¼€å§‹æ‰§è¡Œ
- `Waker` æ˜¯ `Future` è¢«æ‰§è¡Œçš„å…³é”®ï¼Œå®ƒå¯ä»¥é“¾æ¥èµ· `Future` ä»»åŠ¡å’Œæ‰§è¡Œå™¨
- å½“èµ„æºæ²¡æœ‰å‡†å¤‡æ—¶ï¼Œä¼šè¿”å›ä¸€ä¸ª `Poll::Pending`
- å½“èµ„æºå‡†å¤‡å¥½æ—¶ï¼Œä¼šé€šè¿‡ `waker.wake` å‘å‡ºé€šçŸ¥
- æ‰§è¡Œå™¨ä¼šæ”¶åˆ°é€šçŸ¥ï¼Œç„¶åè°ƒåº¦è¯¥ä»»åŠ¡ç»§ç»­æ‰§è¡Œï¼Œæ­¤æ—¶ç”±äºèµ„æºå·²ç»å‡†å¤‡å¥½ï¼Œå› æ­¤ä»»åŠ¡å¯ä»¥é¡ºåˆ©å¾€å‰æ¨è¿›äº†



================================================
FILE: src/advance-practice/bridging-with-sync.md
================================================
# å¼‚æ­¥è·ŸåŒæ­¥å…±å­˜

ä¸€äº›å¼‚æ­¥ç¨‹åºä¾‹å¦‚ tokio æŒ‡å— ç« èŠ‚ä¸­çš„ç»å¤§å¤šæ•°ä¾‹å­ï¼Œå®ƒä»¬æ•´ä¸ªç¨‹åºéƒ½æ˜¯å¼‚æ­¥çš„ï¼ŒåŒ…æ‹¬ç¨‹åºå…¥å£ `main` å‡½æ•°ï¼š

```rust
#[tokio::main]
async fn main() {
    println!("Hello world");
}
```

åœ¨ä¸€äº›åœºæ™¯ä¸­ï¼Œä½ å¯èƒ½åªæƒ³åœ¨å¼‚æ­¥ç¨‹åºä¸­è¿è¡Œä¸€å°éƒ¨åˆ†åŒæ­¥ä»£ç ï¼Œè¿™ç§éœ€æ±‚å¯ä»¥è€ƒè™‘ä¸‹ [`spawn_blocking`](https://docs.rs/tokio/1.16.1/tokio/task/fn.spawn_blocking.html)ã€‚

ä½†æ˜¯åœ¨å¾ˆå¤šåœºæ™¯ä¸­ï¼Œæˆ‘ä»¬åªæƒ³è®©ç¨‹åºçš„æŸä¸€ä¸ªéƒ¨åˆ†æˆä¸ºå¼‚æ­¥çš„ï¼Œä¹Ÿè®¸æ˜¯å› ä¸ºåŒæ­¥ä»£ç æ›´å¥½å®ç°ï¼Œåˆæˆ–è®¸æ˜¯åŒæ­¥ä»£ç å¯è¯»æ€§ã€å…¼å®¹æ€§éƒ½æ›´å¥½ã€‚ä¾‹å¦‚ä¸€ä¸ª `GUI` åº”ç”¨å¯èƒ½æƒ³è¦è®© `UI` ç›¸å…³çš„ä»£ç åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œç„¶åé€šè¿‡å¦ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ `tokio` çš„è¿è¡Œæ—¶æ¥å¤„ç†ä¸€äº›å¼‚æ­¥ä»»åŠ¡ã€‚

å› æ­¤æœ¬ç« èŠ‚çš„ç›®æ ‡å¾ˆçº¯ç²¹ï¼šå¦‚ä½•åœ¨åŒæ­¥ä»£ç ä¸­ä½¿ç”¨ä¸€å°éƒ¨åˆ†å¼‚æ­¥ä»£ç ã€‚

## `#[tokio::main]` çš„å±•å¼€

åœ¨ Rust ä¸­ï¼Œ `main` å‡½æ•°ä¸èƒ½æ˜¯å¼‚æ­¥çš„ï¼Œæœ‰åŒå­¦è‚¯å®šä¸æ„¿æ„äº†ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰ç« èŠ‚..ä¸å¯¹ï¼Œå°±åœ¨å¼€å¤´ï¼Œä½ è¿˜ç”¨åˆ°äº† `async fn main` çš„å£°æ˜æ–¹å¼ï¼Œæ€ä¹ˆå°±ä¸èƒ½å¼‚æ­¥äº†å‘¢ï¼Ÿ

å…¶å®ï¼Œ`#[tokio::main]` è¯¥å®ä»…ä»…æ˜¯æä¾›è¯­æ³•ç³–ï¼Œç›®çš„æ˜¯è®©å¤§å®¶å¯ä»¥æ›´ç®€å•ã€æ›´ä¸€è‡´çš„å»å†™å¼‚æ­¥ä»£ç ï¼Œå®ƒä¼šå°†ä½ å†™ä¸‹çš„`async fn main` å‡½æ•°æ›¿æ¢ä¸ºï¼š

```rust
fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("Hello world");
        })
}
```

æ³¨æ„åˆ°ä¸Šé¢çš„ `block_on` æ–¹æ³•äº†å˜›ï¼Ÿåœ¨æˆ‘ä»¬è‡ªå·±çš„åŒæ­¥ä»£ç ä¸­ï¼Œå¯ä»¥ä½¿ç”¨å®ƒå¼€å¯ä¸€ä¸ª `async/await` ä¸–ç•Œã€‚

## mini-redis çš„åŒæ­¥æ¥å£

åœ¨ä¸‹é¢ï¼Œæˆ‘ä»¬å°†ä¸€èµ·æ„å»ºä¸€ä¸ªåŒæ­¥çš„ `mini-redis` ï¼Œä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œéœ€è¦å°† `Runtime` å¯¹è±¡å­˜å‚¨èµ·æ¥ï¼Œç„¶ååˆ©ç”¨ä¸Šé¢æåˆ°çš„ `block_on` æ–¹æ³•ã€‚

é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ `src/blocking_client.rs`ï¼Œç„¶åä½¿ç”¨ä¸‹é¢ä»£ç å°†å¼‚æ­¥çš„ `Client` ç»“æ„ä½“åŒ…è£¹èµ·æ¥:

```rust
use tokio::net::ToSocketAddrs;
use tokio::runtime::Runtime;

pub use crate::client::Message;

/// å»ºç«‹åˆ° redis æœåŠ¡ç«¯çš„è¿æ¥
pub struct BlockingClient {
    /// ä¹‹å‰å®ç°çš„å¼‚æ­¥å®¢æˆ·ç«¯ `Client`
    inner: crate::client::Client,

    /// ä¸€ä¸ª `current_thread` æ¨¡å¼çš„ `tokio` è¿è¡Œæ—¶ï¼Œ
    /// ä½¿ç”¨é˜»å¡çš„æ–¹å¼æ¥æ‰§è¡Œå¼‚æ­¥å®¢æˆ·ç«¯ `Client` ä¸Šçš„æ“ä½œ
    rt: Runtime,
}

pub fn connect<T: ToSocketAddrs>(addr: T) -> crate::Result<BlockingClient> {
    // æ„å»ºä¸€ä¸ª tokio è¿è¡Œæ—¶ï¼š Runtime
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?;

    // ä½¿ç”¨è¿è¡Œæ—¶æ¥è°ƒç”¨å¼‚æ­¥çš„è¿æ¥æ–¹æ³•
    let inner = rt.block_on(crate::client::connect(addr))?;

    Ok(BlockingClient { inner, rt })
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ„é€ å™¨å‡½æ•°ç”¨äºåœ¨åŒæ­¥ä»£ç ä¸­æ‰§è¡Œå¼‚æ­¥çš„æ–¹æ³•ï¼šä½¿ç”¨ `Runtime` ä¸Šçš„ `block_on` æ–¹æ³•æ¥æ‰§è¡Œä¸€ä¸ªå¼‚æ­¥æ–¹æ³•å¹¶è¿”å›ç»“æœã€‚

æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ç‚¹ï¼Œå°±æ˜¯æˆ‘ä»¬è¿˜ä½¿ç”¨äº† [`current_thread`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_current_thread) æ¨¡å¼çš„è¿è¡Œæ—¶ã€‚è¿™ä¸ªå¯ä¸å¸¸è§ï¼ŒåŸå› æ˜¯å¼‚æ­¥ç¨‹åºå¾€å¾€è¦åˆ©ç”¨å¤šçº¿ç¨‹çš„å¨åŠ›æ¥å®ç°æ›´é«˜çš„ååæ€§èƒ½ï¼Œç›¸å¯¹åº”çš„æ¨¡å¼å°±æ˜¯ [`multi_thread`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_multi_thread)ï¼Œè¯¥æ¨¡å¼ä¼šç”Ÿæˆå¤šä¸ªè¿è¡Œåœ¨åå°çš„çº¿ç¨‹ï¼Œå®ƒä»¬å¯ä»¥é«˜æ•ˆçš„å®ç°å¤šä¸ªä»»åŠ¡çš„åŒæ—¶å¹¶è¡Œå¤„ç†ã€‚

ä½†æ˜¯å¯¹äºæˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯æ¥è¯´ï¼Œåœ¨åŒä¸€æ—¶é—´ç‚¹åªéœ€è¦åšä¸€ä»¶äº‹ï¼Œæ— éœ€å¹¶è¡Œå¤„ç†ï¼Œå¤šä¸ªçº¿ç¨‹å¹¶ä¸èƒ½å¸®åŠ©åˆ°ä»»ä½•äº‹æƒ…ï¼Œå› æ­¤ `current_thread` æ­¤æ—¶æˆä¸ºäº†æœ€ä½³çš„é€‰æ‹©ã€‚

åœ¨æ„å»º `Runtime` çš„è¿‡ç¨‹ä¸­è¿˜æœ‰ä¸€ä¸ª [`enable_all`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.enable_all) æ–¹æ³•è°ƒç”¨ï¼Œå®ƒå¯ä»¥å¼€å¯ `Tokio` è¿è¡Œæ—¶æä¾›çš„ IO å’Œå®šæ—¶å™¨æœåŠ¡ã€‚

> ç”±äº `current_thread` è¿è¡Œæ—¶å¹¶ä¸ç”Ÿæˆæ–°çš„çº¿ç¨‹ï¼Œåªæ˜¯è¿è¡Œåœ¨å·²æœ‰çš„ä¸»çº¿ç¨‹ä¸Šï¼Œå› æ­¤åªæœ‰å½“ `block_on` è¢«è°ƒç”¨åï¼Œè¯¥è¿è¡Œæ—¶æ‰èƒ½æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚ä¸€æ—¦ `block_on` è¿”å›ï¼Œé‚£è¿è¡Œæ—¶ä¸Šæ‰€æœ‰ç”Ÿæˆçš„ä»»åŠ¡å°†å†æ¬¡å†»ç»“ï¼Œç›´åˆ° `block_on` çš„å†æ¬¡è°ƒç”¨ã€‚
>
> å¦‚æœè¿™ç§æ¨¡å¼ä¸ç¬¦åˆä½¿ç”¨åœºæ™¯çš„éœ€æ±‚ï¼Œé‚£å¤§å®¶è¿˜æ˜¯éœ€è¦ç”¨ `multi_thread` è¿è¡Œæ—¶æ¥ä»£æ›¿ã€‚äº‹å®ä¸Šï¼Œåœ¨ tokio ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬é»˜è®¤ä½¿ç”¨çš„å°±æ˜¯ `multi_thread` æ¨¡å¼ã€‚

```rust
use bytes::Bytes;
use std::time::Duration;

impl BlockingClient {
    pub fn get(&mut self, key: &str) -> crate::Result<Option<Bytes>> {
        self.rt.block_on(self.inner.get(key))
    }

    pub fn set(&mut self, key: &str, value: Bytes) -> crate::Result<()> {
        self.rt.block_on(self.inner.set(key, value))
    }

    pub fn set_expires(
        &mut self,
        key: &str,
        value: Bytes,
        expiration: Duration,
    ) -> crate::Result<()> {
        self.rt.block_on(self.inner.set_expires(key, value, expiration))
    }

    pub fn publish(&mut self, channel: &str, message: Bytes) -> crate::Result<u64> {
        self.rt.block_on(self.inner.publish(channel, message))
    }
}
```

è¿™ä»£ç çœ‹ä¸Šå»æŒºé•¿ï¼Œå®é™…ä¸Šå¾ˆç®€å•ï¼Œé€šè¿‡ `block_on` å°†å¼‚æ­¥å½¢å¼çš„ `Client` çš„æ–¹æ³•å˜æˆåŒæ­¥è°ƒç”¨çš„å½¢å¼ã€‚ä¾‹å¦‚ `BlockingClient` çš„ `get` æ–¹æ³•å®é™…ä¸Šæ˜¯å¯¹å†…éƒ¨çš„å¼‚æ­¥ `get` æ–¹æ³•çš„åŒæ­¥è°ƒç”¨ã€‚

ä¸ä¸Šé¢çš„å¹³å¹³æ— å¥‡ç›¸æ¯”ï¼Œä¸‹é¢çš„ä»£ç å°†æ›´æœ‰è¶£ï¼Œå› ä¸ºå®ƒå°† `Client` è½¬å˜æˆä¸€ä¸ª `Subscriber` å¯¹è±¡:

```rust
/// ä¸‹é¢çš„å®¢æˆ·ç«¯å¯ä»¥è¿›å…¥ pub/sub (å‘å¸ƒ/è®¢é˜…) æ¨¡å¼
///
/// ä¸€æ—¦å®¢æˆ·ç«¯è®¢é˜…äº†æŸä¸ªæ¶ˆæ¯é€šé“ï¼Œé‚£å°±åªèƒ½æ‰§è¡Œ pub/sub ç›¸å…³çš„å‘½ä»¤ã€‚
/// å°†`BlockingClient` ç±»å‹è½¬æ¢æˆ `BlockingSubscriber` æ˜¯ä¸ºäº†é˜²æ­¢é `pub/sub` æ–¹æ³•è¢«è°ƒç”¨
pub struct BlockingSubscriber {
    /// å¼‚æ­¥ç‰ˆæœ¬çš„ `Subscriber`
    inner: crate::client::Subscriber,

    /// ä¸€ä¸ª `current_thread` æ¨¡å¼çš„ `tokio` è¿è¡Œæ—¶ï¼Œ
    /// ä½¿ç”¨é˜»å¡çš„æ–¹å¼æ¥æ‰§è¡Œå¼‚æ­¥å®¢æˆ·ç«¯ `Client` ä¸Šçš„æ“ä½œ
    rt: Runtime,
}

impl BlockingClient {
    pub fn subscribe(self, channels: Vec<String>) -> crate::Result<BlockingSubscriber> {
        let subscriber = self.rt.block_on(self.inner.subscribe(channels))?;
        Ok(BlockingSubscriber {
            inner: subscriber,
            rt: self.rt,
        })
    }
}

impl BlockingSubscriber {
    pub fn get_subscribed(&self) -> &[String] {
        self.inner.get_subscribed()
    }

    pub fn next_message(&mut self) -> crate::Result<Option<Message>> {
        self.rt.block_on(self.inner.next_message())
    }

    pub fn subscribe(&mut self, channels: &[String]) -> crate::Result<()> {
        self.rt.block_on(self.inner.subscribe(channels))
    }

    pub fn unsubscribe(&mut self, channels: &[String]) -> crate::Result<()> {
        self.rt.block_on(self.inner.unsubscribe(channels))
    }
}
```

ç”±ä¸Šå¯çŸ¥ï¼Œ`subscribe` æ–¹æ³•ä¼šä½¿ç”¨è¿è¡Œæ—¶å°†ä¸€ä¸ªå¼‚æ­¥çš„ `Client` è½¬å˜æˆä¸€ä¸ªå¼‚æ­¥çš„ `Subscriber`ï¼Œæ­¤å¤–ï¼Œ`Subscriber` ç»“æ„ä½“æœ‰ä¸€ä¸ªéå¼‚æ­¥çš„æ–¹æ³• `get_subscribed`ï¼Œå¯¹äºè¿™ç§æ–¹æ³•ï¼Œåªéœ€ç›´æ¥è°ƒç”¨å³å¯ï¼Œè€Œæ— éœ€ä½¿ç”¨è¿è¡Œæ—¶ã€‚

## å…¶å®ƒæ–¹æ³•

ä¸Šé¢ä»‹ç»çš„æ˜¯æœ€ç®€å•çš„æ–¹æ³•ï¼Œä½†æ˜¯ï¼Œå¦‚æœåªæœ‰è¿™ä¸€ç§ï¼Œ tokio ä¹Ÿä¸ä¼šå¦‚æ­¤å¤§åé¼é¼ã€‚

#### runtime.spawn

å¯ä»¥é€šè¿‡ `Runtime` çš„ `spawn` æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªåŸºäºè¯¥è¿è¡Œæ—¶çš„åå°ä»»åŠ¡ï¼š

```rust
use tokio::runtime::Builder;
use tokio::time::{sleep, Duration};

fn main() {
    let runtime = Builder::new_multi_thread()
        .worker_threads(1)
        .enable_all()
        .build()
        .unwrap();

    let mut handles = Vec::with_capacity(10);
    for i in 0..10 {
        handles.push(runtime.spawn(my_bg_task(i)));
    }

    // åœ¨åå°ä»»åŠ¡è¿è¡Œçš„åŒæ—¶åšä¸€äº›è€—è´¹æ—¶é—´çš„äº‹æƒ…
    std::thread::sleep(Duration::from_millis(750));
    println!("Finished time-consuming task.");

    // ç­‰å¾…è¿™äº›åå°ä»»åŠ¡çš„å®Œæˆ
    for handle in handles {
        // `spawn` æ–¹æ³•è¿”å›ä¸€ä¸ª `JoinHandle`ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Future`ï¼Œå› æ­¤å¯ä»¥é€šè¿‡  `block_on` æ¥ç­‰å¾…å®ƒå®Œæˆ
        runtime.block_on(handle).unwrap();
    }
}

async fn my_bg_task(i: u64) {
    let millis = 1000 - 50 * i;
    println!("Task {} sleeping for {} ms.", i, millis);

    sleep(Duration::from_millis(millis)).await;

    println!("Task {} stopping.", i);
}
```

è¿è¡Œè¯¥ç¨‹åºï¼Œè¾“å‡ºå¦‚ä¸‹:

```console
Task 0 sleeping for 1000 ms.
Task 1 sleeping for 950 ms.
Task 2 sleeping for 900 ms.
Task 3 sleeping for 850 ms.
Task 4 sleeping for 800 ms.
Task 5 sleeping for 750 ms.
Task 6 sleeping for 700 ms.
Task 7 sleeping for 650 ms.
Task 8 sleeping for 600 ms.
Task 9 sleeping for 550 ms.
Task 9 stopping.
Task 8 stopping.
Task 7 stopping.
Task 6 stopping.
Finished time-consuming task.
Task 5 stopping.
Task 4 stopping.
Task 3 stopping.
Task 2 stopping.
Task 1 stopping.
Task 0 stopping.
```

åœ¨æ­¤ä¾‹ä¸­ï¼Œæˆ‘ä»¬ç”Ÿæˆäº† 10 ä¸ªåå°ä»»åŠ¡åœ¨è¿è¡Œæ—¶ä¸­è¿è¡Œï¼Œç„¶åç­‰å¾…å®ƒä»¬çš„å®Œæˆã€‚ä½œä¸ºä¸€ä¸ªä¾‹å­ï¼Œæƒ³è±¡ä¸€ä¸‹åœ¨å›¾å½¢æ¸²æŸ“åº”ç”¨( GUI )ä¸­ï¼Œæœ‰æ—¶å€™éœ€è¦é€šè¿‡ç½‘ç»œè®¿é—®è¿œç¨‹æœåŠ¡æ¥è·å–ä¸€äº›æ•°æ®ï¼Œé‚£ä¸Šé¢çš„è¿™ç§æ¨¡å¼å°±éå¸¸é€‚åˆï¼Œå› ä¸ºè¿™äº›ç½‘ç»œè®¿é—®æ¯”è¾ƒè€—æ—¶ï¼Œè€Œä¸”ä¸ä¼šå½±å“å›¾å½¢çš„ä¸»ä½“æ¸²æŸ“ï¼Œå› æ­¤å¯ä»¥åœ¨ä¸»çº¿ç¨‹ä¸­æ¸²æŸ“å›¾å½¢ï¼Œç„¶åä½¿ç”¨å…¶å®ƒçº¿ç¨‹æ¥è¿è¡Œ Tokio çš„è¿è¡Œæ—¶ï¼Œå¹¶é€šè¿‡è¯¥è¿è¡Œæ—¶ä½¿ç”¨å¼‚æ­¥çš„æ–¹å¼å®Œæˆç½‘ç»œè®¿é—®ï¼Œæœ€åå°†è¿™äº›ç½‘ç»œè®¿é—®çš„ç»“æœå‘é€åˆ° GUI è¿›è¡Œæ•°æ®æ¸²æŸ“ï¼Œä¾‹å¦‚ä¸€ä¸ªè¿›åº¦æ¡ã€‚

è¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼Œåœ¨æœ¬ä¾‹å­ä¸­åªèƒ½ä½¿ç”¨ `multi_thread` è¿è¡Œæ—¶ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨äº† `current_thread`ï¼Œä½ ä¼šå‘ç°ä¸»çº¿ç¨‹çš„è€—æ—¶ä»»åŠ¡ä¼šåœ¨åå°ä»»åŠ¡å¼€å§‹ä¹‹å‰å°±å®Œæˆäº†ã€‚å› ä¸ºåœ¨ `current_thread` æ¨¡å¼ä¸‹ï¼Œç”Ÿæˆçš„ä»»åŠ¡åªä¼šåœ¨ `block_on` æœŸé—´æ‰æ‰§è¡Œã€‚

åœ¨ `multi_thread` æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦é€šè¿‡ `block_on` æ¥è§¦å‘ä»»åŠ¡çš„è¿è¡Œï¼Œè¿™é‡Œä»…ä»…æ˜¯ç”¨æ¥é˜»å¡å¹¶ç­‰å¾…æœ€ç»ˆçš„ç»“æœã€‚è€Œé™¤äº†é€šè¿‡ `block_on` ç­‰å¾…ç»“æœå¤–ï¼Œä½ è¿˜å¯ä»¥ï¼š

- ä½¿ç”¨æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼ï¼Œä¾‹å¦‚ `tokio::sync::mpsc`ï¼Œè®©å¼‚æ­¥ä»»åŠ¡å°†ç»“æœå‘é€åˆ°ä¸»çº¿ç¨‹ï¼Œç„¶åä¸»çº¿ç¨‹é€šè¿‡ `.recv`æ–¹æ³•ç­‰å¾…è¿™äº›ç»“æœ
- é€šè¿‡å…±äº«å˜é‡çš„æ–¹å¼ï¼Œä¾‹å¦‚ `Mutex`ï¼Œè¿™ç§æ–¹å¼éå¸¸é€‚åˆå®ç° GUI çš„è¿›åº¦æ¡: GUI åœ¨æ¯ä¸ªæ¸²æŸ“å¸§è¯»å–è¯¥å˜é‡å³å¯ã€‚

#### å‘é€æ¶ˆæ¯

åœ¨åŒæ­¥ä»£ç ä¸­ä½¿ç”¨å¼‚æ­¥çš„å¦ä¸€ä¸ªæ–¹æ³•å°±æ˜¯ç”Ÿæˆä¸€ä¸ªè¿è¡Œæ—¶ï¼Œç„¶åä½¿ç”¨æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼è·Ÿå®ƒè¿›è¡Œäº¤äº’ã€‚è¿™ä¸ªæ–¹æ³•è™½ç„¶æ›´å•°å—¦ä¸€äº›ï¼Œä½†æ˜¯ç›¸å¯¹äºä¹‹å‰çš„ä¸¤ç§æ–¹æ³•æ›´åŠ çµæ´»ï¼š

```rust
use tokio::runtime::Builder;
use tokio::sync::mpsc;

pub struct Task {
    name: String,
    // ä¸€äº›ä¿¡æ¯ç”¨äºæè¿°è¯¥ä»»åŠ¡
}

async fn handle_task(task: Task) {
    println!("Got task {}", task.name);
}

#[derive(Clone)]
pub struct TaskSpawner {
    spawn: mpsc::Sender<Task>,
}

impl TaskSpawner {
    pub fn new() -> TaskSpawner {
        // åˆ›å»ºä¸€ä¸ªæ¶ˆæ¯é€šé“ç”¨äºé€šä¿¡
        let (send, mut recv) = mpsc::channel(16);

        let rt = Builder::new_current_thread()
            .enable_all()
            .build()
            .unwrap();

        std::thread::spawn(move || {
            rt.block_on(async move {
                while let Some(task) = recv.recv().await {
                    tokio::spawn(handle_task(task));
                }

                // ä¸€æ—¦æ‰€æœ‰çš„å‘é€ç«¯è¶…å‡ºä½œç”¨åŸŸè¢« drop åï¼Œ`.recv()` æ–¹æ³•ä¼šè¿”å› Noneï¼ŒåŒæ—¶ while å¾ªç¯ä¼šé€€å‡ºï¼Œç„¶åçº¿ç¨‹ç»“æŸ
            });
        });

        TaskSpawner {
            spawn: send,
        }
    }

    pub fn spawn_task(&self, task: Task) {
        match self.spawn.blocking_send(task) {
            Ok(()) => {},
            Err(_) => panic!("The shared runtime has shut down."),
        }
    }
}
```

ä¸ºä½•è¯´è¿™ç§æ–¹æ³•æ¯”è¾ƒçµæ´»å‘¢ï¼Ÿä»¥ä¸Šé¢ä»£ç ä¸ºä¾‹ï¼Œå®ƒå¯ä»¥åœ¨å¾ˆå¤šæ–¹é¢è¿›è¡Œé…ç½®ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨ä¿¡å·é‡ [`Semaphore`](https://docs.rs/tokio/1.16.1/tokio/sync/struct.Semaphore.html)æ¥é™åˆ¶å½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡æ•°ï¼Œæˆ–è€…ä½ è¿˜å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ¶ˆæ¯é€šé“å°†æ¶ˆæ¯åå‘å‘é€å›ä»»åŠ¡ç”Ÿæˆå™¨ `spawner`ã€‚

æŠ›å¼€ç»†èŠ‚ï¼ŒæŠ½è±¡æ¥çœ‹ï¼Œè¿™æ˜¯ä¸æ˜¯å¾ˆåƒä¸€ä¸ª Actor ï¼Ÿ



================================================
FILE: src/advance-practice/channels.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/design-pattern.md
================================================
# Rust è®¾è®¡æ¨¡å¼


https://github.com/rust-unofficial/patterns


================================================
FILE: src/advance-practice/frame.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/getting-startted.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/graceful-shutdown.md
================================================
# ä¼˜é›…çš„å…³é—­

å¦‚æœä½ çš„æœåŠ¡æ˜¯ä¸€ä¸ªå°è¯´é˜…è¯»ç½‘ç«™ï¼Œé‚£å¤§æ¦‚ç‡ç”¨ä¸åˆ°ä¼˜é›…å…³é—­çš„ï¼Œç®€å•ç²—æš´çš„å…³é—­æœåŠ¡å™¨ï¼Œç„¶åç”¨æˆ·å†æ¬¡è¯·æ±‚æ—¶è·å–ä¸€ä¸ªé”™è¯¯å°±æ˜¯äº†ã€‚ä½†å¦‚æœæ˜¯ä¸€ä¸ª web æœåŠ¡æˆ–æ•°æ®åº“æœåŠ¡å‘¢ï¼Ÿå½“å‰çš„è¿æ¥å¾ˆå¯èƒ½åœ¨åšç€é‡è¦çš„äº‹æƒ…ï¼Œä¸€æ—¦å…³é—­ä¼šå¯¼è‡´æ•°æ®çš„ä¸¢å¤±ç”šè‡³é”™è¯¯ï¼Œæ­¤æ—¶ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¼˜é›…çš„å…³é—­(graceful shutdown)äº†ã€‚

è¦è®©ä¸€ä¸ªå¼‚æ­¥åº”ç”¨ä¼˜é›…çš„å…³é—­å¾€å¾€éœ€è¦åšåˆ° 3 ç‚¹ï¼š

- æ‰¾å‡ºåˆé€‚çš„å…³é—­æ—¶æœº
- é€šçŸ¥ç¨‹åºçš„æ¯ä¸€ä¸ªå­éƒ¨åˆ†å¼€å§‹å…³é—­
- åœ¨ä¸»çº¿ç¨‹ç­‰å¾…å„ä¸ªéƒ¨åˆ†çš„å…³é—­ç»“æœ

åœ¨æœ¬æ–‡çš„ä¸‹é¢éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•åšåˆ°è¿™ä¸‰ç‚¹ã€‚å¦‚æœæƒ³è¦è¿›ä¸€æ­¥äº†è§£åœ¨çœŸå®é¡¹ç›®ä¸­è¯¥å¦‚ä½•ä½¿ç”¨ï¼Œå¤§å®¶å¯ä»¥çœ‹çœ‹ mini-redis çš„å®Œæ•´ä»£ç å®ç°ï¼Œç‰¹åˆ«æ˜¯ [`src/server.rs`](https://github.com/tokio-rs/mini-redis/blob/master/src/server.rs) å’Œ [`src/shutdown.rs`](https://github.com/tokio-rs/mini-redis/blob/master/src/shutdown.rs)ã€‚

## æ‰¾å‡ºåˆé€‚çš„å…³é—­æ—¶æœº

ä¸€èˆ¬æ¥è¯´ï¼Œä½•æ—¶å…³é—­æ˜¯å–å†³äºåº”ç”¨è‡ªèº«çš„ï¼Œä½†æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…³é—­å‡†åˆ™å°±æ˜¯å½“åº”ç”¨æ”¶åˆ°æ¥è‡ªäºæ“ä½œç³»ç»Ÿçš„å…³é—­ä¿¡å·æ—¶ã€‚ä¾‹å¦‚é€šè¿‡ `ctrl + c` æ¥å…³é—­æ­£åœ¨è¿è¡Œçš„å‘½ä»¤è¡Œç¨‹åºã€‚

ä¸ºäº†æ£€æµ‹æ¥è‡ªæ“ä½œç³»ç»Ÿçš„å…³é—­ä¿¡å·ï¼Œ`Tokio` æä¾›äº†ä¸€ä¸ª `tokio::signal::ctrl_c` å‡½æ•°ï¼Œå®ƒå°†ä¸€ç›´ç¡çœ ç›´åˆ°æ”¶åˆ°å¯¹åº”çš„ä¿¡å·:

```rust
use tokio::signal;

#[tokio::main]
async fn main() {
    // ... spawn application as separate task ...
    // åœ¨ä¸€ä¸ªå•ç‹¬çš„ä»»åŠ¡ä¸­å¤„ç†åº”ç”¨é€»è¾‘

    match signal::ctrl_c().await {
        Ok(()) => {},
        Err(err) => {
            eprintln!("Unable to listen for shutdown signal: {}", err);
        },
    }

    //  å‘é€å…³é—­ä¿¡å·ç»™åº”ç”¨æ‰€åœ¨çš„ä»»åŠ¡ï¼Œç„¶åç­‰å¾…
}
```

## é€šçŸ¥ç¨‹åºçš„æ¯ä¸€ä¸ªéƒ¨åˆ†å¼€å§‹å…³é—­

å¤§å®¶çœ‹åˆ°è¿™ä¸ªæ ‡é¢˜ï¼Œä¸çŸ¥é“ä¼šæƒ³åˆ°ç”¨ä»€ä¹ˆæŠ€æœ¯æ¥è§£å†³é—®é¢˜ï¼Œåæ­£æˆ‘é¦–å…ˆæƒ³åˆ°çš„æ˜¯ï¼ŒçœŸçš„å¾ˆåƒå¹¿æ’­å“ã€‚ã€‚

äº‹å®ä¸Šä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæœ€å¸¸è§çš„é€šçŸ¥ç¨‹åºå„ä¸ªéƒ¨åˆ†å…³é—­çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªå¹¿æ’­æ¶ˆæ¯é€šé“ã€‚å…³äºå¦‚ä½•å®ç°ï¼Œå…¶å®ä¹Ÿä¸å¤æ‚ï¼šåº”ç”¨ä¸­çš„æ¯ä¸ªä»»åŠ¡éƒ½æŒæœ‰ä¸€ä¸ªå¹¿æ’­æ¶ˆæ¯é€šé“çš„æ¥æ”¶ç«¯ï¼Œå½“æ¶ˆæ¯è¢«å¹¿æ’­åˆ°è¯¥é€šé“æ—¶ï¼Œæ¯ä¸ªä»»åŠ¡éƒ½å¯ä»¥æ”¶åˆ°è¯¥æ¶ˆæ¯ï¼Œå¹¶å…³é—­è‡ªå·±:

```rust
let next_frame = tokio::select! {
    res = self.connection.read_frame() => res?,
    _ = self.shutdown.recv() => {
        // å½“æ”¶åˆ°å…³é—­ä¿¡å·åï¼Œç›´æ¥ä» `select!` è¿”å›ï¼Œæ­¤æ—¶ `select!` ä¸­çš„å¦ä¸€ä¸ªåˆ†æ”¯ä¼šè‡ªåŠ¨é‡Šæ”¾ï¼Œå…¶ä¸­çš„ä»»åŠ¡ä¹Ÿä¼šç»“æŸ
        return Ok(());
    }
};
```

åœ¨ `mini-redis` ä¸­ï¼Œå½“æ”¶åˆ°å…³é—­æ¶ˆæ¯æ—¶ï¼Œä»»åŠ¡ä¼šç«‹å³ç»“æŸï¼Œä½†åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™ç§æ–¹å¼å¯èƒ½ä¼šè¿‡äºç†æƒ³ï¼Œä¾‹å¦‚å½“æˆ‘ä»¬å‘æ–‡ä»¶æˆ–æ•°æ®åº“å†™å…¥æ•°æ®æ—¶ï¼Œç«‹åˆ»ç»ˆæ­¢ä»»åŠ¡å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›æ— æ³•é¢„æ–™çš„é”™è¯¯ï¼Œå› æ­¤ï¼Œåœ¨ç»“æŸå‰åšä¸€äº›æ”¶å°¾å·¥ä½œä¼šæ˜¯éå¸¸å¥½çš„é€‰æ‹©ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„:

- å°†å¹¿æ’­æ¶ˆæ¯é€šé“ä½œä¸ºç»“æ„ä½“çš„ä¸€ä¸ªå­—æ®µæ˜¯ç›¸å½“ä¸é”™çš„é€‰æ‹©, ä¾‹å¦‚[è¿™ä¸ªä¾‹å­](https://github.com/tokio-rs/mini-redis/blob/master/src/shutdown.rs)
- è¿˜å¯ä»¥ä½¿ç”¨ [`watch channel`](https://docs.rs/tokio/1.16.1/tokio/sync/watch/index.html) å®ç°åŒæ ·çš„æ•ˆæœï¼Œä¸ä¹‹å‰çš„æ–¹å¼ç›¸æ¯”ï¼Œè¿™ä¸¤ç§æ–¹æ³•å¹¶æ²¡æœ‰å¤ªå¤§çš„åŒºåˆ«

## ç­‰å¾…å„ä¸ªéƒ¨åˆ†çš„ç»“æŸ

åœ¨ä¹‹å‰ç« èŠ‚ï¼Œæˆ‘ä»¬è®²åˆ°è¿‡ä¸€ä¸ª [`mpsc`](https://docs.rs/tokio/1/tokio/sync/mpsc/index.html) æ¶ˆæ¯é€šé“æœ‰ä¸€ä¸ªé‡è¦ç‰¹æ€§ï¼šå½“æ‰€æœ‰å‘é€ç«¯éƒ½ `drop` æ—¶ï¼Œæ¶ˆæ¯é€šé“ä¼šè‡ªåŠ¨å…³é—­ï¼Œæ­¤æ—¶ç»§ç»­æ¥æ”¶æ¶ˆæ¯å°±ä¼šæŠ¥é”™ã€‚

å¤§å®¶å‘ç°æ²¡ï¼Ÿè¿™ä¸ªç‰¹æ€§ç‰¹åˆ«é€‚åˆä¼˜é›…å…³é—­çš„åœºæ™¯ï¼šä¸»çº¿ç¨‹æŒæœ‰æ¶ˆæ¯é€šé“çš„æ¥æ”¶ç«¯ï¼Œç„¶åæ¯ä¸ªä»£ç éƒ¨åˆ†æ‹¿èµ°ä¸€ä¸ªå‘é€ç«¯ï¼Œå½“è¯¥éƒ¨åˆ†ç»“æŸæ—¶ï¼Œå°± `drop` æ‰å‘é€ç«¯ï¼Œå› æ­¤æ‰€æœ‰å‘é€ç«¯è¢« `drop` ä¹Ÿå°±æ„å‘³ç€æ‰€æœ‰çš„éƒ¨åˆ†éƒ½å·²å…³é—­ï¼Œæ­¤æ—¶ä¸»çº¿ç¨‹çš„æ¥æ”¶ç«¯å°±ä¼šæ”¶åˆ°é”™è¯¯ï¼Œè¿›è€Œç»“æŸã€‚

```rust
use tokio::sync::mpsc::{channel, Sender};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (send, mut recv) = channel(1);

    for i in 0..10 {
        tokio::spawn(some_operation(i, send.clone()));
    }

    // ç­‰å¾…å„ä¸ªä»»åŠ¡çš„å®Œæˆ
    //
    // æˆ‘ä»¬éœ€è¦ drop è‡ªå·±çš„å‘é€ç«¯ï¼Œå› ä¸ºç­‰ä¸‹çš„ `recv()` è°ƒç”¨ä¼šé˜»å¡, å¦‚æœä¸ `drop` ï¼Œé‚£å‘é€ç«¯å°±æ— æ³•è¢«å…¨éƒ¨å…³é—­
    // `recv` ä¹Ÿå°†æ°¸è¿œæ— æ³•ç»“æŸï¼Œè¿™å°†é™·å…¥ä¸€ä¸ªç±»ä¼¼æ­»é”çš„å›°å¢ƒ
    drop(send);

    // å½“æ‰€æœ‰å‘é€ç«¯éƒ½è¶…å‡ºä½œç”¨åŸŸè¢« `drop` æ—¶ (å½“å‰çš„å‘é€ç«¯å¹¶ä¸æ˜¯å› ä¸ºè¶…å‡ºä½œç”¨åŸŸè¢« `drop` è€Œæ˜¯æ‰‹åŠ¨ `drop` çš„)
    // `recv` è°ƒç”¨ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯
    let _ = recv.recv().await;
}

async fn some_operation(i: u64, _sender: Sender<()>) {
    sleep(Duration::from_millis(100 * i)).await;
    println!("Task {} shutting down.", i);

    // å‘é€ç«¯è¶…å‡ºä½œç”¨åŸŸï¼Œç„¶åè¢« `drop`
}
```

å…³äºå¿˜è®° `drop` æœ¬èº«æŒæœ‰çš„å‘é€ç«¯è¿›è€Œå¯¼è‡´ bug çš„é—®é¢˜ï¼Œå¤§å®¶å¯ä»¥çœ‹çœ‹[è¿™ç¯‡æ–‡ç« ](https://course.rs/compiler/pitfalls/main-with-channel-blocked.html)ã€‚



================================================
FILE: src/advance-practice/intro.md
================================================
# è¿›é˜¶å®æˆ˜: å®ç°ä¸€ä¸ªç®€å• redis

åœ¨å…¥é—¨å®æˆ˜ï¼Œä½ å¯ä»¥è¯´ä¼—è§ˆåŠå±±ä¸å’‹å°ï¼Œä½†æ˜¯èƒ½åšæŒåˆ°è¿™é‡Œï¼Œç”šè‡³å½“å®Œæˆåï¼Œå°±çœŸçš„æ˜¯ä¸€è§ˆä¼—å±±å°ï¼Œä½™æ•Œçš†é±¼è™¾äº†ã€‚

åœ¨è¿›é˜¶å®æˆ˜ä¸­ï¼Œæˆ‘ä»¬è¦æ¥çœŸçš„äº†ï¼Œä¹‹å‰çš„ç®€å•å‘½ä»¤è¡Œç¨‹åºï¼Œæ˜¯çœŸçš„ç®€å•ï¼Œä½†æ˜¯è¿™æ¬¡çš„ç®€å• redis æ˜¯çœŸçš„ä¸ç®€å•ï¼Œåœ¨è¿™é‡Œä½ å°†è¢«è¿«ä½¿ç”¨åå…«èˆ¬æ­¦è‰ºï¼Œç‰¹åˆ«çš„ï¼Œæˆ‘ä»¬è¿˜å°†å­¦ä¼š Rust å¼‚æ­¥é•‡å±±ä¹‹å® `tokio` åŒ…çš„ä½¿ç”¨ã€‚


> æœ¬ç« åœ¨å†…å®¹ä¸Šå¤§é‡å€Ÿé‰´å’Œç¿»è¯‘äº† tokio å®˜æ–¹æ–‡æ¡£[Tokio Tutorial](https://tokio.rs/tokio/tutorial), ä½†æ˜¯é‡æ–°ç»„ç»‡äº†å†…å®¹å½¢å¼å¹¶èå…¥äº†å¾ˆå¤šè‡ªå·±çš„è§è§£å’Œæ„Ÿæ‚Ÿï¼Œç»™å¤§å®¶æä¾›æ›´å¥½çš„å¯è¯»æ€§å’ŒçŸ¥è¯†æ‰©å±•æ€§




================================================
FILE: src/advance-practice/io.md
================================================
# I/O

æœ¬ç« èŠ‚ä¸­æˆ‘ä»¬å°†æ·±å…¥å­¦ä¹  Tokio ä¸­çš„ I/O æ“ä½œï¼Œäº†è§£å®ƒçš„åŸç†ä»¥åŠè¯¥å¦‚ä½•ä½¿ç”¨ã€‚

Tokio ä¸­çš„ I/O æ“ä½œå’Œ `std` åœ¨ä½¿ç”¨æ–¹å¼ä¸Šå‡ æ— åŒºåˆ«ï¼Œæœ€å¤§çš„åŒºåˆ«å°±æ˜¯å‰è€…æ˜¯å¼‚æ­¥çš„ï¼Œä¾‹å¦‚ Tokio çš„è¯»å†™ç‰¹å¾åˆ†åˆ«æ˜¯ `AsyncRead` å’Œ `AsyncWrite`:

- æœ‰éƒ¨åˆ†ç±»å‹æŒ‰ç…§è‡ªå·±çš„æ‰€éœ€å®ç°äº†å®ƒä»¬: `TcpStream`ï¼Œ`File`ï¼Œ`Stdout`
- è¿˜æœ‰æ•°æ®ç»“æ„ä¹Ÿå®ç°äº†å®ƒä»¬ï¼š`Vec<u8>`ã€`&[u8]`ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™äº›æ•°æ®ç»“æ„ä½œä¸ºè¯»å†™å™¨( reader / writer)

## AsyncRead å’Œ AsyncWrite

è¿™ä¸¤ä¸ªç‰¹å¾ä¸ºå­—èŠ‚æµçš„å¼‚æ­¥è¯»å†™æä¾›äº†ä¾¿åˆ©ï¼Œé€šå¸¸æˆ‘ä»¬ä¼šä½¿ç”¨ `AsyncReadExt` å’Œ `AsyncWriteExt` æä¾›çš„å·¥å…·æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•éƒ½ä½¿ç”¨ `async` å£°æ˜ï¼Œä¸”éœ€è¦é€šè¿‡ `.await` è¿›è¡Œè°ƒç”¨ï¼Œ

#### async fn read

`AsyncReadExt::read` æ˜¯ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•å¯ä»¥å°†æ•°æ®è¯»å…¥ç¼“å†²åŒº( `buffer` )ä¸­ï¼Œç„¶åè¿”å›è¯»å–çš„å­—èŠ‚æ•°ã€‚

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buffer = [0; 10];

    // ç”±äº buffer çš„é•¿åº¦é™åˆ¶ï¼Œå½“æ¬¡çš„ `read` è°ƒç”¨æœ€å¤šå¯ä»¥ä»æ–‡ä»¶ä¸­è¯»å– 10 ä¸ªå­—èŠ‚çš„æ•°æ®
    let n = f.read(&mut buffer[..]).await?;

    println!("The bytes: {:?}", &buffer[..n]);
    Ok(())
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼šå½“ `read` è¿”å› `Ok(0)` æ—¶ï¼Œæ„å‘³ç€å­—èŠ‚æµ( stream )å·²ç»å…³é—­ï¼Œåœ¨è¿™ä¹‹åç»§ç»­è°ƒç”¨ `read` ä¼šç«‹åˆ»å®Œæˆï¼Œä¾ç„¶è·å–åˆ°è¿”å›å€¼ `Ok(0)`ã€‚ ä¾‹å¦‚ï¼Œå­—èŠ‚æµå¦‚æœæ˜¯ `TcpStream` ç±»å‹ï¼Œé‚£ `Ok(0)` è¯´æ˜è¯¥**è¿æ¥çš„è¯»å–ç«¯å·²ç»è¢«å…³é—­**(å†™å…¥ç«¯å…³é—­ï¼Œä¼šæŠ¥å…¶å®ƒçš„é”™è¯¯)ã€‚

#### async fn read_to_end

`AsyncReadExt::read_to_end` æ–¹æ³•ä¼šä»å­—èŠ‚æµä¸­è¯»å–æ‰€æœ‰çš„å­—èŠ‚ï¼Œç›´åˆ°é‡åˆ° `EOF` ï¼š

```rust
use tokio::io::{self, AsyncReadExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buffer = Vec::new();

    // è¯»å–æ•´ä¸ªæ–‡ä»¶çš„å†…å®¹
    f.read_to_end(&mut buffer).await?;
    Ok(())
}
```

#### async fn write

`AsyncWriteExt::write` å¼‚æ­¥æ–¹æ³•ä¼šå°è¯•å°†ç¼“å†²åŒºçš„å†…å®¹å†™å…¥åˆ°å†™å…¥å™¨( `writer` )ä¸­ï¼ŒåŒæ—¶è¿”å›å†™å…¥çš„å­—èŠ‚æ•°:

```rust
use tokio::io::{self, AsyncWriteExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut file = File::create("foo.txt").await?;

    let n = file.write(b"some bytes").await?;

    println!("Wrote the first {} bytes of 'some bytes'.", n);
    Ok(())
}
```

ä¸Šé¢ä»£ç å¾ˆæ¸…æ™°ï¼Œä½†æ˜¯å¤§å®¶å¯èƒ½ä¼šç–‘æƒ‘ `b"some bytes"` æ˜¯ä»€ä¹ˆæ„æ€ã€‚è¿™ç§å†™æ³•å¯ä»¥å°†ä¸€ä¸ª `&str` å­—ç¬¦ä¸²è½¬å˜æˆä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼š`&[u8;10]`ï¼Œç„¶å `write` æ–¹æ³•åˆä¼šå°†è¿™ä¸ª `&[u8;10]` çš„æ•°ç»„ç±»å‹éšå¼å¼ºè½¬ä¸ºæ•°ç»„åˆ‡ç‰‡: `&[u8]`ã€‚

#### async fn write_all

`AsyncWriteExt::write_all` å°†ç¼“å†²åŒºçš„å†…å®¹å…¨éƒ¨å†™å…¥åˆ°å†™å…¥å™¨ä¸­ï¼š

```rust
use tokio::io::{self, AsyncWriteExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut file = File::create("foo.txt").await?;

    file.write_all(b"some bytes").await?;
    Ok(())
}
```

ä»¥ä¸Šåªæ˜¯éƒ¨åˆ†æ–¹æ³•ï¼Œå®é™…ä¸Šè¿˜æœ‰ä¸€äº›å®ç”¨çš„æ–¹æ³•ç”±äºç¯‡å¹…æœ‰é™æ— æ³•åˆ—å‡ºï¼Œå¤§å®¶å¯ä»¥é€šè¿‡ [API æ–‡æ¡£](https://docs.rs/tokio/latest/tokio/io/index.html) æŸ¥çœ‹å®Œæ•´çš„åˆ—è¡¨ã€‚

## å®ç”¨å‡½æ•°

å¦å¤–ï¼Œå’Œæ ‡å‡†åº“ä¸€æ ·ï¼Œ `tokio::io` æ¨¡å—åŒ…å«äº†å¤šä¸ªå®ç”¨çš„å‡½æ•°æˆ– APIï¼Œå¯ä»¥ç”¨äºå¤„ç†æ ‡å‡†è¾“å…¥/è¾“å‡º/é”™è¯¯ç­‰ã€‚

ä¾‹å¦‚ï¼Œ`tokio::io::copy` å¼‚æ­¥çš„å°†è¯»å–å™¨( `reader` )ä¸­çš„å†…å®¹æ‹·è´åˆ°å†™å…¥å™¨( `writer` )ä¸­ã€‚

```rust
use tokio::fs::File;
use tokio::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut reader: &[u8] = b"hello";
    let mut file = File::create("foo.txt").await?;

    io::copy(&mut reader, &mut file).await?;
    Ok(())
}
```

è¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰æåˆ°çš„å­—èŠ‚æ•°ç»„ `&[u8]` å®ç°äº† `AsyncRead` å—ï¼Ÿæ­£å› ä¸ºè¿™ä¸ªåŸå› ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ç›´æ¥å°† `&u8` ç”¨ä½œè¯»å–å™¨ã€‚

## å›å£°æœåŠ¡( Echo )

å°±å¦‚åŒå†™ä»£ç å¿…å†™ `hello, world`ï¼Œå®ç° web æœåŠ¡å™¨ï¼Œå¾€å¾€ä¼šé€‰æ‹©å®ç°ä¸€ä¸ªå›å£°æœåŠ¡ã€‚è¯¥æœåŠ¡ä¼šå°†ç”¨æˆ·çš„è¾“å…¥å†…å®¹ç›´æ¥è¿”å›ç»™ç”¨æˆ·ï¼Œå°±åƒå›å£°å£ä¸€æ ·ã€‚

å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯ä»ç”¨æˆ·å»ºç«‹çš„ TCP è¿æ¥çš„ socket ä¸­è¯»å–åˆ°æ•°æ®ï¼Œç„¶åç«‹åˆ»å°†åŒæ ·çš„æ•°æ®å†™å›åˆ°è¯¥ socket ä¸­ã€‚å› æ­¤å®¢æˆ·ç«¯ä¼šæ”¶åˆ°å’Œè‡ªå·±å‘é€çš„æ•°æ®ä¸€æ¨¡ä¸€æ ·çš„å›å¤ã€‚

ä¸‹é¢æˆ‘ä»¬å°†ä½¿ç”¨ä¸¤ç§ç¨æœ‰ä¸åŒçš„æ–¹æ³•å®ç°è¯¥å›å£°æœåŠ¡ã€‚

#### ä½¿ç”¨ `io::copy()`

å…ˆæ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ bin æ–‡ä»¶ï¼Œç”¨äºè¿è¡Œæˆ‘ä»¬çš„å›å£°æœåŠ¡ï¼š

```console
touch src/bin/echo-server-copy.rs
```

ç„¶åå¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤è¿è¡Œå®ƒ(è·Ÿä¸Šä¸€ç« èŠ‚çš„æ–¹å¼ç›¸åŒ)ï¼š

```console
cargo run --bin echo-server-copy
```

è‡³äºå®¢æˆ·ç«¯ï¼Œå¯ä»¥ç®€å•çš„ä½¿ç”¨ `telnet` çš„æ–¹å¼æ¥è¿æ¥ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥ä½¿ç”¨ `tokio::net::TcpStream`ï¼Œå®ƒçš„[æ–‡æ¡£ç¤ºä¾‹](https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html#examples)éå¸¸é€‚åˆå¤§å®¶è¿›è¡Œå‚è€ƒã€‚

å…ˆæ¥å®ç°ä¸€ä¸‹åŸºæœ¬çš„æœåŠ¡å™¨æ¡†æ¶ï¼šé€šè¿‡ loop å¾ªç¯æ¥æ”¶ TCP è¿æ¥ï¼Œç„¶åä¸ºæ¯ä¸€æ¡è¿æ¥åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„ä»»åŠ¡å»å¤„ç†ã€‚

```rust
use tokio::io;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            // åœ¨è¿™é‡Œæ‹·è´æ•°æ®
        });
    }
}
```

ä¸‹é¢ï¼Œæ¥çœ‹çœ‹é‡å¤´æˆ `io::copy` ï¼Œå®ƒæœ‰ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ªè¯»å–å™¨ï¼Œä¸€ä¸ªå†™å…¥å™¨ï¼Œç„¶åå°†è¯»å–å™¨ä¸­çš„æ•°æ®ç›´æ¥æ‹·è´åˆ°å†™å…¥å™¨ä¸­ï¼Œç±»ä¼¼çš„å®ç°ä»£ç å¦‚ä¸‹ï¼š

```rust
io::copy(&mut socket, &mut socket).await
```

è¿™æ®µä»£ç ç›¸ä¿¡å¤§å®¶ä¸€çœ¼å°±èƒ½çœ‹å‡ºé—®é¢˜ï¼Œç”±äºæˆ‘ä»¬çš„è¯»å–å™¨å’Œå†™å…¥å™¨éƒ½æ˜¯åŒä¸€ä¸ª socketï¼Œå› æ­¤éœ€è¦å¯¹å…¶è¿›è¡Œä¸¤æ¬¡å¯å˜å€Ÿç”¨ï¼Œè¿™æ˜æ˜¾è¿èƒŒäº† Rust çš„å€Ÿç”¨è§„åˆ™ã€‚

##### åˆ†ç¦»è¯»å†™å™¨

æ˜¾ç„¶ï¼Œä½¿ç”¨åŒä¸€ä¸ª socket æ˜¯ä¸è¡Œçš„ï¼Œä¸ºäº†å®ç°ç›®æ ‡åŠŸèƒ½ï¼Œå¿…é¡»å°† `socket` åˆ†ç¦»æˆä¸€ä¸ªè¯»å–å™¨å’Œå†™å…¥å™¨ã€‚

ä»»ä½•ä¸€ä¸ªè¯»å†™å™¨( reader + writer )éƒ½å¯ä»¥ä½¿ç”¨ `io::split` æ–¹æ³•è¿›è¡Œåˆ†ç¦»ï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ªè¯»å–å™¨å’Œå†™å…¥å™¨ï¼Œè¿™ä¸¤è€…å¯ä»¥ç‹¬è‡ªçš„ä½¿ç”¨ï¼Œä¾‹å¦‚å¯ä»¥æ”¾å…¥ä¸åŒçš„ä»»åŠ¡ä¸­ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„å›å£°å®¢æˆ·ç«¯å¯ä»¥è¿™æ ·å®ç°ï¼Œä»¥å®ç°åŒæ—¶å¹¶å‘è¯»å†™ï¼š

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

#[tokio::main]
async fn main() -> io::Result<()> {
    let socket = TcpStream::connect("127.0.0.1:6142").await?;
    let (mut rd, mut wr) = io::split(socket);

    // åˆ›å»ºå¼‚æ­¥ä»»åŠ¡ï¼Œåœ¨åå°å†™å…¥æ•°æ®
    tokio::spawn(async move {
        wr.write_all(b"hello\r\n").await?;
        wr.write_all(b"world\r\n").await?;

        // æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ç»™äºˆ Rust ä¸€äº›ç±»å‹æš—ç¤ºï¼Œå®ƒæ‰èƒ½æ­£ç¡®çš„æ¨å¯¼å‡ºç±»å‹
        Ok::<_, io::Error>(())
    });

    let mut buf = vec![0; 128];

    loop {
        let n = rd.read(&mut buf).await?;

        if n == 0 {
            break;
        }

        println!("GOT {:?}", &buf[..n]);
    }

    Ok(())
}
```

å®é™…ä¸Šï¼Œ`io::split` å¯ä»¥ç”¨äºä»»ä½•åŒæ—¶å®ç°äº† `AsyncRead` å’Œ `AsyncWrite` çš„å€¼ï¼Œå®ƒçš„å†…éƒ¨ä½¿ç”¨äº† `Arc` å’Œ `Mutex` æ¥å®ç°ç›¸åº”çš„åŠŸèƒ½ã€‚å¦‚æœå¤§å®¶è§‰å¾—è¿™ç§å®ç°æœ‰äº›é‡ï¼Œå¯ä»¥ä½¿ç”¨ Tokio æä¾›çš„ `TcpStream`ï¼Œå®ƒæä¾›äº†ä¸¤ç§æ–¹å¼è¿›è¡Œåˆ†ç¦»:

- [`TcpStream::split`](https://docs.rs/tokio/1.15.0/tokio/net/struct.TcpStream.html#method.split)ä¼šè·å–å­—èŠ‚æµçš„å¼•ç”¨ï¼Œç„¶åå°†å…¶åˆ†ç¦»æˆä¸€ä¸ªè¯»å–å™¨å’Œå†™å…¥å™¨ã€‚ä½†ç”±äºä½¿ç”¨äº†å¼•ç”¨çš„æ–¹å¼ï¼Œå®ƒä»¬ä¿©å¿…é¡»å’Œ `split` åœ¨åŒä¸€ä¸ªä»»åŠ¡ä¸­ã€‚ ä¼˜ç‚¹å°±æ˜¯ï¼Œè¿™ç§å®ç°æ²¡æœ‰æ€§èƒ½å¼€é”€ï¼Œå› ä¸ºæ— éœ€ `Arc` å’Œ `Mutex`ã€‚
- [`TcpStream::into_split`](https://docs.rs/tokio/1.15.0/tokio/net/struct.TcpStream.html#method.into_split)è¿˜æä¾›äº†ä¸€ç§åˆ†ç¦»å®ç°ï¼Œåˆ†ç¦»å‡ºæ¥çš„ç»“æœå¯ä»¥åœ¨ä»»åŠ¡é—´ç§»åŠ¨ï¼Œå†…éƒ¨æ˜¯é€šè¿‡ `Arc` å®ç°

å†æ¥åˆ†æä¸‹æˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯ï¼Œç”±äº `io::copy()` è°ƒç”¨æ—¶æ‰€åœ¨çš„ä»»åŠ¡å’Œ `split` æ‰€åœ¨çš„ä»»åŠ¡æ˜¯åŒä¸€ä¸ªï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ€§èƒ½æœ€é«˜çš„ `TcpStream::split`:

```rust
tokio::spawn(async move {
    let (mut rd, mut wr) = socket.split();

    if io::copy(&mut rd, &mut wr).await.is_err() {
        eprintln!("failed to copy");
    }
});
```

ä½¿ç”¨ `io::copy` å®ç°çš„å®Œæ•´ä»£ç è§[æ­¤å¤„](https://github.com/tokio-rs/website/blob/master/tutorial-code/io/src/echo-server-copy.rs)ã€‚

#### æ‰‹åŠ¨æ‹·è´

ç¨‹åºå‘˜å¾€å¾€æ‹¥æœ‰ä¸€é¢—æ‰‹åŠ¨å¹²ç¿»ä¸€åˆ‡çš„å¿ƒï¼Œå› æ­¤å¦‚æœä½ ä¸æƒ³ç”¨ `io::copy` æ¥ç®€å•å®ç°ï¼Œè¿˜å¯ä»¥è‡ªå·±æ‰‹åŠ¨å»æ‹·è´æ•°æ®:

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let mut buf = vec![0; 1024];

            loop {
                match socket.read(&mut buf).await {
                    // è¿”å›å€¼ `Ok(0)` è¯´æ˜å¯¹ç«¯å·²ç»å…³é—­
                    Ok(0) => return,
                    Ok(n) => {
                        // Copy the data back to socket
                        // å°†æ•°æ®æ‹·è´å› socket ä¸­
                        if socket.write_all(&buf[..n]).await.is_err() {
                            // éé¢„æœŸé”™è¯¯ï¼Œç”±äºæˆ‘ä»¬è¿™é‡Œæ— éœ€å†åšä»€ä¹ˆï¼Œå› æ­¤ç›´æ¥åœæ­¢å¤„ç†
                            return;
                        }
                    }
                    Err(_) => {
                      // éé¢„æœŸé”™è¯¯ï¼Œç”±äºæˆ‘ä»¬æ— éœ€å†åšä»€ä¹ˆï¼Œå› æ­¤ç›´æ¥åœæ­¢å¤„ç†
                        return;
                    }
                }
            }
        });
    }
}
```

å»ºè®®è¿™æ®µä»£ç æ”¾å…¥ä¸€ä¸ªå’Œä¹‹å‰ `io::copy` ä¸åŒçš„æ–‡ä»¶ä¸­ `src/bin/echo-server.rs` ï¼Œ ç„¶åä½¿ç”¨ `cargo run --bin echo-server` è¿è¡Œã€‚

ä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹è¿™æ®µä»£ç æœ‰å“ªäº›å€¼å¾—æ³¨æ„çš„åœ°æ–¹ã€‚é¦–å…ˆï¼Œç”±äºä½¿ç”¨äº† `write_all` å’Œ `read` æ–¹æ³•ï¼Œéœ€è¦å…ˆå°†å¯¹åº”çš„ç‰¹å¾å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸå†…:

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
```

##### åœ¨å †ä¸Šåˆ†é…ç¼“å†²åŒº

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å°†æ•°æ®ä» `socket` ä¸­è¯»å–åˆ°ä¸€ä¸ªç¼“å†²åŒº `buffer` ä¸­ï¼š

```rust
let mut buf = vec![0; 1024];
```

å¯ä»¥çœ‹åˆ°ï¼Œæ­¤å¤„çš„ç¼“å†²åŒºæ˜¯ä¸€ä¸ª `Vec` åŠ¨æ€æ•°ç»„ï¼Œå®ƒçš„æ•°æ®æ˜¯å­˜å‚¨åœ¨å †ä¸Šï¼Œè€Œä¸æ˜¯æ ˆä¸Š(è‹¥æ”¹æˆ `let mut buf = [0; 1024];`ï¼Œåˆ™å­˜å‚¨åœ¨æ ˆä¸Š)ã€‚

åœ¨ä¹‹å‰ï¼Œæˆ‘ä»¬æåˆ°è¿‡ä¸€ä¸ªæ•°æ®å¦‚æœæƒ³åœ¨ `.await` è°ƒç”¨è¿‡ç¨‹ä¸­å­˜åœ¨ï¼Œé‚£å®ƒå¿…é¡»å­˜å‚¨åœ¨å½“å‰ä»»åŠ¡å†…ã€‚åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­ï¼Œ`buf` ä¼šåœ¨ `.await` è°ƒç”¨è¿‡ç¨‹ä¸­è¢«ä½¿ç”¨ï¼Œå› æ­¤å®ƒå¿…é¡»è¦å­˜å‚¨åœ¨ä»»åŠ¡å†…ã€‚

è‹¥è¯¥ç¼“å†²åŒºæ•°ç»„åˆ›å»ºåœ¨æ ˆä¸Šï¼Œé‚£æ¯æ¡è¿æ¥æ‰€å¯¹åº”çš„ä»»åŠ¡çš„å†…éƒ¨æ•°æ®ç»“æ„çœ‹ä¸Šå»å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
struct Task {
    task: enum {
        AwaitingRead {
            socket: TcpStream,
            buf: [BufferType],
        },
        AwaitingWriteAll {
            socket: TcpStream,
            buf: [BufferType],
        }

    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œæ ˆæ•°ç»„è¦è¢«ä½¿ç”¨ï¼Œå°±å¿…é¡»å­˜å‚¨åœ¨ç›¸åº”çš„ç»“æ„ä½“å†…ï¼Œå…¶ä¸­ä¸¤ä¸ªç»“æ„ä½“åˆ†åˆ«æŒæœ‰äº†ä¸åŒçš„æ ˆæ•°ç»„ `[BufferType]`ï¼Œè¿™ç§æ–¹å¼ä¼šå¯¼è‡´ä»»åŠ¡ç»“æ„å˜å¾—å¾ˆå¤§ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬é€‰æ‹©ç¼“å†²åŒºé•¿åº¦å¾€å¾€ä¼šä½¿ç”¨åˆ†é¡µé•¿åº¦(page size)ï¼Œå› æ­¤ä½¿ç”¨æ ˆæ•°ç»„ä¼šå¯¼è‡´ä»»åŠ¡çš„å†…å­˜å¤§å°å˜å¾—å¾ˆå¥‡æ€ªç”šè‡³ç³Ÿç³•ï¼š`$page-size + ä¸€äº›é¢å¤–çš„å­—èŠ‚`ã€‚

å½“ç„¶ï¼Œç¼–è¯‘å™¨ä¼šå¸®åŠ©æˆ‘ä»¬åšä¸€äº›ä¼˜åŒ–ã€‚ä¾‹å¦‚ï¼Œä¼šè¿›ä¸€æ­¥ä¼˜åŒ– `async` è¯­å¥å—çš„å¸ƒå±€ï¼Œè€Œä¸æ˜¯åƒä¸Šé¢ä¸€æ ·ç®€å•çš„ä½¿ç”¨ `enum`ã€‚åœ¨å®è·µä¸­ï¼Œå˜é‡ä¹Ÿä¸ä¼šåœ¨æšä¸¾æˆå‘˜é—´ç§»åŠ¨ã€‚

ä½†æ˜¯å†æ€ä¹ˆä¼˜åŒ–ï¼Œä»»åŠ¡çš„ç»“æ„ä½“è‡³å°‘ä¹Ÿä¼šè·Ÿå…¶ä¸­çš„æ ˆæ•°ç»„ä¸€æ ·å¤§ï¼Œå› æ­¤é€šå¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨å †ä¸Šçš„ç¼“å†²åŒºä¼šé«˜æ•ˆå®ç”¨çš„å¤šã€‚

> å½“ä»»åŠ¡å› ä¸ºè°ƒåº¦åœ¨çº¿ç¨‹é—´ç§»åŠ¨æ—¶ï¼Œå­˜å‚¨åœ¨æ ˆä¸Šçš„æ•°æ®éœ€è¦è¿›è¡Œä¿å­˜å’Œæ¢å¤ï¼Œè¿‡å¤§çš„æ ˆä¸Šå˜é‡ä¼šå¸¦æ¥ä¸å°çš„æ•°æ®æ‹·è´å¼€é”€
>
> å› æ­¤ï¼Œå­˜å‚¨å¤§é‡æ•°æ®çš„å˜é‡æœ€å¥½æ”¾åˆ°å †ä¸Š

##### å¤„ç† EOF

å½“ TCP è¿æ¥çš„è¯»å–ç«¯å…³é—­åï¼Œå†è°ƒç”¨ `read` æ–¹æ³•ä¼šè¿”å› `Ok(0)`ã€‚æ­¤æ—¶ï¼Œå†ç»§ç»­ä¸‹å»å·²ç»æ²¡æœ‰æ„ä¹‰ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€€å‡ºå¾ªç¯ã€‚å¿˜è®°åœ¨ EOF æ—¶é€€å‡ºè¯»å–å¾ªç¯ï¼Œæ˜¯ç½‘ç»œç¼–ç¨‹ä¸­ä¸€ä¸ªå¸¸è§çš„ bug :

```rust
loop {
    match socket.read(&mut buf).await {
        Ok(0) => return,
        // ... å…¶ä½™é”™è¯¯å¤„ç†
    }
}
```

å¤§å®¶ä¸å¦¨æ·±å…¥æ€è€ƒä¸‹ï¼Œå¦‚æœæ²¡æœ‰é€€å‡ºå¾ªç¯ä¼šæ€ä¹ˆæ ·ï¼Ÿä¹‹å‰æˆ‘ä»¬æåˆ°è¿‡ï¼Œä¸€æ—¦è¯»å–ç«¯å…³é—­åï¼Œé‚£åé¢çš„ `read` è°ƒç”¨å°±ä¼šç«‹å³è¿”å› `Ok(0)`ï¼Œè€Œä¸ä¼šé˜»å¡ç­‰å¾…ï¼Œå› æ­¤è¿™ç§æ— é˜»å¡å¾ªç¯ä¼šæœ€ç»ˆå¯¼è‡´ CPU ç«‹åˆ»è·‘åˆ° 100% ï¼Œå¹¶å°†ä¸€ç›´æŒç»­ä¸‹å»ï¼Œç›´åˆ°ç¨‹åºå…³é—­ã€‚




================================================
FILE: src/advance-practice/overview.md
================================================
# tokio æ¦‚è§ˆ

å¯¹äº Async Rustï¼Œæœ€æœ€é‡è¦çš„è«è¿‡äºåº•å±‚çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼Œå®ƒæä¾›äº†æ‰§è¡Œå™¨ã€ä»»åŠ¡è°ƒåº¦ã€å¼‚æ­¥ API ç­‰æ ¸å¿ƒæœåŠ¡ã€‚ç®€å•æ¥è¯´ï¼Œä½¿ç”¨ Rust æä¾›çš„ `async/await` ç‰¹æ€§ç¼–å†™çš„å¼‚æ­¥ä»£ç è¦è¿è¡Œèµ·æ¥ï¼Œå°±å¿…é¡»ä¾èµ–äºå¼‚æ­¥è¿è¡Œæ—¶ï¼Œå¦åˆ™è¿™äº›ä»£ç å°†æ¯«æ— ç”¨å¤„ã€‚

## å¼‚æ­¥è¿è¡Œæ—¶

Rust è¯­è¨€æœ¬èº«åªæä¾›äº†å¼‚æ­¥ç¼–ç¨‹æ‰€éœ€çš„åŸºæœ¬ç‰¹æ€§ï¼Œä¾‹å¦‚ `async/await` å…³é”®å­—ï¼Œæ ‡å‡†åº“ä¸­çš„ `Future` ç‰¹å¾ï¼Œå®˜æ–¹æä¾›çš„ `futures` å®ç”¨åº“ï¼Œè¿™äº›ç‰¹æ€§å•ç‹¬ä½¿ç”¨æ²¡æœ‰ä»»ä½•ç”¨å¤„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¿è¡Œæ—¶æ¥å°†è¿™äº›ç‰¹æ€§å®ç°çš„ä»£ç è¿è¡Œèµ·æ¥ã€‚

å¼‚æ­¥è¿è¡Œæ—¶æ˜¯ç”± Rust ç¤¾åŒºæä¾›çš„ï¼Œå®ƒä»¬çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ª `reactor` å’Œä¸€ä¸ªæˆ–å¤šä¸ª `executor`(æ‰§è¡Œå™¨):

- `reactor` ç”¨äºæä¾›å¤–éƒ¨äº‹ä»¶çš„è®¢é˜…æœºåˆ¶ï¼Œä¾‹å¦‚ `I/O` ã€è¿›ç¨‹é—´é€šä¿¡ã€å®šæ—¶å™¨ç­‰
- `executor` åœ¨ä¸Šä¸€ç« æˆ‘ä»¬æœ‰è¿‡æ·±å…¥ä»‹ç»ï¼Œå®ƒç”¨äºè°ƒåº¦å’Œæ‰§è¡Œç›¸åº”çš„ä»»åŠ¡( `Future` )

ç›®å‰æœ€å—æ¬¢è¿çš„å‡ ä¸ªè¿è¡Œæ—¶æœ‰:

- [`tokio`](https://github.com/tokio-rs/tokio)ï¼Œç›®å‰æœ€å—æ¬¢è¿çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œè¿˜æä¾›äº†å¼‚æ­¥æ‰€éœ€çš„å„ç§å·¥å…·(ä¾‹å¦‚ tracing )ã€ç½‘ç»œåè®®æ¡†æ¶(ä¾‹å¦‚ HTTPï¼ŒgRPC )ç­‰ç­‰
- [`async-std`](https://github.com/async-rs/async-std)ï¼Œæœ€å¤§çš„ä¼˜ç‚¹å°±æ˜¯è·Ÿæ ‡å‡†åº“å…¼å®¹æ€§è¾ƒå¼º
- [`smol`](https://github.com/smol-rs/smol), ä¸€ä¸ªå°å·§çš„å¼‚æ­¥è¿è¡Œæ—¶

ä½†æ˜¯ï¼Œå¤§æµªæ·˜æ²™ï¼Œç•™ä¸‹çš„æ‰æ˜¯é‡‘å­ï¼Œéšç€æ—¶é—´çš„æµé€ï¼Œ`tokio`è¶Šæ¥è¶Šäº®çœ¼ï¼Œæ— è®ºæ˜¯æ€§èƒ½ã€åŠŸèƒ½è¿˜æ˜¯ç¤¾åŒºã€æ–‡æ¡£ï¼Œå®ƒåœ¨å„ä¸ªæ–¹é¢éƒ½å¼‚å¸¸ä¼˜ç§€ï¼Œæ—¶è‡³ä»Šæ—¥ï¼Œå¯ä»¥è¯´å·²æˆä¸ºäº‹å®ä¸Šçš„æ ‡å‡†ã€‚

#### å¼‚æ­¥è¿è¡Œæ—¶çš„å…¼å®¹æ€§

ä¸ºä½•é€‰æ‹©å¼‚æ­¥è¿è¡Œæ—¶è¿™ä¹ˆé‡è¦ï¼Ÿä¸ä»…ä»…æ˜¯å®ƒä»¬åœ¨åŠŸèƒ½ã€æ€§èƒ½ä¸Šå­˜åœ¨åŒºåˆ«ï¼Œæ›´é‡è¦çš„æ˜¯å½“ä½ é€‰æ‹©äº†ä¸€ä¸ªï¼Œå¾€å¾€å°±æ— æ³•åˆ‡æ¢åˆ°å¦å¤–ä¸€ä¸ªï¼Œé™¤éå¼‚æ­¥ä»£ç å¾ˆå°‘ã€‚

ä½¿ç”¨å¼‚æ­¥è¿è¡Œæ—¶ï¼Œå¾€å¾€ä¼´éšç€å¯¹å®ƒç›¸å…³çš„ç”Ÿæ€ç³»ç»Ÿçš„æ·±å…¥ä½¿ç”¨ï¼Œå› æ­¤è€¦åˆæ€§ä¼šè¶Šæ¥è¶Šå¼ºï¼Œç›´è‡³æœ€åä½ å¾ˆéš¾åˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿è¡Œæ—¶ï¼Œä¾‹å¦‚ `tokio` å’Œ `async-std` ï¼Œå°±å­˜åœ¨è¿™ç§é—®é¢˜ã€‚

å¦‚æœä½ å®åœ¨æœ‰è¿™ç§éœ€æ±‚ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ [`async-compat`](https://github.com/smol-rs/async-compat)ï¼Œè¯¥åŒ…æä¾›äº†ä¸€ä¸ªä¸­é—´å±‚ï¼Œç”¨äºå…¼å®¹ `tokio` å’Œå…¶å®ƒè¿è¡Œæ—¶ã€‚

#### ç»“è®º

ç›¸ä¿¡å¤§å®¶çœ‹åˆ°ç°åœ¨ï¼Œå¿ƒä¸­åº”è¯¥æœ‰ä¸€ä¸ªç»“è®ºäº†ã€‚é¦–å…ˆï¼Œè¿è¡Œæ—¶ä¹‹é—´çš„ä¸å…¼å®¹æ€§ï¼Œè®©æˆ‘ä»¬å¿…é¡»æå‰é€‰æ‹©ä¸€ä¸ªè¿è¡Œæ—¶ï¼Œå¹¶ä¸”åœ¨æœªæ¥åšæŒç”¨ä¸‹å»ï¼Œé‚£è¿™ä¸ªè¿è¡Œæ—¶å°±åº”è¯¥æ˜¯æœ€ä¼˜ç§€ã€æœ€æˆç†Ÿçš„é‚£ä¸ªï¼Œ`tokio` å‡ ä¹æˆäº†ä¸äºŒé€‰æ‹©ï¼Œå½“ç„¶ `tokio` ä¹Ÿæœ‰è‡ªå·±çš„é—®é¢˜ï¼šæ›´éš¾ä¸Šæ‰‹å’Œè¿è¡Œæ—¶ä¹‹é—´çš„å…¼å®¹æ€§ã€‚

å¦‚æœä½ åªç”¨ `tokio` ï¼Œé‚£å…¼å®¹æ€§è‡ªç„¶ä¸æ˜¯é—®é¢˜ï¼Œè‡³äºéš¾ä»¥ä¸Šæ‰‹ï¼ŒRust è¿™ä¹ˆéš¾ï¼Œæˆ‘ä»¬éƒ½å­¦åˆ°ç°åœ¨äº†ï¼Œä½•å†µåŒºåŒºä¸€ä¸ªå¼‚æ­¥è¿è¡Œæ—¶ï¼Œåœ¨æœ¬ä¹¦çš„å¸®åŠ©ä¸‹ï¼Œè¿™äº›éƒ½ä¸å†æ˜¯é—®é¢˜ï¼šï¼‰

## tokio ç®€ä»‹

tokio æ˜¯ä¸€ä¸ªçº¸é†‰é‡‘è¿·ä¹‹åœ°ï¼Œåªè¦æœ‰é’±å°±å¯ä»¥ä¸ºæ‰€æ¬²ä¸ºï¼Œå“¦ï¼ŒæŠ±æ­‰ï¼Œèµ°é”™ç‰‡åœºäº†ã€‚`tokio` æ˜¯ Rust æœ€ä¼˜ç§€çš„å¼‚æ­¥è¿è¡Œæ—¶æ¡†æ¶ï¼Œå®ƒæä¾›äº†å†™å¼‚æ­¥ç½‘ç»œæœåŠ¡æ‰€éœ€çš„å‡ ä¹æ‰€æœ‰åŠŸèƒ½ï¼Œä¸ä»…ä»…é€‚ç”¨äºå¤§å‹æœåŠ¡å™¨ï¼Œè¿˜é€‚ç”¨äºå°å‹åµŒå…¥å¼è®¾å¤‡ï¼Œå®ƒä¸»è¦ç”±ä»¥ä¸‹ç»„ä»¶æ„æˆï¼š

- å¤šçº¿ç¨‹ç‰ˆæœ¬çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼Œå¯ä»¥è¿è¡Œä½¿ç”¨ `async/await` ç¼–å†™çš„ä»£ç 
- æ ‡å‡†åº“ä¸­é˜»å¡ API çš„å¼‚æ­¥ç‰ˆæœ¬ï¼Œä¾‹å¦‚`thread::sleep`ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œ`tokio`ä¸­å°±æä¾›äº†ç›¸åº”çš„å¼‚æ­¥å®ç°ç‰ˆæœ¬
- æ„å»ºå¼‚æ­¥ç¼–ç¨‹æ‰€éœ€çš„ç”Ÿæ€ï¼Œç”šè‡³è¿˜æä¾›äº† [`tracing`](https://github.com/tokio-rs/tracing) ç”¨äºæ—¥å¿—å’Œåˆ†å¸ƒå¼è¿½è¸ªï¼Œ æä¾› [`console`](https://github.com/tokio-rs/console) ç”¨äº Debug å¼‚æ­¥ç¼–ç¨‹

### ä¼˜åŠ¿

ä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹ä½¿ç”¨ `tokio` èƒ½ç»™ä½ æä¾›å“ªäº›ä¼˜åŠ¿ã€‚

**é«˜æ€§èƒ½**

å› ä¸ºå¿«æ‰€ä»¥å¿«ï¼Œå‰è€…æ˜¯ Rust å¿«ï¼Œåè€…æ˜¯ `tokio` å¿«ã€‚ `tokio` åœ¨ç¼–å†™æ—¶å……åˆ†åˆ©ç”¨äº† Rust æä¾›çš„å„ç§é›¶æˆæœ¬æŠ½è±¡å’Œé«˜æ€§èƒ½ç‰¹æ€§ï¼Œè€Œä¸”è´¯å½»äº† Rust çš„ç‰›é€¼æ€æƒ³ï¼šå¦‚æœä½ é€‰æ‹©æ‰‹å†™ä»£ç ï¼Œé‚£ä¹ˆæœ€å¥½çš„ç»“æœå°±æ˜¯è·Ÿ `tokio` ä¸€æ ·å¿«ï¼

ä»¥ä¸‹æ˜¯ä¸€å¼ å®˜æ–¹æä¾›çš„æ€§èƒ½å‚è€ƒå›¾ï¼Œå¤§è‡´èƒ½ä½“ç°å‡º `tokio` çš„æ€§èƒ½ä¹‹ææ€–:
<img alt="tokio performance" src="https://pica.zhimg.com/80/v2-5f5ca10550ec936427c2919191331ae8_1440w.png" class="center"  />

**é«˜å¯é **

Rust è¯­è¨€çš„å®‰å…¨å¯é æ€§é¡ºç†æˆç« çš„å½±å“äº† `tokio` çš„å¯é æ€§ï¼Œæ›¾ç»æœ‰ä¸€ä¸ªè°ƒæŸ¥ç»™å‡ºäº†ä»¤äººä¹èˆŒçš„[ç»“è®º](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)ï¼šè½¯ä»¶ç³»ç»Ÿ 70%çš„é«˜å±æ¼æ´éƒ½æ˜¯ç”±å†…å­˜ä¸å®‰å…¨æ€§å¯¼è‡´çš„ã€‚

åœ¨ Rust æä¾›çš„å®‰å…¨æ€§ä¹‹å¤–ï¼Œ`tokio` è¿˜è‡´åŠ›äºæä¾›ä¸€è‡´æ€§çš„è¡Œä¸ºè¡¨ç°ï¼šæ— è®ºä½ ä½•æ—¶è¿è¡Œç³»ç»Ÿï¼Œå®ƒçš„é¢„æœŸè¡¨ç°å’Œæ€§èƒ½éƒ½æ˜¯ä¸€è‡´çš„ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°è«åå…¶å¦™çš„è¯·æ±‚å»¶è¿Ÿæˆ–å“åº”æ—¶é—´å¤§å¹…å¢åŠ ã€‚

**ç®€å•æ˜“ç”¨**

é€šè¿‡ Rust æä¾›çš„ `async/await` ç‰¹æ€§ï¼Œç¼–å†™å¼‚æ­¥ç¨‹åºçš„å¤æ‚æ€§ç›¸æ¯”å½“åˆå·²ç»å¤§å¹…é™ä½ï¼ŒåŒæ—¶ `tokio` è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸°å¯Œçš„ç”Ÿæ€ï¼Œè¿›ä¸€æ­¥å¤§å¹…é™ä½äº†å…¶å¤æ‚æ€§ã€‚

åŒæ—¶ `tokio` éµå¾ªäº†æ ‡å‡†åº“çš„å‘½åè§„åˆ™ï¼Œè®©ç†Ÿæ‚‰æ ‡å‡†åº“çš„ç”¨æˆ·å¯ä»¥å¾ˆå¿«ä¹ æƒ¯äº `tokio` çš„è¯­æ³•ï¼Œå†å€ŸåŠ©äº Rust å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿï¼Œç”¨æˆ·å¯ä»¥è½»æ¾åœ°ç¼–å†™å’Œäº¤ä»˜æ­£ç¡®çš„ä»£ç ã€‚

**ä½¿ç”¨çµæ´»æ€§**

`tokio` æ”¯æŒä½ çµæ´»çš„å®šåˆ¶è‡ªå·±æƒ³è¦çš„è¿è¡Œæ—¶ï¼Œä¾‹å¦‚ä½ å¯ä»¥é€‰æ‹©å¤šçº¿ç¨‹ + ä»»åŠ¡ç›—å–æ¨¡å¼çš„å¤æ‚è¿è¡Œæ—¶ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©å•çº¿ç¨‹çš„è½»é‡çº§è¿è¡Œæ—¶ã€‚æ€»ä¹‹ï¼Œå‡ ä¹ä½ çš„æ¯ä¸€ç§éœ€æ±‚åœ¨ `tokio` ä¸­éƒ½èƒ½å¯»æ‰¾åˆ°æ”¯æŒ(ç”»å¤–éŸ³ï¼šå¼ºå¤§çš„çµæ´»æ€§éœ€è¦ä¸€å®šçš„å¤æ‚æ€§æ¥æ¢å–ï¼Œå¹¶ä¸æ˜¯å…è´¹çš„åˆé¤)ã€‚

### åŠ£åŠ¿

è™½ç„¶ `tokio` å¯¹äºå¤§å¤šæ•°éœ€è¦å¹¶å‘çš„é¡¹ç›®éƒ½æ˜¯éå¸¸é€‚åˆçš„ï¼Œä½†æ˜¯ç¡®å®æœ‰ä¸€äº›åœºæ™¯å®ƒå¹¶ä¸é€‚åˆä½¿ç”¨:

- **å¹¶è¡Œè¿è¡Œ CPU å¯†é›†å‹çš„ä»»åŠ¡**ã€‚`tokio` éå¸¸é€‚åˆäº IO å¯†é›†å‹ä»»åŠ¡ï¼Œè¿™äº› IO ä»»åŠ¡çš„ç»å¤§å¤šæ•°æ—¶é—´éƒ½ç”¨äºé˜»å¡ç­‰å¾… IO çš„ç»“æœï¼Œè€Œä¸æ˜¯åˆ·åˆ·åˆ·çš„å•çƒ¤ CPUã€‚å¦‚æœä½ çš„åº”ç”¨æ˜¯ CPU å¯†é›†å‹(ä¾‹å¦‚å¹¶è¡Œè®¡ç®—)ï¼Œå»ºè®®ä½¿ç”¨ [`rayon`](https://github.com/rayon-rs/rayon)ï¼Œå½“ç„¶ï¼Œå¯¹äºå…¶ä¸­çš„ IO ä»»åŠ¡éƒ¨åˆ†ï¼Œä½ ä¾ç„¶å¯ä»¥æ··ç”¨ `tokio`
- **è¯»å–å¤§é‡çš„æ–‡ä»¶**ã€‚è¯»å–æ–‡ä»¶çš„ç“¶é¢ˆä¸»è¦åœ¨äºæ“ä½œç³»ç»Ÿï¼Œå› ä¸º OS æ²¡æœ‰æä¾›å¼‚æ­¥æ–‡ä»¶è¯»å–æ¥å£ï¼Œå¤§é‡çš„å¹¶å‘å¹¶ä¸ä¼šæå‡æ–‡ä»¶è¯»å–çš„å¹¶è¡Œæ€§èƒ½ï¼Œåè€Œå¯èƒ½ä¼šé€ æˆä¸å¯å¿½è§†çš„æ€§èƒ½æŸè€—ï¼Œå› æ­¤å»ºè®®ä½¿ç”¨çº¿ç¨‹(æˆ–çº¿ç¨‹æ± )çš„æ–¹å¼
- **å‘é€å°‘é‡ HTTP è¯·æ±‚**ã€‚`tokio` çš„ä¼˜åŠ¿æ˜¯ç»™äºˆä½ å¹¶å‘å¤„ç†å¤§é‡ä»»åŠ¡çš„èƒ½åŠ›ï¼Œå¯¹äºè¿™ç§è½»é‡çº§ HTTP è¯·æ±‚åœºæ™¯ï¼Œ`tokio` é™¤äº†å¢åŠ ä½ çš„ä»£ç å¤æ‚æ€§ï¼Œå¹¶æ— æ³•å¸¦æ¥ä»€ä¹ˆé¢å¤–çš„ä¼˜åŠ¿ã€‚å› æ­¤ï¼Œå¯¹äºè¿™ç§åœºæ™¯ï¼Œä½ å¯ä»¥ä½¿ç”¨ [`reqwest`](https://github.com/seanmonstar/reqwest) åº“ï¼Œå®ƒä¼šæ›´åŠ ç®€å•æ˜“ç”¨ã€‚


> è‹¥å¤§å®¶ä½¿ç”¨ tokioï¼Œé‚£ CPU å¯†é›†çš„ä»»åŠ¡å°¤å…¶éœ€è¦ç”¨çº¿ç¨‹çš„æ–¹å¼å»å¤„ç†ï¼Œä¾‹å¦‚ä½¿ç”¨ `spawn_blocking` åˆ›å»ºä¸€ä¸ªé˜»å¡çš„çº¿ç¨‹å»å®Œæˆç›¸åº” CPU å¯†é›†ä»»åŠ¡ã€‚
>
> åŸå› æ˜¯ï¼štokio æ˜¯åä½œå¼çš„è°ƒåº¦å™¨ï¼Œå¦‚æœæŸä¸ª CPU å¯†é›†çš„å¼‚æ­¥ä»»åŠ¡æ˜¯é€šè¿‡ tokio åˆ›å»ºçš„ï¼Œé‚£ç†è®ºä¸Šæ¥è¯´ï¼Œè¯¥å¼‚æ­¥ä»»åŠ¡éœ€è¦è·Ÿå…¶å®ƒçš„å¼‚æ­¥ä»»åŠ¡äº¤é”™æ‰§è¡Œï¼Œæœ€ç»ˆå¤§å®¶éƒ½å¾—åˆ°äº†æ‰§è¡Œï¼Œçš†å¤§æ¬¢å–œã€‚ä½†å®é™…æƒ…å†µæ˜¯ï¼ŒCPU å¯†é›†çš„ä»»åŠ¡å¾ˆå¯èƒ½ä¼šä¸€ç›´éœ¸ç€ç€ CPUï¼Œæ­¤æ—¶ tokio çš„è°ƒåº¦æ–¹å¼å†³å®šäº†è¯¥ä»»åŠ¡ä¼šä¸€ç›´è¢«æ‰§è¡Œï¼Œè¿™æ„å‘³ç€ï¼Œå…¶å®ƒçš„å¼‚æ­¥ä»»åŠ¡æ— æ³•å¾—åˆ°æ‰§è¡Œçš„æœºä¼šï¼Œæœ€ç»ˆè¿™äº›ä»»åŠ¡éƒ½ä¼šå› ä¸ºå¾—ä¸åˆ°èµ„æºè€Œé¥¿æ­»ã€‚
>
> è€Œä½¿ç”¨ `spawn_blocking` åï¼Œä¼šåˆ›å»ºä¸€ä¸ªå•ç‹¬çš„ OS çº¿ç¨‹ï¼Œè¯¥çº¿ç¨‹å¹¶ä¸ä¼šè¢« tokio æ‰€è°ƒåº¦( è¢« OS æ‰€è°ƒåº¦ )ï¼Œå› æ­¤å®ƒæ‰€æ‰§è¡Œçš„ CPU å¯†é›†ä»»åŠ¡ä¹Ÿä¸ä¼šå¯¼è‡´ tokio è°ƒåº¦çš„é‚£äº›å¼‚æ­¥ä»»åŠ¡è¢«é¥¿æ­»


## æ€»ç»“

ç¦»å¼€ç¬¬ä¸‰æ–¹å¼€æºç¤¾åŒºæä¾›çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼Œ `async/await` ä»€ä¹ˆéƒ½ä¸æ˜¯ï¼Œç”šè‡³è¿˜ä¸å¦‚ä¸€å †ç ´é“œçƒ‚é“ï¼Œé™¤éä½ é€‰æ‹©æ ¹æ®è‡ªå·±çš„éœ€æ±‚æ‰‹æ’¸ä¸€ä¸ªã€‚

è€Œ `tokio` å°±æ˜¯é‚£é¢—çš‡å† ä¸Šçš„å¤œæ˜ç ï¼Œä¹Ÿæ˜¯å€¼å¾—æˆ‘ä»¬æŠ•å…¥æ—¶é—´å»æ·±å…¥å­¦ä¹ çš„å¼€æºåº“ï¼Œå®ƒçš„è®¾è®¡åŸç†å’Œä»£ç å®ç°éƒ½å¼‚å¸¸ä¼˜ç§€ï¼Œåœ¨ä¹‹åçš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹å…¶è¿›è¡Œæ·±å…¥å­¦ä¹ å’Œå‰–æï¼Œæ•¬è¯·æœŸå¾…ã€‚




================================================
FILE: src/advance-practice/select.md
================================================
# select!

åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œä¸€ä¸ªé‡è¦çš„åœºæ™¯å°±æ˜¯åŒæ—¶ç­‰å¾…å¤šä¸ªå¼‚æ­¥æ“ä½œçš„ç»“æœï¼Œå¹¶ä¸”å¯¹å…¶ç»“æœè¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ï¼Œåœ¨æœ¬ç« èŠ‚ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ï¼Œå¼ºå¤§çš„ `select!` æ˜¯å¦‚ä½•å¸®åŠ©å’±ä»¬æ›´å¥½çš„æ§åˆ¶å¤šä¸ªå¼‚æ­¥æ“ä½œå¹¶å‘æ‰§è¡Œçš„ã€‚

## tokio::select!

`select!` å…è®¸åŒæ—¶ç­‰å¾…å¤šä¸ªè®¡ç®—æ“ä½œï¼Œç„¶åå½“å…¶ä¸­ä¸€ä¸ªæ“ä½œå®Œæˆæ—¶å°±é€€å‡ºç­‰å¾…:

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        let _ = tx1.send("one");
    });

    tokio::spawn(async {
        let _ = tx2.send("two");
    });

    tokio::select! {
        val = rx1 => {
            println!("rx1 completed first with {:?}", val);
        }
        val = rx2 => {
            println!("rx2 completed first with {:?}", val);
        }
    }

    // ä»»ä½•ä¸€ä¸ª select åˆ†æ”¯ç»“æŸåï¼Œéƒ½ä¼šç»§ç»­æ‰§è¡Œæ¥ä¸‹æ¥çš„ä»£ç 
}
```

è¿™é‡Œç”¨åˆ°äº†ä¸¤ä¸ª `oneshot` æ¶ˆæ¯é€šé“ï¼Œè™½ç„¶ä¸¤ä¸ªæ“ä½œçš„åˆ›å»ºåœ¨ä»£ç ä¸Šæœ‰å…ˆåé¡ºåºï¼Œä½†åœ¨å®é™…æ‰§è¡Œæ—¶å´ä¸è¿™æ ·ã€‚å› æ­¤ï¼Œ `select` åœ¨ä»ä¸¤ä¸ªé€šé“**é˜»å¡ç­‰å¾…**æ¥æ”¶æ¶ˆæ¯æ—¶ï¼Œ`rx1` å’Œ `rx2` éƒ½æœ‰å¯èƒ½è¢«å…ˆæ‰“å°å‡ºæ¥ã€‚

éœ€è¦æ³¨æ„ï¼Œä»»ä½•ä¸€ä¸ª `select` åˆ†æ”¯å®Œæˆåï¼Œéƒ½ä¼šç»§ç»­æ‰§è¡Œåé¢çš„ä»£ç ï¼Œæ²¡è¢«æ‰§è¡Œçš„åˆ†æ”¯ä¼šè¢«ä¸¢å¼ƒ( `dropped` )ã€‚

#### å–æ¶ˆ

å¯¹äº `Async Rust` æ¥è¯´ï¼Œé‡Šæ”¾( drop )æ‰ä¸€ä¸ª `Future` å°±æ„å‘³ç€å–æ¶ˆä»»åŠ¡ã€‚ä»ä¸Šä¸€ç« èŠ‚å¯ä»¥å¾—çŸ¥ï¼Œ `async` æ“ä½œä¼šè¿”å›ä¸€ä¸ª `Future`ï¼Œè€Œåè€…æ˜¯æƒ°æ€§çš„ï¼Œç›´åˆ°è¢« `poll` è°ƒç”¨æ—¶ï¼Œæ‰ä¼šè¢«æ‰§è¡Œã€‚ä¸€æ—¦ `Future` è¢«é‡Šæ”¾ï¼Œé‚£æ“ä½œå°†æ— æ³•ç»§ç»­ï¼Œå› ä¸ºæ‰€æœ‰ç›¸å…³çš„çŠ¶æ€éƒ½è¢«é‡Šæ”¾ã€‚

å¯¹äº Tokio çš„ `oneshot` çš„æ¥æ”¶ç«¯æ¥è¯´ï¼Œå®ƒåœ¨è¢«é‡Šæ”¾æ—¶ä¼šå‘é€ä¸€ä¸ªå…³é—­é€šçŸ¥åˆ°å‘é€ç«¯ï¼Œå› æ­¤å‘é€ç«¯å¯ä»¥é€šè¿‡é‡Šæ”¾ä»»åŠ¡çš„æ–¹å¼æ¥ç»ˆæ­¢æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ã€‚

```rust
use tokio::sync::oneshot;

async fn some_operation() -> String {
    // åœ¨è¿™é‡Œæ‰§è¡Œä¸€äº›æ“ä½œ...
}

#[tokio::main]
async fn main() {
    let (mut tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        // ç­‰å¾… `some_operation` çš„å®Œæˆ
        // æˆ–è€…å¤„ç† `oneshot` çš„å…³é—­é€šçŸ¥
        tokio::select! {
            val = some_operation() => {
                let _ = tx1.send(val);
            }
            _ = tx1.closed() => {
                // æ”¶åˆ°äº†å‘é€ç«¯å‘æ¥çš„å…³é—­ä¿¡å·
                // `select` å³å°†ç»“æŸï¼Œæ­¤æ—¶ï¼Œæ­£åœ¨è¿›è¡Œçš„ `some_operation()` ä»»åŠ¡ä¼šè¢«å–æ¶ˆï¼Œä»»åŠ¡è‡ªåŠ¨å®Œæˆï¼Œ
                // tx1 è¢«é‡Šæ”¾
            }
        }
    });

    tokio::spawn(async {
        let _ = tx2.send("two");
    });

    tokio::select! {
        val = rx1 => {
            println!("rx1 completed first with {:?}", val);
        }
        val = rx2 => {
            println!("rx2 completed first with {:?}", val);
        }
    }
}
```

ä¸Šé¢ä»£ç çš„é‡ç‚¹å°±åœ¨äº `tx1.closed` æ‰€åœ¨çš„åˆ†æ”¯ï¼Œä¸€æ—¦å‘é€ç«¯è¢«å…³é—­ï¼Œé‚£è¯¥åˆ†æ”¯å°±ä¼šè¢«æ‰§è¡Œï¼Œç„¶å `select` ä¼šé€€å‡ºï¼Œå¹¶æ¸…ç†æ‰è¿˜æ²¡æ‰§è¡Œçš„ç¬¬ä¸€ä¸ªåˆ†æ”¯ `val = some_operation()` ï¼Œè¿™å…¶ä¸­ `some_operation` è¿”å›çš„ `Future` ä¹Ÿä¼šè¢«æ¸…ç†ï¼Œæ ¹æ®ä¹‹å‰çš„å†…å®¹ï¼Œ`Future` è¢«æ¸…ç†é‚£ç›¸åº”çš„ä»»åŠ¡ä¼šç«‹å³å–æ¶ˆï¼Œå› æ­¤ `some_operation` ä¼šè¢«å–æ¶ˆï¼Œä¸å†æ‰§è¡Œã€‚

#### Future çš„å®ç°

ä¸ºäº†æ›´å¥½çš„ç†è§£ `select` çš„å·¥ä½œåŸç†ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å¦‚æœä½¿ç”¨ `Future` è¯¥å¦‚ä½•å®ç°ã€‚å½“ç„¶ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼Œåœ¨å®é™…ä¸­ï¼Œ`select!` ä¼šåŒ…å«ä¸€äº›é¢å¤–çš„åŠŸèƒ½ï¼Œä¾‹å¦‚ä¸€å¼€å§‹ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªåˆ†æ”¯è¿›è¡Œ `poll`ã€‚

```rust
use tokio::sync::oneshot;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MySelect {
    rx1: oneshot::Receiver<&'static str>,
    rx2: oneshot::Receiver<&'static str>,
}

impl Future for MySelect {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        if let Poll::Ready(val) = Pin::new(&mut self.rx1).poll(cx) {
            println!("rx1 completed first with {:?}", val);
            return Poll::Ready(());
        }

        if let Poll::Ready(val) = Pin::new(&mut self.rx2).poll(cx) {
            println!("rx2 completed first with {:?}", val);
            return Poll::Ready(());
        }

        Poll::Pending
    }
}

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    // ä½¿ç”¨ tx1 å’Œ tx2

    MySelect {
        rx1,
        rx2,
    }.await;
}
```

`MySelect` åŒ…å«äº†ä¸¤ä¸ªåˆ†æ”¯ä¸­çš„ `Future`ï¼Œå½“å®ƒè¢« `poll` æ—¶ï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯ä¼šå…ˆæ‰§è¡Œã€‚å¦‚æœæ‰§è¡Œå®Œæˆï¼Œé‚£å–å‡ºçš„å€¼ä¼šè¢«ä½¿ç”¨ï¼Œç„¶å `MySelect` ä¹Ÿéšä¹‹ç»“æŸã€‚è€Œå¦ä¸€ä¸ªåˆ†æ”¯å¯¹åº”çš„ `Future` ä¼šè¢«é‡Šæ”¾æ‰ï¼Œå¯¹åº”çš„æ“ä½œä¹Ÿä¼šè¢«å–æ¶ˆã€‚

è¿˜è®°å¾—ä¸Šä¸€ç« èŠ‚ä¸­å¾ˆé‡è¦çš„ä¸€æ®µè¯å—ï¼Ÿ

> å½“ä¸€ä¸ª `Future` è¿”å› `Poll::Pending` æ—¶ï¼Œå®ƒå¿…é¡»ç¡®ä¿ä¼šåœ¨æŸä¸€ä¸ªæ—¶åˆ»é€šè¿‡ `Waker` æ¥å”¤é†’ï¼Œä¸ç„¶è¯¥ `Future` å°†æ°¸è¿œåœ°è¢«æŒ‚èµ·

ä½†æ˜¯ä»”ç»†è§‚å¯Ÿæˆ‘ä»¬ä¹‹å‰çš„ä»£ç ï¼Œé‡Œé¢å¹¶æ²¡æœ‰ä»»ä½•çš„ `wake` è°ƒç”¨ï¼äº‹å®ä¸Šï¼Œè¿™æ˜¯å› ä¸ºå‚æ•° `cx` è¢«ä¼ å…¥äº†å†…å±‚çš„ `poll` è°ƒç”¨ã€‚ åªè¦å†…éƒ¨çš„ `Future` å®ç°äº†å”¤é†’å¹¶ä¸”è¿”å›äº† `Poll::Pending`ï¼Œé‚£ `MySelect` ä¹Ÿç­‰äºå®ç°äº†å”¤é†’ï¼

## è¯­æ³•

ç›®å‰æ¥è¯´ï¼Œ`select!` æœ€å¤šå¯ä»¥æ”¯æŒ 64 ä¸ªåˆ†æ”¯ï¼Œæ¯ä¸ªåˆ†æ”¯å½¢å¼å¦‚ä¸‹ï¼š

```rust
<æ¨¡å¼> = <async è¡¨è¾¾å¼> => <ç»“æœå¤„ç†>,
```

å½“ `select` å®å¼€å§‹æ‰§è¡Œåï¼Œæ‰€æœ‰çš„åˆ†æ”¯ä¼šå¼€å§‹å¹¶å‘çš„æ‰§è¡Œã€‚å½“ä»»ä½•ä¸€ä¸ª**è¡¨è¾¾å¼**å®Œæˆæ—¶ï¼Œä¼šå°†ç»“æœè·Ÿ**æ¨¡å¼**è¿›è¡ŒåŒ¹é…ã€‚è‹¥åŒ¹é…æˆåŠŸï¼Œåˆ™å‰©ä¸‹çš„è¡¨è¾¾å¼ä¼šè¢«é‡Šæ”¾ã€‚

æœ€å¸¸ç”¨çš„**æ¨¡å¼**å°±æ˜¯ç”¨å˜é‡åå»åŒ¹é…è¡¨è¾¾å¼è¿”å›çš„å€¼ï¼Œç„¶åè¯¥å˜é‡å°±å¯ä»¥åœ¨**ç»“æœå¤„ç†**ç¯èŠ‚ä½¿ç”¨ã€‚

å¦‚æœå½“å‰çš„æ¨¡å¼ä¸èƒ½åŒ¹é…ï¼Œå‰©ä½™çš„ `async` è¡¨è¾¾å¼å°†ç»§ç»­å¹¶å‘çš„æ‰§è¡Œï¼Œç›´åˆ°ä¸‹ä¸€ä¸ªå®Œæˆã€‚

ç”±äº `select!` ä½¿ç”¨çš„æ˜¯ä¸€ä¸ª `async` è¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€äº›æ›´å¤æ‚çš„è®¡ç®—ã€‚

ä¾‹å¦‚ä»åœ¨åˆ†æ”¯ä¸­è¿›è¡Œ TCP è¿æ¥ï¼š

```rust
use tokio::net::TcpStream;
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx, rx) = oneshot::channel();

    // ç”Ÿæˆä¸€ä¸ªä»»åŠ¡ï¼Œç”¨äºå‘ oneshot å‘é€ä¸€æ¡æ¶ˆæ¯
    tokio::spawn(async move {
        tx.send("done").unwrap();
    });

    tokio::select! {
        socket = TcpStream::connect("localhost:3465") => {
            println!("Socket connected {:?}", socket);
        }
        msg = rx => {
            println!("received message first {:?}", msg);
        }
    }
}
```

å†æ¯”å¦‚ï¼Œåœ¨åˆ†æ”¯ä¸­è¿›è¡Œ TCP ç›‘å¬:

```rust
use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    let (tx, rx) = oneshot::channel();

    tokio::spawn(async move {
        tx.send(()).unwrap();
    });

    let mut listener = TcpListener::bind("localhost:3465").await?;

    tokio::select! {
        _ = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            // ç»™äºˆ Rust ç±»å‹æš—ç¤º
            Ok::<_, io::Error>(())
        } => {}
        _ = rx => {
            println!("terminating accept loop");
        }
    }

    Ok(())
}
```

åˆ†æ”¯ä¸­æ¥æ”¶è¿æ¥çš„å¾ªç¯ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°é‡åˆ°é”™è¯¯æ‰åœæ­¢ï¼Œæˆ–è€…å½“ `rx` ä¸­æœ‰å€¼æ—¶ï¼Œä¹Ÿä¼šåœæ­¢ã€‚ `_` è¡¨ç¤ºæˆ‘ä»¬å¹¶ä¸å…³å¿ƒè¿™ä¸ªå€¼ï¼Œè¿™æ ·ä½¿ç”¨å”¯ä¸€çš„ç›®çš„å°±æ˜¯ä¸ºäº†ç»“æŸç¬¬ä¸€åˆ†æ”¯ä¸­çš„å¾ªç¯ã€‚

## è¿”å›å€¼

`select!` è¿˜èƒ½è¿”å›ä¸€ä¸ªå€¼:

```rust
async fn computation1() -> String {
    // .. è®¡ç®—
}

async fn computation2() -> String {
    // .. è®¡ç®—
}

#[tokio::main]
async fn main() {
    let out = tokio::select! {
        res1 = computation1() => res1,
        res2 = computation2() => res2,
    };

    println!("Got = {}", out);
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ­¤æ—¶ `select!` çš„æ‰€æœ‰åˆ†æ”¯å¿…é¡»è¿”å›ä¸€æ ·çš„ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼

## é”™è¯¯ä¼ æ’­

åœ¨ Rust ä¸­ä½¿ç”¨ `?` å¯ä»¥å¯¹é”™è¯¯è¿›è¡Œä¼ æ’­ï¼Œä½†æ˜¯åœ¨ `select!` ä¸­ï¼Œ`?` å¦‚ä½•å·¥ä½œå–å†³äºå®ƒæ˜¯åœ¨åˆ†æ”¯ä¸­çš„ `async` è¡¨è¾¾å¼ä½¿ç”¨è¿˜æ˜¯åœ¨ç»“æœå¤„ç†çš„ä»£ç ä¸­ä½¿ç”¨:

- åœ¨åˆ†æ”¯ä¸­ `async` è¡¨è¾¾å¼ä½¿ç”¨ä¼šå°†è¯¥è¡¨è¾¾å¼çš„ç»“æœå˜æˆä¸€ä¸ª `Result`
- åœ¨ç»“æœå¤„ç†ä¸­ä½¿ç”¨ï¼Œä¼šå°†é”™è¯¯ç›´æ¥ä¼ æ’­åˆ° `select!` ä¹‹å¤–

```rust
use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    // [è®¾ç½® `rx` oneshot æ¶ˆæ¯é€šé“]

    let listener = TcpListener::bind("localhost:3465").await?;

    tokio::select! {
        res = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            Ok::<_, io::Error>(())
        } => {
            res?;
        }
        _ = rx => {
            println!("terminating accept loop");
        }
    }

    Ok(())
}
```

`listener.accept().await?` æ˜¯åˆ†æ”¯è¡¨è¾¾å¼ä¸­çš„ `?`ï¼Œå› æ­¤å®ƒä¼šå°†è¡¨è¾¾å¼çš„è¿”å›å€¼å˜æˆ `Result` ç±»å‹ï¼Œç„¶åèµ‹äºˆç»™ `res` å˜é‡ã€‚

ä¸ä¹‹ä¸åŒçš„æ˜¯ï¼Œç»“æœå¤„ç†ä¸­çš„ `res?;` ä¼šè®© `main` å‡½æ•°ç›´æ¥ç»“æŸå¹¶è¿”å›ä¸€ä¸ª `Result`ï¼Œå¯ä»¥çœ‹å‡ºï¼Œè¿™é‡Œ `?` çš„ç”¨æ³•è·Ÿæˆ‘ä»¬å¹³æ—¶çš„ç”¨æ³•å¹¶æ— åŒºåˆ«ã€‚

## æ¨¡å¼åŒ¹é…

æ—¢ç„¶æ˜¯æ¨¡å¼åŒ¹é…ï¼Œæˆ‘ä»¬éœ€è¦å†æ¥å›å¿†ä¸‹ `select!` çš„åˆ†æ”¯è¯­æ³•å½¢å¼:

```rust
<æ¨¡å¼> = <async è¡¨è¾¾å¼> => <ç»“æœå¤„ç†>,
```

è¿„ä»Šä¸ºæ­¢ï¼Œæˆ‘ä»¬åªç”¨äº†å˜é‡ç»‘å®šçš„æ¨¡å¼ï¼Œäº‹å®ä¸Šï¼Œ[ä»»ä½• Rust æ¨¡å¼](https://course.rs/basic/match-pattern/all-patterns.html)éƒ½å¯ä»¥åœ¨æ­¤å¤„ä½¿ç”¨ã€‚

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (mut tx1, mut rx1) = mpsc::channel(128);
    let (mut tx2, mut rx2) = mpsc::channel(128);

    tokio::spawn(async move {
        // ç”¨ tx1 å’Œ tx2 å¹²ä¸€äº›ä¸ä¸ºäººçŸ¥çš„äº‹
    });

    tokio::select! {
        Some(v) = rx1.recv() => {
            println!("Got {:?} from rx1", v);
        }
        Some(v) = rx2.recv() => {
            println!("Got {:?} from rx2", v);
        }
        else => {
            println!("Both channels closed");
        }
    }
}
```

ä¸Šé¢ä»£ç ä¸­ï¼Œ`rx` é€šé“å…³é—­åï¼Œ`recv()` æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª `None`ï¼Œå¯ä»¥çœ‹åˆ°æ²¡æœ‰ä»»ä½•æ¨¡å¼èƒ½å¤ŸåŒ¹é…è¿™ä¸ª `None`ï¼Œé‚£ä¸ºä½•ä¸ä¼šæŠ¥é”™ï¼Ÿç§˜å¯†å°±åœ¨äº `else` ä¸Šï¼šå½“ä½¿ç”¨æ¨¡å¼å»åŒ¹é…åˆ†æ”¯æ—¶ï¼Œè‹¥ä¹‹å‰çš„æ‰€æœ‰åˆ†æ”¯éƒ½æ— æ³•è¢«åŒ¹é…ï¼Œé‚£ `else` åˆ†æ”¯å°†è¢«æ‰§è¡Œã€‚

## å€Ÿç”¨

å½“åœ¨ Tokio ä¸­ç”Ÿæˆ( spawn )ä»»åŠ¡æ—¶ï¼Œå…¶ async è¯­å¥å—å¿…é¡»æ‹¥æœ‰å…¶ä¸­æ•°æ®çš„æ‰€æœ‰æƒã€‚è€Œ `select!` å¹¶æ²¡æœ‰è¿™ä¸ªé™åˆ¶ï¼Œå®ƒçš„æ¯ä¸ªåˆ†æ”¯è¡¨è¾¾å¼å¯ä»¥ç›´æ¥å€Ÿç”¨æ•°æ®ï¼Œç„¶åè¿›è¡Œå¹¶å‘æ“ä½œã€‚åªè¦éµå¾ª Rust çš„å€Ÿç”¨è§„åˆ™ï¼Œå¤šä¸ªåˆ†æ”¯è¡¨è¾¾å¼å¯ä»¥ä¸å¯å˜çš„å€Ÿç”¨åŒä¸€ä¸ªæ•°æ®ï¼Œæˆ–è€…åœ¨ä¸€ä¸ªè¡¨è¾¾å¼å¯å˜çš„å€Ÿç”¨æŸä¸ªæ•°æ®ã€‚

æ¥çœ‹ä¸ªä¾‹å­ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬åŒæ—¶å‘ä¸¤ä¸ª TCP ç›®æ ‡å‘é€åŒæ ·çš„æ•°æ®:

```rust
use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use std::io;
use std::net::SocketAddr;

async fn race(
    data: &[u8],
    addr1: SocketAddr,
    addr2: SocketAddr
) -> io::Result<()> {
    tokio::select! {
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr1).await?;
            socket.write_all(data).await?;
            Ok::<_, io::Error>(())
        } => {}
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr2).await?;
            socket.write_all(data).await?;
            Ok::<_, io::Error>(())
        } => {}
        else => {}
    };

    Ok(())
}
```

æœ‰è¶£çš„é¢˜å¤–è¯ï¼šç”±äº TCP çš„è¿æ¥è¿‡ç¨‹æ˜¯åœ¨æ¨¡å¼ä¸­å‘ç”Ÿï¼Œå› æ­¤å½“æŸä¸€ä¸ªè¿æ¥è¿‡ç¨‹å¤±è´¥åï¼Œå®ƒé€šè¿‡ `?` è¿”å›çš„ `Err` ç±»å‹æ— æ³•åŒ¹é… `Ok`ï¼Œå¯¼è‡´å¦ä¸€ä¸ªåˆ†æ”¯ä¼šç»§ç»­è¢«æ‰§è¡Œã€ç»§ç»­è¿æ¥ã€‚

å¦‚æœä½ æŠŠè¿æ¥è¿‡ç¨‹æ”¾åœ¨äº†ç»“æœå¤„ç†ä¸­ï¼Œé‚£è¿æ¥å¤±è´¥ä¼šç›´æ¥ä» `race` å‡½æ•°ä¸­è¿”å›ï¼Œè€Œä¸æ˜¯ç»§ç»­æ‰§è¡Œå¦ä¸€ä¸ªåˆ†æ”¯ä¸­çš„è¿æ¥ï¼

è¿˜æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„ç‚¹ï¼Œ**å€Ÿç”¨è§„åˆ™åœ¨åˆ†æ”¯è¡¨è¾¾å¼å’Œç»“æœå¤„ç†ä¸­å­˜åœ¨å¾ˆå¤§çš„ä¸åŒ**ã€‚ä¾‹å¦‚ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸¤ä¸ªåˆ†æ”¯è¡¨è¾¾å¼ä¸­åˆ†åˆ«å¯¹ `data` åšäº†ä¸å¯å˜å€Ÿç”¨ï¼Œè¿™å½“ç„¶ okï¼Œä½†æ˜¯è‹¥æ˜¯ä¸¤æ¬¡å¯å˜å€Ÿç”¨ï¼Œé‚£ç¼–è¯‘å™¨ä¼šç«‹å³è¿›è¡ŒæŠ¥é”™ã€‚ä½†æ˜¯è½¬æŠ˜æ¥äº†ï¼šå½“åœ¨ç»“æœå¤„ç†ä¸­è¿›è¡Œä¸¤æ¬¡å¯å˜å€Ÿç”¨æ—¶ï¼Œå´ä¸ä¼šæŠ¥é”™ï¼Œå¤§å®¶å¯ä»¥æ€è€ƒä¸‹ä¸ºä»€ä¹ˆï¼Œæç¤ºä¸‹ï¼šæ€è€ƒä¸‹åˆ†æ”¯åœ¨æ‰§è¡Œå®Œæˆåä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    let mut out = String::new();

    tokio::spawn(async move {
    });

    tokio::select! {
        _ = rx1 => {
            out.push_str("rx1 completed");
        }
        _ = rx2 => {
            out.push_str("rx2 completed");
        }
    }

    println!("{}", out);
}
```

ä¾‹å¦‚ä»¥ä¸Šä»£ç ï¼Œå°±åœ¨ä¸¤ä¸ªåˆ†æ”¯çš„ç»“æœå¤„ç†ä¸­åˆ†åˆ«è¿›è¡Œäº†å¯å˜å€Ÿç”¨ï¼Œå¹¶ä¸ä¼šæŠ¥é”™ã€‚åŸå› å°±åœ¨äºï¼š`select!`ä¼šä¿è¯åªæœ‰ä¸€ä¸ªåˆ†æ”¯çš„ç»“æœå¤„ç†ä¼šè¢«è¿è¡Œï¼Œç„¶ååœ¨è¿è¡Œç»“æŸåï¼Œå¦ä¸€ä¸ªåˆ†æ”¯ä¼šè¢«ç›´æ¥ä¸¢å¼ƒã€‚

## å¾ªç¯

æ¥çœ‹çœ‹è¯¥å¦‚ä½•åœ¨å¾ªç¯ä¸­ä½¿ç”¨ `select!`ï¼Œé¡ºä¾¿è¯´ä¸€å¥ï¼Œè·Ÿå¾ªç¯ä¸€èµ·ä½¿ç”¨æ˜¯æœ€å¸¸è§çš„ä½¿ç”¨æ–¹å¼ã€‚

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx1, mut rx1) = mpsc::channel(128);
    let (tx2, mut rx2) = mpsc::channel(128);
    let (tx3, mut rx3) = mpsc::channel(128);

    loop {
        let msg = tokio::select! {
            Some(msg) = rx1.recv() => msg,
            Some(msg) = rx2.recv() => msg,
            Some(msg) = rx3.recv() => msg,
            else => { break }
        };

        println!("Got {}", msg);
    }

    println!("All channels have been closed.");
}
```

åœ¨å¾ªç¯ä¸­ä½¿ç”¨ `select!` æœ€å¤§çš„ä¸åŒå°±æ˜¯ï¼Œå½“æŸä¸€ä¸ªåˆ†æ”¯æ‰§è¡Œå®Œæˆåï¼Œ`select!` ä¼šç»§ç»­å¾ªç¯ç­‰å¾…å¹¶æ‰§è¡Œä¸‹ä¸€ä¸ªåˆ†æ”¯ï¼Œç›´åˆ°æ‰€æœ‰åˆ†æ”¯æœ€ç»ˆéƒ½å®Œæˆï¼Œæœ€ç»ˆåŒ¹é…åˆ° `else` åˆ†æ”¯ï¼Œç„¶åé€šè¿‡ `break` è·³å‡ºå¾ªç¯ã€‚

è€ç”Ÿå¸¸è°ˆçš„ä¸€å¥è¯ï¼š`select!` ä¸­å“ªä¸ªåˆ†æ”¯å…ˆè¢«æ‰§è¡Œæ˜¯æ— æ³•ç¡®å®šçš„ï¼Œå› æ­¤ä¸è¦ä¾èµ–äºåˆ†æ”¯æ‰§è¡Œçš„é¡ºåºï¼æƒ³è±¡ä¸€ä¸‹ï¼Œåœ¨å¼‚æ­¥ç¼–ç¨‹åœºæ™¯ï¼Œè‹¥ `select!` æŒ‰ç…§åˆ†æ”¯çš„é¡ºåºæ¥æ‰§è¡Œä¼šå¦‚ä½•ï¼šè‹¥ `rx1` ä¸­æ€»æ˜¯æœ‰æ•°æ®ï¼Œé‚£æ¯æ¬¡å¾ªç¯éƒ½åªä¼šå»å¤„ç†ç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼Œåé¢ä¸¤ä¸ªåˆ†æ”¯æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œã€‚

#### æ¢å¤ä¹‹å‰çš„å¼‚æ­¥æ“ä½œ

```rust
async fn action() {
    // ä¸€äº›å¼‚æ­¥é€»è¾‘
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);

    let operation = action();
    tokio::pin!(operation);

    loop {
        tokio::select! {
            _ = &mut operation => break,
            Some(v) = rx.recv() => {
                if v % 2 == 0 {
                    break;
                }
            }
        }
    }
}
```

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬æ²¡æœ‰ç›´æ¥åœ¨ `select!` åˆ†æ”¯ä¸­è°ƒç”¨ `action()` ï¼Œè€Œæ˜¯åœ¨ `loop` å¾ªç¯å¤–é¢å…ˆå°† `action()` èµ‹å€¼ç»™ `operation`ï¼Œå› æ­¤ `operation` æ˜¯ä¸€ä¸ª `Future`ã€‚

**é‡ç‚¹æ¥äº†**ï¼Œåœ¨ `select!` å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå¥‡æ€ªçš„è¯­æ³• `&mut operation`ï¼Œå¤§å®¶æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä¸åŠ  `&mut` ä¼šå¦‚ä½•ï¼Ÿç­”æ¡ˆæ˜¯ï¼Œæ¯ä¸€æ¬¡å¾ªç¯è°ƒç”¨çš„éƒ½æ˜¯ä¸€æ¬¡å…¨æ–°çš„ `action()`è°ƒç”¨ï¼Œä½†æ˜¯å½“åŠ äº† `&mut operatoion` åï¼Œæ¯ä¸€æ¬¡å¾ªç¯è°ƒç”¨å°±å˜æˆäº†å¯¹åŒä¸€æ¬¡ `action()` çš„è°ƒç”¨ã€‚ä¹Ÿå°±æ˜¯æˆ‘ä»¬å®ç°äº†åœ¨æ¯æ¬¡å¾ªç¯ä¸­æ¢å¤äº†ä¹‹å‰çš„å¼‚æ­¥æ“ä½œï¼

`select!` çš„å¦ä¸€ä¸ªåˆ†æ”¯ä»æ¶ˆæ¯é€šé“æ”¶å–æ¶ˆæ¯ï¼Œä¸€æ—¦æ”¶åˆ°å€¼æ˜¯å¶æ•°ï¼Œå°±è·³å‡ºå¾ªç¯ï¼Œå¦åˆ™å°±ç»§ç»­å¾ªç¯ã€‚

è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯æˆ‘ä»¬ä½¿ç”¨äº† `tokio::pin!`ï¼Œå…·ä½“çš„ç»†èŠ‚è¿™é‡Œå…ˆä¸ä»‹ç»ï¼Œå€¼å¾—æ³¨æ„çš„ç‚¹æ˜¯ï¼šå¦‚æœè¦åœ¨ä¸€ä¸ªå¼•ç”¨ä¸Šä½¿ç”¨ `.await`ï¼Œé‚£ä¹ˆå¼•ç”¨çš„å€¼å°±å¿…é¡»æ˜¯ä¸èƒ½ç§»åŠ¨çš„æˆ–è€…å®ç°äº† `Unpin`ï¼Œå…³äº `Pin` å’Œ `Unpin` å¯ä»¥å‚è§[è¿™é‡Œ](https://course.rs/async/pin-unpin.html)ã€‚

ä¸€æ—¦ç§»é™¤ `tokio::pin!` æ‰€åœ¨è¡Œçš„ä»£ç ï¼Œç„¶åè¯•å›¾ç¼–è¯‘ï¼Œå°±ä¼šè·å¾—ä»¥ä¸‹é”™è¯¯:

```console
error[E0599]: no method named `poll` found for struct
     `std::pin::Pin<&mut &mut impl std::future::Future>`
     in the current scope
  --> src/main.rs:16:9
   |
16 | /         tokio::select! {
17 | |             _ = &mut operation => break,
18 | |             Some(v) = rx.recv() => {
19 | |                 if v % 2 == 0 {
...  |
22 | |             }
23 | |         }
   | |_________^ method not found in
   |             `std::pin::Pin<&mut &mut impl std::future::Future>`
   |
   = note: the method `poll` exists but the following trait bounds
            were not satisfied:
           `impl std::future::Future: std::marker::Unpin`
           which is required by
           `&mut impl std::future::Future: std::future::Future`
```

è™½ç„¶æˆ‘ä»¬å·²ç»å­¦äº†å¾ˆå¤šå…³äº `Future` çš„çŸ¥è¯†ï¼Œä½†æ˜¯è¿™ä¸ªé”™è¯¯ä¾ç„¶ä¸å¤ªå¥½ç†è§£ã€‚ä½†æ˜¯å®ƒä¸éš¾è§£å†³ï¼šå½“ä½ è¯•å›¾åœ¨**ä¸€ä¸ªå¼•ç”¨ä¸Šè°ƒç”¨ `.await` ç„¶åé‡åˆ°äº† `Future æœªå®ç°` è¿™ç§é”™è¯¯æ—¶**ï¼Œå¾€å¾€åªéœ€è¦å°†å¯¹åº”çš„ `Future` è¿›è¡Œå›ºå®šå³å¯: ` tokio::pin!(operation);`ã€‚

#### ä¿®æ”¹ä¸€ä¸ªåˆ†æ”¯

ä¸‹é¢ä¸€èµ·æ¥çœ‹ä¸€ä¸ªç¨å¾®å¤æ‚ä¸€äº›çš„ `loop` å¾ªç¯ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬æ‹¥æœ‰ï¼š

- ä¸€ä¸ªæ¶ˆæ¯é€šé“å¯ä»¥ä¼ é€’ `i32` ç±»å‹çš„å€¼
- å®šä¹‰åœ¨ `i32` å€¼ä¸Šçš„ä¸€ä¸ªå¼‚æ­¥æ“ä½œ

æƒ³è¦å®ç°çš„é€»è¾‘æ˜¯ï¼š

- åœ¨æ¶ˆæ¯é€šé“ä¸­ç­‰å¾…ä¸€ä¸ªå¶æ•°å‡ºç°
- ä½¿ç”¨è¯¥å¶æ•°ä½œä¸ºè¾“å…¥æ¥å¯åŠ¨ä¸€ä¸ªå¼‚æ­¥æ“ä½œ
- ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆï¼Œä¸æ­¤åŒæ—¶ç›‘å¬æ¶ˆæ¯é€šé“ä»¥è·å–æ›´å¤šçš„å¶æ•°
- è‹¥åœ¨å¼‚æ­¥æ“ä½œå®Œæˆå‰ä¸€ä¸ªæ–°çš„å¶æ•°åˆ°æ¥äº†ï¼Œç»ˆæ­¢å½“å‰çš„å¼‚æ­¥æ“ä½œï¼Œç„¶åæ¥ç€ä½¿ç”¨æ–°çš„å¶æ•°å¼€å§‹å¼‚æ­¥æ“ä½œ

```rust
async fn action(input: Option<i32>) -> Option<String> {
    // è‹¥ inputï¼ˆè¾“å…¥ï¼‰æ˜¯Noneï¼Œåˆ™è¿”å› None
    // äº‹å®ä¸Šä¹Ÿå¯ä»¥è¿™ä¹ˆå†™: `let i = input?;`
    let i = match input {
        Some(input) => input,
        None => return None,
    };

    // è¿™é‡Œå®šä¹‰ä¸€äº›é€»è¾‘
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);

    let mut done = false;
    let operation = action(None);
    tokio::pin!(operation);

    tokio::spawn(async move {
        let _ = tx.send(1).await;
        let _ = tx.send(3).await;
        let _ = tx.send(2).await;
    });

    loop {
        tokio::select! {
            res = &mut operation, if !done => {
                done = true;

                if let Some(v) = res {
                    println!("GOT = {}", v);
                    return;
                }
            }
            Some(v) = rx.recv() => {
                if v % 2 == 0 {
                    // `.set` æ˜¯ `Pin` ä¸Šå®šä¹‰çš„æ–¹æ³•
                    operation.set(action(Some(v)));
                    done = false;
                }
            }
        }
    }
}
```

å½“ç¬¬ä¸€æ¬¡å¾ªç¯å¼€å§‹æ—¶ï¼Œ ç¬¬ä¸€ä¸ªåˆ†æ”¯ä¼šç«‹å³å®Œæˆï¼Œå› ä¸º `operation` çš„å‚æ•°æ˜¯ `None`ã€‚å½“ç¬¬ä¸€ä¸ªåˆ†æ”¯æ‰§è¡Œå®Œæˆæ—¶ï¼Œ`done` ä¼šå˜æˆ `true`ï¼Œæ­¤æ—¶ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¡ä»¶å°†æ— æ³•è¢«æ»¡è¶³ï¼Œå¼€å§‹æ‰§è¡Œç¬¬äºŒä¸ªåˆ†æ”¯ã€‚

å½“ç¬¬äºŒä¸ªåˆ†æ”¯æ”¶åˆ°ä¸€ä¸ªå¶æ•°æ—¶ï¼Œ`done` ä¼šè¢«ä¿®æ”¹ä¸º `false`ï¼Œä¸” `operation` è¢«è®¾ç½®äº†å€¼ã€‚ æ­¤åå†ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯ä¼šè¢«æ‰§è¡Œï¼Œä¸” `operation` è¿”å›ä¸€ä¸ª `Some(2)`ï¼Œå› æ­¤ä¼šè§¦å‘ `return` ï¼Œæœ€ç»ˆç»“æŸå¾ªç¯å¹¶è¿”å›ã€‚

è¿™æ®µä»£ç å¼•å…¥äº†ä¸€ä¸ªæ–°çš„è¯­æ³•: `if !done`ï¼Œåœ¨è§£é‡Šä¹‹å‰ï¼Œå…ˆçœ‹çœ‹å»æ‰åä¼šå¦‚ä½•ï¼š

```console
thread 'main' panicked at '`async fn` resumed after completion', src/main.rs:1:55
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

```'`async fn` resumed after completion'``` é”™è¯¯çš„å«ä¹‰æ˜¯ï¼š`async fn` å¼‚æ­¥å‡½æ•°åœ¨å®Œæˆåï¼Œä¾ç„¶è¢«æ¢å¤äº†(ç»§ç»­ä½¿ç”¨)ã€‚

å›åˆ°ä¾‹å­ä¸­æ¥ï¼Œè¿™ä¸ªé”™è¯¯æ˜¯ç”±äº `operation` åœ¨å®ƒå·²ç»è°ƒç”¨å®Œæˆåä¾ç„¶è¢«ä½¿ç”¨ã€‚é€šå¸¸æ¥è¯´ï¼Œå½“ä½¿ç”¨ `.await` åï¼Œè°ƒç”¨ `.await` çš„å€¼ä¼šè¢«æ¶ˆè€—æ‰ï¼Œå› æ­¤å¹¶ä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜ã€‚ä½†æ˜¯åœ¨è¿™ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨å¼•ç”¨ä¸Šè°ƒç”¨ `.await`ï¼Œå› æ­¤ä¹‹åè¯¥å¼•ç”¨ä¾ç„¶å¯ä»¥è¢«ä½¿ç”¨ã€‚

ä¸ºäº†é¿å…è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦åœ¨ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„ `operation` å®Œæˆåç¦æ­¢å†ä½¿ç”¨è¯¥åˆ†æ”¯ã€‚è¿™é‡Œçš„ `done` çš„å¼•å…¥å°±å¾ˆå¥½çš„è§£å†³äº†é—®é¢˜ã€‚å¯¹äº `select!` æ¥è¯´ `if !done` çš„è¯­æ³•è¢«ç§°ä¸ºé¢„æ¡ä»¶( **precondition** )ï¼Œè¯¥æ¡ä»¶ä¼šåœ¨åˆ†æ”¯è¢« `.await` æ‰§è¡Œå‰è¿›è¡Œæ£€æŸ¥ã€‚

é‚£å¤§å®¶è‚¯å®šæœ‰ç–‘é—®äº†ï¼Œæ—¢ç„¶ `operation` ä¸èƒ½å†è¢«è°ƒç”¨äº†ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•åœ¨æœ‰å¶æ•°å€¼æ—¶ï¼Œå†å›åˆ°ç¬¬ä¸€ä¸ªåˆ†æ”¯å¯¹å…¶è¿›è¡Œè°ƒç”¨å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯ `operation.set(action(Some(v)));`ï¼Œè¯¥æ“ä½œä¼šé‡æ–°ä½¿ç”¨æ–°çš„å‚æ•°è®¾ç½® `operation`ã€‚

## spawn å’Œ select! çš„ä¸€äº›ä¸åŒ

å­¦åˆ°ç°åœ¨ï¼Œç›¸ä¿¡å¤§å®¶å¯¹äº `tokio::spawn` å’Œ `select!` å·²ç»éå¸¸ç†Ÿæ‚‰ï¼Œå®ƒä»¬çš„å…±åŒç‚¹å°±æ˜¯éƒ½å¯ä»¥å¹¶å‘çš„è¿è¡Œå¼‚æ­¥æ“ä½œã€‚
ç„¶è€Œå®ƒä»¬ä½¿ç”¨çš„ç­–ç•¥å¤§ç›¸å¾„åº­ã€‚

`tokio::spawn` å‡½æ•°ä¼šå¯åŠ¨æ–°çš„ä»»åŠ¡æ¥è¿è¡Œä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼Œæ¯ä¸ªä»»åŠ¡éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¯¹è±¡å¯ä»¥å•ç‹¬è¢« Tokio è°ƒåº¦è¿è¡Œï¼Œå› æ­¤ä¸¤ä¸ªä¸åŒçš„ä»»åŠ¡çš„è°ƒåº¦éƒ½æ˜¯ç‹¬ç«‹è¿›è¡Œçš„ï¼Œç”šè‡³äºå®ƒä»¬å¯èƒ½ä¼šè¿è¡Œåœ¨ä¸¤ä¸ªä¸åŒçš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ä¸Šã€‚é‰´äºæ­¤ï¼Œç”Ÿæˆçš„ä»»åŠ¡å’Œç”Ÿæˆçš„çº¿ç¨‹æœ‰ä¸€ä¸ªç›¸åŒçš„é™åˆ¶ï¼šä¸å…è®¸å¯¹å¤–éƒ¨ç¯å¢ƒä¸­çš„å€¼è¿›è¡Œå€Ÿç”¨ã€‚

è€Œ `select!` å®å°±ä¸ä¸€æ ·äº†ï¼Œå®ƒåœ¨åŒä¸€ä¸ªä»»åŠ¡ä¸­å¹¶å‘è¿è¡Œæ‰€æœ‰çš„åˆ†æ”¯ã€‚æ­£æ˜¯å› ä¸ºè¿™æ ·ï¼Œåœ¨åŒä¸€ä¸ªä»»åŠ¡ä¸­ï¼Œè¿™äº›åˆ†æ”¯æ— æ³•è¢«åŒæ—¶è¿è¡Œã€‚ `select!` å®åœ¨å•ä¸ªä»»åŠ¡ä¸­å®ç°äº†å¤šè·¯å¤ç”¨çš„åŠŸèƒ½ã€‚



================================================
FILE: src/advance-practice/shared-state.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/spawning.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/stream.md
================================================
# Stream

å¤§å®¶æœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œ Rust ä¸­çš„è¿­ä»£å™¨åœ¨è¿­ä»£æ—¶èƒ½å¦å¼‚æ­¥è¿›è¡Œï¼Ÿè‹¥ä¸å¯ä»¥ï¼Œæ˜¯ä¸æ˜¯æœ‰ç›¸åº”çš„è§£å†³æ–¹æ¡ˆï¼Ÿ

ä»¥ä¸Šçš„é—®é¢˜å…¶å®å¾ˆé‡è¦ï¼Œå› ä¸ºåœ¨å®é™…åœºæ™¯ä¸­ï¼Œè¿­ä»£ä¸€ä¸ªé›†åˆï¼Œç„¶åå¼‚æ­¥çš„å»æ‰§è¡Œæ˜¯å¾ˆå¸¸è§çš„éœ€æ±‚ï¼Œå¥½åœ¨ Tokio ä¸ºæˆ‘ä»¬æä¾›äº† `stream`ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¼‚æ­¥å‡½æ•°ä¸­å¯¹å…¶è¿›è¡Œè¿­ä»£ï¼Œç”šè‡³å’Œè¿­ä»£å™¨ `Iterator` ä¸€æ ·ï¼Œ`stream` è¿˜èƒ½ä½¿ç”¨é€‚é…å™¨ï¼Œä¾‹å¦‚ `map` ! Tokio åœ¨ [`StreamExt`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html) ç‰¹å¾ä¸Šå®šä¹‰äº†å¸¸ç”¨çš„é€‚é…å™¨ã€‚

è¦ä½¿ç”¨ `stream` ï¼Œç›®å‰è¿˜éœ€è¦æ‰‹åŠ¨å¼•å…¥å¯¹åº”çš„åŒ…ï¼š

```rust
tokio-stream = "0.1"
```

> stream æ²¡æœ‰æ”¾åœ¨ `tokio` åŒ…çš„åŸå› åœ¨äºæ ‡å‡†åº“ä¸­çš„ `Stream` ç‰¹å¾è¿˜æ²¡æœ‰ç¨³å®šï¼Œä¸€æ—¦ç¨³å®šåï¼Œ`stream` å°†ç§»åŠ¨åˆ° `tokio` ä¸­æ¥

## è¿­ä»£

ç›®å‰ï¼Œ Rust è¯­è¨€è¿˜ä¸æ”¯æŒå¼‚æ­¥çš„ `for` å¾ªç¯ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ `while let` å¾ªç¯å’Œ [`StreamExt::next()`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html#method.next) ä¸€èµ·ä½¿ç”¨æ¥å®ç°è¿­ä»£çš„ç›®çš„:

```rust
use tokio_stream::StreamExt;

#[tokio::main]
async fn main() {
    let mut stream = tokio_stream::iter(&[1, 2, 3]);

    while let Some(v) = stream.next().await {
        println!("GOT = {:?}", v);
    }
}
```

å’Œè¿­ä»£å™¨ `Iterator` ç±»ä¼¼ï¼Œ`next()` æ–¹æ³•è¿”å›ä¸€ä¸ª `Option<T>`ï¼Œå…¶ä¸­ `T` æ˜¯ä» `stream` ä¸­è·å–çš„å€¼çš„ç±»å‹ã€‚è‹¥æ”¶åˆ° `None` åˆ™æ„å‘³ç€ `stream` è¿­ä»£å·²ç»ç»“æŸã€‚

#### mini-redis å¹¿æ’­

ä¸‹é¢æˆ‘ä»¬æ¥å®ç°ä¸€ä¸ªå¤æ‚ä¸€äº›çš„ mini-redis å®¢æˆ·ç«¯ï¼Œå®Œæ•´ä»£ç è§[è¿™é‡Œ](https://github.com/tokio-rs/website/blob/master/tutorial-code/streams/src/main.rs)ã€‚

åœ¨å¼€å§‹ä¹‹å‰ï¼Œé¦–å…ˆå¯åŠ¨ä¸€ä¸‹å®Œæ•´çš„ mini-redis æœåŠ¡å™¨ç«¯ï¼š

```console
$ mini-redis-server
```

```rust
use tokio_stream::StreamExt;
use mini_redis::client;

async fn publish() -> mini_redis::Result<()> {
    let mut client = client::connect("127.0.0.1:6379").await?;

    // å‘å¸ƒä¸€äº›æ•°æ®
    client.publish("numbers", "1".into()).await?;
    client.publish("numbers", "two".into()).await?;
    client.publish("numbers", "3".into()).await?;
    client.publish("numbers", "four".into()).await?;
    client.publish("numbers", "five".into()).await?;
    client.publish("numbers", "6".into()).await?;
    Ok(())
}

async fn subscribe() -> mini_redis::Result<()> {
    let client = client::connect("127.0.0.1:6379").await?;
    let subscriber = client.subscribe(vec!["numbers".to_string()]).await?;
    let messages = subscriber.into_stream();

    tokio::pin!(messages);

    while let Some(msg) = messages.next().await {
        println!("got = {:?}", msg);
    }

    Ok(())
}

#[tokio::main]
async fn main() -> mini_redis::Result<()> {
    tokio::spawn(async {
        publish().await
    });

    subscribe().await?;

    println!("DONE");

    Ok(())
}
```

ä¸Šé¢ç”Ÿæˆäº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ä¸“é—¨ç”¨äºå‘å¸ƒæ¶ˆæ¯åˆ° min-redis æœåŠ¡å™¨ç«¯çš„ `numbers` æ¶ˆæ¯é€šé“ä¸­ã€‚ç„¶åï¼Œåœ¨ `main` ä¸­ï¼Œæˆ‘ä»¬è®¢é˜…äº† `numbers` æ¶ˆæ¯é€šé“ï¼Œå¹¶ä¸”æ‰“å°ä»ä¸­æ¥æ”¶åˆ°çš„æ¶ˆæ¯ã€‚

è¿˜æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„çš„:

- [`into_stream`](https://docs.rs/mini-redis/0.4.1/mini_redis/client/struct.Subscriber.html#method.into_stream) ä¼šå°† `Subscriber` å˜æˆä¸€ä¸ª `stream`
- åœ¨ `stream` ä¸Šè°ƒç”¨ `next` æ–¹æ³•è¦æ±‚è¯¥ `stream` è¢«å›ºå®šä½([`pinned`](https://doc.rust-lang.org/std/pin/index.html))ï¼Œå› æ­¤éœ€è¦è°ƒç”¨ `tokio::pin!`

> å…³äº Pin çš„è¯¦ç»†è§£è¯»ï¼Œå¯ä»¥é˜…è¯»[è¿™ç¯‡æ–‡ç« ](https://course.rs/async/pin-unpin.html)

å¤§å®¶å¯ä»¥å»æ‰ `pin!` çš„è°ƒç”¨ï¼Œç„¶åè§‚å¯Ÿä¸‹æŠ¥é”™ï¼Œè‹¥ä»¥åä½ é‡åˆ°è¿™ç§é”™è¯¯ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ä¸‹ `pin!`ã€‚

æ­¤æ—¶ï¼Œå¯ä»¥è¿è¡Œä¸‹æˆ‘ä»¬çš„å®¢æˆ·ç«¯ä»£ç çœ‹çœ‹æ•ˆæœ(åˆ«å¿˜äº†å…ˆå¯åŠ¨å‰é¢æåˆ°çš„ mini-redis æœåŠ¡ç«¯):

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"two" })
got = Ok(Message { channel: "numbers", content: b"3" })
got = Ok(Message { channel: "numbers", content: b"four" })
got = Ok(Message { channel: "numbers", content: b"five" })
got = Ok(Message { channel: "numbers", content: b"6" })
```

åœ¨äº†è§£äº† `stream` çš„åŸºæœ¬ç”¨æ³•åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨é€‚é…å™¨æ¥æ‰©å±•å®ƒã€‚

## é€‚é…å™¨

åœ¨å‰é¢ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº†è¿­ä»£å™¨æœ‰[ä¸¤ç§é€‚é…å™¨](https://course.rs/advance/functional-programing/iterator.html#æ¶ˆè´¹è€…ä¸é€‚é…å™¨)ï¼š

- è¿­ä»£å™¨é€‚é…å™¨ï¼Œä¼šå°†ä¸€ä¸ªè¿­ä»£å™¨è½¬å˜æˆå¦ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¾‹å¦‚ `map`ï¼Œ`filter` ç­‰
- æ¶ˆè´¹è€…é€‚é…å™¨ï¼Œä¼šæ¶ˆè´¹æ‰ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªå€¼ï¼Œä¾‹å¦‚ `collect` å¯ä»¥å°†è¿­ä»£å™¨æ”¶é›†æˆä¸€ä¸ªé›†åˆ

ä¸è¿­ä»£å™¨ç±»ä¼¼ï¼Œ`stream` ä¹Ÿæœ‰é€‚é…å™¨ï¼Œä¾‹å¦‚ä¸€ä¸ª `stream` é€‚é…å™¨å¯ä»¥å°†ä¸€ä¸ª `stream` è½¬å˜æˆå¦ä¸€ä¸ª `stream` ï¼Œä¾‹å¦‚ `map`ã€`take` å’Œ `filter`ã€‚

åœ¨ä¹‹å‰çš„å®¢æˆ·ç«¯ä¸­ï¼Œ`subscribe` è®¢é˜…ä¸€ç›´æŒç»­ä¸‹å»ï¼Œç›´åˆ°ç¨‹åºè¢«å…³é—­ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å‡çº§ä¸‹ï¼Œè®©å®ƒåœ¨æ”¶åˆ°ä¸‰æ¡æ¶ˆæ¯åå°±åœæ­¢è¿­ä»£ï¼Œæœ€ç»ˆç»“æŸã€‚

```rust
let messages = subscriber
    .into_stream()
    .take(3);
```

è¿™é‡Œå…³é”®å°±åœ¨äº `take` é€‚é…å™¨ï¼Œå®ƒä¼šé™åˆ¶ `stream` åªèƒ½ç”Ÿæˆæœ€å¤š `n` æ¡æ¶ˆæ¯ã€‚è¿è¡Œä¸‹çœ‹çœ‹ç»“æœï¼š

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"two" })
got = Ok(Message { channel: "numbers", content: b"3" })
```

ç¨‹åºç»ˆäºå¯ä»¥æ­£å¸¸ç»“æŸäº†ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿‡æ»¤ `stream` ä¸­çš„æ¶ˆæ¯ï¼Œåªä¿ç•™æ•°å­—ç±»å‹çš„å€¼:

```rust
let messages = subscriber
    .into_stream()
    .filter(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => true,
        _ => false,
    })
    .take(3);
```

è¿è¡Œåè¾“å‡ºï¼š

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"3" })
got = Ok(Message { channel: "numbers", content: b"6" })
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé€‚é…å™¨çš„é¡ºåºéå¸¸é‡è¦ï¼Œ`.filter(...).take(3)` å’Œ `.take(3).filter(...)` çš„ç»“æœå¯èƒ½å¤§ç›¸å¾„åº­ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±å°è¯•ä¸‹ã€‚

ç°åœ¨ï¼Œè¿˜æœ‰ä¸€ä»¶äº‹è¦åšï¼Œå’±ä»¬çš„æ¶ˆæ¯è¢«ä¸å¤ªå¥½çœ‹çš„ `Ok(...)` æ‰€åŒ…è£¹ï¼Œç°åœ¨é€šè¿‡ `map` é€‚é…å™¨æ¥ç®€åŒ–ä¸‹:

```rust
let messages = subscriber
    .into_stream()
    .filter(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => true,
        _ => false,
    })
    .map(|msg| msg.unwrap().content)
    .take(3);
```

æ³¨æ„åˆ° `msg.unwrap` äº†å—ï¼Ÿå¤§å®¶å¯èƒ½ä¼šä»¥ä¸ºæˆ‘ä»¬æ˜¯å‡ºäºç¤ºä¾‹çš„ç›®çš„æ‰è¿™ä¹ˆç”¨ï¼Œå®é™…ä¸Šå¹¶ä¸æ˜¯ï¼Œç”±äº `filter` çš„å…ˆæ‰§è¡Œï¼Œ `map` ä¸­çš„ `msg` åªèƒ½æ˜¯ `Ok(...)`ï¼Œå› æ­¤ `unwrap` éå¸¸å®‰å…¨ã€‚

```console
got = b"1"
got = b"3"
got = b"6"
```

è¿˜æœ‰ä¸€ç‚¹å¯ä»¥æ”¹è¿›çš„åœ°æ–¹ï¼šå½“ `filter` å’Œ `map` ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œä½ å¾€å¾€å¯ä»¥ç”¨ä¸€ä¸ªç»Ÿä¸€çš„æ–¹æ³•æ¥å®ç° [`filter_map`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html#method.filter_map)ã€‚

```rust
let messages = subscriber
    .into_stream()
    .filter_map(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => Some(msg.content),
        _ => None,
    })
    .take(3);
```

æƒ³è¦å­¦ä¹ æ›´å¤šçš„é€‚é…å™¨ï¼Œå¯ä»¥çœ‹çœ‹ [`StreamExt`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html) ç‰¹å¾ã€‚

## å®ç° Stream ç‰¹å¾

å¦‚æœå¤§å®¶è¿˜æ²¡å¿˜è®° `Future` ç‰¹å¾ï¼Œé‚£ `Stream` ç‰¹å¾ç›¸ä¿¡ä½ ä¹Ÿä¼šå¾ˆå¿«è®°ä½ï¼Œå› ä¸ºå®ƒä»¬éå¸¸ç±»ä¼¼ï¼š

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;

    fn size_hint(&self) -> (usize, Option<usize>) {
        (0, None)
    }
}
```

`Stream::poll_next()` å‡½æ•°è·Ÿ `Future::poll` å¾ˆç›¸ä¼¼ï¼ŒåŒºåˆ«å°±æ˜¯å‰è€…ä¸ºäº†ä» `stream` æ”¶åˆ°å¤šä¸ªå€¼éœ€è¦é‡å¤çš„è¿›è¡Œè°ƒç”¨ã€‚ å°±åƒåœ¨ [`æ·±å…¥async`](https://course.rs/tokio/async.html) ç« èŠ‚æåˆ°çš„é‚£æ ·ï¼Œå½“ä¸€ä¸ª `stream` æ²¡æœ‰åšå¥½è¿”å›ä¸€ä¸ªå€¼çš„å‡†å¤‡æ—¶ï¼Œå®ƒå°†è¿”å›ä¸€ä¸ª `Poll::Pending` ï¼ŒåŒæ—¶å°†ä»»åŠ¡çš„ `waker` è¿›è¡Œæ³¨å†Œã€‚ä¸€æ—¦ `stream` å‡†å¤‡å¥½åï¼Œ `waker` å°†è¢«è°ƒç”¨ã€‚

é€šå¸¸æ¥è¯´ï¼Œå¦‚æœæƒ³è¦æ‰‹åŠ¨å®ç°ä¸€ä¸ª `Stream`ï¼Œéœ€è¦ç»„åˆ `Future` å’Œå…¶å®ƒ `Stream`ã€‚ä¸‹é¢ï¼Œè¿˜è®°å¾—åœ¨[`æ·±å…¥async`](https://course.rs/tokio/async.html) ä¸­æ„å»ºçš„ `Delay Future` å—ï¼Ÿç°åœ¨è®©æˆ‘ä»¬æ¥æ›´è¿›ä¸€æ­¥ï¼Œå°†å®ƒè½¬æ¢æˆä¸€ä¸ª `stream`ï¼Œæ¯ 10 æ¯«ç§’ç”Ÿæˆä¸€ä¸ªå€¼ï¼Œæ€»å…±ç”Ÿæˆ 3 æ¬¡:

```rust
use tokio_stream::Stream;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::Duration;

struct Interval {
    rem: usize,
    delay: Delay,
}

impl Stream for Interval {
    type Item = ();

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<Option<()>>
    {
        if self.rem == 0 {
            // å»é™¤è®¡æ—¶å™¨å®ç°
            return Poll::Ready(None);
        }

        match Pin::new(&mut self.delay).poll(cx) {
            Poll::Ready(_) => {
                let when = self.delay.when + Duration::from_millis(10);
                self.delay = Delay { when };
                self.rem -= 1;
                Poll::Ready(Some(()))
            }
            Poll::Pending => Poll::Pending,
        }
    }
}
```

#### async-stream

æ‰‹åŠ¨å®ç° `Stream` ç‰¹å¾å®é™…ä¸Šæ˜¯ç›¸å½“éº»çƒ¦çš„äº‹ï¼Œä¸å¹¸åœ°æ˜¯ï¼ŒRust è¯­è¨€çš„ `async/await` è¯­æ³•ç›®å‰è¿˜ä¸èƒ½ç”¨äºå®šä¹‰ `stream`ï¼Œè™½ç„¶ç›¸å…³çš„å·¥ä½œå·²ç»åœ¨è¿›è¡Œä¸­ã€‚

ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆï¼Œ[`async-stream`](https://docs.rs/async-stream/latest/async_stream/) åŒ…æä¾›äº†ä¸€ä¸ª `stream!` å®ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªè¾“å…¥è½¬æ¢æˆ `stream`ï¼Œä½¿ç”¨è¿™ä¸ªåŒ…ï¼Œä¸Šé¢çš„ä»£ç å¯ä»¥è¿™æ ·å®ç°ï¼š

```rust
use async_stream::stream;
use std::time::{Duration, Instant};

stream! {
    let mut when = Instant::now();
    for _ in 0..3 {
        let delay = Delay { when };
        delay.await;
        yield ();
        when += Duration::from_millis(10);
    }
}
```

å—¯ï¼Œçœ‹ä¸Šå»è¿˜æ˜¯ç›¸å½“ä¸é”™çš„ï¼Œä»£ç å¯è¯»æ€§å¤§å¹…æå‡ï¼

<!-- todo generators -->
æ˜¯ä¸æ˜¯å‘ç°äº†ä¸€ä¸ªå…³é”®å­— `yield` ï¼Œä»–æ˜¯ç”¨æ¥é…åˆç”Ÿæˆå™¨ä½¿ç”¨çš„ã€‚è¯¦è§[åŸæ–‡](https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html)



================================================
FILE: src/advance-practice1/graceful-shutdown.md
================================================
# ä¼˜é›…å…³é—­å’Œèµ„æºæ¸…ç†

ä¹‹å‰çš„ç¨‹åºï¼Œå¦‚æœä½¿ç”¨ `ctrl-c` çš„æ–¹æ³•æ¥å…³é—­ï¼Œæ‰€æœ‰çš„çº¿ç¨‹éƒ½ä¼šç«‹å³åœæ­¢ï¼Œè¿™ä¼šé€ æˆæ­£åœ¨è¯·æ±‚çš„ç”¨æˆ·æ„ŸçŸ¥åˆ°ä¸€ä¸ªæ˜æ˜¾çš„é”™è¯¯ã€‚


å› æ­¤æˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€äº›ä¼˜é›…å…³é—­( Graceful Shutdown )ï¼Œä»¥æ›´å¥½çš„å®Œæˆèµ„æºæ¸…ç†ç­‰æ”¶å°¾å·¥ä½œã€‚

## ä¸ºçº¿ç¨‹æ± å®ç° Drop

å½“çº¿ç¨‹æ± è¢« drop æ—¶ï¼Œéœ€è¦ç­‰å¾…æ‰€æœ‰çš„å­çº¿ç¨‹å®Œæˆå®ƒä»¬çš„å·¥ä½œï¼Œç„¶åå†é€€å‡ºï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªåˆæ­¥å°è¯•:

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
```

è¿™é‡Œé€šè¿‡å®ç° `Drop` ç‰¹å¾æ¥ä¸ºçº¿ç¨‹æ± æ·»åŠ èµ„æºæ”¶å°¾å·¥ä½œï¼Œä»£ç æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯ä¾æ¬¡è°ƒç”¨æ¯ä¸ªçº¿ç¨‹çš„ `join` æ–¹æ³•ã€‚ç¼–è¯‘ä¸‹è¯•è¯•ï¼š

```rust
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --> src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait
   |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
```

è¿™é‡Œçš„æŠ¥é”™å¾ˆæ˜æ˜¾ï¼Œ`worker.thread` è¯•å›¾æ‹¿èµ°æ‰€æœ‰æƒï¼Œä½†æ˜¯ `worker` ä»…ä»…æ˜¯ä¸€ä¸ªå¯å˜å€Ÿç”¨ï¼Œæ˜¾ç„¶æ˜¯ä¸å¯è¡Œçš„ã€‚

ç›®å‰æ¥çœ‹ï¼Œåªèƒ½å°† `thread` ä» `worker` ä¸­ç§»åŠ¨å‡ºæ¥ï¼Œä¸€ä¸ªå¯è¡Œçš„å°è¯•:

```rust
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
```

å¯¹äº `Option` ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ `take` æ–¹æ³•æ‹¿èµ°å†…éƒ¨å€¼çš„æ‰€æœ‰æƒï¼ŒåŒæ—¶ç•™ä¸‹ä¸€ä¸ª `None` åœ¨é£ä¸­å­¤ç‹¬å‡Œä¹±ã€‚ç»§ç»­å°è¯•ç¼–è¯‘é©±åŠ¨å¼€å‘æ¨¡å¼:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --> src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option<JoinHandle<()>>`
   |
note: the method `join` exists on the type `JoinHandle<()>`
help: consider using `Option::expect` to unwrap the `JoinHandle<()>` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect("REASON").join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --> src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option<JoinHandle<()>>`
            found struct `JoinHandle<_>`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +
```

å…ˆæ¥è§£å†³ç¬¬äºŒä¸ªç±»å‹ä¸åŒ¹é…çš„é”™è¯¯:

```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

ç®€å•æå®šï¼Œå›å¤´çœ‹çœ‹ç¬¬ä¸€ä¸ªé”™è¯¯ï¼Œæ—¢ç„¶æ¢äº† `Option`ï¼Œå°±å¯ä»¥ç”¨ `take` æ‹¿èµ°æ‰€æœ‰æƒ:

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

æ³¨æ„è¿™ç§ `if let` çš„å†™æ³•ï¼Œè‹¥ `worker.thread` å·²ç»æ˜¯ `None`ï¼Œä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿï¼Œç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸ; è‹¥åŒ…å«ä¸€ä¸ªçº¿ç¨‹ï¼Œé‚£å°±æ‹¿èµ°å…¶æ‰€æœ‰æƒï¼Œç„¶åè°ƒç”¨ `join`ã€‚

## åœæ­¢å·¥ä½œçº¿ç¨‹

è™½ç„¶è°ƒç”¨äº† `join` ï¼Œä½†æ˜¯ç›®æ ‡çº¿ç¨‹ä¾ç„¶ä¸ä¼šåœæ­¢ï¼ŒåŸå› åœ¨äºå®ƒä»¬åœ¨æ— é™çš„ `loop` å¾ªç¯ç­‰å¾…ï¼Œçœ‹èµ·æ¥éœ€è¦å€Ÿç”¨ `channel` çš„ `drop` æœºåˆ¶ï¼šé‡Šæ”¾ `sender`å‘é€ç«¯åï¼Œ`receiver` æ¥æ”¶ç«¯ä¼šæ”¶åˆ°æŠ¥é”™ï¼Œç„¶åå†é€€å‡ºå³å¯ã€‚

```rust
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}
// --snip--
impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        // --snip--

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

ä¸Šé¢åšäº†ä¸¤å¤„æ”¹å˜:

1. ä¸º `sender` å¢åŠ  `Option` å°è£…ï¼Œè¿™æ ·å¯ä»¥ç”¨ `take` æ‹¿èµ°æ‰€æœ‰æƒï¼Œè·Ÿä¹‹å‰çš„ `thread` ä¸€æ ·
2. ä¸»åŠ¨è°ƒç”¨ `drop` å…³é—­å‘é€ç«¯ `sender`

å…³é—­ `sender` åï¼Œå°†å…³é—­å¯¹åº”çš„ `channel`ï¼Œæ„å‘³ç€ä¸ä¼šå†æœ‰ä»»ä½•æ¶ˆæ¯è¢«å‘é€ã€‚éšåï¼Œæ‰€æœ‰çš„å¤„äºæ— é™ `loop` çš„æ¥æ”¶ç«¯å°†æ”¶åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œæˆ‘ä»¬æ ¹æ®é”™è¯¯å†è¿›è¡Œè¿›ä¸€æ­¥çš„å¤„ç†ã€‚


```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

ä¸ºäº†å¿«é€ŸéªŒè¯ä»£ç æ˜¯å¦æ­£ç¡®ï¼Œä¿®æ”¹ `main` å‡½æ•°ï¼Œè®©å…¶åªæ¥æ”¶å‰ä¸¤ä¸ªè¯·æ±‚:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
```

`take` æ˜¯è¿­ä»£å™¨ `Iterator` ä¸Šçš„æ–¹æ³•ï¼Œä¼šé™åˆ¶åç»­çš„è¿­ä»£è¿›è¡Œæœ€å¤šä¸¤æ¬¡ï¼Œç„¶åå°±ç»“æŸç›‘å¬ï¼Œéšå `ThreadPool` ä¹Ÿå°†è¶…å‡ºä½œç”¨åŸŸå¹¶è‡ªåŠ¨è§¦å‘ `drop`ã€‚

```shell
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```

å¯ä»¥çœ‹åˆ°ï¼Œä»£ç æŒ‰ç…§æˆ‘ä»¬çš„è®¾æƒ³å¦‚æœŸè¿è¡Œï¼Œè‡³æ­¤ï¼Œä¸€ä¸ªåŸºäºçº¿ç¨‹æ± çš„ç®€å• Web æœåŠ¡å™¨å·²ç»å®Œæˆï¼Œä¸‹é¢æ˜¯å®Œæ•´çš„ä»£ç :


## å®Œæ•´ä»£ç 
```rust
// src/main.rs
use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

```rust
// src/lib.rs
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

### å¯ä»¥åšçš„æ›´å¤š

äº‹å®ä¸Šï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åšæ›´å¤šï¼Œä½†æ˜¯å—åˆ¶äºç¯‡å¹…ï¼Œå°±ä¸å†å±•å¼€ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡Œå®Œæˆã€‚

- å¢åŠ æ›´å¤šçš„æ–‡æ¡£
- ä¸ºçº¿ç¨‹æ± å¢åŠ æµ‹è¯•
- å°½å¯èƒ½ç§»é™¤ `unwrap`ï¼Œæ›¿æ¢ä¸ºé”™è¯¯å¤„ç†
- ä½¿ç”¨çº¿ç¨‹æ± å®Œæˆå…¶å®ƒç±»å‹çš„å·¥ä½œï¼Œè€Œä¸ä»…ä»…æ˜¯æœ¬ç« çš„ Web æœåŠ¡å™¨
- åœ¨ `crates.io` ä¸Šæ‰¾åˆ°ä¸€ä¸ªçº¿ç¨‹æ± å®ç°ï¼Œç„¶åä½¿ç”¨è¯¥åŒ…å®ç°ä¸€ä¸ªç±»ä¼¼çš„ Web æœåŠ¡å™¨


## ä¸Šä¸€ç« èŠ‚çš„é—ç•™é—®é¢˜

åœ¨ä¸Šä¸€ç« èŠ‚çš„æœ«å°¾ï¼Œæˆ‘ä»¬æåˆ°å°† `let` æ›¿æ¢ä¸º `while let` åï¼Œå¤šçº¿ç¨‹çš„ä¼˜åŠ¿å°†è¡ç„¶æ— å­˜ï¼ŒåŸå› è—çš„å¾ˆéšè”½ï¼š

1. `Mutex` ç»“æ„ä½“æ²¡æœ‰æä¾›æ˜¾å¼çš„ `unlock`ï¼Œè¦ä¾èµ–ä½œç”¨åŸŸç»“æŸåçš„ `drop` æ¥è‡ªåŠ¨é‡Šæ”¾ 
2. `let job = receiver.lock().unwrap().recv().unwrap();` åœ¨è¿™è¡Œä»£ç ä¸­ï¼Œç”±äºä½¿ç”¨äº† `let`ï¼Œå³è¾¹çš„ä»»ä½•ä¸´æ—¶å˜é‡ä¼šåœ¨ `let` è¯­å¥ç»“æŸåç«‹å³è¢« `drop`ï¼Œå› æ­¤é”ä¼šè‡ªåŠ¨é‡Šæ”¾
3. ç„¶è€Œ `while let` (è¿˜åŒ…æ‹¬ `if let` å’Œ `match`) ç›´åˆ°æœ€åä¸€ä¸ªèŠ±æ‹¬å·åï¼Œæ‰è§¦å‘ `drop`

```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

æ ¹æ®ä¹‹å‰çš„åˆ†æï¼Œä¸Šé¢çš„ä»£ç ç›´åˆ° `job()` ä»»åŠ¡æ‰§è¡Œç»“æŸåï¼Œæ‰ä¼šé‡Šæ”¾é”ï¼Œå»æ‰§è¡Œå¦ä¸€ä¸ªè¯·æ±‚ï¼Œæœ€ç»ˆé€ æˆè¯·æ±‚æ’é˜Ÿã€‚



================================================
FILE: src/advance-practice1/intro.md
================================================
# å®è·µåº”ç”¨ï¼šå¤šçº¿ç¨‹WebæœåŠ¡å™¨

ä¸€èˆ¬æ¥è¯´ï¼Œç°ä»£åŒ–çš„ web æœåŠ¡å™¨å¾€å¾€éƒ½åŸºäºæ›´åŠ è½»é‡çº§çš„åç¨‹æˆ– async/await ç­‰æ¨¡å¼å®ç°ï¼Œä½†æ˜¯åŸºäºæœ¬ç« çš„å†…å®¹ï¼Œæˆ‘ä»¬è¿˜æ˜¯é‡‡å–è¾ƒä¸ºä¼ ç»Ÿçš„å¤šçº¿ç¨‹çš„æ–¹å¼æ¥å®ç°ï¼Œå³ï¼šä¸€ä¸ªè¯·æ±‚è¿æ¥åˆ†é…ä¸€ä¸ªçº¿ç¨‹å»ç‹¬ç«‹å¤„ç†ï¼Œå½“ç„¶è¿˜æœ‰å‡çº§ç‰ˆçš„çº¿ç¨‹æ± ã€‚

åœ¨æœ¬ç« ä¸­ä½ å°†äº†è§£ï¼š

1. å­¦ä¹ ä¸€ç‚¹ TCP å’Œ HTTP
2. åœ¨å¥—æ¥å­— socket ä¸Šç›‘å¬è¿›å…¥çš„ TCP è¿æ¥
3. è§£æ HTTP è¯·æ±‚
4. åˆ›å»ºåˆé€‚çš„ HTTP åº”ç­”
5. ä½¿ç”¨çº¿ç¨‹æ± æ¥æå‡ web æœåŠ¡å™¨çš„ååé‡

> æœ¬ç« çš„å®ç°æ–¹æ³•å¹¶ä¸æ˜¯åœ¨ Rust ä¸­å®ç° Web æœåŠ¡å™¨çš„æœ€ä½³æ–¹æ³•ï¼Œåç»­ç« èŠ‚çš„ async/await ä¼šæ›´åŠ é€‚åˆ!



================================================
FILE: src/advance-practice1/multi-threads.md
================================================
# æ„å»ºå¤šçº¿ç¨‹ Web æœåŠ¡å™¨

ç›®å‰çš„å•çº¿ç¨‹ç‰ˆæœ¬åªèƒ½ä¾æ¬¡å¤„ç†ç”¨æˆ·çš„è¯·æ±‚ï¼šä¸€æ—¶é—´åªèƒ½å¤„ç†ä¸€ä¸ªè¯·æ±‚è¿æ¥ã€‚éšç€ç”¨æˆ·çš„è¯·æ±‚æ•°å¢å¤šï¼Œå¯ä»¥é¢„æ–™çš„æ˜¯æ’åœ¨åé¢çš„ç”¨æˆ·å¯èƒ½è¦ç­‰å¾…æ•°åç§’ç”šè‡³è¶…æ—¶ï¼

æœ¬ç« æˆ‘ä»¬å°†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯é¦–å…ˆæ¥æ¨¡æ‹Ÿä¸€ä¸ªæ…¢è¯·æ±‚åœºæ™¯ï¼Œçœ‹çœ‹å•çº¿ç¨‹æ˜¯å¦çœŸçš„å¦‚æ­¤ç³Ÿç³•ã€‚

## åŸºäºå•çº¿ç¨‹æ¨¡æ‹Ÿæ…¢è¯·æ±‚

ä¸‹é¢çš„ä»£ç ä¸­ï¼Œä½¿ç”¨ sleep çš„æ–¹å¼è®©æ¯æ¬¡è¯·æ±‚æŒç»­ 5 ç§’ï¼Œæ¨¡æ‹ŸçœŸå®çš„æ…¢è¯·æ±‚:

```rust
// in main.rs
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = match &request_line[..] {
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
}
```

ç”±äºå¢åŠ äº†æ–°çš„è¯·æ±‚è·¯å¾„ `/sleep`ï¼Œä¹‹å‰çš„ `if else` è¢«ä¿®æ”¹ä¸º `match`ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº `match` ä¸ä¼šåƒæ–¹æ³•é‚£æ ·è‡ªåŠ¨åšå¼•ç”¨æˆ–è€…è§£å¼•ç”¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ˜¾å¼è°ƒç”¨: `match &request_line[..]` ï¼Œæ¥è·å–æ‰€éœ€çš„ `&str` ç±»å‹ã€‚

å¯ä»¥çœ‹å‡ºï¼Œå½“ç”¨æˆ·è®¿é—® `/sleep` æ—¶ï¼Œè¯·æ±‚ä¼šæŒç»­ 5 ç§’åæ‰è¿”å›ï¼Œä¸‹é¢æ¥è¯•è¯•ï¼Œå¯åŠ¨æœåŠ¡å™¨åï¼Œæ‰“å¼€ä½ çš„æµè§ˆå™¨ï¼Œè¿™æ¬¡è¦åˆ†åˆ«æ‰“å¼€ä¸¤ä¸ªé¡µé¢(tabé¡µ): `http://127.0.0.1:7878/` å’Œ `http://127.0.0.1:7878/sleep`ã€‚

æ­¤æ—¶ï¼Œå¦‚æœæˆ‘ä»¬è¿ç»­è®¿é—® `/` è·¯å¾„ï¼Œé‚£æ•ˆæœè·Ÿä¹‹å‰ä¸€æ ·ï¼šç«‹åˆ»çœ‹åˆ°è¯·æ±‚çš„é¡µé¢ã€‚ä½†å‡å¦‚å…ˆè®¿é—® `/sleep` ï¼Œæ¥ç€åœ¨å¦ä¸€ä¸ªé¡µé¢è®¿é—® `/`ï¼Œå°±ä¼šçœ‹åˆ° `/` çš„é¡µé¢ç›´åˆ° 5 ç§’åæ‰ä¼šåˆ·å‡ºæ¥ï¼ŒéªŒè¯äº†è¯·æ±‚æ’é˜Ÿè¿™ä¸ªç³Ÿç³•çš„äº‹å®ã€‚

è‡³äºå¦‚ä½•è§£å†³ï¼Œå…¶å®åŠæ³•ä¸å°‘ï¼Œæœ¬ç« æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€ä¸ªç»å…¸è§£å†³æ–¹æ¡ˆï¼šçº¿ç¨‹æ± ã€‚

## ä½¿ç”¨çº¿ç¨‹æ± æ”¹å–„åå

çº¿ç¨‹æ± åŒ…å«ä¸€ç»„å·²ç”Ÿæˆçš„çº¿ç¨‹ï¼Œå®ƒä»¬æ—¶åˆ»ç­‰å¾…ç€æ¥æ”¶å¹¶å¤„ç†æ–°çš„ä»»åŠ¡ã€‚å½“ç¨‹åºæ¥æ”¶åˆ°æ–°ä»»åŠ¡æ—¶ï¼Œå®ƒä¼šå°†çº¿ç¨‹æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹æŒ‡æ´¾ç»™è¯¥ä»»åŠ¡ï¼Œåœ¨è¯¥çº¿ç¨‹å¿™ç€å¤„ç†æ—¶ï¼Œæ–°æ¥çš„ä»»åŠ¡ä¼šäº¤ç»™æ± ä¸­å‰©ä½™çš„çº¿ç¨‹è¿›è¡Œå¤„ç†ã€‚æœ€ç»ˆï¼Œå½“æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹å¤„ç†å®Œåï¼Œå®ƒä¼šè¢«é‡æ–°æ”¾å…¥åˆ°çº¿ç¨‹æ± ä¸­ï¼Œå‡†å¤‡å¤„ç†æ–°ä»»åŠ¡ã€‚

å‡è®¾çº¿ç¨‹æ± ä¸­åŒ…å« N ä¸ªçº¿ç¨‹ï¼Œé‚£ä¹ˆå¯ä»¥æ¨æ–­å‡ºï¼ŒæœåŠ¡å™¨å°†æ‹¥æœ‰å¹¶å‘å¤„ç† N ä¸ªè¯·æ±‚è¿æ¥çš„èƒ½åŠ›ï¼Œä»è€Œå¢åŠ æœåŠ¡å™¨çš„ååé‡ã€‚

åŒæ—¶ï¼Œæˆ‘ä»¬å°†é™åˆ¶çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡ï¼Œä»¥ä¿æŠ¤æœåŠ¡å™¨å…å—æ‹’ç»æœåŠ¡æ”»å‡»ï¼ˆDoSï¼‰çš„å½±å“ï¼šå¦‚æœé’ˆå¯¹æ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œé‚£ä¹ˆä¸€ä¸ªäººå‘æˆ‘ä»¬çš„æœåŠ¡å™¨å‘å‡º1000ä¸‡ä¸ªè¯·æ±‚ï¼Œä¼šç›´æ¥è€—å°½èµ„æºï¼Œå¯¼è‡´åç»­ç”¨æˆ·çš„è¯·æ±‚æ— æ³•è¢«å¤„ç†ï¼Œè¿™ä¹Ÿæ˜¯æ‹’ç»æœåŠ¡åç§°çš„æ¥æºã€‚

å› æ­¤ï¼Œè¿˜éœ€å¯¹çº¿ç¨‹æ± è¿›è¡Œä¸€å®šçš„æ¶æ„è®¾è®¡ï¼Œé¦–å…ˆæ˜¯è®¾å®šæœ€å¤§çº¿ç¨‹æ•°çš„ä¸Šé™ï¼Œå…¶æ¬¡ç»´æŠ¤ä¸€ä¸ªè¯·æ±‚é˜Ÿåˆ—ã€‚æ± ä¸­çš„çº¿ç¨‹å»é˜Ÿåˆ—ä¸­ä¾æ¬¡å¼¹å‡ºè¯·æ±‚å¹¶å¤„ç†ã€‚è¿™æ ·å°±å¯ä»¥åŒæ—¶å¹¶å‘å¤„ç† N ä¸ªè¯·æ±‚ï¼Œå…¶ä¸­ N æ˜¯çº¿ç¨‹æ•°ã€‚

ä½†èªæ˜çš„è¯»è€…å¯èƒ½ä¼šæƒ³åˆ°ï¼Œå‡å¦‚æ¯ä¸ªè¯·æ±‚ä¾ç„¶è€—æ—¶å¾ˆé•¿ï¼Œé‚£è¯·æ±‚é˜Ÿåˆ—ä¾ç„¶ä¼šå †ç§¯ï¼Œåç»­çš„ç”¨æˆ·è¯·æ±‚è¿˜æ˜¯éœ€è¦ç­‰å¾…è¾ƒé•¿çš„æ—¶é—´ï¼Œæ¯•ç«Ÿä½ ä¹Ÿå°± N ä¸ªçº¿ç¨‹ï¼Œä½†æ€»å½’æ¯”å•çº¿ç¨‹è¦å¼º N å€å§ :D

å½“ç„¶ï¼Œçº¿ç¨‹æ± ä¾ç„¶æ˜¯è¾ƒä¸ºä¼ ç»Ÿçš„æå‡ååæ–¹æ³•ï¼Œæ¯”è¾ƒæ–°çš„æœ‰ï¼šå•çº¿ç¨‹å¼‚æ­¥ IOï¼Œä¾‹å¦‚ redisï¼›å¤šçº¿ç¨‹å¼‚æ­¥ IOï¼Œä¾‹å¦‚ Rust çš„ä¸»æµ web æ¡†æ¶ã€‚äº‹å®ä¸Šï¼Œå¤§å®¶åœ¨ä¸‹ä¸€ä¸ªå®æˆ˜é¡¹ç›®ä¸­ï¼Œä¼šçœ‹åˆ°ç›¸å…³æŠ€æœ¯çš„åº”ç”¨ã€‚

### ä¸ºæ¯ä¸ªè¯·æ±‚ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹

è¿™æ˜¾ç„¶ä¸æ˜¯æˆ‘ä»¬çš„æœ€ç»ˆæ–¹æ¡ˆï¼ŒåŸå› åœ¨äºå®ƒä¼šç”Ÿæˆæ— ä¸Šé™çš„çº¿ç¨‹æ•°ï¼Œæœ€ç»ˆå¯¼è‡´èµ„æºè€—å°½ã€‚ä½†å®ƒç¡®å®æ˜¯ä¸€ä¸ªå¥½çš„èµ·ç‚¹:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

è¿™ç§å®ç°ä¸‹ï¼Œä¾æ¬¡è®¿é—® `/sleep` å’Œ `/` å°±æ— éœ€å†ç­‰å¾…ï¼Œä¸é”™çš„å¼€å§‹ã€‚

### é™åˆ¶åˆ›å»ºçº¿ç¨‹çš„æ•°é‡

åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸Šé¢ä»£ç çš„åŸºç¡€ä¸Šï¼Œå°½é‡å°‘çš„å»ä¿®æ”¹ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå‡æƒ³çš„çº¿ç¨‹æ±  API å®ç°:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
```

ä»£ç è·Ÿä¹‹å‰çš„ç±»ä¼¼ï¼Œä¹Ÿéå¸¸ç®€æ´æ˜äº†ï¼Œ `ThreadPool::new(4)` åˆ›å»ºä¸€ä¸ªåŒ…å« 4 ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± ï¼Œæ¥ç€é€šè¿‡ `pool.execute` å»åˆ†å‘æ‰§è¡Œè¯·æ±‚ã€‚

æ˜¾ç„¶ï¼Œä¸Šé¢çš„ä»£ç æ— æ³•ç¼–è¯‘ï¼Œä¸‹é¢æ¥é€æ­¥å®ç°ã€‚

### ä½¿ç”¨ç¼–è¯‘å™¨é©±åŠ¨çš„æ–¹å¼å¼€å‘ ThreadPool

ä½ å¯èƒ½å¬è¯´è¿‡æµ‹è¯•é©±åŠ¨å¼€å‘ï¼Œä½†å¬è¿‡ç¼–è¯‘å™¨é©±åŠ¨å¼€å‘å—ï¼Ÿæ¥è§è¯†ä¸‹ Rust ä¸­çš„ç»æ‹›å§ã€‚

æ£€æŸ¥ä¹‹å‰çš„ä»£ç ï¼Œçœ‹çœ‹æŠ¥ä»€ä¹ˆé”™:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --> src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
```

ä¿—è¯è¯´ï¼Œä¸æ€•æ•Œäººå¾ˆå¼ºï¼Œå°±æ€•ä»–ä»¬ä¸çŠ¯é”™ï¼Œå¾ˆå¥½ï¼Œç¼–è¯‘å™¨æ¼å‡ºäº†ç ´ç»½ã€‚çœ‹èµ·æ¥æˆ‘ä»¬éœ€è¦å®ç° `ThreadPool` ç±»å‹ã€‚çœ‹èµ·æ¥ï¼Œè¿˜éœ€è¦æ·»åŠ ä¸€ä¸ªåº“åŒ…ï¼Œæœªæ¥çº¿ç¨‹æ± çš„ä»£ç éƒ½å°†åœ¨è¿™ä¸ªç‹¬ç«‹çš„åŒ…ä¸­å®Œæˆï¼Œç”šè‡³äºæœªæ¥ä½ è¦å®ç°å…¶å®ƒçš„æœåŠ¡ï¼Œä¹Ÿå¯ä»¥å¤ç”¨è¿™ä¸ªå¤šçº¿ç¨‹åº“åŒ…ã€‚

åˆ›å»º `src/lib.rs` æ–‡ä»¶å¹¶å†™å…¥å¦‚ä¸‹ä»£ç :

```rust
pub struct ThreadPool;
```

æ¥ç€åœ¨ `main.rs` ä¸­å¼•å…¥:

```rust
// main.rs
use hello::ThreadPool;
```

ç¼–è¯‘åä¾ç„¶æŠ¥é”™:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --> src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

å¥½ï¼Œç»§ç»­å®ç° `new` å‡½æ•° :

```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
```

ç»§ç»­æ£€æŸ¥ï¼š

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --> src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

è¿™ä¸ªæ–¹æ³•ç±»ä¼¼äº `thread::spawn`ï¼Œç”¨äºå°†é—­åŒ…ä¸­çš„ä»»åŠ¡äº¤ç»™æŸä¸ªç©ºé—²çš„çº¿ç¨‹å»æ‰§è¡Œã€‚

å…¶å®è¿™é‡Œæœ‰ä¸€ä¸ªå°éš¾ç‚¹ï¼š`execute` çš„å‚æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå›å¿†ä¸‹ä¹‹å‰å­¦è¿‡çš„å†…å®¹ï¼Œé—­åŒ…ä½œä¸ºå‚æ•°æ—¶å¯ä»¥ç”±ä¸‰ä¸ªç‰¹å¾è¿›è¡Œçº¦æŸ: `Fn`ã€`FnMut` å’Œ `FnOnce`ï¼Œé€‰å“ªä¸ªå°±æˆä¸ºä¸€ä¸ªé—®é¢˜ã€‚ç”±äº `execute` åœ¨å®ç°ä¸Šç±»ä¼¼ `thread::spawn`ï¼Œæˆ‘ä»¬å¯ä»¥å‚è€ƒä¸‹åè€…çš„ç­¾åå¦‚ä½•å£°æ˜ã€‚

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

å¯ä»¥çœ‹å‡ºï¼Œ`spawn` é€‰æ‹© `FnOnce` ä½œä¸º `F` é—­åŒ…çš„ç‰¹å¾çº¦æŸï¼ŒåŸå› æ˜¯é—­åŒ…ä½œä¸ºä»»åŠ¡åªéœ€è¢«çº¿ç¨‹æ‰§è¡Œä¸€æ¬¡å³å¯ã€‚

`F` è¿˜æœ‰ä¸€ä¸ªç‰¹å¾çº¦æŸ `Send` ï¼Œä¹Ÿå¯ä»¥ç…§æŠ„è¿‡æ¥ï¼Œæ¯•ç«Ÿé—­åŒ…éœ€è¦ä»ä¸€ä¸ªçº¿ç¨‹ä¼ é€’åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè‡³äºç”Ÿå‘½å‘¨æœŸçº¦æŸ `'static`ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¹¶ä¸çŸ¥é“çº¿ç¨‹éœ€è¦å¤šä¹…æ—¶é—´æ¥æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚

```rust
impl ThreadPool {
    // --snip--
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
```

åœ¨ç†è§£ `spawn` åï¼Œå°±å¯ä»¥è½»æ¾å†™å‡ºå¦‚ä¸Šçš„ `execute` å®ç°ï¼Œæ³¨æ„è¿™é‡Œçš„ `FnOnce()` è·Ÿ `spawn` æœ‰æ‰€ä¸åŒï¼ŒåŸå› æ˜¯è¦ `execute` ä¼ å…¥çš„é—­åŒ…æ²¡æœ‰å‚æ•°ä¹Ÿæ²¡æœ‰è¿”å›å€¼ã€‚

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```

æˆåŠŸç¼–è¯‘ï¼Œä½†åœ¨æµè§ˆå™¨è®¿é—®ä¾ç„¶ä¼šæŠ¥ä¹‹å‰ç±»ä¼¼çš„é”™è¯¯ï¼Œä¸‹é¢æ¥å®ç° `execute`ã€‚

### `new` è¿˜æ˜¯ `build`

å…³äº `ThreadPool` çš„æ„é€ å‡½æ•°ï¼Œå­˜åœ¨ä¸¤ä¸ªé€‰æ‹© `new` å’Œ `build`ã€‚

`new` å¾€å¾€ç”¨äºç®€å•åˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹ï¼Œè€Œ `build` å¾€å¾€ä¼šå®Œæˆæ›´åŠ å¤æ‚çš„æ„å»ºå·¥ä½œï¼Œä¾‹å¦‚å…¥é—¨å®æˆ˜ä¸­çš„ `Config::build`ã€‚

åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦åœ¨åˆå§‹åŒ–çº¿ç¨‹æ± çš„åŒæ—¶åˆ›å»ºç›¸åº”çš„çº¿ç¨‹ï¼Œå› æ­¤ `new` æ˜¯æ›´é€‚åˆçš„é€‰æ‹©:

```rust
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
}
```

è¿™é‡Œæœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„:

- `usize` ç±»å‹åŒ…å« `0`ï¼Œä½†æ˜¯åˆ›å»ºæ²¡æœ‰ä»»ä½•çº¿ç¨‹çš„çº¿ç¨‹æ± æ˜¾ç„¶æ˜¯æ— æ„ä¹‰çš„ï¼Œå› æ­¤åšä¸€ä¸‹ `assert!` éªŒè¯
- `ThreadPool` æ‹¥æœ‰ä¸é”™çš„[æ–‡æ¡£æ³¨é‡Š](https://course.rs/basic/comment.html#æ–‡æ¡£æ³¨é‡Š)ï¼Œç”šè‡³åŒ…å«äº†å¯èƒ½ `panic` çš„æƒ…å†µï¼Œé€šè¿‡ `cargo doc --open` å¯ä»¥è®¿é—®æ–‡æ¡£æ³¨é‡Š

### å­˜å‚¨çº¿ç¨‹

åˆ›å»º `ThreadPool` åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å­˜å‚¨å…·ä½“çš„çº¿ç¨‹ï¼Œæ—¢ç„¶è¦å­˜æ”¾çº¿ç¨‹ï¼Œä¸€ä¸ªç»•ä¸è¿‡å»çš„é—®é¢˜å°±æ˜¯ï¼šç”¨ä»€ä¹ˆç±»å‹æ¥å­˜æ”¾ï¼Œä¾‹å¦‚å‡å¦‚ä½¿ç”¨ `Vec<T>`  æ¥å­˜å‚¨ï¼Œé‚£è¿™ä¸ª `T` åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ

ä¼°è®¡è¿˜å¾—æ¢ç´¢ä¸‹ `thread::spawn` çš„ç­¾åï¼Œæ¯•ç«Ÿå®ƒç”Ÿæˆå¹¶è¿”å›ä¸€ä¸ªçº¿ç¨‹:

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

çœ‹èµ·æ¥ `JoinHandle<T>` æ˜¯æˆ‘ä»¬éœ€è¦çš„ï¼Œè¿™é‡Œçš„ `T` æ˜¯ä¼ å…¥çš„é—­åŒ…ä»»åŠ¡æ‰€è¿”å›çš„ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ— éœ€ä»»ä½•è¿”å›ï¼Œå› æ­¤ `T` ç›´æ¥ä½¿ç”¨ `()` å³å¯ã€‚

```rust
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæœ€ç»ˆæˆ‘ä»¬ä½¿ç”¨ `Vec<thread::JoinHandle<()>>` æ¥å­˜å‚¨çº¿ç¨‹ï¼ŒåŒæ—¶è®¾å®šäº†å®¹é‡ä¸Šé™ `with_capacity(size)`ï¼Œè¯¥æ–¹æ³•è¿˜å¯ä»¥æå‰åˆ†é…å¥½å†…å­˜ç©ºé—´ï¼Œæ¯” `Vec::new` çš„æ€§èƒ½è¦æ›´å¥½ä¸€ç‚¹ã€‚

### å°†ä»£ç ä» ThreadPool å‘é€åˆ°çº¿ç¨‹ä¸­

ä¸Šé¢çš„ä»£ç ç•™ä¸‹ä¸€ä¸ªæœªå®ç°çš„ `for` å¾ªç¯ï¼Œç”¨äºåˆ›å»ºå’Œå­˜å‚¨çº¿ç¨‹ã€‚

å­¦è¿‡å¤šçº¿ç¨‹ä¸€ç« åï¼Œå¤§å®¶åº”è¯¥çŸ¥é“ `thread::spawn` è™½ç„¶æ˜¯ç”Ÿæˆçº¿ç¨‹æœ€å¥½çš„æ–¹å¼ï¼Œä½†æ˜¯å®ƒä¼šç«‹å³æ‰§è¡Œä¼ å…¥çš„ä»»åŠ¡ï¼Œç„¶è€Œï¼Œåœ¨æˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯ä¸­ï¼Œåˆ›å»ºçº¿ç¨‹å’Œæ‰§è¡Œä»»åŠ¡æ˜æ˜¾æ˜¯è¦åˆ†ç¦»çš„ï¼Œå› æ­¤æ ‡å‡†åº“çœ‹èµ·æ¥ä¸å†é€‚åˆã€‚

å¯ä»¥è€ƒè™‘åˆ›å»ºä¸€ä¸ª `Worker` ç»“æ„ä½“ï¼Œä½œä¸º `ThreadPool` å’Œä»»åŠ¡çº¿ç¨‹è”ç³»çš„æ¡¥æ¢ï¼Œå®ƒçš„ä»»åŠ¡æ˜¯è·å¾—å°†è¦æ‰§è¡Œçš„ä»£ç ï¼Œç„¶ååœ¨å…·ä½“çš„çº¿ç¨‹ä¸­å»æ‰§è¡Œã€‚æƒ³è±¡ä¸€ä¸ªåœºæ™¯ï¼šä¸€ä¸ªé¤é¦†ï¼Œ`Worker` ç­‰å¾…é¡¾å®¢çš„ç‚¹é¤ï¼Œç„¶åå°†å…·ä½“çš„ç‚¹é¤ä¿¡æ¯ä¼ é€’ç»™å¨æˆ¿ï¼Œæ„Ÿè§‰ç±»ä¼¼æœåŠ¡å‘˜ï¼Ÿ

å¼•å…¥ `Worker` åï¼Œå°±æ— éœ€å†å­˜å‚¨ `JoinHandle<()>` å®ä¾‹ï¼Œç›´æ¥å­˜å‚¨ `Worker` å®ä¾‹ï¼šè¯¥å®ä¾‹å†…éƒ¨ä¼šå­˜å‚¨ `JoinHandle<()>`ã€‚ä¸‹é¢æ˜¯æ–°çš„çº¿ç¨‹æ± åˆ›å»ºæµç¨‹:

```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        // å°šæœªå®ç°..
        let thread = thread::spawn(|| {});
        // æ¯ä¸ª `Worker` éƒ½æ‹¥æœ‰è‡ªå·±çš„å”¯ä¸€ id
        Worker { id, thread }
    }
}
```

ç”±äºå¤–éƒ¨è°ƒç”¨è€…æ— éœ€çŸ¥é“ `Worker` çš„å­˜åœ¨ï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨äº†ç§æœ‰çš„å£°æ˜ã€‚

å¤§å®¶å¯ä»¥ç¼–è¯‘ä¸‹ä»£ç ï¼Œå¦‚æœå‡ºé”™äº†ï¼Œè¯·ä»”ç»†æ£€æŸ¥ä¸‹ï¼Œæ˜¯å¦é—æ¼äº†ä»€ä¹ˆï¼Œæˆªæ­¢ç›®å‰ï¼Œä»£ç æ˜¯å®Œå…¨å¯ä»¥é€šè¿‡ç¼–è¯‘çš„ï¼Œä½†æ˜¯ä»»åŠ¡è¯¥æ€ä¹ˆæ‰§è¡Œä¾ç„¶è¿˜æ²¡æœ‰å®ç°ã€‚

### å°†è¯·æ±‚å‘é€ç»™çº¿ç¨‹

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œ `thread::spawn(|| {})` è¿˜æ²¡æœ‰ç»™äºˆå®è´¨æ€§çš„å†…å®¹ï¼Œç°åœ¨ä¸€èµ·æ¥å®Œå–„ä¸‹ã€‚

é¦–å…ˆ `Worker` ç»“æ„ä½“éœ€è¦ä»çº¿ç¨‹æ±  `ThreadPool` çš„é˜Ÿåˆ—ä¸­è·å–å¾…æ‰§è¡Œçš„ä»£ç ï¼Œå¯¹äºè¿™ç±»åœºæ™¯ï¼Œæ¶ˆæ¯ä¼ é€’éå¸¸é€‚åˆï¼šæˆ‘ä»¬å°†ä½¿ç”¨æ¶ˆæ¯é€šé“( channel )ä½œä¸ºä»»åŠ¡é˜Ÿåˆ—ã€‚

```rust
use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}
```

é˜…è¯»è¿‡ä¹‹å‰å†…å®¹çš„åŒå­¦åº”è¯¥çŸ¥é“ï¼Œæ¶ˆæ¯é€šé“æœ‰å‘é€ç«¯å’Œæ¥æ”¶ç«¯ï¼Œå…¶ä¸­çº¿ç¨‹æ±  `ThreadPool` æŒæœ‰å‘é€ç«¯ï¼Œé€šè¿‡ `execute` æ–¹æ³•æ¥å‘é€ä»»åŠ¡ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè°æŒæœ‰æ¥æ”¶ç«¯å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ `Worker`ï¼Œå®ƒçš„å†…éƒ¨çº¿ç¨‹å°†æ¥æ”¶ä»»åŠ¡ï¼Œç„¶åè¿›è¡Œå¤„ç†ã€‚

```rust
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```

çœ‹èµ·æ¥å¾ˆç¾å¥½ï¼Œä½†æ˜¯å¾ˆä¸å¹¸ï¼Œå®ƒä¼šæŠ¥é”™: 

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --> src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
```

åŸå› ä¹Ÿå¾ˆç®€å•ï¼Œ`receiver` å¹¶æ²¡æœ‰å®ç° `Copy`ï¼Œå› æ­¤å®ƒçš„æ‰€æœ‰æƒåœ¨ç¬¬ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œå°±è¢«ä¼ å…¥åˆ°ç¬¬ä¸€ä¸ª `Worker` å®ä¾‹ä¸­ï¼Œåç»­è‡ªç„¶æ— æ³•å†ä½¿ç”¨ã€‚

æŠ¥é”™å°±è§£å†³å‘—ï¼Œä½† Rust ä¸­çš„ channel å®ç°æ˜¯ mpscï¼Œå³å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•é€šè¿‡å…‹éš†æ¶ˆè´¹è€…çš„æ–¹å¼æ¥ä¿®å¤è¿™ä¸ªé”™è¯¯ã€‚å½“ç„¶ï¼Œå‘é€å¤šæ¡æ¶ˆæ¯ç»™å¤šä¸ªæ¥æ”¶è€…ä¹Ÿä¸åœ¨è€ƒè™‘èŒƒç•´ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿä¼¼ä¹é™·å…¥äº†ç»å¢ƒã€‚

é›ªä¸ŠåŠ éœœçš„æ˜¯ï¼Œå°±ç®— `receiver` å¯ä»¥å…‹éš†ï¼Œä½†æ˜¯ä½ å¾—ä¿è¯åŒä¸€ä¸ªæ—¶é—´åªæœ‰ä¸€ä¸ª`receiver` èƒ½æ¥æ”¶æ¶ˆæ¯ï¼Œå¦åˆ™ä¸€ä¸ªä»»åŠ¡å¯èƒ½åŒæ—¶è¢«å¤šä¸ª `Worker` æ‰§è¡Œï¼Œå› æ­¤å¤šä¸ªçº¿ç¨‹éœ€è¦å®‰å…¨çš„å…±äº«å’Œä½¿ç”¨ `receiver`ï¼Œç­‰ç­‰ï¼Œå®‰å…¨çš„å…±äº«ï¼Ÿå¬ä¸Šå» `Arc` è¿™ä¸ªå¤šæ‰€æœ‰æƒç»“æ„éå¸¸é€‚åˆï¼Œäº’æ–¥ä½¿ç”¨ï¼Ÿè²Œä¼¼ `Mutex` å¾ˆé€‚åˆï¼Œç»“åˆä¸€ä¸‹ï¼Œ`Arc<Mutex<T>>`ï¼Œè¿™ä¸å°±æ˜¯æˆ‘ä»¬ä¹‹å‰è§è¿‡å¤šæ¬¡çš„çº¿ç¨‹å®‰å…¨ç±»å‹å—ï¼Ÿ

æ€»ä¹‹ï¼Œ`Arc` å…è®¸å¤šä¸ª `Worker` åŒæ—¶æŒæœ‰ `receiver`ï¼Œè€Œ `Mutex` å¯ä»¥ç¡®ä¿ä¸€æ¬¡åªæœ‰ä¸€ä¸ª `Worker` èƒ½ä» `receiver` æ¥æ”¶æ¶ˆæ¯ã€‚

```rust
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
    }
}
```

ä¿®æ”¹åï¼Œæ¯ä¸€ä¸ª Worker éƒ½å¯ä»¥å®‰å…¨çš„æŒæœ‰ `receiver`ï¼ŒåŒæ—¶ä¸å¿…æ‹…å¿ƒä¸€ä¸ªä»»åŠ¡ä¼šè¢«é‡å¤æ‰§è¡Œå¤šæ¬¡ï¼Œå®Œç¾ï¼


### å®ç° execute æ–¹æ³•

é¦–å…ˆï¼Œéœ€è¦ä¸ºä¸€ä¸ªå¾ˆé•¿çš„ç±»å‹åˆ›å»ºä¸€ä¸ªåˆ«å, æœ‰å¤šé•¿å‘¢ï¼Ÿ 

```rust
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
```

åˆ›å»ºåˆ«åçš„å¨åŠ›æš‚æ—¶è¿˜çœ‹ä¸åˆ°ï¼Œæ•¬è¯·æœŸå¾…ã€‚æ€»ä¹‹ï¼Œè¿™é‡Œçš„å·¥ä½œå¾ˆç®€å•ï¼Œå°†ä¼ å…¥çš„ä»»åŠ¡åŒ…è£…æˆ `Job` ç±»å‹åï¼Œå‘é€å‡ºå»ã€‚

ä½†æ˜¯è¿˜æ²¡å®Œï¼Œæ¥æ”¶çš„ä»£ç ä¹Ÿè¦å®Œå–„ä¸‹:

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}
```

ä¿®æ”¹åï¼Œå°±å¯ä»¥ä¸åœåœ°å¾ªç¯å»æ¥æ”¶ä»»åŠ¡ï¼Œæœ€åè¿›è¡Œæ‰§è¡Œã€‚è¿˜å¯ä»¥çœ‹åˆ°å› ä¸ºä¹‹å‰ `Job` åˆ«åçš„å¼•å…¥ï¼Œ `new` å‡½æ•°çš„ç­¾åæ‰æ²¡æœ‰è¿‡åº¦å¤æ‚ï¼Œå¦åˆ™ä½ å°†çœ‹åˆ°çš„æ˜¯ `fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Box<dyn FnOnce() + Send + 'static>>>>) -> Worker` ï¼Œæ„Ÿå—ä¸‹ç±»å‹åˆ«åçš„å¨åŠ›å§ :D

`lock()` æ–¹æ³•å¯ä»¥è·å¾—ä¸€ä¸ª `Mutex` é”ï¼Œè‡³äºä¸ºä½•ä½¿ç”¨ `unwrap`ï¼Œéš¾é“è·å–é”è¿˜èƒ½å¤±è´¥ï¼Ÿæ²¡é”™ï¼Œå‡å¦‚å½“å‰æŒæœ‰é”çš„çº¿ç¨‹ `panic` äº†ï¼Œé‚£ä¹ˆè¿™äº›ç­‰å¾…é”çš„çº¿ç¨‹å°±ä¼šè·å–ä¸€ä¸ªé”™è¯¯ï¼Œå› æ­¤ é€šè¿‡ `unwrap` æ¥è®©å½“å‰ç­‰å¾…çš„çº¿ç¨‹ `panic` æ˜¯ä¸€ä¸ªä¸é”™çš„è§£å†³æ–¹æ¡ˆï¼Œå½“ç„¶ä½ è¿˜å¯ä»¥æ¢æˆ `expect`ã€‚

ä¸€æ—¦è·å–åˆ°é”é‡Œçš„å†…å®¹ `mpsc::Receiver<Job>>` åï¼Œå°±å¯ä»¥è°ƒç”¨å…¶ä¸Šçš„ `recv` æ–¹æ³•æ¥æ¥æ”¶æ¶ˆæ¯ï¼Œä¾ç„¶æ˜¯ä¸€ä¸ª `unwrap`ï¼ŒåŸå› åœ¨äºæŒæœ‰å‘é€ç«¯çš„çº¿ç¨‹å¯èƒ½ä¼šè¢«å…³é—­ï¼Œè¿™ç§æƒ…å†µä¸‹ç›´æ¥ `panic` ä¹Ÿæ˜¯ä¸é”™çš„ã€‚

`recv` çš„è°ƒç”¨è¿‡ç¨‹æ˜¯é˜»å¡çš„ï¼Œæ„å‘³ç€è‹¥æ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œé‚£å½“å‰çš„è°ƒç”¨çº¿ç¨‹å°†ä¸€ç›´ç­‰å¾…ï¼Œç›´åˆ°æ¥æ”¶åˆ°æ–°çš„ä»»åŠ¡ã€‚`Mutex<T>` å¯ä»¥ä¿è¯åŒä¸€ä¸ªä»»åŠ¡åªä¼šè¢«ä¸€ä¸ª Worker è·å–ï¼Œä¸ä¼šè¢«é‡å¤æ‰§è¡Œã€‚

```shell
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --> src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --> src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --> src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```

ç»ˆäºï¼Œç¨‹åºå¦‚æ„¿è¿è¡Œèµ·æ¥ï¼Œæˆ‘ä»¬çš„çº¿ç¨‹æ± å¯ä»¥å¹¶å‘å¤„ç†ä»»åŠ¡äº†ï¼ä»æ‰“å°çš„æ•°å­—å¯ä»¥çœ‹åˆ°ï¼Œåªæœ‰ 4 ä¸ªçº¿ç¨‹å»æ‰§è¡Œä»»åŠ¡ï¼Œç¬¦åˆæˆ‘ä»¬å¯¹çº¿ç¨‹æ± çš„è¦æ±‚ï¼Œè¿™æ ·å†ä¹Ÿä¸ç”¨æ‹…å¿ƒç³»ç»Ÿçš„çº¿ç¨‹èµ„æºä¼šè¢«æ¶ˆè€—æ®†å°½äº†ï¼


> æ³¨æ„ï¼š å‡ºäºç¼“å­˜çš„è€ƒè™‘ï¼Œæœ‰äº›æµè§ˆå™¨ä¼šå¯¹å¤šæ¬¡åŒæ ·çš„è¯·æ±‚è¿›è¡Œé¡ºåºçš„æ‰§è¡Œï¼Œå› æ­¤ä½ å¯èƒ½è¿˜æ˜¯ä¼šé‡åˆ°è®¿é—® `/sleep` åï¼Œå°±æ— æ³•è®¿é—®å¦ä¸€ä¸ª `/sleep` çš„é—®é¢˜ :(


## while let çš„å·¨å¤§é™·é˜±

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œä¸ºå•¥ä¹‹å‰æˆ‘ä»¬ä¸ç”¨ `while let` æ¥å¾ªç¯ï¼Ÿä¾‹å¦‚ï¼š

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

è¿™æ®µä»£ç ç¼–è¯‘èµ·æ¥æ²¡é—®é¢˜ï¼Œä½†æ˜¯å¹¶ä¸ä¼šäº§ç”Ÿæˆ‘ä»¬é¢„æœŸçš„ç»“æœï¼šåç»­è¯·æ±‚ä¾ç„¶éœ€è¦ç­‰å¾…æ…¢è¯·æ±‚çš„å¤„ç†å®Œæˆåï¼Œæ‰èƒ½è¢«å¤„ç†ã€‚å¥‡æ€ªå§ï¼Œä»…ä»…æ˜¯ä» `let` æ”¹æˆ `while let` å°±ä¼šå˜æˆè¿™æ ·ï¼Ÿå¤§å®¶å¯ä»¥æ€è€ƒä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Œå…·ä½“ç­”æ¡ˆä¼šåœ¨ä¸‹ä¸€ç« èŠ‚æœ«å°¾ç»™å‡ºï¼Œè¿™é‡Œå…ˆå‡ºç»™ä¸€ä¸ªå°æç¤ºï¼š`Mutex` è·å–çš„é”åœ¨ä½œç”¨åŸŸç»“æŸåæ‰ä¼šè¢«é‡Šæ”¾ã€‚















================================================
FILE: src/advance-practice1/web-server.md
================================================
[Binary file]


================================================
FILE: src/appendix/derive.md
================================================
## é™„å½• Dï¼šæ´¾ç”Ÿç‰¹å¾ trait

åœ¨æœ¬ä¹¦çš„å„ä¸ªéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¯åº”ç”¨äºç»“æ„ä½“å’Œæšä¸¾å®šä¹‰çš„ `derive` å±æ€§ã€‚è¢« `derive` æ ‡è®°çš„å¯¹è±¡ä¼šè‡ªåŠ¨å®ç°å¯¹åº”çš„é»˜è®¤ç‰¹å¾ä»£ç ï¼Œç»§æ‰¿ç›¸åº”çš„åŠŸèƒ½ã€‚

åœ¨æœ¬é™„å½•ä¸­,æˆ‘ä»¬åˆ—ä¸¾äº†æ‰€æœ‰æ ‡å‡†åº“å­˜åœ¨çš„ `derive` ç‰¹å¾ï¼Œæ¯ä¸ªç‰¹å¾è¦†ç›–äº†ä»¥ä¸‹å†…å®¹

- è¯¥ç‰¹å¾å°†ä¼šæ´¾ç”Ÿä»€ä¹ˆæ ·çš„æ“ä½œç¬¦å’Œæ–¹æ³•
- ç”± `derive` æä¾›ä»€ä¹ˆæ ·çš„ç‰¹å¾å®ç°
- å®ç°ç‰¹å¾å¯¹äºç±»å‹æ„å‘³ç€ä»€ä¹ˆ
- ä½ éœ€è¦ä»€ä¹ˆæ¡ä»¶æ¥å®ç°è¯¥ç‰¹å¾
- ç‰¹å¾ç¤ºä¾‹

å¦‚æœä½ å¸Œæœ›ä¸åŒäº `derive` å±æ€§æ‰€æä¾›çš„è¡Œä¸ºï¼Œè¯·æŸ¥é˜… [æ ‡å‡†åº“æ–‡æ¡£](https://doc.rust-lang.org/std/index.html) ä¸­æ¯ä¸ªç‰¹å¾çš„ç»†èŠ‚ä»¥äº†è§£å¦‚ä½•æ‰‹åŠ¨å®ç°å®ƒä»¬ã€‚

é™¤äº†æœ¬æ–‡åˆ—å‡ºçš„ç‰¹å¾ä¹‹å¤–ï¼Œæ ‡å‡†åº“ä¸­å®šä¹‰çš„å…¶å®ƒç‰¹å¾ä¸èƒ½é€šè¿‡ `derive` åœ¨ç±»å‹ä¸Šå®ç°ã€‚è¿™äº›ç‰¹å¾ä¸å­˜åœ¨æœ‰æ„ä¹‰çš„é»˜è®¤è¡Œä¸ºï¼Œæ‰€ä»¥ç”±ä½ è´Ÿè´£ä»¥åˆç†çš„æ–¹å¼å®ç°å®ƒä»¬ã€‚

ä¸€ä¸ªæ— æ³•è¢«æ´¾ç”Ÿçš„ç‰¹å¾ä¾‹å­æ˜¯ä¸ºç»ˆç«¯ç”¨æˆ·å¤„ç†æ ¼å¼åŒ–çš„ `Display` ã€‚ä½ åº”è¯¥æ—¶å¸¸è€ƒè™‘ä½¿ç”¨åˆé€‚çš„æ–¹æ³•æ¥ä¸ºç»ˆç«¯ç”¨æˆ·æ˜¾ç¤ºä¸€ä¸ªç±»å‹ã€‚ç»ˆç«¯ç”¨æˆ·åº”è¯¥çœ‹åˆ°ç±»å‹çš„ä»€ä¹ˆéƒ¨åˆ†ï¼Ÿä»–ä»¬ä¼šæ‰¾å‡ºç›¸å…³éƒ¨åˆ†å—ï¼Ÿå¯¹ä»–ä»¬æ¥è¯´æœ€å…³å¿ƒçš„æ•°æ®æ ¼å¼æ˜¯ä»€ä¹ˆæ ·çš„ï¼ŸRust ç¼–è¯‘å™¨æ²¡æœ‰è¿™æ ·çš„æ´å¯ŸåŠ›ï¼Œå› æ­¤æ— æ³•ä¸ºä½ æä¾›åˆé€‚çš„é»˜è®¤è¡Œä¸ºã€‚

æœ¬é™„å½•æ‰€æä¾›çš„å¯æ´¾ç”Ÿç‰¹å¾åˆ—è¡¨å…¶å®å¹¶ä¸å…¨é¢ï¼šåº“å¯ä»¥ä¸ºå…¶å†…éƒ¨çš„ç‰¹å¾å®ç° `derive` ï¼Œå› æ­¤é™¤äº†æœ¬æ–‡åˆ—å‡ºçš„æ ‡å‡†åº“ `derive` ä¹‹å¤–ï¼Œè¿˜æœ‰å¾ˆå¤šå¾ˆå¤šå…¶å®ƒåº“çš„ `derive` ã€‚å®ç° `derive` æ¶‰åŠåˆ°è¿‡ç¨‹å®çš„åº”ç”¨ï¼Œè¿™åœ¨[å®ç« èŠ‚](https://course.rs/advance/macro.html)ä¸­æœ‰ä»‹ç»ã€‚

### ç”¨äºå¼€å‘è€…è¾“å‡ºçš„ `Debug`

`Debug` ç‰¹å¾å¯ä»¥è®©æŒ‡å®šå¯¹è±¡è¾“å‡ºè°ƒè¯•æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œé€šè¿‡åœ¨ `{}` å ä½ç¬¦ä¸­å¢åŠ  `:?` è¡¨æ˜ï¼Œä¾‹å¦‚`println!("show you some debug info: {:?}", MyObject);`.

`Debug` ç‰¹å¾å…è®¸ä»¥è°ƒè¯•ä¸ºç›®çš„æ¥æ‰“å°ä¸€ä¸ªç±»å‹çš„å®ä¾‹ï¼Œæ‰€ä»¥ç¨‹åºå‘˜å¯ä»¥åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­çœ‹åˆ°è¯¥å®ä¾‹çš„å…·ä½“ä¿¡æ¯ã€‚

ä¾‹å¦‚ï¼Œåœ¨ä½¿ç”¨ `assert_eq!` å®æ—¶ï¼Œ `Debug` ç‰¹å¾æ˜¯å¿…é¡»çš„ã€‚å¦‚æœæ–­è¨€å¤±è´¥ï¼Œè¿™ä¸ªå®å°±æŠŠç»™å®šå®ä¾‹çš„å€¼æ‰“å°å‡ºæ¥ï¼Œè¿™æ ·ç¨‹åºå‘˜å°±èƒ½çœ‹åˆ°ä¸¤ä¸ªå®ä¾‹ä¸ºä»€ä¹ˆä¸ç›¸ç­‰ã€‚

### ç­‰å€¼æ¯”è¾ƒçš„ `PartialEq` å’Œ `Eq`

`PartialEq` ç‰¹å¾å¯ä»¥æ¯”è¾ƒä¸€ä¸ªç±»å‹çš„å®ä¾‹ä»¥æ£€æŸ¥æ˜¯å¦ç›¸ç­‰ï¼Œå¹¶å¼€å¯äº† `==` å’Œ `!=` è¿ç®—ç¬¦çš„åŠŸèƒ½ã€‚

æ´¾ç”Ÿçš„ `PartialEq` å®ç°äº† `eq` æ–¹æ³•ã€‚å½“ `PartialEq` åœ¨ç»“æ„ä½“ä¸Šæ´¾ç”Ÿæ—¶ï¼Œåªæœ‰*æ‰€æœ‰* çš„å­—æ®µéƒ½ç›¸ç­‰æ—¶ä¸¤ä¸ªå®ä¾‹æ‰ç›¸ç­‰ï¼ŒåŒæ—¶åªè¦æœ‰ä»»ä½•å­—æ®µä¸ç›¸ç­‰åˆ™ä¸¤ä¸ªå®ä¾‹å°±ä¸ç›¸ç­‰ã€‚å½“åœ¨æšä¸¾ä¸Šæ´¾ç”Ÿæ—¶ï¼Œæ¯ä¸€ä¸ªæˆå‘˜éƒ½å’Œå…¶è‡ªèº«ç›¸ç­‰ï¼Œä¸”å’Œå…¶ä»–æˆå‘˜éƒ½ä¸ç›¸ç­‰ã€‚

ä¾‹å¦‚ï¼Œå½“ä½¿ç”¨ `assert_eq!` å®æ—¶ï¼Œéœ€è¦æ¯”è¾ƒä¸€ä¸ªç±»å‹çš„ä¸¤ä¸ªå®ä¾‹æ˜¯å¦ç›¸ç­‰ï¼Œåˆ™ `PartialEq` ç‰¹å¾æ˜¯å¿…é¡»çš„ã€‚

`Eq` ç‰¹å¾æ²¡æœ‰æ–¹æ³•, å…¶ä½œç”¨æ˜¯è¡¨æ˜æ¯ä¸€ä¸ªè¢«æ ‡è®°ç±»å‹çš„å€¼éƒ½ç­‰äºå…¶è‡ªèº«ã€‚ `Eq` ç‰¹å¾åªèƒ½åº”ç”¨äºé‚£äº›å®ç°äº† `PartialEq` çš„ç±»å‹ï¼Œä½†å¹¶éæ‰€æœ‰å®ç°äº† `PartialEq` çš„ç±»å‹éƒ½å¯ä»¥å®ç° `Eq`ã€‚æµ®ç‚¹ç±»å‹å°±æ˜¯ä¸€ä¸ªä¾‹å­ï¼šæµ®ç‚¹æ•°çš„å®ç°è¡¨æ˜ä¸¤ä¸ªéæ•°å­—ï¼ˆ `NaN` ï¼Œnot-a-numberï¼‰å€¼æ˜¯äº’ä¸ç›¸ç­‰çš„ã€‚

ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ª `HashMap<K, V>` ä¸­çš„ key æ¥è¯´ï¼Œ `Eq` æ˜¯å¿…é¡»çš„ï¼Œè¿™æ · `HashMap<K, V>` å°±å¯ä»¥çŸ¥é“ä¸¤ä¸ª key æ˜¯å¦ä¸€æ ·ã€‚

### æ¬¡åºæ¯”è¾ƒçš„ `PartialOrd` å’Œ `Ord`

`PartialOrd` ç‰¹å¾å¯ä»¥è®©ä¸€ä¸ªç±»å‹çš„å¤šä¸ªå®ä¾‹å®ç°æ’åºåŠŸèƒ½ã€‚å®ç°äº† `PartialOrd` çš„ç±»å‹å¯ä»¥ä½¿ç”¨ `<`ã€ `>`ã€`<=` å’Œ `>=` æ“ä½œç¬¦ã€‚ä¸€ä¸ªç±»å‹æƒ³è¦å®ç° `PartialOrd` çš„å‰ææ˜¯è¯¥ç±»å‹å·²ç»å®ç°äº† `PartialEq` ã€‚

æ´¾ç”Ÿ `PartialOrd` å®ç°äº† `partial_cmp` æ–¹æ³•ï¼Œä¸€èˆ¬æƒ…å†µä¸‹å…¶è¿”å›ä¸€ä¸ª `Option<Ordering>`ï¼Œä½†æ˜¯å½“ç»™å®šçš„å€¼æ— æ³•è¿›è¡Œæ’åºæ—¶å°†è¿”å› `None`ã€‚å°½ç®¡å¤§å¤šæ•°ç±»å‹çš„å€¼éƒ½å¯ä»¥æ¯”è¾ƒï¼Œä½†ä¸€ä¸ªæ— æ³•äº§ç”Ÿé¡ºåºçš„ä¾‹å­æ˜¯ï¼šæµ®ç‚¹ç±»å‹çš„éæ•°å­—å€¼ã€‚å½“åœ¨æµ®ç‚¹æ•°ä¸Šè°ƒç”¨ `partial_cmp` æ—¶ï¼Œ `NaN` çš„æµ®ç‚¹æ•°å°†è¿”å› `None`ã€‚

å½“åœ¨ç»“æ„ä½“ä¸Šæ´¾ç”Ÿæ—¶ï¼Œ `PartialOrd` ä»¥åœ¨ç»“æ„ä½“å®šä¹‰ä¸­å­—æ®µå‡ºç°çš„é¡ºåºæ¯”è¾ƒæ¯ä¸ªå­—æ®µçš„å€¼æ¥æ¯”è¾ƒä¸¤ä¸ªå®ä¾‹ã€‚å½“åœ¨æšä¸¾ä¸Šæ´¾ç”Ÿæ—¶ï¼Œè®¤ä¸ºåœ¨æšä¸¾å®šä¹‰ä¸­å£°æ˜è¾ƒæ—©çš„æšä¸¾é¡¹å°äºå…¶åçš„æšä¸¾é¡¹ã€‚

ä¾‹å¦‚ï¼Œå¯¹äºæ¥è‡ªäº `rand` åŒ…çš„ `gen_range` æ–¹æ³•æ¥è¯´ï¼Œå½“åœ¨ä¸€ä¸ªå¤§å€¼å’Œå°å€¼æŒ‡å®šçš„èŒƒå›´å†…ç”Ÿæˆä¸€ä¸ªéšæœºå€¼æ—¶ï¼Œ `PartialOrd` trait æ˜¯å¿…é¡»çš„ã€‚

å¯¹äºæ´¾ç”Ÿäº† `Ord` ç‰¹å¾çš„ç±»å‹ï¼Œä»»ä½•ä¸¤ä¸ªè¯¥ç±»å‹çš„å€¼éƒ½èƒ½è¿›è¡Œæ’åºã€‚ `Ord` ç‰¹å¾å®ç°äº† `cmp` æ–¹æ³•ï¼Œå®ƒè¿”å›ä¸€ä¸ª `Ordering` è€Œä¸æ˜¯ `Option<Ordering>`ï¼Œå› ä¸ºæ€»å­˜åœ¨ä¸€ä¸ªåˆæ³•çš„é¡ºåºã€‚ä¸€ä¸ªç±»å‹è¦æƒ³ä½¿ç”¨ `Ord` ç‰¹å¾ï¼Œå®ƒå¿…é¡»è¦å…ˆå®ç° `PartialOrd` å’Œ `Eq` ã€‚å½“åœ¨ç»“æ„ä½“æˆ–æšä¸¾ä¸Šæ´¾ç”Ÿæ—¶ï¼Œ `cmp` æ–¹æ³• å’Œ `PartialOrd` çš„ `partial_cmp` æ–¹æ³•è¡¨ç°æ˜¯ä¸€è‡´çš„ã€‚

ä¾‹å¦‚ï¼Œå½“åœ¨ `BTreeSet<T>`ï¼ˆä¸€ç§åŸºäºæœ‰åºå€¼å­˜å‚¨æ•°æ®çš„æ•°æ®ç»“æ„ï¼‰ä¸Šå­˜å€¼æ—¶ï¼Œ `Ord` æ˜¯å¿…é¡»çš„ã€‚

### å¤åˆ¶å€¼çš„ `Clone` å’Œ `Copy`

`Clone` ç‰¹å¾ç”¨äºåˆ›å»ºä¸€ä¸ªå€¼çš„æ·±æ‹·è´ï¼ˆdeep copyï¼‰ï¼Œå¤åˆ¶è¿‡ç¨‹å¯èƒ½åŒ…å«ä»£ç çš„æ‰§è¡Œä»¥åŠå †ä¸Šæ•°æ®çš„å¤åˆ¶ã€‚æŸ¥é˜… [é€šè¿‡ Clone è¿›è¡Œæ·±æ‹·è´](https://course.rs/basic/ownership/ownership.html#å…‹éš†æ·±æ‹·è´)è·å–æœ‰å…³ `Clone` çš„æ›´å¤šä¿¡æ¯ã€‚

æ´¾ç”Ÿ `Clone` å®ç°äº† `clone` æ–¹æ³•ï¼Œå½“ä¸ºæ•´ä¸ªçš„ç±»å‹å®ç° `Clone` æ—¶ï¼Œåœ¨è¯¥ç±»å‹çš„æ¯ä¸€éƒ¨åˆ†ä¸Šéƒ½ä¼šè°ƒç”¨ `clone` æ–¹æ³•ã€‚è¿™æ„å‘³ç€ç±»å‹ä¸­æ‰€æœ‰å­—æ®µæˆ–å€¼ä¹Ÿå¿…é¡»å®ç°äº† `Clone`ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿæ´¾ç”Ÿ `Clone` ã€‚

ä¾‹å¦‚ï¼Œå½“åœ¨ä¸€ä¸ªåˆ‡ç‰‡ï¼ˆsliceï¼‰ä¸Šè°ƒç”¨ `to_vec` æ–¹æ³•æ—¶ï¼Œ `Clone` æ˜¯å¿…é¡»çš„ã€‚åˆ‡ç‰‡åªæ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œå¹¶ä¸æ‹¥æœ‰å…¶æ‰€åŒ…å«çš„å®ä¾‹æ•°æ®ï¼Œä½†æ˜¯ä» `to_vec` ä¸­è¿”å›çš„ Vector éœ€è¦æ‹¥æœ‰å®ä¾‹æ•°æ®ï¼Œå› æ­¤ï¼Œ `to_vec` éœ€è¦åœ¨æ¯ä¸ªå…ƒç´ ä¸Šè°ƒç”¨ `clone` æ¥é€ä¸ªå¤åˆ¶ã€‚å› æ­¤ï¼Œå­˜å‚¨åœ¨åˆ‡ç‰‡ä¸­çš„ç±»å‹å¿…é¡»å®ç° `Clone`ã€‚

`Copy` ç‰¹å¾å…è®¸ä½ é€šè¿‡åªæ‹·è´å­˜å‚¨åœ¨æ ˆä¸Šçš„æ•°æ®æ¥å¤åˆ¶å€¼(æµ…æ‹·è´),è€Œæ— éœ€å¤åˆ¶å­˜å‚¨åœ¨å †ä¸Šçš„åº•å±‚æ•°æ®ã€‚æŸ¥é˜… [é€šè¿‡ Copy å¤åˆ¶æ ˆæ•°æ®](https://course.rs/basic/ownership/ownership.html#æ‹·è´æµ…æ‹·è´) çš„éƒ¨åˆ†æ¥è·å–æœ‰å…³ `Copy` çš„æ›´å¤šä¿¡æ¯ã€‚

å®é™…ä¸Š `Copy` ç‰¹å¾å¹¶ä¸é˜»æ­¢ä½ åœ¨å®ç°æ—¶ä½¿ç”¨äº†æ·±æ‹·è´ï¼Œåªæ˜¯ï¼Œæˆ‘ä»¬ä¸åº”è¯¥è¿™ä¹ˆåšï¼Œæ¯•ç«Ÿéµå¾ªä¸€ä¸ªè¯­è¨€çš„æƒ¯ä¾‹æ˜¯å¾ˆé‡è¦çš„ã€‚å½“ç”¨æˆ·çœ‹åˆ° `Copy` æ—¶ï¼Œæ½œæ„è¯†å°±åº”è¯¥çŸ¥é“è¿™æ˜¯æµ…æ‹·è´ï¼Œå¤åˆ¶ä¸€ä¸ªå€¼ä¼šéå¸¸å¿«ã€‚

å½“ä¸€ä¸ªç±»å‹çš„å†…éƒ¨å­—æ®µå…¨éƒ¨å®ç°äº† `Copy` æ—¶ï¼Œä½ å°±å¯ä»¥åœ¨è¯¥ç±»å‹ä¸Šæ´¾ä¸Š `Copy` ç‰¹å¾ã€‚ ä¸€ä¸ªç±»å‹å¦‚æœè¦å®ç° `Copy` å®ƒå¿…é¡»å…ˆå®ç° `Clone` ï¼Œå› ä¸ºä¸€ä¸ªç±»å‹å®ç° `Clone` åï¼Œå°±ç­‰äºé¡ºä¾¿å®ç°äº† `Copy` ã€‚

æ€»ä¹‹ï¼Œ `Copy` æ‹¥æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå½“æµ…æ‹·è´è¶³å¤Ÿçš„æ—¶å€™ï¼Œå°±ä¸è¦ä½¿ç”¨ `Clone` ï¼Œä¸ç„¶ä¼šå¯¼è‡´ä½ çš„ä»£ç è¿è¡Œæ›´æ…¢ï¼Œå¯¹äº[æ€§èƒ½ä¼˜åŒ–](https://course.rs/profiling/performance/intro.html)æ¥è¯´ï¼Œä¸€ä¸ªå¾ˆå¤§çš„æ–¹é¢å°±æ˜¯å‡å°‘çƒ­ç‚¹è·¯å¾„æ·±æ‹·è´çš„å‘ç”Ÿã€‚

### å›ºå®šå¤§å°çš„å€¼æ˜ å°„çš„ `Hash`

`Hash` ç‰¹å¾å…è®¸ä½ ä½¿ç”¨ `hash` å‡½æ•°æŠŠä¸€ä¸ªä»»æ„å¤§å°çš„å®ä¾‹æ˜ å°„åˆ°ä¸€ä¸ªå›ºå®šå¤§å°çš„å€¼ä¸Šã€‚æ´¾ç”Ÿ `Hash` å®ç°äº† `hash` æ–¹æ³•ï¼Œå¯¹æŸä¸ªç±»å‹è¿›è¡Œ `hash` è°ƒç”¨ï¼Œå…¶å®å°±æ˜¯å¯¹è¯¥ç±»å‹ä¸‹æ¯ä¸ªå­—æ®µå•ç‹¬è¿›è¡Œ `hash` è°ƒç”¨ï¼Œç„¶åæŠŠç»“æœè¿›è¡Œæ±‡æ€»ï¼Œè¿™æ„å‘³ç€è¯¥ç±»å‹ä¸‹çš„æ‰€æœ‰çš„å­—æ®µä¹Ÿå¿…é¡»å®ç°äº† `Hash`ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿæ´¾ç”Ÿ `Hash`ã€‚

ä¾‹å¦‚ï¼Œåœ¨ `HashMap<K, V>` ä¸Šå­˜å‚¨æ•°æ®ï¼Œå­˜æ”¾ key çš„æ—¶å€™ï¼Œ `Hash` æ˜¯å¿…é¡»çš„ã€‚

### é»˜è®¤å€¼çš„ `Default`

`Default` ç‰¹å¾ä¼šå¸®ä½ åˆ›å»ºä¸€ä¸ªç±»å‹çš„é»˜è®¤å€¼ã€‚ æ´¾ç”Ÿ `Default` æ„å‘³ç€è‡ªåŠ¨å®ç°äº† `default` å‡½æ•°ã€‚ `default` å‡½æ•°çš„æ´¾ç”Ÿå®ç°è°ƒç”¨äº†ç±»å‹æ¯éƒ¨åˆ†çš„ `default` å‡½æ•°ï¼Œè¿™æ„å‘³ç€ç±»å‹ä¸­æ‰€æœ‰çš„å­—æ®µä¹Ÿå¿…é¡»å®ç°äº† `Default`ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿæ´¾ç”Ÿ `Default` ã€‚

`Default::default` å‡½æ•°é€šå¸¸ç»“åˆç»“æ„ä½“æ›´æ–°è¯­æ³•ä¸€èµ·ä½¿ç”¨ï¼Œè¿™åœ¨ç¬¬äº”ç« çš„ [ç»“æ„ä½“æ›´æ–°è¯­æ³•](https://course.rs/basic/compound-type/struct.html#ç»“æ„ä½“æ›´æ–°è¯­æ³•) éƒ¨åˆ†æœ‰è®¨è®ºã€‚å¯ä»¥è‡ªå®šä¹‰ä¸€ä¸ªç»“æ„ä½“çš„ä¸€å°éƒ¨åˆ†å­—æ®µè€Œå‰©ä½™å­—æ®µåˆ™ä½¿ç”¨ `..Default::default()` è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚

ä¾‹å¦‚ï¼Œå½“ä½ åœ¨ `Option<T>` å®ä¾‹ä¸Šä½¿ç”¨ `unwrap_or_default` æ–¹æ³•æ—¶ï¼Œ `Default` ç‰¹å¾æ˜¯å¿…é¡»çš„ã€‚å¦‚æœ `Option<T>` æ˜¯ `None` çš„è¯, `unwrap_or_default` æ–¹æ³•å°†è¿”å› `T` ç±»å‹çš„ `Default::default` çš„ç»“æœã€‚



================================================
FILE: src/appendix/difficulties.md
================================================
[Binary file]


================================================
FILE: src/appendix/expressions.md
================================================
# é™„å½• Cï¼šè¡¨è¾¾å¼

åœ¨[è¯­å¥ä¸è¡¨è¾¾å¼](https://course.rs/basic/base-type/statement-expression.html)ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¯¹è¡¨è¾¾å¼æœ‰è¿‡ä»‹ç»ï¼Œä¸‹é¢å¯¹è¿™äº›å¸¸ç”¨è¡¨è¾¾å¼è¿›è¡Œä¸€ä¸€è¯´æ˜ã€‚

### åŸºæœ¬è¡¨è¾¾å¼

```rust
let n = 3;
let s = "test";
```

### if è¡¨è¾¾å¼

```rust
fn main() {
    let var1 = 10;

    let var2 = if var1 >= 10 {
        var1
    } else {
        var1 + 10
    };

    println!("{}", var2);
}
```

é€šè¿‡ `if` è¡¨è¾¾å¼å°†å€¼èµ‹äºˆ `var2`ã€‚

ä½ è¿˜å¯ä»¥åœ¨å¾ªç¯ä¸­ç»“åˆ `continue` ã€`break` æ¥ä½¿ç”¨ï¼š

```rust
let mut v = 0;
for i in 1..10 {
    v = if i == 9 {
        continue
    } else {
        i
    }
}
println!("{}", v);
```

### if let è¡¨è¾¾å¼

```rust
let o = Some(3);
let v = if let Some(x) = o {
    x
} else {
    0
};
```

### match è¡¨è¾¾å¼

```rust
let o = Some(3);
let v = match o {
    Some(x) => x,
    _ => 0
};
```

### loop è¡¨è¾¾å¼

```rust
let mut n = 0;
let v = loop {
    if n == 10 {
        break n
    }
    n += 1;
};
```

### è¯­å¥å— {}

```rust
let mut n = 0;
let v = {
    println!("before: {}", n);
    n += 1;
    println!("after: {}", n);
    n
};
println!("{}", v);
```



================================================
FILE: src/appendix/intro.md
================================================
# é™„å½•

é™„å½•ä¸­åŒ…å«äº†ä¸€äº› Rust å¸¸ç”¨æ¦‚å¿µçš„å¿«é€Ÿç´¢å¼•ï¼Œæ–¹ä¾¿ä½ çš„æ—¥å¸¸æŸ¥è¯¢ä½¿ç”¨ã€‚

> å¤§éƒ¨åˆ†çš„é™„å½•å€Ÿé‰´äº† Rust Book ä»¥åŠç›¸åº”çš„ [ä¸­æ–‡ç¿»è¯‘ä¹¦ç±](https://rustwiki.org/zh-CN/book/)ï¼Œä½†åŒæ—¶åšäº†ä¸€äº›çš„ä¿®æ”¹ï¼Œå¢åŠ å‡†ç¡®æ€§å’Œé˜…è¯»æµç•…åº¦



================================================
FILE: src/appendix/keywords.md
================================================
## é™„å½• Aï¼šå…³é”®å­—

ä¸‹é¢çš„åˆ—è¡¨åŒ…å« Rust ä¸­æ­£åœ¨ä½¿ç”¨æˆ–è€…ä»¥åä¼šç”¨åˆ°çš„å…³é”®å­—ã€‚å› æ­¤ï¼Œè¿™äº›å…³é”®å­—ä¸èƒ½è¢«ç”¨ä½œæ ‡è¯†ç¬¦ï¼ˆé™¤äº†[åŸç”Ÿæ ‡è¯†ç¬¦](#åŸç”Ÿæ ‡è¯†ç¬¦)ï¼‰ï¼ŒåŒ…æ‹¬å‡½æ•°ã€å˜é‡ã€å‚æ•°ã€ç»“æ„ä½“å­—æ®µã€æ¨¡å—ã€åŒ…ã€å¸¸é‡ã€å®ã€é™æ€å€¼ã€å±æ€§ã€ç±»å‹ã€ç‰¹å¾æˆ–ç”Ÿå‘½å‘¨æœŸã€‚

### ç›®å‰æ­£åœ¨ä½¿ç”¨çš„å…³é”®å­—

å¦‚ä¸‹å…³é”®å­—ç›®å‰æœ‰å¯¹åº”å…¶æè¿°çš„åŠŸèƒ½ã€‚

- `as` - å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œæˆ–`use` å’Œ `extern crate`åŒ…å’Œæ¨¡å—å¼•å…¥è¯­å¥ä¸­çš„é‡å‘½å
- `break` - ç«‹åˆ»é€€å‡ºå¾ªç¯
- `const` - å®šä¹‰å¸¸é‡æˆ–åŸç”Ÿå¸¸é‡æŒ‡é’ˆï¼ˆconstant raw pointerï¼‰
- `continue` - ç»§ç»­è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯è¿­ä»£
- `crate` - é“¾æ¥å¤–éƒ¨åŒ…
- `dyn` - åŠ¨æ€åˆ†å‘ç‰¹å¾å¯¹è±¡
- `else` - ä½œä¸º `if` å’Œ `if let` æ§åˆ¶æµç»“æ„çš„ fallback
- `enum` - å®šä¹‰ä¸€ä¸ªæšä¸¾ç±»å‹
- `extern` - é“¾æ¥ä¸€ä¸ªå¤–éƒ¨åŒ…,æˆ–è€…ä¸€ä¸ªå®å˜é‡(è¯¥å˜é‡å®šä¹‰åœ¨å¦å¤–ä¸€ä¸ªåŒ…ä¸­)
- `false` - å¸ƒå°”å€¼ `false`
- `fn` - å®šä¹‰ä¸€ä¸ªå‡½æ•°æˆ– **å‡½æ•°æŒ‡é’ˆç±»å‹** (_function pointer type_)
- `for` - éå†ä¸€ä¸ªè¿­ä»£å™¨æˆ–å®ç°ä¸€ä¸ª trait æˆ–è€…æŒ‡å®šä¸€ä¸ªæ›´é«˜çº§çš„ç”Ÿå‘½å‘¨æœŸ
- `if` - åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„ç»“æœæ¥æ‰§è¡Œç›¸åº”çš„åˆ†æ”¯
- `impl` - ä¸ºç»“æ„ä½“æˆ–è€…ç‰¹å¾å®ç°å…·ä½“åŠŸèƒ½
- `in` - `for` å¾ªç¯è¯­æ³•çš„ä¸€éƒ¨åˆ†
- `let` - ç»‘å®šä¸€ä¸ªå˜é‡
- `loop` - æ— æ¡ä»¶å¾ªç¯
- `match` - æ¨¡å¼åŒ¹é…
- `mod` - å®šä¹‰ä¸€ä¸ªæ¨¡å—
- `move` - ä½¿é—­åŒ…è·å–å…¶æ‰€æ•è·é¡¹çš„æ‰€æœ‰æƒ
- `mut` - åœ¨å¼•ç”¨ã€è£¸æŒ‡é’ˆæˆ–æ¨¡å¼ç»‘å®šä¸­ä½¿ç”¨ï¼Œè¡¨æ˜å˜é‡æ˜¯å¯å˜çš„
- `pub` - è¡¨ç¤ºç»“æ„ä½“å­—æ®µã€`impl` å—æˆ–æ¨¡å—çš„å…¬å…±å¯è§æ€§
- `ref` - é€šè¿‡å¼•ç”¨ç»‘å®š
- `return` - ä»å‡½æ•°ä¸­è¿”å›
- `Self` - å®ç°ç‰¹å¾ç±»å‹çš„ç±»å‹åˆ«å
- `self` - è¡¨ç¤ºæ–¹æ³•æœ¬èº«æˆ–å½“å‰æ¨¡å—
- `static` - è¡¨ç¤ºå…¨å±€å˜é‡æˆ–åœ¨æ•´ä¸ªç¨‹åºæ‰§è¡ŒæœŸé—´ä¿æŒå…¶ç”Ÿå‘½å‘¨æœŸ
- `struct` - å®šä¹‰ä¸€ä¸ªç»“æ„ä½“
- `super` - è¡¨ç¤ºå½“å‰æ¨¡å—çš„çˆ¶æ¨¡å—
- `trait` - å®šä¹‰ä¸€ä¸ªç‰¹å¾
- `true` - å¸ƒå°”å€¼ `true`
- `type` - å®šä¹‰ä¸€ä¸ªç±»å‹åˆ«åæˆ–å…³è”ç±»å‹
- `unsafe` - è¡¨ç¤ºä¸å®‰å…¨çš„ä»£ç ã€å‡½æ•°ã€ç‰¹å¾æˆ–å®ç°
- `use` - åœ¨å½“å‰ä»£ç èŒƒå›´å†…(æ¨¡å—æˆ–è€…èŠ±æ‹¬å·å¯¹)å¼•å…¥å¤–éƒ¨çš„åŒ…ã€æ¨¡å—ç­‰
- `where` - è¡¨ç¤ºä¸€ä¸ªçº¦æŸç±»å‹çš„ä»å¥
- `while` - åŸºäºä¸€ä¸ªè¡¨è¾¾å¼çš„ç»“æœåˆ¤æ–­æ˜¯å¦ç»§ç»­å¾ªç¯

### ä¿ç•™åšå°†æ¥ä½¿ç”¨çš„å…³é”®å­—

å¦‚ä¸‹å…³é”®å­—æ²¡æœ‰ä»»ä½•åŠŸèƒ½ï¼Œä¸è¿‡ç”± Rust ä¿ç•™ä»¥å¤‡å°†æ¥çš„åº”ç”¨ã€‚

- `abstract`
- `async`
- `await`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### åŸç”Ÿæ ‡è¯†ç¬¦

åŸç”Ÿæ ‡è¯†ç¬¦ï¼ˆRaw identifiersï¼‰å…è®¸ä½ ä½¿ç”¨é€šå¸¸ä¸èƒ½ä½¿ç”¨çš„å…³é”®å­—ï¼Œå…¶å¸¦æœ‰ `r#` å‰ç¼€ã€‚

ä¾‹å¦‚ï¼Œ`match` æ˜¯å…³é”®å­—ã€‚å¦‚æœå°è¯•ç¼–è¯‘å¦‚ä¸‹ä½¿ç”¨ `match` ä½œä¸ºåå­—çš„å‡½æ•°ï¼š

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

ä¼šå¾—åˆ°è¿™ä¸ªé”™è¯¯ï¼š

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

è¯¥é”™è¯¯è¡¨ç¤ºä½ ä¸èƒ½å°†å…³é”®å­— `match` ç”¨ä½œå‡½æ•°æ ‡è¯†ç¬¦ã€‚ä½ å¯ä»¥ä½¿ç”¨åŸç”Ÿæ ‡è¯†ç¬¦å°† `match` ä½œä¸ºå‡½æ•°åç§°ä½¿ç”¨ï¼š

<span class="filename">æ–‡ä»¶å: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

æ­¤ä»£ç ç¼–è¯‘æ²¡æœ‰ä»»ä½•é”™è¯¯ã€‚æ³¨æ„ `r#` å‰ç¼€éœ€åŒæ—¶ç”¨äºå‡½æ•°åå®šä¹‰å’Œ `main` å‡½æ•°ä¸­çš„è°ƒç”¨ã€‚

åŸç”Ÿæ ‡è¯†ç¬¦å…è®¸ä½¿ç”¨ä½ é€‰æ‹©çš„ä»»ä½•å•è¯ä½œä¸ºæ ‡è¯†ç¬¦ï¼Œå³ä½¿è¯¥å•è¯æ°å¥½æ˜¯ä¿ç•™å…³é”®å­—ã€‚ æ­¤å¤–ï¼ŒåŸç”Ÿæ ‡è¯†ç¬¦å…è®¸ä½ ä½¿ç”¨å…¶å®ƒ Rust ç‰ˆæœ¬ç¼–å†™çš„åº“ã€‚æ¯”å¦‚ï¼Œ`try` åœ¨ Rust 2015 edition ä¸­ä¸æ˜¯å…³é”®å­—ï¼Œå´åœ¨ Rust 2018 edition æ˜¯å…³é”®å­—ã€‚æ‰€ä»¥å¦‚æœç”¨ 2015 edition ç¼–å†™çš„åº“ä¸­å¸¦æœ‰ `try` å‡½æ•°ï¼Œåœ¨ 2018 edition ä¸­è°ƒç”¨æ—¶å°±éœ€è¦ä½¿ç”¨åŸå§‹æ ‡è¯†ç¬¦è¯­æ³•ï¼Œåœ¨è¿™é‡Œæ˜¯ `r#try`ã€‚



================================================
FILE: src/appendix/operators.md
================================================
## é™„å½• Bï¼šè¿ç®—ç¬¦ä¸ç¬¦å·

è¯¥é™„å½•åŒ…å«äº† Rust ç›®å‰å‡ºç°è¿‡çš„å„ç§ç¬¦å·ï¼Œè¿™äº›ç¬¦å·ä¹‹å‰éƒ½åˆ†æ•£åœ¨å„ä¸ªç« èŠ‚ä¸­ã€‚

### è¿ç®—ç¬¦

è¡¨ B-1 åŒ…å«äº† Rust ä¸­çš„è¿ç®—ç¬¦ã€ä¸Šä¸‹æ–‡ä¸­çš„ç¤ºä¾‹ã€ç®€çŸ­è§£é‡Šä»¥åŠè¯¥è¿ç®—ç¬¦æ˜¯å¦å¯é‡è½½ã€‚å¦‚æœä¸€ä¸ªè¿ç®—ç¬¦æ˜¯å¯é‡è½½çš„ï¼Œåˆ™è¯¥è¿ç®—ç¬¦ä¸Šç”¨äºé‡è½½çš„ç‰¹å¾ä¹Ÿä¼šåˆ—å‡ºã€‚

ä¸‹è¡¨ä¸­ï¼Œ`expr` æ˜¯è¡¨è¾¾å¼ï¼Œ`ident` æ˜¯æ ‡è¯†ç¬¦ï¼Œ`type` æ˜¯ç±»å‹ï¼Œ`var` æ˜¯å˜é‡ï¼Œ`trait` æ˜¯ç‰¹å¾ï¼Œ`pat` æ˜¯åŒ¹é…åˆ†æ”¯(pattern)ã€‚

<span class="caption">è¡¨ B-1ï¼šè¿ç®—ç¬¦</span>

| è¿ç®—ç¬¦                    | ç¤ºä¾‹                                                    | è§£é‡Š                               | æ˜¯å¦å¯é‡è½½     |
| ------------------------- | ------------------------------------------------------- | ---------------------------------- | -------------- |
| `!`                       | `ident!(...)`, `ident!{...}`, `ident![...]`             | å®å±•å¼€                             |                |
| `!`                       | `!expr`                                                 | æŒ‰ä½éæˆ–é€»è¾‘é                     | `Not`          |
| `!=`                      | `var != expr`                                           | ä¸ç­‰æ¯”è¾ƒ                           | `PartialEq`    |
| `%`                       | `expr % expr`                                           | ç®—æœ¯æ±‚ä½™                           | `Rem`          |
| `%=`                      | `var %= expr`                                           | ç®—æœ¯æ±‚ä½™ä¸èµ‹å€¼                     | `RemAssign`    |
| `&`                       | `&expr`, `&mut expr`                                    | å€Ÿç”¨                               |                |
| `&`                       | `&type`, `&mut type`, `&'a type`, `&'a mut type`        | å€Ÿç”¨æŒ‡é’ˆç±»å‹                       |                |
| `&`                       | `expr & expr`                                           | æŒ‰ä½ä¸                             | `BitAnd`       |
| `&=`                      | `var &= expr`                                           | æŒ‰ä½ä¸åŠèµ‹å€¼                       | `BitAndAssign` |
| `&&`                      | `expr && expr`                                          | é€»è¾‘ä¸                             |                |
| `*`                       | `expr * expr`                                           | ç®—æœ¯ä¹˜æ³•                           | `Mul`          |
| `*=`                      | `var *= expr`                                           | ç®—æœ¯ä¹˜æ³•ä¸èµ‹å€¼                     | `MulAssign`    |
| `*`                       | `*expr`                                                 | è§£å¼•ç”¨                             |                |
| `*`                       | `*const type`, `*mut type`                              | è£¸æŒ‡é’ˆ                           |                |
| `+`                       | `trait + trait`, `'a + trait`                           | å¤åˆç±»å‹é™åˆ¶                       |                |
| `+`                       | `expr + expr`                                           | ç®—æœ¯åŠ æ³•                           | `Add`          |
| `+=`                      | `var += expr`                                           | ç®—æœ¯åŠ æ³•ä¸èµ‹å€¼                     | `AddAssign`    |
| `,`                       | `expr, expr`                                            | å‚æ•°ä»¥åŠå…ƒç´ åˆ†éš”ç¬¦                 |                |
| `-`                       | `- expr`                                                | ç®—æœ¯å–è´Ÿ                           | `Neg`          |
| `-`                       | `expr - expr`                                           | ç®—æœ¯å‡æ³•                           | `Sub`          |
| `-=`                      | `var -= expr`                                           | ç®—æœ¯å‡æ³•ä¸èµ‹å€¼                     | `SubAssign`    |
| `->`                      | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | å‡½æ•°ä¸é—­åŒ…ï¼Œè¿”å›ç±»å‹               |                |
| `.`                       | `expr.ident`                                            | æˆå‘˜è®¿é—®                           |                |
| `..`                      | `..`, `expr..`, `..expr`, `expr..expr`                  | å³åŠå¼€åŒºé—´                         | PartialOrd     |
| `..=`                     | `..=expr`, `expr..=expr`                                | é—­åˆåŒºé—´                           | PartialOrd     |
| `..`                      | `..expr`                                                | ç»“æ„ä½“æ›´æ–°è¯­æ³•                     |                |
| `..`                      | `variant(x, ..)`, `struct_type { x, .. }`               | â€œä»£è¡¨å‰©ä½™éƒ¨åˆ†â€çš„æ¨¡å¼ç»‘å®š           |                |
| `...`                     | `expr...expr`                                           | (ä¸æ¨èä½¿ç”¨ï¼Œç”¨`..=`æ›¿ä»£) é—­åˆåŒºé—´ |                |
| `/`                       | `expr / expr`                                           | ç®—æœ¯é™¤æ³•                           | `Div`          |
| `/=`                      | `var /= expr`                                           | ç®—æœ¯é™¤æ³•ä¸èµ‹å€¼                     | `DivAssign`    |
| `:`                       | `pat: type`, `ident: type`                              | çº¦æŸ                               |                |
| `:`                       | `ident: expr`                                           | ç»“æ„ä½“å­—æ®µåˆå§‹åŒ–                   |                |
| `:`                       | `'a: loop {...}`                                        | å¾ªç¯æ ‡å¿—                           |                |
| `;`                       | `expr;`                                                 | è¯­å¥å’Œè¯­å¥ç»“æŸç¬¦                   |                |
| `;`                       | `[...; len]`                                            | å›ºå®šå¤§å°æ•°ç»„è¯­æ³•çš„éƒ¨åˆ†             |                |
| `<<`                      | `expr << expr`                                          | å·¦ç§»                               | `Shl`          |
| `<<=`                     | `var <<= expr`                                          | å·¦ç§»ä¸èµ‹å€¼                         | `ShlAssign`    |
| `<`                       | `expr < expr`                                           | å°äºæ¯”è¾ƒ                           | `PartialOrd`   |
| `<=`                      | `expr <= expr`                                          | å°äºç­‰äºæ¯”è¾ƒ                       | `PartialOrd`   |
| `=`                       | `var = expr`, `ident = type`                            | èµ‹å€¼/ç­‰å€¼                          |                |
| `==`                      | `expr == expr`                                          | ç­‰äºæ¯”è¾ƒ                           | `PartialEq`    |
| `=>`                      | `pat => expr`                                           | åŒ¹é…åˆ†æ”¯è¯­æ³•çš„éƒ¨åˆ†                 |                |
| `>`                       | `expr > expr`                                           | å¤§äºæ¯”è¾ƒ                           | `PartialOrd`   |
| `>=`                      | `expr >= expr`                                          | å¤§äºç­‰äºæ¯”è¾ƒ                       | `PartialOrd`   |
| `>>`                      | `expr >> expr`                                          | å³ç§»                               | `Shr`          |
| `>>=`                     | `var >>= expr`                                          | å³ç§»ä¸èµ‹å€¼                         | `ShrAssign`    |
| `@`                       | `ident @ pat`                                           | æ¨¡å¼ç»‘å®š                           |                |
| `^`                       | `expr ^ expr`                                           | æŒ‰ä½å¼‚æˆ–                           | `BitXor`       |
| `^=`                      | `var ^= expr`                                           | æŒ‰ä½å¼‚æˆ–ä¸èµ‹å€¼                     | `BitXorAssign` |
| <code>&vert;</code>       | <code>pat &vert; pat</code>                             | æ¨¡å¼åŒ¹é…ä¸­çš„å¤šä¸ªå¯é€‰æ¡ä»¶           |                |
| <code>&vert;</code>       | <code>expr &vert; expr</code>                           | æŒ‰ä½æˆ–                             | `BitOr`        |
| <code>&vert;=</code>      | <code>var &vert;= expr</code>                           | æŒ‰ä½æˆ–ä¸èµ‹å€¼                       | `BitOrAssign`  |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code>                     | é€»è¾‘æˆ–                             |                |
| `?`                       | `expr?`                                                 | é”™è¯¯ä¼ æ’­                           |                |

### éè¿ç®—ç¬¦ç¬¦å·

<span class="caption">è¡¨ B-2ï¼šç‹¬ç«‹è¯­æ³•</span>

| ç¬¦å·                                        | è§£é‡Š                                                   |
| ------------------------------------------- | ------------------------------------------------------ |
| `'ident`                                    | ç”Ÿå‘½å‘¨æœŸåç§°æˆ–å¾ªç¯æ ‡ç­¾                                 |
| `...u8`, `...i32`, `...f64`, `...usize`, ç­‰ | æŒ‡å®šç±»å‹çš„æ•°å€¼å¸¸é‡                                     |
| `"..."`                                     | å­—ç¬¦ä¸²å¸¸é‡                                             |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc.    | åŸç”Ÿå­—ç¬¦ä¸², æœªè½¬ä¹‰å­—ç¬¦                                 |
| `b"..."`                                    | å°† `&str` è½¬æ¢æˆ `&[u8; N]` ç±»å‹çš„æ•°ç»„                 |
| `br"..."`, `br#"..."#`, `br##"..."##`, ç­‰   | åŸç”Ÿå­—èŠ‚å­—ç¬¦ä¸²ï¼ŒåŸç”Ÿå’Œå­—èŠ‚å­—ç¬¦ä¸²å­—é¢å€¼çš„ç»“åˆ           |
| `'...'`                                     | Char å­—ç¬¦                                              |
| `b'...'`                                    | ASCII å­—èŠ‚                                             |
| <code>&vert;...&vert; expr</code>           | é—­åŒ…                                                   |
| `!`                                         | ä»£è¡¨æ€»æ˜¯ç©ºçš„ç±»å‹ï¼Œç”¨äºå‘æ•£å‡½æ•°(æ— è¿”å›å€¼å‡½æ•°)           |
| `_`                                         | æ¨¡å¼ç»‘å®šä¸­è¡¨ç¤ºå¿½ç•¥çš„æ„æ€ï¼›ä¹Ÿç”¨äºå¢å¼ºæ•´å‹å­—é¢å€¼çš„å¯è¯»æ€§ |

è¡¨ B-3 å±•ç¤ºäº†æ¨¡å—å’Œå¯¹è±¡è°ƒç”¨è·¯å¾„çš„è¯­æ³•ã€‚

<span class="caption">è¡¨ B-3ï¼šè·¯å¾„ç›¸å…³è¯­æ³•</span>

| ç¬¦å·                                    | è§£é‡Š                                                              |
| --------------------------------------- | ----------------------------------------------------------------- |
| `ident::ident`                          | å‘½åç©ºé—´è·¯å¾„                                                      |
| `::path`                                | ä»å½“å‰çš„åŒ…çš„æ ¹è·¯å¾„å¼€å§‹çš„ç›¸å¯¹è·¯å¾„                                  |
| `self::path`                            | ä¸å½“å‰æ¨¡å—ç›¸å¯¹çš„è·¯å¾„ï¼ˆå¦‚ä¸€ä¸ªæ˜¾å¼ç›¸å¯¹è·¯å¾„ï¼‰                        |
| `super::path`                           | ä¸çˆ¶æ¨¡å—ç›¸å¯¹çš„è·¯å¾„                                                |
| `type::ident`, `<type as trait>::ident` | å…³è”å¸¸é‡ã€å…³è”å‡½æ•°ã€å…³è”ç±»å‹                                      |
| `<type>::...`                           | ä¸å¯ä»¥è¢«ç›´æ¥å‘½åçš„å…³è”é¡¹ç±»å‹ï¼ˆå¦‚ `<&T>::...`ï¼Œ`<[T]>::...`ï¼Œ ç­‰ï¼‰ |
| `trait::method(...)`                    | ä½¿ç”¨ç‰¹å¾åè¿›è¡Œæ–¹æ³•è°ƒç”¨ï¼Œä»¥æ¶ˆé™¤æ–¹æ³•è°ƒç”¨çš„äºŒä¹‰æ€§                    |
| `type::method(...)`                     | ä½¿ç”¨ç±»å‹åè¿›è¡Œæ–¹æ³•è°ƒç”¨, ä»¥æ¶ˆé™¤æ–¹æ³•è°ƒç”¨çš„äºŒä¹‰æ€§                    |
| `<type as trait>::method(...)`          | å°†ç±»å‹è½¬æ¢ä¸ºç‰¹å¾ï¼Œå†è¿›è¡Œæ–¹æ³•è°ƒç”¨,ä»¥æ¶ˆé™¤æ–¹æ³•è°ƒç”¨çš„äºŒä¹‰æ€§           |

è¡¨ B-4 å±•ç¤ºäº†ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ç”¨åˆ°çš„ç¬¦å·ã€‚

<span class="caption">è¡¨ B-4ï¼šæ³›å‹</span>

| ç¬¦å·                           | è§£é‡Š                                                                                              |
| ------------------------------ | ------------------------------------------------------------------------------------------------- |
| `path<...>`                    | ä¸ºä¸€ä¸ªç±»å‹ä¸­çš„æ³›å‹æŒ‡å®šå…·ä½“å‚æ•°ï¼ˆå¦‚ `Vec<u8>`ï¼‰                                                    |
| `path::<...>`, `method::<...>` | ä¸ºä¸€ä¸ªæ³›å‹ã€å‡½æ•°æˆ–è¡¨è¾¾å¼ä¸­çš„æ–¹æ³•æŒ‡å®šå…·ä½“å‚æ•°ï¼Œé€šå¸¸æŒ‡åŒå†’å·(turbofish)ï¼ˆå¦‚ `"42".parse::<i32>()`ï¼‰ |
| `fn ident<...> ...`            | æ³›å‹å‡½æ•°å®šä¹‰                                                                                      |
| `struct ident<...> ...`        | æ³›å‹ç»“æ„ä½“å®šä¹‰                                                                                    |
| `enum ident<...> ...`          | æ³›å‹æšä¸¾å®šä¹‰                                                                                      |
| `impl<...> ...`                | å®ç°æ³›å‹                                                                                          |
| `for<...> type`                | é«˜é˜¶ç”Ÿå‘½å‘¨æœŸé™åˆ¶                                                                                  |
| `type<ident=type>`             | æ³›å‹ï¼Œå…¶ä¸€ä¸ªæˆ–å¤šä¸ªç›¸å…³ç±»å‹å¿…é¡»è¢«æŒ‡å®šä¸ºç‰¹å®šç±»å‹ï¼ˆå¦‚ `Iterator<Item=T>`ï¼‰                           |

è¡¨ B-5 å±•ç¤ºäº†ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥é™åˆ¶æ³›å‹å‚æ•°çš„ç¬¦å·ã€‚

<span class="caption">è¡¨ B-5ï¼šç‰¹å¾çº¦æŸ</span>

| ç¬¦å·                          | è§£é‡Š                                                                                     |
| ----------------------------- | ---------------------------------------------------------------------------------------- |
| `T: U`                        | æ³›å‹å‚æ•° `T`éœ€å®ç°`U`ç±»å‹                                                                |
| `T: 'a`                       | æ³›å‹ `T` çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»é•¿äº `'a`ï¼ˆæ„å‘³ç€è¯¥ç±»å‹ä¸èƒ½ä¼ é€’åŒ…å«ç”Ÿå‘½å‘¨æœŸçŸ­äº `'a` çš„ä»»ä½•å¼•ç”¨ï¼‰ |
| `T : 'static`                 | æ³›å‹ T åªèƒ½ä½¿ç”¨å£°æ˜å‘¨æœŸä¸º'static çš„å¼•ç”¨                                                  |
| `'b: 'a`                      | ç”Ÿå‘½å‘¨æœŸ`'b`å¿…é¡»é•¿äºç”Ÿå‘½å‘¨æœŸ`'a`                                                         |
| `T: ?Sized`                   | ä½¿ç”¨ä¸€ä¸ªä¸å®šå¤§å°çš„æ³›å‹ç±»å‹                                                               |
| `'a + trait`, `trait + trait` | å¤šä¸ªç±»å‹ç»„æˆçš„å¤åˆç±»å‹é™åˆ¶                                                               |

è¡¨ B-6 å±•ç¤ºäº†å®ä»¥åŠåœ¨ä¸€ä¸ªå¯¹è±¡ä¸Šå®šä¹‰å±æ€§çš„ç¬¦å·ã€‚

<span class="caption">è¡¨ B-6ï¼šå®ä¸å±æ€§</span>

| ç¬¦å·                                        | è§£é‡Š     |
| ------------------------------------------- | -------- |
| `#[meta]`                                   | å¤–éƒ¨å±æ€§ |
| `#![meta]`                                  | å†…éƒ¨å±æ€§ |
| `$ident`                                    | å®æ›¿æ¢   |
| `$ident:kind`                               | å®æ•è·   |
| `$(â€¦)â€¦`                                     | å®é‡å¤   |
| `ident!(...)`, `ident!{...}`, `ident![...]` | å®è°ƒç”¨   |

è¡¨ B-7 å±•ç¤ºäº†å†™æ³¨é‡Šçš„ç¬¦å·ã€‚

<span class="caption">è¡¨ B-7ï¼šæ³¨é‡Š</span>

| ç¬¦å·       | æ³¨é‡Š                 |
| ---------- | -------------------- |
| `//`       | è¡Œæ³¨é‡Š               |
| `//!`      | å†…éƒ¨è¡Œ(hang)æ–‡æ¡£æ³¨é‡Š |
| `///`      | å¤–éƒ¨è¡Œæ–‡æ¡£æ³¨é‡Š       |
| `/*...*/`  | å—æ³¨é‡Š               |
| `/*!...*/` | å†…éƒ¨å—æ–‡æ¡£æ³¨é‡Š       |
| `/**...*/` | å¤–éƒ¨å—æ–‡æ¡£æ³¨é‡Š       |

è¡¨ B-8 å±•ç¤ºäº†å‡ºç°åœ¨ä½¿ç”¨å…ƒç»„æ—¶çš„ç¬¦å·ã€‚

<span class="caption">è¡¨ B-8ï¼šå…ƒç»„</span>

| ç¬¦å·                     | è§£é‡Š                                                                     |
| ------------------------ | ------------------------------------------------------------------------ |
| `()`                     | ç©ºå…ƒç»„ï¼ˆäº¦ç§°å•å…ƒï¼‰ï¼Œå³æ˜¯å­—é¢å€¼ä¹Ÿæ˜¯ç±»å‹                                   |
| `(expr)`                 | æ‹¬å·è¡¨è¾¾å¼                                                               |
| `(expr,)`                | å•ä¸€å…ƒç´ å…ƒç»„è¡¨è¾¾å¼                                                       |
| `(type,)`                | å•ä¸€å…ƒç´ å…ƒç»„ç±»å‹                                                         |
| `(expr, ...)`            | å…ƒç»„è¡¨è¾¾å¼                                                               |
| `(type, ...)`            | å…ƒç»„ç±»å‹                                                                 |
| `expr(expr, ...)`        | å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼ï¼›ä¹Ÿç”¨äºåˆå§‹åŒ–å…ƒç»„ç»“æ„ä½“ `struct` ä»¥åŠå…ƒç»„æšä¸¾ `enum` å˜ä½“ |
| `expr.0`, `expr.1`, etc. | å…ƒç»„ç´¢å¼•                                                                 |

è¡¨ B-9 å±•ç¤ºäº†ä½¿ç”¨å¤§æ‹¬å·çš„ä¸Šä¸‹æ–‡ã€‚

<span class="caption">è¡¨ B-9ï¼šå¤§æ‹¬å·</span>

| ç¬¦å·         | è§£é‡Š         |
| ------------ | ------------ |
| `{...}`      | ä»£ç å—è¡¨è¾¾å¼ |
| `Type {...}` | ç»“æ„ä½“å­—é¢å€¼ |

è¡¨ B-10 å±•ç¤ºäº†ä½¿ç”¨æ–¹æ‹¬å·çš„ä¸Šä¸‹æ–‡ã€‚

<span class="caption">è¡¨ B-10ï¼šæ–¹æ‹¬å·</span>

| ç¬¦å·                                               | è§£é‡Š                                                                                                     |
| -------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| `[...]`                                            | æ•°ç»„                                                                                                     |
| `[expr; len]`                                      | æ•°ç»„é‡ŒåŒ…å«`len`ä¸ª`expr`                                                                                  |
| `[type; len]`                                      | æ•°ç»„é‡ŒåŒ…å«äº†`len`ä¸ª`type`ç±»å‹çš„å¯¹è±¡                                                                      |
| `expr[expr]`                                       | é›†åˆç´¢å¼•ã€‚ é‡è½½ï¼ˆ`Index`, `IndexMut`ï¼‰                                                                   |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | é›†åˆç´¢å¼•ï¼Œä¹Ÿç§°ä¸ºé›†åˆåˆ‡ç‰‡ï¼Œç´¢å¼•è¦å®ç°ä»¥ä¸‹ç‰¹å¾ä¸­çš„å…¶ä¸­ä¸€ä¸ªï¼š`Range`ï¼Œ`RangeFrom`ï¼Œ`RangeTo` æˆ– `RangeFull` |



================================================
FILE: src/appendix/prelude.md
================================================
# é™„å½• Eï¼šprelude æ¨¡å—



================================================
FILE: src/appendix/rust-version.md
================================================
# é™„å½• Fï¼šRust ç‰ˆæœ¬å‘å¸ƒ

## Rust ç‰ˆæœ¬è¯´æ˜

æ—©åœ¨ç¬¬ä¸€ç« ï¼Œæˆ‘ä»¬è§è¿‡ `cargo new` åœ¨ _Cargo.toml_ ä¸­å¢åŠ äº†ä¸€äº›æœ‰å…³ `edition` çš„å…ƒæ•°æ®ã€‚æœ¬é™„å½•å°†è§£é‡Šå…¶æ„ä¹‰ï¼

ä¸å…¶å®ƒè¯­è¨€ç›¸æ¯”ï¼ŒRust çš„æ›´æ–°è¿­ä»£è¾ƒä¸ºé¢‘ç¹ï¼ˆå¾—ç›Šäºç²¾å¿ƒè®¾è®¡è¿‡çš„å‘å¸ƒæµç¨‹ä»¥åŠ Rust è¯­è¨€å¼€å‘è€…å›¢é˜Ÿç®¡ç†ï¼‰ï¼š

- æ¯ 6 å‘¨å‘å¸ƒä¸€ä¸ªè¿­ä»£ç‰ˆæœ¬
- 2 - 3 å¹´å‘å¸ƒä¸€ä¸ªæ–°çš„å¤§ç‰ˆæœ¬ï¼šæ¯ä¸€ä¸ªç‰ˆæœ¬ä¼šç»“åˆå·²ç»è½åœ°çš„åŠŸèƒ½ï¼Œå¹¶æä¾›ä¸€ä¸ªæ¸…æ™°çš„å¸¦æœ‰å®Œæ•´æ›´æ–°æ–‡æ¡£å’Œå·¥å…·çš„åŠŸèƒ½åŒ…ã€‚æ–°ç‰ˆæœ¬ä¼šä½œä¸ºå¸¸è§„çš„ 6 å‘¨å‘å¸ƒè¿‡ç¨‹çš„ä¸€éƒ¨åˆ†å‘å¸ƒã€‚

å¥½å¤„åœ¨äºï¼Œå¯ä»¥æ»¡è¶³ä¸åŒçš„ç”¨æˆ·ç¾¤ä½“çš„éœ€æ±‚ï¼š

- å¯¹äºæ´»è·ƒçš„ Rust ç”¨æˆ·ï¼Œä»–ä»¬æ€»æ˜¯èƒ½å¾ˆå¿«è·å–åˆ°æ–°çš„è¯­è¨€å†…å®¹ï¼Œæ¯•ç«Ÿï¼Œå°é²œæ˜¯æŠ€æœ¯çˆ±å¥½è€…çš„å…±åŒç‰¹ç‚¹:)
- å¯¹äºä¸€èˆ¬çš„ç”¨æˆ·ï¼Œedition çš„å‘å¸ƒä¼šå‘Šè¯‰è¿™äº›ç”¨æˆ·ï¼šRust è¯­è¨€ç›¸æ¯”ä¸Šæ¬¡å¤§ç‰ˆæœ¬å‘å¸ƒï¼Œæœ‰äº†é‡å¤§çš„æ”¹è¿›ï¼Œå€¼å¾—ä¸€çœ‹
- å¯¹äº Rust è¯­è¨€å¼€å‘è€…ï¼Œå¯ä»¥è®©ä»–ä»¬çš„å·¥ä½œæˆæœæ›´å¿«çš„è¢«ä¸–äººæ‰€çŸ¥ï¼Œä¸å¿…é”¦è¡£å¤œè¡Œ

åœ¨æœ¬æ–‡æ¡£ç¼–å†™æ—¶ï¼ŒRust å·²ç»æœ‰ä¸‰ä¸ªç‰ˆæœ¬ï¼šRust 2015ã€2018ã€2021ã€‚æœ¬ä¹¦åŸºäº `Rust 2021 edition` ç¼–å†™ã€‚

_Cargo.toml_ ä¸­çš„ `edition` å­—æ®µè¡¨æ˜ä»£ç åº”è¯¥ä½¿ç”¨å“ªä¸ªç‰ˆæœ¬ç¼–è¯‘ã€‚å¦‚æœè¯¥å­—æ®µä¸å­˜åœ¨ï¼Œå…¶é»˜è®¤ä¸º `2021` ä»¥æä¾›åå‘å…¼å®¹æ€§ã€‚

æ¯ä¸ªé¡¹ç›®éƒ½å¯ä»¥é€‰æ‹©ä¸åŒäºé»˜è®¤çš„ `Rust 2021 edition` çš„ç‰ˆæœ¬ã€‚è¿™æ ·ï¼Œç‰ˆæœ¬å¯èƒ½ä¼šåŒ…å«ä¸å…¼å®¹çš„ä¿®æ”¹ï¼Œæ¯”å¦‚æ–°ç‰ˆæœ¬ä¸­æ–°å¢çš„å…³é”®å­—å¯èƒ½ä¼šä¸è€ä»£ç ä¸­çš„æ ‡è¯†ç¬¦å†²çªå¹¶å¯¼è‡´é”™è¯¯ã€‚ä¸è¿‡ï¼Œé™¤éä½ é€‰æ‹©åº”ç”¨è¿™äº›ä¿®æ”¹ï¼Œå¦åˆ™æ—§ä»£ç ä¾ç„¶èƒ½å¤Ÿè¢«ç¼–è¯‘ï¼Œå³ä¾¿ä½ å‡çº§äº†ç¼–è¯‘å™¨ç‰ˆæœ¬ã€‚

æ‰€æœ‰ Rust ç¼–è¯‘å™¨éƒ½æ”¯æŒä»»ä½•ä¹‹å‰å­˜åœ¨çš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œå¹¶å¯ä»¥é“¾æ¥ä»»ä½•æ”¯æŒç‰ˆæœ¬çš„åŒ…ã€‚ç¼–è¯‘å™¨ä¿®æ”¹åªå½±å“æœ€åˆçš„è§£æä»£ç çš„è¿‡ç¨‹ã€‚å› æ­¤ï¼Œå¦‚æœä½ ä½¿ç”¨ `Rust 2021` è€ŒæŸä¸ªä¾èµ–ä½¿ç”¨ `Rust 2018`ï¼Œä½ çš„é¡¹ç›®ä»æ—§èƒ½å¤Ÿç¼–è¯‘å¹¶ä½¿ç”¨è¯¥ä¾èµ–ã€‚åä¹‹ï¼Œè‹¥é¡¹ç›®ä½¿ç”¨ `Rust 2018` è€Œä¾èµ–ä½¿ç”¨ `Rust 2021` äº¦å¯å·¥ä½œã€‚

æœ‰ä¸€ç‚¹éœ€è¦æ˜ç¡®ï¼šå¤§éƒ¨åˆ†åŠŸèƒ½åœ¨æ‰€æœ‰ç‰ˆæœ¬ä¸­éƒ½èƒ½ä½¿ç”¨ã€‚å¼€å‘è€…ä½¿ç”¨ä»»ä½• Rust ç‰ˆæœ¬å°†èƒ½ç»§ç»­æ¥æ”¶æœ€æ–°ç¨³å®šç‰ˆçš„æ”¹è¿›ã€‚ç„¶è€Œåœ¨ä¸€äº›æƒ…å†µï¼Œä¸»è¦æ˜¯å¢åŠ äº†æ–°å…³é”®å­—çš„æ—¶å€™ï¼Œåˆ™å¯èƒ½å‡ºç°äº†åªèƒ½ç”¨äºæ–°ç‰ˆæœ¬çš„åŠŸèƒ½ã€‚åªéœ€åˆ‡æ¢ç‰ˆæœ¬å³å¯åˆ©ç”¨æ–°ç‰ˆæœ¬çš„åŠŸèƒ½ã€‚

è¯·æŸ¥çœ‹ [Edition Guide](https://rust-lang-nursery.github.io/edition-guide/) äº†è§£æ›´å¤šç»†èŠ‚ï¼Œè¿™æ˜¯ä¸€ä¸ªå®Œå…¨ä»‹ç»ç‰ˆæœ¬çš„ä¹¦ç±ï¼ŒåŒ…æ‹¬å¦‚ä½•é€šè¿‡ `cargo fix` è‡ªåŠ¨å°†ä»£ç è¿ç§»åˆ°æ–°ç‰ˆæœ¬ã€‚

## Rust è‡ªèº«å¼€å‘æµç¨‹

æœ¬é™„å½•ä»‹ç» Rust è¯­è¨€è‡ªèº«æ˜¯å¦‚ä½•å¼€å‘çš„ä»¥åŠè¿™å¦‚ä½•å½±å“ä½œä¸º Rust å¼€å‘è€…çš„ä½ ã€‚

### æ— åœæ»ç¨³å®š

ä½œä¸ºä¸€ä¸ªè¯­è¨€ï¼ŒRust **ååˆ†** æ³¨é‡ä»£ç çš„ç¨³å®šæ€§ã€‚æˆ‘ä»¬å¸Œæœ› Rust æˆä¸ºä½ ä»£ç åšå®çš„åŸºç¡€ï¼Œå‡å¦‚æŒç»­åœ°æœ‰ä¸œè¥¿åœ¨å˜ï¼Œè¿™ä¸ªå¸Œæœ›å°±å®ç°ä¸äº†ã€‚ä½†ä¸æ­¤åŒæ—¶ï¼Œå¦‚æœä¸èƒ½å®éªŒæ–°åŠŸèƒ½çš„è¯ï¼Œåœ¨å‘å¸ƒä¹‹å‰æˆ‘ä»¬åˆæ— æ³•å‘ç°å…¶ä¸­é‡å¤§çš„ç¼ºé™·ï¼Œè€Œä¸€æ—¦å‘å¸ƒä¾¿å†ä¹Ÿæ²¡æœ‰ä¿®æ”¹çš„æœºä¼šäº†ã€‚

å¯¹äºè¿™ä¸ªé—®é¢˜æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆè¢«ç§°ä¸º â€œæ— åœæ»ç¨³å®šâ€ï¼ˆâ€œstability without stagnationâ€ï¼‰ï¼Œå…¶æŒ‡å¯¼æ€§åŸåˆ™æ˜¯ï¼šæ— éœ€æ‹…å¿ƒå‡çº§åˆ°æœ€æ–°çš„ç¨³å®šç‰ˆ Rustã€‚æ¯æ¬¡å‡çº§åº”è¯¥æ˜¯æ— ç—›çš„ï¼Œå¹¶åº”å¸¦æ¥æ–°åŠŸèƒ½ï¼Œæ›´å°‘çš„ Bug å’Œæ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦ã€‚

### Choo, Choo! ~~ å°ç«è½¦å‘å¸ƒæµç¨‹å¯åŠ¨

å¼€å‘ Rust è¯­è¨€æ˜¯åŸºäºä¸€ä¸ª**ç«è½¦æ—¶åˆ»è¡¨**æ¥è¿›è¡Œçš„ï¼šæ‰€æœ‰çš„å¼€å‘å·¥ä½œåœ¨ Master åˆ†æ”¯ä¸Šå®Œæˆï¼Œä½†æ˜¯å‘å¸ƒå°±åƒç«è½¦æ—¶åˆ»è¡¨ä¸€æ ·ï¼Œæ‹¥æœ‰ä¸åŒçš„æ—¶é—´ï¼Œå‘å¸ƒé‡‡ç”¨çš„è½¯ä»¶å‘å¸ƒåˆ—è½¦æ¨¡å‹ï¼Œè¢«ç”¨äºæ€ç§‘ IOS ç­‰å…¶å®ƒè½¯ä»¶é¡¹ç›®ã€‚Rust æœ‰ä¸‰ä¸ª **å‘å¸ƒé€šé“**ï¼ˆ_release channel_ï¼‰ï¼š

- Nightly
- Beta
- Stableï¼ˆç¨³å®šç‰ˆï¼‰

å¤§éƒ¨åˆ† Rust å¼€å‘è€…ä¸»è¦é‡‡ç”¨ç¨³å®šç‰ˆé€šé“ï¼Œä¸è¿‡å¸Œæœ›å®éªŒæ–°åŠŸèƒ½çš„å¼€å‘è€…å¯èƒ½ä¼šä½¿ç”¨ nightly æˆ– beta ç‰ˆã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªå¼€å‘å’Œå‘å¸ƒè¿‡ç¨‹å¦‚ä½•è¿è½¬çš„ä¾‹å­ï¼šå‡è®¾ Rust å›¢é˜Ÿæ­£åœ¨è¿›è¡Œ Rust 1.5 çš„å‘å¸ƒå·¥ä½œã€‚è¯¥ç‰ˆæœ¬å‘å¸ƒäº 2015 å¹´ 12 æœˆï¼Œè¿™ä¸ªç‰ˆæœ¬å’Œæ—¶é—´æ˜¾ç„¶æ¯”è¾ƒè€äº†ï¼Œä¸è¿‡è¿™é‡Œåªæ˜¯ä¸ºäº†æä¾›ä¸€ä¸ªçœŸå®çš„ç‰ˆæœ¬ã€‚Rust æ–°å¢äº†ä¸€é¡¹åŠŸèƒ½ï¼šä¸€ä¸ª `master` åˆ†æ”¯çš„æ–°æäº¤ã€‚æ¯å¤©æ™šä¸Šï¼Œä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„ nightly ç‰ˆæœ¬ã€‚æ¯å¤©éƒ½æ˜¯å‘å¸ƒç‰ˆæœ¬çš„æ—¥å­ï¼Œè€Œè¿™äº›å‘å¸ƒç”±å‘å¸ƒåŸºç¡€è®¾æ–½è‡ªåŠ¨å®Œæˆã€‚æ‰€ä»¥éšç€æ—¶é—´æ¨ç§»ï¼Œå‘å¸ƒè½¨è¿¹çœ‹èµ·æ¥åƒè¿™æ ·ï¼Œç‰ˆæœ¬ä¸€å¤©ä¸€å‘ï¼š

```text
nightly: * - - * - - *
```

æ¯ 6 å‘¨æ—¶é—´ï¼Œæ˜¯å‡†å¤‡å‘å¸ƒæ–°ç‰ˆæœ¬çš„æ—¶å€™äº†ï¼Rust ä»“åº“çš„ `beta` åˆ†æ”¯ä¼šä»ç”¨äº nightly çš„ `master` åˆ†æ”¯äº§ç”Ÿã€‚ç°åœ¨ï¼Œæœ‰äº†ä¸¤ä¸ªå‘å¸ƒç‰ˆæœ¬ï¼š

```text
nightly: * - - * - - *
                     |
beta:                *
```

å¤§éƒ¨åˆ† Rust ç”¨æˆ·ä¸ä¼šä¸»è¦ä½¿ç”¨ beta ç‰ˆæœ¬ï¼Œä¸è¿‡åœ¨ CI ç³»ç»Ÿä¸­å¯¹ beta ç‰ˆæœ¬è¿›è¡Œæµ‹è¯•èƒ½å¤Ÿå¸®åŠ© Rust å‘ç°å¯èƒ½çš„å›å½’ç¼ºé™·ï¼ˆregressionï¼‰ã€‚åŒæ—¶ï¼Œæ¯å¤©ä»äº§ç”Ÿ nightly å‘å¸ƒï¼š

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

æ¯”å¦‚æˆ‘ä»¬å‘ç°äº†ä¸€ä¸ªå›å½’ç¼ºé™·ã€‚å¥½æ¶ˆæ¯æ˜¯åœ¨è¿™äº›ç¼ºé™·æµå…¥ç¨³å®šå‘å¸ƒä¹‹å‰è¿˜æœ‰ä¸€äº›æ—¶é—´æ¥æµ‹è¯• beta ç‰ˆæœ¬ï¼fix è¢«åˆå¹¶åˆ° `master`ï¼Œä¸ºæ­¤ nightly ç‰ˆæœ¬å¾—åˆ°äº†ä¿®å¤ï¼Œæ¥ç€è¿™äº› fix å°† backport åˆ° `beta` åˆ†æ”¯ï¼Œä¸€ä¸ªæ–°çš„ beta å‘å¸ƒå°±äº§ç”Ÿäº†ï¼š

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

ç¬¬ä¸€ä¸ª beta ç‰ˆçš„ 6 å‘¨åï¼Œæ˜¯å‘å¸ƒç¨³å®šç‰ˆçš„æ—¶å€™äº†ï¼`stable` åˆ†æ”¯ä» `beta` åˆ†æ”¯ç”Ÿæˆï¼š

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

å¥½çš„ï¼Rust 1.5 å‘å¸ƒäº†ï¼ç„¶è€Œï¼Œæˆ‘ä»¬å¿˜äº†äº›ä¸œè¥¿ï¼šå› ä¸ºåˆè¿‡äº† 6 å‘¨ï¼Œæˆ‘ä»¬è¿˜éœ€å‘å¸ƒ **æ–°ç‰ˆ** Rust çš„ beta ç‰ˆï¼ŒRust 1.6ã€‚æ‰€ä»¥ä» `beta` åˆ†æ”¯ç”Ÿæˆ `stable` åˆ†æ”¯åï¼Œæ–°ç‰ˆçš„ `beta` åˆ†æ”¯ä¹Ÿå†æ¬¡ä» `nightly` ç”Ÿæˆï¼š

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

è¿™è¢«ç§°ä¸º â€œtrain modelâ€ï¼Œå› ä¸ºæ¯ 6 å‘¨ï¼Œä¸€ä¸ªç‰ˆæœ¬ â€œç¦»å¼€è½¦ç«™â€ï¼ˆâ€œleaves the stationâ€ï¼‰ï¼Œä¸è¿‡ä» beta é€šé“åˆ°è¾¾ç¨³å®šé€šé“è¿˜æœ‰ä¸€æ®µæ—…ç¨‹ã€‚

Rust æ¯ 6 å‘¨å‘å¸ƒä¸€ä¸ªç‰ˆæœ¬ï¼Œå¦‚æ—¶é’Ÿèˆ¬å‡†ç¡®ã€‚å¦‚æœä½ çŸ¥é“äº†æŸä¸ª Rust ç‰ˆæœ¬çš„å‘å¸ƒæ—¶é—´ï¼Œå°±å¯ä»¥çŸ¥é“ä¸‹ä¸ªç‰ˆæœ¬çš„æ—¶é—´ï¼š6 å‘¨åã€‚æ¯ 6 å‘¨å‘å¸ƒç‰ˆæœ¬çš„ä¸€ä¸ªå¥½çš„æ–¹é¢æ˜¯ä¸‹ä¸€ç­è½¦ä¼šæ¥å¾—æ›´å¿«ã€‚å¦‚æœç‰¹å®šç‰ˆæœ¬ç¢°å·§ç¼ºå¤±æŸä¸ªåŠŸèƒ½ä¹Ÿæ— éœ€æ‹…å¿ƒï¼šå¦ä¸€ä¸ªç‰ˆæœ¬å¾ˆå¿«å°±ä¼šåˆ°æ¥ï¼è¿™æœ‰åŠ©äºå‡å°‘å› ä¸´è¿‘å‘ç‰ˆæ—¶é—´è€Œå·å·é‡Šå‡ºæœªç»å®Œå–„çš„åŠŸèƒ½çš„å‹åŠ›ã€‚

å¤šäºäº†è¿™ä¸ªè¿‡ç¨‹ï¼Œä½ æ€»æ˜¯å¯ä»¥åˆ‡æ¢åˆ°ä¸‹ä¸€ç‰ˆæœ¬çš„ Rust å¹¶éªŒè¯æ˜¯å¦å¯ä»¥è½»æ˜“çš„å‡çº§ï¼šå¦‚æœ beta ç‰ˆä¸èƒ½å¦‚æœŸå·¥ä½œï¼Œä½ å¯ä»¥å‘ Rust å›¢é˜ŸæŠ¥å‘Šå¹¶åœ¨å‘å¸ƒç¨³å®šç‰ˆä¹‹å‰å¾—åˆ°ä¿®å¤ï¼beta ç‰ˆé€ æˆçš„ç ´åæ˜¯éå¸¸å°‘è§çš„ï¼Œä¸è¿‡ `rustc` ä¹Ÿä¸è¿‡æ˜¯ä¸€ä¸ªè½¯ä»¶ï¼Œå¯èƒ½ä¼šå­˜åœ¨ Bugã€‚

### ä¸ç¨³å®šåŠŸèƒ½

è¿™ä¸ªå‘å¸ƒæ¨¡å‹ä¸­å¦ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹ï¼šä¸ç¨³å®šåŠŸèƒ½ï¼ˆunstable featuresï¼‰ã€‚Rust ä½¿ç”¨ä¸€ä¸ªè¢«ç§°ä¸º â€œåŠŸèƒ½æ ‡è®°â€ï¼ˆâ€œfeature flagsâ€ï¼‰çš„æŠ€æœ¯æ¥ç¡®å®šç»™å®šç‰ˆæœ¬çš„æŸä¸ªåŠŸèƒ½æ˜¯å¦å¯ç”¨ã€‚å¦‚æœæ–°åŠŸèƒ½æ­£åœ¨ç§¯æåœ°å¼€å‘ä¸­ï¼Œå…¶æäº¤åˆ°äº† `master`ï¼Œå› æ­¤ä¼šå‡ºç°åœ¨ nightly ç‰ˆä¸­ï¼Œä¸è¿‡ä¼šä½äºä¸€ä¸ª **åŠŸèƒ½æ ‡è®°** ä¹‹åã€‚ä½œä¸ºç”¨æˆ·ï¼Œå¦‚æœä½ å¸Œæœ›å°è¯•è¿™ä¸ªæ­£åœ¨å¼€å‘çš„åŠŸèƒ½ï¼Œåˆ™å¯ä»¥åœ¨æºç ä¸­ä½¿ç”¨åˆé€‚çš„æ ‡è®°æ¥å¼€å¯ï¼Œä¸è¿‡å¿…é¡»ä½¿ç”¨ nightly ç‰ˆã€‚

å¦‚æœä½¿ç”¨çš„æ˜¯ beta æˆ–ç¨³å®šç‰ˆ Rustï¼Œåˆ™ä¸èƒ½ä½¿ç”¨ä»»ä½•åŠŸèƒ½æ ‡è®°ã€‚è¿™æ˜¯åœ¨æ–°åŠŸèƒ½è¢«å®£å¸ƒä¸ºæ°¸ä¹…ç¨³å®šä¹‹å‰è·å¾—å®ç”¨ä»·å€¼çš„å…³é”®ã€‚è¿™æ—¢æ»¡è¶³äº†å¸Œæœ›ä½¿ç”¨æœ€å°–ç«¯æŠ€æœ¯çš„åŒå­¦ï¼Œé‚£äº›åšæŒç¨³å®šç‰ˆçš„åŒå­¦ä¹ŸçŸ¥é“å…¶ä»£ç ä¸ä¼šè¢«ç ´åã€‚è¿™å°±æ˜¯æ— åœæ»ç¨³å®šã€‚

æœ¬ä¹¦åªåŒ…å«ç¨³å®šçš„åŠŸèƒ½ï¼Œå› ä¸ºè¿˜åœ¨å¼€å‘ä¸­çš„åŠŸèƒ½ä»å¯èƒ½æ”¹å˜ï¼Œå½“å…¶è¿›å…¥ç¨³å®šç‰ˆæ—¶è‚¯å®šä¼šä¸ç¼–å†™æœ¬ä¹¦çš„æ—¶å€™æœ‰æ‰€ä¸åŒã€‚ä½ å¯ä»¥åœ¨ç½‘ä¸Šè·å– nightly ç‰ˆçš„æ–‡æ¡£ã€‚

### Rustup å’Œ Rust Nightly çš„èŒè´£

#### å®‰è£… Rust Nightly ç‰ˆæœ¬

Rustup ä½¿å¾—æ”¹å˜ä¸åŒå‘å¸ƒé€šé“çš„ Rust æ›´ä¸ºç®€å•ï¼Œå…¶åœ¨å…¨å±€æˆ–åˆ†é¡¹ç›®çš„å±‚æ¬¡å·¥ä½œã€‚å…¶é»˜è®¤ä¼šå®‰è£…ç¨³å®šç‰ˆ Rustã€‚ä¾‹å¦‚ä¸ºäº†å®‰è£… nightlyï¼š

```text
$ rustup install nightly
```

ä½ ä¼šå‘ç° `rustup` ä¹Ÿå®‰è£…äº†æ‰€æœ‰çš„ **å·¥å…·é“¾**ï¼ˆ_toolchains_ï¼Œ Rust å’Œå…¶ç›¸å…³ç»„ä»¶ï¼‰ã€‚å¦‚ä¸‹æ˜¯ä¸€ä½ä½œè€…çš„ Windows è®¡ç®—æœºä¸Šçš„ä¾‹å­ï¼š

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

#### åœ¨æŒ‡å®šç›®å½•ä½¿ç”¨ Rust Nightly

å¦‚ä½ æ‰€è§ï¼Œé»˜è®¤æ˜¯ç¨³å®šç‰ˆã€‚å¤§éƒ¨åˆ† Rust ç”¨æˆ·åœ¨å¤§éƒ¨åˆ†æ—¶é—´ä½¿ç”¨ç¨³å®šç‰ˆã€‚ä½ å¯èƒ½ä¹Ÿä¼šè¿™ä¹ˆåšï¼Œä¸è¿‡å¦‚æœä½ å…³å¿ƒæœ€æ–°çš„åŠŸèƒ½ï¼Œå¯ä»¥ä¸ºç‰¹å®šé¡¹ç›®ä½¿ç”¨ nightly ç‰ˆã€‚ä¸ºæ­¤ï¼Œå¯ä»¥åœ¨é¡¹ç›®ç›®å½•ä½¿ç”¨ `rustup override` æ¥è®¾ç½®å½“å‰ç›®å½• `rustup` ä½¿ç”¨ nightly å·¥å…·é“¾ï¼š

```text
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

ç°åœ¨ï¼Œæ¯æ¬¡åœ¨ *~/éœ€è¦ nightly çš„é¡¹ç›®/*ä¸‹(åœ¨é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹ï¼Œä¹Ÿå°±æ˜¯ `Cargo.toml` æ‰€åœ¨çš„ç›®å½•) è°ƒç”¨ `rustc` æˆ– `cargo`ï¼Œ`rustup` ä¼šç¡®ä¿ä½¿ç”¨ nightly ç‰ˆ Rustã€‚åœ¨ä½ æœ‰å¾ˆå¤š Rust é¡¹ç›®æ—¶å¤§æœ‰è£¨ç›Šï¼

### RFC è¿‡ç¨‹å’Œå›¢é˜Ÿ

é‚£ä¹ˆä½ å¦‚ä½•äº†è§£è¿™äº›æ–°åŠŸèƒ½å‘¢ï¼ŸRust å¼€å‘æ¨¡å¼éµå¾ªä¸€ä¸ª **Request For Comments (RFC) è¿‡ç¨‹**ã€‚å¦‚æœä½ å¸Œæœ›æ”¹è¿› Rustï¼Œå¯ä»¥ç¼–å†™ä¸€ä¸ªæè®®ï¼Œä¹Ÿå°±æ˜¯ RFCã€‚

ä»»ä½•äººéƒ½å¯ä»¥ç¼–å†™ RFC æ¥æ”¹è¿› Rustï¼ŒåŒæ—¶è¿™äº› RFC ä¼šè¢« Rust å›¢é˜Ÿè¯„å®¡å’Œè®¨è®ºï¼Œä»–ä»¬ç”±å¾ˆå¤šä¸åŒåˆ†å·¥çš„å­å›¢é˜Ÿç»„æˆã€‚è¿™é‡Œæ˜¯ [Rust å®˜ç½‘](https://www.rust-lang.org/governance) ä¸Šæ‰€æœ‰å›¢é˜Ÿçš„æ€»åˆ—è¡¨ï¼Œå…¶åŒ…å«äº†é¡¹ç›®ä¸­æ¯ä¸ªé¢†åŸŸçš„å›¢é˜Ÿï¼šè¯­è¨€è®¾è®¡ã€ç¼–è¯‘å™¨å®ç°ã€åŸºç¡€è®¾æ–½ã€æ–‡æ¡£ç­‰ã€‚å„ä¸ªå›¢é˜Ÿä¼šé˜…è¯»ç›¸åº”çš„æè®®å’Œè¯„è®ºï¼Œç¼–å†™å›å¤ï¼Œå¹¶æœ€ç»ˆè¾¾æˆæ¥å—æˆ–å›ç»åŠŸèƒ½çš„ä¸€è‡´ã€‚

å¦‚æœåŠŸèƒ½è¢«æ¥å—äº†ï¼Œåœ¨ Rust ä»“åº“ä¼šæ‰“å¼€ä¸€ä¸ª issueï¼Œäººä»¬å°±å¯ä»¥å®ç°å®ƒã€‚å®ç°åŠŸèƒ½çš„äººå¯èƒ½ä¸æ˜¯æœ€åˆæè®®åŠŸèƒ½çš„äººï¼å½“å®ç°å®Œæˆåï¼Œå…¶ä¼šåˆå¹¶åˆ° `master` åˆ†æ”¯å¹¶ä½äºä¸€ä¸ªç‰¹æ€§å¼€å…³ï¼ˆfeature gateï¼‰ä¹‹åï¼Œæ­£å¦‚[ä¸ç¨³å®šåŠŸèƒ½](#ä¸ç¨³å®šåŠŸèƒ½) éƒ¨åˆ†æ‰€è®¨è®ºçš„ã€‚

åœ¨ç¨åçš„æŸä¸ªæ—¶é—´ï¼Œä¸€æ—¦ä½¿ç”¨ nightly ç‰ˆçš„ Rust å›¢é˜Ÿèƒ½å¤Ÿå°è¯•è¿™ä¸ªåŠŸèƒ½äº†ï¼Œå›¢é˜Ÿæˆå‘˜ä¼šè®¨è®ºè¿™ä¸ªåŠŸèƒ½åœ¨ nightly ä¸­è¿è¡Œçš„æƒ…å†µï¼Œå¹¶å†³å®šæ˜¯å¦åº”è¯¥è¿›å…¥ç¨³å®šç‰ˆã€‚å¦‚æœå†³å®šç»§ç»­æ¨è¿›ï¼Œç‰¹æ€§å¼€å…³ä¼šç§»é™¤ï¼Œç„¶åè¿™ä¸ªåŠŸèƒ½å°±è¢«è®¤ä¸ºæ˜¯ç¨³å®šçš„äº†ï¼ä¹˜ç€â€œå‘å¸ƒçš„åˆ—è½¦â€ï¼Œæœ€ç»ˆåœ¨æ–°çš„ç¨³å®šç‰ˆ Rust ä¸­å‡ºç°ã€‚



================================================
FILE: src/appendix/rust-versions/1.58.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.58 | é‡ç‚¹: æ ¼å¼åŒ–å­—ç¬¦ä¸²æ•è·ç¯å¢ƒä¸­çš„å€¼

ä¼—æ‰€å‘¨çŸ¥ï¼ŒRust å°ç‰ˆæœ¬å‘å¸ƒéå¸¸é¢‘ç¹ï¼Œ6 å‘¨å°±å‘å¸ƒä¸€æ¬¡ï¼Œå› æ­¤é€šå¸¸ä¸ä¼šæœ‰ç‰¹åˆ«å€¼å¾—æ™®é€šç”¨æˆ·å…³æ³¨çš„å†…å®¹ï¼Œä½†æ˜¯è¿™æ¬¡ 1.58 ç‰ˆæœ¬ä¸åŒï¼Œæ–°å¢äº†(stable åŒ–äº†)ä¸€ä¸ªéå¸¸å¥½ç”¨çš„åŠŸèƒ½ï¼š **åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¶æ•è·ç¯å¢ƒä¸­çš„å€¼**ã€‚

> Rust 1.58 å®˜æ–¹ release doc: [Announcing Rust 1.58.0 | Rust Blog](https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html)

## åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¶æ•è·ç¯å¢ƒä¸­çš„å€¼

åœ¨ä»¥å‰ï¼Œæƒ³è¦è¾“å‡ºä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œä½ éœ€è¦è¿™ä¹ˆåšï¼š

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let p = get_person();
    println!("Hello, {}!", p);                // implicit position
    println!("Hello, {0}!", p);               // explicit index
    println!("Hello, {person}!", person = p);
}
```

é—®é¢˜å€’ä¹Ÿä¸å¤§ï¼Œä½†æ˜¯ä¸€æ—¦æ ¼å¼åŒ–å­—ç¬¦ä¸²é•¿äº†åï¼Œå°±ä¼šéå¸¸å†—ä½™ï¼Œè€Œåœ¨ 1.58 åï¼Œæˆ‘ä»¬å¯ä»¥è¿™ä¹ˆå†™ï¼š

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    println!("Hello, {person}!");
}
```

æ˜¯ä¸æ˜¯æ¸…æ™°ã€ç®€æ´äº†å¾ˆå¤šï¼Ÿç”šè‡³è¿˜å¯ä»¥å°†ç¯å¢ƒä¸­çš„å€¼ç”¨äºæ ¼å¼åŒ–å‚æ•°:

```rust
let (width, precision) = get_format();
for (name, score) in get_scores() {
  println!("{name}: {score:width$.precision$}");
}
```

ä½†ä¹Ÿæœ‰å±€é™ï¼Œå®ƒåªèƒ½æ•è·æ™®é€šçš„å˜é‡ï¼Œå¯¹äºæ›´å¤æ‚çš„ç±»å‹ï¼ˆä¾‹å¦‚è¡¨è¾¾å¼ï¼‰ï¼Œå¯ä»¥å…ˆå°†å®ƒèµ‹å€¼ç»™ä¸€ä¸ªå˜é‡æˆ–ä½¿ç”¨ä»¥å‰çš„ `name = expression` å½¢å¼çš„æ ¼å¼åŒ–å‚æ•°ã€‚

ç›®å‰é™¤äº† `panic!` å¤–ï¼Œå…¶å®ƒæ¥æ”¶æ ¼å¼åŒ–å‚æ•°çš„å®ï¼Œéƒ½å¯ä»¥ä½¿ç”¨æ–°çš„ç‰¹æ€§ã€‚å¯¹äº `panic!` è€Œè¨€ï¼Œå¦‚æœè¿˜åœ¨ä½¿ç”¨ `2015ç‰ˆæœ¬` æˆ– `2018ç‰ˆæœ¬` ç‰ˆæœ¬ ï¼Œé‚£ `panic!("{ident}")` ä¾ç„¶ä¼šè¢«å½“æˆ æ­£å¸¸çš„å­—ç¬¦ä¸²æ¥å¤„ç†ï¼ŒåŒæ—¶ç¼–è¯‘å™¨ä¼šç»™äºˆ `warn` æç¤ºã€‚è€Œå¯¹äº `2021ç‰ˆæœ¬` ï¼Œåˆ™å¯ä»¥æ­£å¸¸ä½¿ç”¨:

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    panic!("Hello, {person}!");
}
```

è¾“å‡º:

```console
thread 'main' panicked at 'Hello, sunface!', src/main.rs:6:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

## æ¯” unwrap æ›´å±é™©çš„ unwrap_unchecked

åœ¨ 1.58 ä¸­ä¸º `Option` å’Œ `Result` æ–°å¢äº† `unwrap_unchecked` æ–¹æ³•ï¼Œä¸ `unwrap` é‡åˆ°é”™è¯¯æˆ–è€…ç©ºå€¼ç›´æ¥ `panic` ä¸åŒï¼Œ`unwrap_unchecked` é‡åˆ°é”™è¯¯æ—¶å¤„ç†æ–¹å¼ç³Ÿç³•çš„å¤šï¼š

```rust
fn get_num() -> Option<i32> {
   None
}
fn main() {
    unsafe {
        let n = get_num().unwrap_unchecked();
    }
}
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```console
zsh: segmentation fault  cargo run
```

å—¯ï¼Œæ®µé”™è¯¯äº†ï¼Œå¯¹æ¯”ä¸‹ `panic`ï¼Œæœ‰ä¸€ç§æ³ªæµæ»¡é¢çš„å†²åŠ¨ï¼šæˆ‘è¦è¿™ä¸å®‰å…¨çš„æ–¹æ³•ä½•ç”¨ï¼Ÿ

å…¶å®ï¼Œè¿˜çœŸæœ‰äº›ç”¨ï¼š

- æƒ³è¦è¾ƒå°çš„å¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼ˆåµŒå…¥å¼ï¼ŒWASM ç­‰ï¼‰ï¼Œè¯¥æ–¹æ³•å°±å¯ä»¥å¤§æ˜¾èº«æ‰‹ã€‚å› ä¸º `panic` ä¼šå¯¼è‡´[äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å˜å¤§ä¸å°‘](https://zhuanlan.zhihu.com/p/445465092)
- å®ƒè¿˜å¯ä»¥æé«˜ä¸€ç‚¹æ€§èƒ½ï¼Œ å› ä¸ºç¼–è¯‘å™¨å¯èƒ½æ— æ³•ä¼˜åŒ–æ‰ `unwrap` çš„æŒ‡ä»¤åˆ†æ”¯ï¼Œ è™½ç„¶å®ƒåªä¼šå¢åŠ åŒºåŒºå‡ æ¡åˆ†æ”¯é¢„æµ‹æŒ‡ä»¤



================================================
FILE: src/appendix/rust-versions/1.59.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.59 | é‡ç‚¹: å†…è”æ±‡ç¼–ã€è§£æ„å¼èµ‹å€¼

Rust å›¢é˜Ÿäºä»Šå¤©å‡Œæ™¨( 2022-02-25 )å‘å¸ƒäº†æœ€æ–°çš„ 1.59 ç‰ˆæœ¬ï¼Œå…¶ä¸­æœ€å¼•äººç©ç›®çš„ç‰¹æ€§åº”è¯¥å°±æ˜¯æ”¯æŒåœ¨ä»£ç ä¸­å†…è”æ±‡ç¼–äº†ï¼Œä¸€èµ·æ¥çœ‹çœ‹ã€‚

## å†…è”æ±‡ç¼–( inline assembly )

è¯¥ç‰¹æ€§å¯¹äºéœ€è¦åº•å±‚æ§åˆ¶çš„åº”ç”¨éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚æƒ³è¦æ§åˆ¶åº•å±‚æ‰§è¡Œã€è®¿é—®ç‰¹å®šçš„æœºå™¨æŒ‡ä»¤ç­‰ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœç›®æ ‡å¹³å°æ˜¯ `x86-64` æ—¶ï¼Œä½ å¯ä»¥è¿™ä¹ˆå†™ï¼š

```rust
use std::arch::asm;

// ä½¿ç”¨ shifts å’Œ adds å®ç° x ä¹˜ä»¥ 6
let mut x: u64 = 4;
unsafe {``
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
```

å¤§å®¶å‘ç°æ²¡ï¼Œè¿™é‡Œçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„ä½¿ç”¨æ–¹å¼è·Ÿæˆ‘ä»¬å¹³æ—¶çš„ `println!`ã€`format!` å¹¶æ— åŒºåˆ«ï¼Œ é™¤äº† `asm!` ä¹‹å¤–ï¼Œ `global_asm!` å®ä¹Ÿå¯ä»¥è¿™ä¹ˆä½¿ç”¨ã€‚

å†…è”æ±‡ç¼–ä¸­ä½¿ç”¨çš„æ±‡ç¼–è¯­è¨€å’ŒæŒ‡ä»¤å–å†³äºç›¸åº”çš„æœºå™¨å¹³å°ï¼Œæˆªè‡³ç›®å‰ï¼ŒRust æ”¯æŒä»¥ä¸‹å¹³å°çš„å†…è”æ±‡ç¼–ï¼š

- x86 å’Œ x86-64
- ARM
- AArch64
- RISC-V

å¦‚æœå¤§å®¶å¸Œæœ›æ·±å…¥äº†è§£ï¼Œå¯ä»¥çœ‹å®˜æ–¹çš„ [Reference](https://doc.rust-lang.org/nightly/reference/inline-assembly.html) æ–‡æ¡£ï¼ŒåŒæ—¶åœ¨ [Rust Exercise](https://zh.exercise.rs/unsafe/inline-asm) ä¸­æä¾›äº†æ›´å¤šçš„ç¤ºä¾‹(ç›®å‰æ­£åœ¨ç¿»è¯‘ä¸­..)ã€‚

## è§£æ„å¼èµ‹å€¼( Destructuring assignments)

ç°åœ¨ä½ å¯ä»¥åœ¨èµ‹å€¼è¯­å¥çš„å·¦å¼ä¸­ä½¿ç”¨å…ƒç»„ã€åˆ‡ç‰‡å’Œç»“æ„ä½“æ¨¡å¼äº†ã€‚

```rust
let (a, b, c, d, e);

(a, b) = (1, 2);
[c, .., d, _] = [1, 2, 3, 4, 5];
Struct { e, .. } = Struct { e: 5, f: 3 };

assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

è¿™ç§ä½¿ç”¨æ–¹å¼è·Ÿ `let` ä¿æŒäº†ä¸€è‡´æ€§ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ï¼Œä½¿ç”¨ `+=` çš„èµ‹å€¼è¯­å¥è¿˜ä¸æ”¯æŒè§£æ„å¼èµ‹å€¼ã€‚

## const æ³›å‹

#### ä¸ºå‚æ•°è®¾ç½®é»˜è®¤å€¼

ç°åœ¨æˆ‘ä»¬å¯ä»¥ä¸º const æ³›å‹å‚æ•°è®¾ç½®é»˜è®¤å€¼ï¼š

```rust
struct ArrayStorage<T, const N: usize = 2> {
    arr: [T; N],
}

impl<T> ArrayStorage<T> {
    fn new(a: T, b: T) -> ArrayStorage<T> {
        ArrayStorage {
            arr: [a, b],
        }
    }
}
```

#### å–æ¶ˆå‚æ•°é¡ºåºçš„é™åˆ¶

åœ¨ä¹‹å‰ç‰ˆæœ¬ä¸­ï¼Œç±»å‹å‚æ•°å¿…é¡»è¦åœ¨æ‰€æœ‰çš„ const æ³›å‹å‚æ•°ä¹‹å‰ï¼Œç°åœ¨ï¼Œè¿™ä¸ªé™åˆ¶è¢«æ”¾å®½äº†ï¼Œä¾‹å¦‚ä½ å¯ä»¥è¿™æ ·äº¤æ›¿æ’åˆ—å®ƒä»¬ï¼š

```rust
fn cartesian_product<
    T, const N: usize,
    U, const M: usize,
    V, F
>(a: [T; N], b: [U; M], f: F) -> [[V; N]; M]
where
    F: FnMut(&T, &U) -> V
{
    // ...
}
```

## ç¼©å°äºŒè¿›åˆ¶æ–‡ä»¶ä½“ç§¯ï¼šåˆ é™¤ debug ä¿¡æ¯

å¯¹äºå—é™çš„ç¯å¢ƒæ¥è¯´ï¼Œç¼©å°ç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä½“ç§¯æ˜¯éå¸¸é‡è¦çš„ã€‚

ä»¥å¾€æˆ‘ä»¬å¯ä»¥åœ¨äºŒè¿›åˆ¶æ–‡ä»¶è¢«åˆ›å»ºåï¼Œæ‰‹åŠ¨çš„æ¥å®Œæˆã€‚ç°åœ¨ cargo å’Œ rustc æ”¯æŒåœ¨é“¾æ¥( linked )åå°±åˆ é™¤ debug ä¿¡æ¯ï¼Œåœ¨ `Cargo.toml` ä¸­æ–°å¢ä»¥ä¸‹é…ç½®ï¼š

```toml
[profile.release]
strip = "debuginfo"
```

ä»¥ä¸Šé…ç½®ä¼šå°† `release` äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„ debug ä¿¡æ¯ç§»é™¤ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ `"symbols"` æˆ– `true` é€‰é¡¹æ¥ç§»é™¤æ‰€æœ‰æ”¯æŒçš„ `symbol` ä¿¡æ¯ã€‚

æ ¹æ® reddit ç½‘å‹çš„æµ‹è¯•ï¼Œå¦‚æœä½¿ç”¨äº† `strip = true`ï¼Œé‚£ç¼–è¯‘åçš„ä½“ç§¯å°†å¤§å¹…å‡å°‘(50% å·¦å³):

- å…ˆä½¿ç”¨ `lto = true` : 4,397,320 bytes
- å†ä½¿ç”¨ `strip = true` : 2,657,304 bytes
- æœ€å `opt-level = "z"` : 1,857,680 bytes

å¦‚æœæ˜¯ WASMï¼Œè¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹é…ç½®è¿›ä¸€æ­¥å‡å°‘ä½“ç§¯:

```toml
[package.metadata.wasm-pack.profile.release]
wasm-opt = ['-Os']
```

[github ä¸Šä¸€ä¸ªå¼€æºä»“åº“](https://github.com/rsadsb/adsb_deku/blob/master/CHANGELOG.md#unreleased)ä¹Ÿè¯æ˜äº†è¿™ä¸€ç‚¹ï¼Œæ€»ä½“æ¥çœ‹ï¼Œè¿™ä¸ªé…ç½®çš„æ•ˆæœæ˜¯éå¸¸æ˜¾è‘—çš„ï¼

## é»˜è®¤å…³é—­å¢é‡ç¼–è¯‘

1.59.0 ç‰ˆæœ¬é»˜è®¤å…³é—­äº†å¢é‡ç¼–è¯‘çš„åŠŸèƒ½ï¼ˆä½ å¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡æ˜¾å¼åœ°å¯ç”¨ï¼š`RUSTC_FORCE_INCREMENTAL=1` ï¼‰ï¼Œè¿™ä¼šé™ä½å·²çŸ¥ Bug [#94124](https://github.com/rust-lang/rust/issues/94124) çš„å½±å“ï¼Œè¯¥ Bug ä¼šå¯¼è‡´å¢é‡ç¼–è¯‘è¿‡ç¨‹ä¸­çš„ååºåˆ—åŒ–é”™è¯¯å’Œ `panic`ã€‚

ä¸è¿‡å¤§å®¶ä¹Ÿä¸ç”¨æ‹…å¿ƒï¼Œè¿™ä¸ª Bug ä¼šåœ¨ 1.60.0 ç‰ˆæœ¬ä¿®å¤ï¼Œä¹Ÿå°±æ˜¯ 6 å‘¨åï¼Œå¢é‡ç¼–è¯‘ä¼šé‡æ–°è®¾ç½®ä¸ºé»˜è®¤å¼€å¯ï¼Œå¦‚æœæ²¡æœ‰æ„å¤–çš„è¯ :)

## ç¨³å®šåŒ–çš„ API åˆ—è¡¨

ä¸€äº›æ–¹æ³•å’Œç‰¹å¾å®ç°ç°åœ¨å·²ç»å¯ä»¥ stable ä¸­ä½¿ç”¨ï¼Œå…·ä½“è§[å®˜æ–¹å‘å¸ƒè¯´æ˜](https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.60.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.60 | é‡ç‚¹: æŸ¥çœ‹ Cargo æ„å»ºè€—æ—¶è¯¦æƒ…ã€Cargo Feature å¢åŠ æ–°è¯­æ³•

> åŸæ–‡é“¾æ¥: https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html


é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.60 ç‰ˆæœ¬:
```shell
$ rustup update stable
```

## åŸºäºæºç çš„ä»£ç è¦†ç›–
rustc æ–°å¢äº†åŸºäº LLVM çš„ä»£ç è¦†ç›–ç‡æµ‹é‡ï¼Œæƒ³è¦æµ‹è¯•çš„åŒå­¦å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼é‡æ–°æ„å»ºä½ çš„é¡¹ç›®:
```shell
$ RUSTFLAGS="-C instrument-coverage" cargo build
```

è¿è¡Œæ–°ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶å°†åœ¨å½“å‰ç›®å½•ä¸‹äº§ç”Ÿä¸€ä¸ª `default.profraw` æ–‡ä»¶( è·¯å¾„å’Œæ–‡ä»¶åå¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡è¿›è¡Œ[è¦†ç›–](https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data) )ã€‚

`llvm-tools-preview` ç»„ä»¶åŒ…å«äº† `llvm-profdata`ï¼Œå¯ä»¥ç”¨äºå¤„ç†å’Œåˆå¹¶<ruby>åŸç”Ÿçš„æµ‹é‡ç»“æœè¾“å‡º<rt>raw profile output)</rt></ruby>(æµ‹é‡åŒºåŸŸæ‰§è¡Œæ•°)ã€‚

`llvm-cov` ç”¨äºæŠ¥å‘Šç”Ÿæˆï¼Œå®ƒå°† `llvm-profdata` å¤„ç†åçš„è¾“å‡ºè·ŸäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶è‡ªèº«ç›¸ç»“åˆï¼Œå¯¹äºå‰è€…å¤§å®¶å¯èƒ½å¥½ç†è§£ï¼Œä½†æ˜¯ä¸ºä½•è¦è·Ÿåè€…å¯æ‰§è¡Œæ–‡ä»¶ç›¸ç»“åˆå‘¢ï¼ŸåŸå› åœ¨äºå¯æ‰§è¡Œæ–‡ä»¶ä¸­åµŒå…¥äº†ä¸€ä¸ªä»è®¡æ•°å™¨åˆ°å®é™…æºä»£ç å•å…ƒçš„æ˜ å°„ã€‚

```shell
rustup component add llvm-tools-preview
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-profdata merge -sparse default.profraw -o default.profdata
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-cov show -Xdemangler=rustfilt target/debug/coverage-testing \
    -instr-profile=default.profdata \
    -show-line-counts-or-regions \
    -show-instantiations
```

åŸºäºä¸€ä¸ªç®€å•çš„ hello world å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ‰§è¡Œä»¥ä¸Šå‘½ä»¤å°±å¯ä»¥è·å¾—å¦‚ä¸‹å¸¦æœ‰æ ‡è®°çš„ç»“æœï¼š
```rust
1|      1|fn main() {
2|      1|    println!("Hello, world!");
3|      1|}
```

ä»ç»“æœä¸­å¯ä»¥çœ‹å‡ºï¼šæ¯ä¸€è¡Œä»£ç éƒ½å·²ç»è¢«æˆåŠŸè¦†ç›–ã€‚

å¦‚æœå¤§å®¶è¿˜æƒ³è¦äº†è§£æ›´å¤šï¼Œå¯ä»¥çœ‹ä¸‹[å®˜æ–¹çš„ rustc æ–‡æ¡£](https://doc.rust-lang.org/rustc/instrument-coverage.html)ã€‚ç›®å‰æ¥è¯´ï¼ŒåŸºå‡†åŠŸèƒ½å·²ç»ç¨³å®šäº†ï¼Œå¹¶å°†ä»¥æŸç§å½¢å¼å­˜åœ¨äºæœªæ¥æ‰€æœ‰çš„ Rust å‘å¸ƒç‰ˆæœ¬ä¸­ã€‚ ä½†è¾“å‡ºæ ¼å¼å’Œäº§ç”Ÿè¿™äº›è¾“å‡ºçš„ LLVM å·¥å…·å¯èƒ½ä¾ç„¶ä¼šå‘ç”Ÿå˜åŒ–ï¼ŒåŸºäºæ­¤ï¼Œå¤§å®¶åœ¨ä½¿ç”¨æ—¶éœ€è¦ç¡®ä¿ `llvm-tools-preview` å’Œ rustc ( ç”¨äºç¼–è¯‘ä»£ç çš„ )ä½¿ç”¨äº†ç›¸åŒçš„ç‰ˆæœ¬ã€‚

## æŸ¥çœ‹ Cargo æ„å»ºè€—æ—¶
æ–°ç‰ˆæœ¬ä¸­ï¼Œä»¥ä¸‹å‘½ä»¤å·²ç»å¯ä»¥æ­£å¸¸ä½¿ç”¨äº†:
```shell
$ cargo build --timings
   Compiling hello-world v0.1.0 (hello-world)
      Timing report saved to target/cargo-timings/cargo-timing-20220318T174818Z.html
    Finished dev [unoptimized + debuginfo] target(s) in 0.98s
```

æ­¤å‘½ä»¤ä¼šç”Ÿæˆä¸€ä¸ª `cargo build` çš„è€—æ—¶è¯¦æƒ…æŠ¥å‘Šï¼Œé™¤äº†ä¸Šé¢æåˆ°çš„è·¯å¾„å¤–ï¼ŒæŠ¥å‘Šè¿˜ä¼šè¢«æ‹·è´åˆ° `target/cargo-timings/cargo-timing.html`ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ª[åœ¨çº¿ç¤ºä¾‹](https://blog.rust-lang.org/images/2022-04-07-timing.html)ã€‚è¯¥æŠ¥å‘Šåœ¨ä½ éœ€è¦æå‡æ„å»ºé€Ÿåº¦æ—¶ä¼šéå¸¸æœ‰ç”¨ï¼Œæ›´å¤šçš„ä¿¡æ¯è¯·[æŸ¥çœ‹æ–‡æ¡£](https://doc.rust-lang.org/nightly/cargo/reference/timings.html)ã€‚

## Cargo Feature çš„æ–°è¯­æ³•

> å…³äº Cargo Features ï¼Œå¼ºçƒˆæ¨èå¤§å®¶çœ‹çœ‹ [Cargo ä½¿ç”¨æŒ‡å—](https://course.rs/cargo/reference/features/intro.html)ï¼Œå¯èƒ½æ˜¯ç›®å‰æœ€å¥½çš„ä¸­æ–‡ç¿»è¯‘ç‰ˆæœ¬ã€‚

æ–°ç‰ˆæœ¬ä¸º Cargo Features å¼•å…¥äº†ä¸¤ä¸ªæ–°çš„è¯­æ³•: å‘½åç©ºé—´ ( Namespaced )å’Œå¼±ä¾èµ–ï¼Œå®ƒä»¬å¯ä»¥è®© features è·Ÿå¯é€‰ä¾èµ–è¿›è¡Œæ›´å¥½çš„äº¤äº’ã€‚

Cargo æ”¯æŒ[å¯é€‰ä¾èµ–](https://course.rs/cargo/reference/features/intro.html#å¯é€‰ä¾èµ–)å·²ç»å¾ˆä¹…äº†ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç æ‰€ç¤º:
```toml
[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false, optional = true }

[features]
# é€šè¿‡å¼€å¯ jpeg-decoder ä¾èµ–çš„ "rayon` fetureï¼Œæ¥å¯ç”¨å¹¶è¡ŒåŒ–å¤„ç†
parallel = ["jpeg-decoder/rayon"]
```

è¿™ä¸ªä¾‹å­æœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„ï¼š

- å¯é€‰ä¾èµ– `jpeg-decoder` éšå¼åœ°å®šä¹‰äº†ä¸€ä¸ªåŒåçš„ featureï¼Œå½“å¯ç”¨ `jpeg-decoder` feature æ—¶å°†åŒæ—¶å¯ç”¨ `jpeg-decoder`
- `"jpeg-decoder/rayon"` è¯­æ³•ä¼šå¯ç”¨ `jpeg-decoder` ä¾èµ–ï¼Œå¹¶ä¸”è¿˜ä¼šå¯ç”¨ `jpeg-decoder` ä¾èµ–çš„ `rayon` feature

è€Œå‘½åç©ºé—´æ­£æ˜¯ä¸ºäº†å¤„ç†ç¬¬ä¸€ä¸ªé—®é¢˜è€Œå‡ºç°çš„ã€‚æ–°ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ `[features]` ä¸­ä½¿ç”¨ `dep:` å‰ç¼€æ¥æ˜¾å¼åœ°å¼•ç”¨ä¸€ä¸ªå¯é€‰çš„ä¾èµ–ã€‚å†æ— éœ€åƒç¬¬ä¸€ç‚¹ä¸€æ ·ï¼šå…ˆéšå¼çš„å°†å¯é€‰ä¾èµ–æš´éœ²ä¸ºä¸€ä¸ª featureï¼Œå†é€šè¿‡ feature æ¥å¯ç”¨å®ƒã€‚

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°†èƒ½æ›´å¥½çš„å®šä¹‰å¯é€‰ä¾èµ–æ‰€å¯¹åº”çš„ fetureï¼ŒåŒ…æ‹¬å°†å¯é€‰ä¾èµ–éšè—åœ¨ä¸€ä¸ªæ›´å…·æè¿°æ€§çš„ feature åç§°åé¢ã€‚

å¼±ä¾èµ–ç”¨äºå¤„ç†ç¬¬äºŒç‚¹: æ ¹æ®ç¬¬äºŒç‚¹ï¼Œ`optional-dependency/feature-name` å¿…å®šä¼šå¯ç”¨ `optional-dependency` è¿™ä¸ªå¯é€‰ä¾èµ–ã€‚ç„¶è€Œåœ¨ä¸€äº›åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬åªå¸Œæœ›åœ¨å…¶å®ƒ features å·²ç»å¯ç”¨äº†å¯é€‰ä¾èµ– `optional-dependency` æ—¶æ‰å»å¯ç”¨ `feature-name` è¿™ä¸ª featureã€‚

ä» 1.60 å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `"package-name?/feature-name"` è¿™ç§å¸¦æœ‰ `?` å½¢å¼çš„è¯­æ³•: åªæœ‰å½“å…¶å®ƒé¡¹å·²ç»å¯ç”¨äº†å¯é€‰ä¾èµ– `package-name` çš„æƒ…å†µä¸‹æ‰å»å¼€å¯ç»™å®šçš„ feature `feature-name`ã€‚

> è¯‘è€…æ³¨ï¼šç®€å•æ¥è¯´ï¼Œè¦å¯ç”¨ `feature` å¿…é¡»éœ€è¦åˆ«äººå…ˆå¯ç”¨äº†å…¶å‰ç½®çš„å¯é€‰ä¾èµ–ï¼Œå†ä¹Ÿæ— æ³•åƒä¹‹å‰çš„ç¬¬äºŒç‚¹ä¸€æ ·ï¼Œæ—¢èƒ½å¼€å¯å¯é€‰ä¾èµ–ï¼Œåˆèƒ½å¯ç”¨ featureã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºè‡ªå·±çš„åº“å¢åŠ ä¸€äº›åºåˆ—åŒ–åŠŸèƒ½ï¼Œå®ƒéœ€è¦å¼€å¯æŸä¸ªå¯é€‰ä¾èµ–ä¸­çš„æŒ‡å®š featureï¼Œå¯ä»¥è¿™ä¹ˆåš:
```toml
[dependencies]
serde = { version = "1.0.133", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
serde = ["dep:serde", "rgb?/serde"]
```

è¿™é‡Œå®šä¹‰äº†ä»¥ä¸‹å…³ç³»:

1. å¼€å¯ `serde` feature å°†å¯ç”¨å¯é€‰çš„ `serde` ä¾èµ–
2. åªæœ‰å½“ `rgb` ä¾èµ–åœ¨å…¶å®ƒåœ°æ–¹å·²ç»è¢«å¯ç”¨åï¼Œæ­¤å¤„æ‰èƒ½å¯ç”¨ `rgb` çš„ `serde` feature

## å¢é‡ç¼–è¯‘é‡å¯å¼€å¯
åœ¨ [1.59 æ›´æ–°è¯´æ˜ä¸­](https://course.rs/appendix/rust-versions/1.59.html)ï¼Œæˆ‘ä»¬æœ‰æåˆ°å› ä¸ºæŸäº›é—®é¢˜ï¼Œå¢é‡ç¼–è¯‘è¢«é»˜è®¤å…³é—­äº†ï¼Œç°åœ¨å®˜æ–¹ä¿®å¤äº†å…¶ä¸­ä¸€äº›ï¼Œå¹¶ä¸”ç¡®è®¤ç›®å‰çš„çŠ¶æ€ä¸ä¼šå†å½±å“ç”¨æˆ·çš„ä½¿ç”¨ï¼Œå› æ­¤åœ¨ 1.60 ç‰ˆæœ¬ä¸­ï¼Œå¢é‡ç¼–è¯‘åˆé‡æ–°é»˜è®¤å¼€å¯äº†ã€‚

## Instant å•è°ƒæ€§ä¿è¯
> è¯‘è€…æ³¨ï¼šInstant å¯ä»¥è·å–å½“å‰çš„æ—¶é—´ï¼Œå› æ­¤ä¿è¯å…¶å•è°ƒå¢é•¿æ˜¯éå¸¸é‡è¦çš„ï¼Œä¾‹å¦‚ uuid çš„ç”Ÿæˆå¾€å¾€ä¾èµ–äºæ—¶é—´æˆ³çš„å•è°ƒå¢é•¿ï¼Œä¸€æ—¦æ—¶é—´å›é€€ï¼Œå°±å¯èƒ½å‡ºç° uuid é‡å¤çš„æƒ…å†µã€‚

åœ¨ç›®å‰æ‰€æœ‰çš„å¹³å°ä¸Šï¼Œ`Instant` ä¼šå»å°è¯•ä½¿ç”¨ç³»ç»Ÿæä¾›çš„ API æ¥ä¿è¯å•è°ƒæ€§è¡Œä¸º( ç›®å‰ä¸»è¦é’ˆå¯¹ tier 1 çš„å¹³å° )ã€‚ç„¶è€Œåœ¨å®é™…åœºæ™¯ä¸­ï¼Œè¿™ç§å•è°ƒæ€§å¶å°”ä¼šå› ä¸ºç¡¬ä»¶ã€è™šæ‹ŸåŒ–æˆ–æ“ä½œç³»ç»Ÿbug ç­‰åŸå› è€Œå¤±æ•ˆã€‚

ä¸ºäº†è§£å†³è¿™äº›å¤±æ•ˆæˆ–æ˜¯å¹³å°æ²¡æœ‰æä¾› API çš„æƒ…å†µï¼Œ`Instant::duration_since`, `Instant::elapsed` å’Œ `Instant::sub` ç°åœ¨é¥±å’Œä¸ºé›¶( è¿™é‡Œä¸å¤ªå¥½ç¿»è¯‘ï¼ŒåŸæ–‡æ˜¯ now saturate to zeroï¼Œå¤§æ¦‚æ„æ€æ˜¯éè´Ÿï¼Ÿ)ã€‚è€Œåœ¨è€ç‰ˆæœ¬ä¸­ï¼Œè¿™ç§æ—¶é—´å›é€€çš„æƒ…å†µä¼šå¯¼è‡´ panicã€‚

`Instant::checked_duration_since` ä¹Ÿå¯ä»¥ç”¨äºæ£€æµ‹å’Œå¤„ç†å•è°ƒæ€§å¤±è´¥æˆ– `Instants` çš„å‡æ³•é¡ºåºä¸æ­£ç¡®çš„æƒ…å†µã€‚

ä½†æ˜¯ç›®å‰çš„è§£å†³æ–¹æ³•ä¼šé®æ©ä¸€äº›é”™è¯¯çš„å‘ç”Ÿï¼Œå› æ­¤åœ¨æœªæ¥ç‰ˆæœ¬ä¸­ï¼ŒRust å¯èƒ½ä¼šé‡æ–°å°±æŸäº›åœºæ™¯å¼•å…¥ panic æœºåˆ¶ã€‚

åœ¨ 1.60 ç‰ˆæœ¬å‰ï¼Œå•è°ƒæ€§ä¸»è¦é€šè¿‡æ ‡å‡†åº“çš„äº’æ–¥é” Mutex æˆ–åŸå­æ€§ atomic æ¥ä¿è¯ï¼Œä½†æ˜¯åœ¨ `Instant::now()` è°ƒç”¨é¢‘ç¹æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ˜æ˜¾çš„æ€§èƒ½é—®é¢˜ã€‚



================================================
FILE: src/appendix/rust-versions/1.61.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.62.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.62 | é‡ç‚¹: Cargo addï¼Œ#[default] æšä¸¾å˜é‡ï¼ŒLinux ä¸Šæ›´è–„æ›´å¿«çš„ Mutexï¼Œè£¸æœº x86_64 æ„æ¶

> åŸæ–‡é“¾æ¥: https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html
> ç¿»è¯‘ by ï¼š[AllanDowney](https://github.com/AllanDowney)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.62 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## Cargo add

ç°åœ¨å¯ä»¥ä½¿ç”¨ `cargo add` ç›´æ¥ä»å‘½ä»¤è¡Œæ·»åŠ æ–°çš„ä¾èµ–é¡¹ã€‚æ­¤å‘½ä»¤æ”¯æŒæŒ‡å®šåŠŸèƒ½å’Œç‰ˆæœ¬ã€‚å®ƒè¿˜å¯ä»¥ç”¨æ¥ä¿®æ”¹ç°æœ‰çš„ä¾èµ–å…³ç³»ã€‚

ä¾‹å¦‚:

```rust
$ cargo add log
$ cargo add serde --features derive
$ cargo add nom@5
```

æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [cargo æ–‡æ¡£](https://doc.rust-lang.org/nightly/cargo/commands/cargo-add.html)ã€‚

## `#[default]` æšä¸¾å˜é‡

å¦‚æœæŒ‡å®šæšä¸¾é»˜è®¤å˜é‡ï¼Œç°åœ¨å¯ä»¥ä½¿ç”¨ `#[derive(Default)]`ã€‚ä¾‹å¦‚ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨å¿…é¡»æ‰‹åŠ¨ä¸ºæ­¤æšä¸¾å†™å…¥ `Default` ï¼š

```rust
#[derive(Default)]
enum Maybe<T> {
    #[default]
    Nothing,
    Something(T),
}
```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåªå…è®¸å°†â€œå•å…ƒâ€å˜é‡ï¼ˆæ²¡æœ‰å­—æ®µçš„å˜é‡ï¼‰æ ‡è®°ä¸º#[default]ã€‚[RFC](https://rust-lang.github.io/rfcs/3107-derive-default-enum.html) ä¸­æä¾›äº†æœ‰å…³æ­¤åŠŸèƒ½çš„æ›´å¤šä¿¡æ¯ã€‚

## Linux ä¸Šæ›´è–„æ›´å¿«çš„ Mutex

ä»¥å‰ï¼ŒLinux ä¸Šçš„ `pthreads` åº“æ”¯æŒ `Mutex`ã€`Condvar` å’Œ `RwLock` ã€‚ `pthreads é”` æ”¯æŒæ¯” Rust API æœ¬èº«æ›´å¤šçš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬è¿è¡Œæ—¶é…ç½®ï¼Œå¹¶ä¸”è®¾è®¡ç”¨äºæ¯” Rust æä¾›çš„é™æ€ä¿è¯æ›´å°‘çš„è¯­è¨€ä¸­ã€‚

ä¾‹å¦‚ï¼Œ`Mutex` å®ç°æ˜¯ 40 ä¸ªå­—èŠ‚ï¼Œä¸èƒ½è¢«ç§»åŠ¨(move)ã€‚è¿™è¿«ä½¿æ ‡å‡†åº“åœ¨åå°ä¸ºä½¿ç”¨ `pthreads` çš„å¹³å°çš„æ¯ä¸ªæ–° `Mutex` åˆ†é…ä¸€ä¸ª `Box`ã€‚

ç°åœ¨ Rust çš„æ ‡å‡†åº“åœ¨ Linux ä¸Šæä¾›äº†è¿™äº›é”çš„åŸå§‹ futex å®ç°ï¼Œå®ƒéå¸¸è½»é‡çº§ï¼Œä¸éœ€è¦é¢å¤–åˆ†é…ã€‚åœ¨ 1.62.0 ä¸­ï¼Œ`Mutex` åœ¨ Linux ä¸Šçš„å†…éƒ¨çŠ¶æ€åªéœ€è¦ 5 ä¸ªå­—èŠ‚ï¼Œå°½ç®¡åœ¨æœªæ¥çš„ç‰ˆæœ¬ä¸­å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚

è¿™æ˜¯æé«˜ Rust çš„é”ç±»å‹æ•ˆç‡çš„é•¿æœŸåŠªåŠ›çš„ä¸€éƒ¨åˆ†ï¼ŒåŒ…æ‹¬ä»¥å‰åœ¨ Windows ä¸Šçš„æ”¹è¿›ï¼Œå¦‚å–æ¶ˆç»‘å®šå…¶åŸè¯­ã€‚æ‚¨å¯ä»¥åœ¨[è·Ÿè¸ªé—®é¢˜](https://github.com/rust-lang/rust/issues/93740)ä¸­äº†è§£æ›´å¤šæœ‰å…³è¿™æ–¹é¢çš„ä¿¡æ¯ã€‚

## è£¸æœº `x86_64` æ„æ¶

ç°åœ¨æ›´å®¹æ˜“ä¸º `x86_64` æ„å»ºæ— æ“ä½œç³»ç»Ÿçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¾‹å¦‚åœ¨ç¼–å†™å†…æ ¸æ—¶ã€‚`x86_64-unknown-none` æ„æ¶å·²å‡çº§åˆ°ç¬¬ 2 å±‚ï¼Œå¯ä»¥ç”¨ `rustup` å®‰è£…ã€‚

```rust
$ rustup target add x86_64-unknown-none
$ rustc --target x86_64-unknown-none my_no_std_program.rs
```

æ‚¨å¯ä»¥åœ¨ [Embedded Rust book](https://docs.rust-embedded.org/book/intro/no-std.html) ä¸­é˜…è¯»æ›´å¤šå…³äºä½¿ç”¨ `no_std` è¿›è¡Œå¼€å‘çš„ä¿¡æ¯ã€‚



================================================
FILE: src/appendix/rust-versions/1.63.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.64.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.64 | é‡ç‚¹: `IntoFuture` , Cargo ä¼˜åŒ–

> Rust 1.64 å®˜æ–¹ release doc: [Announcing Rust 1.64.0 | Rust Blog](https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.64 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## ä½¿ç”¨ `IntoFuture` å¢å¼º `.await`

1.64 ç¨³å®šäº† `IntoFuture` traitï¼Œä¸åŒäºç”¨åœ¨ `for ... in ...` çš„ `IntoIterator` traitï¼Œ`IntoFuture` å¢å¼ºäº† `.awiat` å…³é”®å­—ã€‚ç°åœ¨ `.await` å¯ä»¥ await é™¤äº† futures å¤–ï¼Œè¿˜å¯ä»¥ await ä»»ä½•å®ç°äº† `IntoFuture` trait å¹¶ç»æ­¤è½¬æ¢æˆ `Future` çš„å¯¹è±¡ã€‚è¿™å¯ä»¥è®©ä½ çš„ api å¯¹ç”¨æˆ·æ›´åŠ ä¼˜åŒ–ã€‚

ä¸¾ä¸€ä¸ªç”¨åœ¨ç½‘ç»œå­˜å‚¨ä¾›åº”ç«¯çš„ä¾‹å­ï¼š

```rust
pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// å®ä¾‹åŒ–ä¸€ä¸ª `StorageRequest` 
    pub fn new() -> Self { ... }
    /// æ˜¯å¦å¼€å¯ debug æ¨¡å¼
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// å‘é€è¯·æ±‚å¹¶æ¥å—å›å¤
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}
```

é€šå¸¸åœ°ä½¿ç”¨æ–¹æ³•å¯èƒ½ç±»ä¼¼å¦‚ä¸‹ä»£ç ï¼š

```rust
let response = StorageRequest::new()  // 1. å®ä¾‹åŒ–
    .set_debug(true)                  // 2. è®¾ç½®ä¸€äº›é€‰é¡¹
    .send()                           // 3. æ„é€  future
    .await?;                          // 4. æ‰§è¡Œ future ï¼Œä¼ é€’ error
```

è¿™ä¸ªä»£ç å·²ç»ä¸é”™äº†ï¼Œä¸è¿‡ 1.64 åå¯ä»¥åšçš„æ›´å¥½ã€‚ä½¿ç”¨ `IntoFuture` ï¼ŒæŠŠç¬¬ä¸‰æ­¥çš„ â€œæ„é€  future â€ å’Œ ç¬¬å››æ­¥çš„ â€œæ‰§è¡Œ future â€ åˆå¹¶åˆ°ä¸€ä¸ªæ­¥éª¤é‡Œï¼š

``` RUST
let response = StorageRequest::new()  // 1. å®ä¾‹åŒ–
    .set_debug(true)                  // 2. è®¾ç½®ä¸€äº›é€‰é¡¹
    .await?;                          // 3. æ„é€ å¹¶æ‰§è¡Œ future ï¼Œä¼ é€’ error
```

æƒ³è¦å®ç°ä¸Šé¢çš„æ•ˆæœï¼Œæˆ‘ä»¬éœ€è¦ç»™ `StorageRequest` å®ç° `IntoFuture` traitã€‚`IntoFuture` éœ€è¦ç¡®å®šå¥½è¦è¿”å›çš„ futureï¼Œå¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥å®ç°ï¼š

``` rust
// é¦–å…ˆéœ€è¦å¼•å…¥ä¸€äº›å¿…é¡»çš„ç±»å‹
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// å®ä¾‹åŒ–ä¸€ä¸ª `StorageRequest` 
    pub fn new() -> Self { ... }
    /// æ˜¯å¦å¼€å¯ debug æ¨¡å¼
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// å‘é€è¯·æ±‚å¹¶æ¥å—å›å¤
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}

// æ–°çš„å®ç°å†…å®¹
// 1. å®šä¹‰å¥½è¿”å›çš„ future ç±»å‹
pub type StorageRequestFuture = Pin<Box<dyn Future<Output = Result<StorageResponse, Error>> + Send + 'static>>
// 2. ç»™ `StorageRequest` å®ç° `IntoFuture`
impl IntoFuture for StorageRequest {
    type IntoFuture = StorageRequestFuture;
    type Output = <StorageRequestFuture as Future>::Output;
    fn into_future(self) -> Self::IntoFuture {
        Box::pin(self.send())
    }
}
```

è¿™ç¡®å®éœ€è¦å¤šå†™ä¸€ç‚¹å®ç°ä»£ç ï¼Œä¸è¿‡å¯ä»¥ç»™ç”¨æˆ·æä¾›ä¸€ä¸ªæ›´ç®€å•çš„ api ã€‚

æœªæ¥ï¼ŒRust å¼‚æ­¥å›¢é˜Ÿ å¸Œæœ›èƒ½å¤Ÿé€šè¿‡ç»™ç±»å‹åˆ«åæä¾› `impl Trait` [Type Alias Impl Trait](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html)ï¼Œæ¥ç®€åŒ–å®šä¹‰ futures å®ç° `IntoFuture` çš„ä»£ç ï¼›å†æƒ³åŠæ³•ç§»é™¤ `Box` æ¥æå‡æ€§èƒ½ã€‚


## `core` å’Œ `alloc` ä¸­å’Œ C è¯­è¨€å…¼å®¹çš„ FFI ç±»å‹

å½“è°ƒç”¨ C-ABI æˆ–è€…è°ƒç”¨ C-ABI çš„æ—¶å€™ï¼ŒRust ä»£ç é€šå¸¸ä¼šä½¿ç”¨è¯¸å¦‚ `c_uint` æˆ–è€… `c_ulong` çš„ç±»å‹åˆ«åæ¥åŒ¹é…ç›®æ ‡è¯­è¨€é‡Œçš„å¯¹åº”ç±»å‹ã€‚

åœ¨æ¬¡ä¹‹å‰ï¼Œè¿™äº›ç±»å‹åˆ«åä»…åœ¨ `std` é‡Œå¯ç”¨ï¼Œè€Œåœ¨åµŒå…¥å¼æˆ–è€…å…¶å®ƒä»…èƒ½ä½¿ç”¨ `core` æˆ–è€… `alloc` çš„åœºæ™¯ä¸‹æ— æ³•ä½¿ç”¨ã€‚

1.64 é‡Œåœ¨ `core::ffi` é‡Œæä¾›äº†æ‰€æœ‰ `c_*` çš„ç±»å‹åˆ«åï¼Œè¿˜æœ‰ `core::ffi::CStr` å¯¹åº” C çš„å­—ç¬¦ä¸²ï¼Œè¿˜æœ‰ä»…ç”¨ `alloc` åº“æƒ…å†µä¸‹å¯ä»¥ç”¨ `alloc::ffi::CString` æ¥å¯¹åº” C çš„å­—ç¬¦ä¸²ã€‚


## å¯ä»¥é€šè¿‡ rustup æ¥ä½¿ç”¨ rust-analyzer 

rust-analyzer ç°åœ¨è¢«åŠ è¿› Rust å·¥å…·é›†é‡Œäº†ã€‚è¿™è®©åœ¨å„å¹³å°ä¸Šä¸‹è½½ä½¿ç”¨ rust-analyzer æ›´åŠ æ–¹ä¾¿ã€‚é€šè¿‡ [rustup component](https://rust-lang.github.io/rustup/concepts/components.html) æ¥å®‰è£…ï¼š

```shell
rustup component add rust-analyzer
```

ç›®å‰ï¼Œä½¿ç”¨ rustup å®‰è£…çš„ç‰ˆæœ¬ï¼Œéœ€è¦è¿™æ ·å¯ç”¨ï¼š

```shell
rustup run stable rust-analyzer
```

ä¸‹ä¸€æ¬¡ rustup çš„å‘å¸ƒæœ¬æŠŠä¼šæä¾›ä¸€ä¸ªå†…ç½®çš„ä»£ç†ï¼Œæ¥è¿è¡Œå¯¹åº”ç‰ˆæœ¬çš„ rust-analyzer ã€‚


## Cargo ä¼˜åŒ–ï¼Œworkspace ç»§æ‰¿å’Œå¤šç›®æ ‡æ„å»º

å½“åœ¨ä¸€ä¸ª Cargo workspace é‡Œç®¡ç†å¤šä¸ªç›¸å…³çš„åº“/äº§å“æ—¶ï¼Œç°åœ¨å¯ä»¥é¿å…åœ¨å¤šä¸ªåº“é‡Œä½¿ç”¨ç›¸åŒçš„å­—æ®µå€¼äº†ï¼Œæ¯”å¦‚ç›¸åŒçš„ç‰ˆæœ¬å·ï¼Œä»“åº“é“¾æ¥ï¼Œ`rust-version`ã€‚åœ¨æ›´æ–°çš„æ—¶å€™ä¹Ÿå¯ä»¥æ›´å®¹æ˜“åœ°ä¿æŒè¿™äº›ä¿¡æ¯åœ°ä¸€è‡´æ€§ã€‚æ›´å¤šç»†èŠ‚å¯ä»¥å‚è€ƒï¼š

* [workspace.package](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table)
* [workspace.dependencies](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table)
* ["inheriting a dependency from a workspace"](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace)

å¦å¤–åœ¨æ„å»ºå¤šä¸ªç›®æ ‡åœ°æ—¶å€™ï¼Œç°åœ¨å¯ä»¥ç›´æ¥ä¼ é€’å¤šä¸ª `--target` é€‰é¡¹ç»™ `cargo build` æ¥ä¸€æ¬¡æ€§ç¼–è¯‘æ‰€æœ‰ç›®æ ‡ã€‚ä¹Ÿå¯ä»¥åœ¨ `.cargo/config.toml` é‡Œè®¾ç½®ä¸€ä¸ª `build.target` çš„ array æ¥æ”¹å˜é»˜è®¤æ„å»ºæ—¶çš„å¯¹è±¡ã€‚

## ç¨³å®šAPI && Others

æ›´å¤šç¨³å®šAPIåˆ—è¡¨å’Œå…¶å®ƒæ›´æ–°å†…å®¹ï¼Œè¯·å‚è€ƒåŸæ–‡æœ€å [stabilized-apis](https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html#stabilized-apis)


================================================
FILE: src/appendix/rust-versions/1.65.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.65 | é‡ç‚¹: æ³›å‹å…³è”ç±»å‹ï¼Œæ–°ç»‘å®šè¯­æ³•ï¼

> Rust 1.65 å®˜æ–¹ release doc: [Announcing Rust 1.65.0 | Rust Blog](https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.65 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## æ³›å‹å…³è”ç±»å‹ Generic associated types (GATs)

å…³è”ç±»å‹ï¼ˆassociated typesï¼‰é‡Œç°åœ¨å¯ä»¥åŠ ä¸Šç”Ÿå‘½å‘¨æœŸã€ç±»å‹ã€constæ³›å‹äº†ï¼Œç±»ä¼¼äºï¼š

```rust
trait Foo {
    type Bar<'x>;
}
```

ä¸‰è¨€ä¸¤è¯­è¯´ä¸æ¸…è¿™ä¸ªå˜åŒ–çš„å¥½å¤„ï¼Œçœ‹å‡ ä¸ªä¾‹å­æ¥æ„Ÿå—ä¸€ä¸‹ï¼š

```rust
/// ä¸€ä¸ªç±»ä¼¼äº `Iterator` çš„ trait ï¼Œå¯ä»¥å€Ÿç”¨ `Self`ã€‚
trait LendingIterator {
    type Item<'a> where Self: 'a;

    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

/// å¯ä»¥ç»™æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼Œæ¯”å¦‚ `Rc` å’Œ `Arc` å®ç°çš„ traitï¼Œæ¥å®ç°æŒ‡é’ˆç±»å‹çš„æ³›ç”¨æ€§
trait PointerFamily {
    type Pointer<T>: Deref<Target = T>;

    fn new<T>(value: T) -> Self::Pointer<T>;
}

/// å…è®¸å€Ÿç”¨æ•°ç»„å¯¹è±¡ï¼Œå¯¹ä¸éœ€è¦è¿ç»­å­˜å‚¨æ•°æ®çš„å›ºå®šé•¿åº¦æ•°ç»„ç±»å‹å¾ˆæœ‰ç”¨
trait BorrowArray<T> {
    type Array<'x, const N: usize> where Self: 'x;

    fn borrow_array<'a, const N: usize>(&'a self) -> Self::Array<'a, N>;
}
```

æ³›å‹å…³è”ç±»å‹ååˆ†é€šç”¨ï¼Œèƒ½å¤Ÿå†™å‡ºè®¸å¤šä¹‹å‰æ— æ³•å®ç°çš„æ¨¡å¼ã€‚æ›´å¤šçš„ä¿¡æ¯å¯ä»¥å‚è€ƒä¸‹é¢çš„é“¾æ¥ï¼š

* [2021/08/03/GATç¨³å®šç‰ˆæœ¬æ¨è¿›](https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html)
* [2022/10/28/GATç¨³å®šç‰ˆæœ¬å‘å¸ƒå…¬å‘Š](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html)

ç¬¬ä¸€ä¸ªå¯¹ä¸Šé¢çš„ä¾‹å­è¿›è¡Œäº†æ›´æ·±å…¥çš„è®¨è®ºï¼Œç¬¬äºŒä¸ªè®¨è®ºäº†ä¸€äº›å·²çŸ¥çš„å±€é™æ€§ã€‚

æ›´æ·±å…¥çš„é˜…è¯»å¯ä»¥åœ¨å…³è”ç±»å‹çš„ [nightly reference](https://doc.rust-lang.org/nightly/reference/items/associated-items.html#associated-types) å’Œ [åŸå§‹ RFC](https://rust-lang.github.io/rfcs/1598-generic_associated_types.html)ï¼ˆå·²ç»è¿‡å»6.5å¹´äº†ï¼ï¼‰ é‡Œæ‰¾åˆ°ã€‚

## `let` - `else` è¯­æ³•

æ–°çš„ `let` è¯­æ³•ï¼Œå°è¯•æ¨¡å¼åŒ¹é…ï¼Œæ‰¾ä¸åˆ°åŒ¹é…çš„æƒ…å†µä¸‹æ‰§è¡Œå‘æ•£çš„ `else` å—ã€‚

```rust
let PATTERN: TYPE = EXPRESSION else {
    DIVERGING_CODE;
};
```

å¸¸è§„çš„ `let` è¯­æ³•ä»…èƒ½ä½¿ç”¨ `irrefutable patterns`ï¼Œç›´è¯‘ä¸ºä¸å¯åé©³çš„æ¨¡å¼ï¼Œä¹Ÿå°±æ˜¯ä¸€å®šè¦åŒ¹é…ä¸Šã€‚ä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯å•ä¸ªå˜é‡ç»‘å®šï¼Œä¹Ÿç”¨åœ¨è§£å¼€ç»“æ„ä½“ï¼Œå…ƒç»„ï¼Œæ•°ç»„ç­‰å¤åˆç±»å‹ä¸Šã€‚åŸå…ˆå¹¶ä¸é€‚ç”¨æ¡ä»¶åŒ¹é…ï¼Œæ¯”å¦‚ä»æšä¸¾é‡Œç¡®å®šæšä¸¾å€¼ã€‚ç›´åˆ°ç°åœ¨æˆ‘ä»¬æœ‰äº† `let` - `else`ã€‚è¿™æ˜¯ `refutable pattern`ï¼Œç›´è¯‘ä¸ºå¯åé©³çš„æ¨¡å¼ï¼Œèƒ½å¤Ÿåƒå¸¸è§„ `let` ä¸€æ ·åŒ¹é…å¹¶ç»‘å®šå˜é‡åˆ°å‘¨å›´èŒƒå›´å†…ï¼Œåœ¨æ¨¡å¼ä¸åŒ¹é…çš„æ—¶å€™æ‰§è¡Œå‘é€çš„ `else` ï¼ˆå¯ä»¥æ˜¯ `break`, `return`, `panic!`ï¼‰ã€‚ 

```rust
fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}
assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
```

`if` - `else` å’Œ `match` æˆ–è€… `if let` æœ€å¤§ä¸ä¸€æ ·çš„åœ°æ–¹æ˜¯å˜é‡ç»‘å®šçš„èŒƒå›´ï¼Œåœ¨æ­¤ä¹‹å‰ä½ éœ€è¦å¤šå†™ä¸€ç‚¹é‡å¤çš„ä»£ç å’Œä¸€æ¬¡å¤–å±‚çš„ `let` ç»‘å®šæ¥å®Œæˆï¼š

```rust
    let (count_str, item) = match (it.next(), it.next()) {
        (Some(count_str), Some(item)) => (count_str, item),
        _ => panic!("Can't segment count item pair: '{s}'"),
    };
    let count = if let Ok(count) = u64::from_str(count_str) {
        count
    } else {
        panic!("Can't parse integer: '{count_str}'");
    };
```

## `break` è·³å‡ºæ ‡è®°è¿‡çš„ä»£ç å—

å—è¡¨è¾¾å¼ç°åœ¨å¯ä»¥æ ‡è®°ä¸º `break` çš„ç›®æ ‡ï¼Œæ¥è¾¾åˆ°æå‰ç»ˆæ­¢å—çš„ç›®çš„ã€‚è¿™å¬èµ·æ¥æœ‰ç‚¹åƒ `goto` è¯­æ³•ï¼Œä¸è¿‡è¿™å¹¶ä¸æ˜¯éšæ„çš„è·³è½¬ï¼Œåªèƒ½ä»å—é‡Œè·³è½¬åˆ°å—æœ«å°¾ã€‚è¿™åœ¨ä¹‹å‰å·²ç»å¯ä»¥ç”¨ `loop` å—æ¥å®ç°äº†ï¼Œä½ å¯èƒ½å¤§æ¦‚ç‡è§è¿‡è¿™ç§æ€»æ˜¯åªæ‰§è¡Œä¸€æ¬¡çš„ `loop`ã€‚

1.65 å¯ä»¥ç›´æ¥ç»™å—è¯­å¥æ·»åŠ æ ‡è®°æ¥æå‰é€€å‡ºäº†ï¼Œè¿˜å¯ä»¥æºå¸¦è¿”å›å€¼ï¼š

```rust
let result = 'block: {
    do_thing();
    if condition_not_met() {
        break 'block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break 'block 2;
    }
    do_last_thing();
    3
};
```


## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html)


================================================
FILE: src/appendix/rust-versions/1.66.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.66 | é‡ç‚¹: æœ‰å­—æ®µæšä¸¾çš„æ˜¾ç¤ºåˆ¤åˆ«

> Rust 1.66 å®˜æ–¹ release doc: [Announcing Rust 1.66.0 | Rust Blog](https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.66 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## å¯¹æœ‰å­—æ®µæšä¸¾çš„æ˜¾ç¤ºåˆ¤åˆ«

æšä¸¾çš„æ˜¾ç¤ºåˆ¤åˆ«åœ¨è·¨è¯­è¨€ä¼ é€’å€¼æ—¶å¾ˆå…³é”®ï¼Œéœ€è¦ä¸¤ä¸ªè¯­è¨€é‡Œæ¯ä¸ªæšä¸¾å€¼çš„åˆ¤åˆ«æ˜¯ä¸€è‡´çš„ï¼Œæ¯”å¦‚ï¼š

```rust
#[repr(u8)]
enum Bar {
    A,
    B,
    C = 42,
    D,
}
```

è¿™ä¸ªä¾‹å­é‡Œï¼Œæšä¸¾ `Bar` ä½¿ç”¨äº† `u8` ä½œä¸ºåŸè¯­è¡¨å½¢(representation)ï¼Œå¹¶ä¸” `Bar::C` ä½¿ç”¨ 42 æ¥åˆ¤åˆ«ï¼Œå…¶å®ƒæ²¡æœ‰æ˜¾ç¤ºåˆ¤åˆ«çš„æšä¸¾å€¼ä¼šæŒ‰ç…§æºç é‡Œåœ°é¡ºåºè‡ªåŠ¨åœ°é€’å¢èµ‹å€¼ï¼Œè¿™é‡Œçš„ `Bar::A` æ˜¯0ï¼Œ`Bar::B` æ˜¯1ï¼Œ`Bar::D` æ˜¯43ã€‚å¦‚æœæ²¡æœ‰æ˜¾ç¤ºåˆ¤åˆ«ï¼Œé‚£å°±åªèƒ½åœ¨ `Bar::B` å’Œ `Bar::C` ä¹‹é—´åŠ ä¸Š 40 ä¸ªæ— æ„ä¹‰çš„æšä¸¾å€¼äº†ã€‚

åœ¨1.66ä¹‹å‰ï¼Œæšä¸¾çš„æ˜¾ç¤ºåˆ¤åˆ«åªèƒ½ç”¨åœ¨æ— å­—æ®µæšä¸¾ä¸Šã€‚ç°åœ¨å¯¹æœ‰å­—æ®µæšä¸¾çš„æ˜¾ç¤ºåˆ¤åˆ«ä¹Ÿç¨³å®šäº†ï¼š

```rust
#[repr(u8)]
enum Foo {
    A(u8),
    B(i8),
    C(bool) = 42,
}
```

æ³¨æ„ï¼šå¯ä»¥é€šè¿‡ `as` è½¬æ¢ï¼ˆæ¯”å¦‚ `Bar::C as u8` ï¼‰æ¥åˆ¤æ–­ä¸€ä¸ªæ— å­—æ®µæšä¸¾çš„åˆ¤åˆ«å€¼ï¼Œä½†æ˜¯ Rust è¿˜æ²¡æœ‰ç»™æœ‰å­—æ®µæšä¸¾æä¾›è¯­è¨€å±‚é¢ä¸Šçš„è·å–åŸå§‹åˆ¤åˆ«å€¼çš„æ–¹æ³•ï¼Œåªèƒ½é€šè¿‡ unsafe çš„ä»£ç æ¥æ£€æŸ¥æœ‰å­—æ®µæšä¸¾çš„åˆ¤åˆ«å€¼ã€‚è€ƒè™‘åˆ°è¿™ä¸ªä½¿ç”¨åœºæ™¯å¾€å¾€å‡ºç°åœ¨å¿…é¡»ä½¿ç”¨ unsafe ä»£ç çš„è·¨è¯­è¨€çš„ FFI é‡Œï¼Œå¸Œæœ›è¿™æ²¡æœ‰é€ æˆå¤ªå¤§çš„è´Ÿæ‹…ã€‚å¦‚æœä½ çš„ç¡®éœ€è¦çš„è¯ï¼Œå‚è€ƒ `std::mem::discriminant`ã€‚

## é»‘ç›’æ–¹æ³• `core::hint::black_box`

å½“å¯¹ç¼–è¯‘å™¨äº§ç”Ÿçš„ä»£ç åšåŸºå‡†æµ‹è¯•æ—¶ï¼Œå¸¸å¸¸éœ€è¦é˜»æ­¢ä¸€äº›ä¼˜åŒ–ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä»£ç é‡Œï¼Œ `push_cap` åœ¨ä¸€ä¸ªå¾ªç¯é‡Œæ‰§è¡Œäº†4æ¬¡ `Vec::push` ï¼š

```rust
fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
    }
}

pub fn bench_push() -> Duration { 
    let mut v = Vec::with_capacity(4);
    let now = Instant::now();
    push_cap(&mut v);
    now.elapsed()
}
```

å¦‚æœä½ æ£€æŸ¥ä¸€ä¸‹åœ¨ x86_64 æœºå™¨ä¸Šç¼–è¯‘çš„ä¼˜åŒ–è¾“å‡ºç»“æœï¼Œä½ ä¼šæ³¨æ„åˆ°æ•´ä¸ª `push_cap` æ–¹æ³•éƒ½è¢«ä¼˜åŒ–æ‰äº†...

```text
example::bench_push:
  sub rsp, 24
  call qword ptr [rip + std::time::Instant::now@GOTPCREL]
  lea rdi, [rsp + 8]
  mov qword ptr [rsp + 8], rax
  mov dword ptr [rsp + 16], edx
  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]
  add rsp, 24
  ret
```

ç°åœ¨å¯ä»¥é€šè¿‡è°ƒç”¨ `black_box` æ¥é¿å…ç±»ä¼¼æƒ…å†µçš„å‘é€ã€‚ è™½ç„¶å®é™…ä¸Š `black_box` å†…éƒ¨åªä¼šå–èµ°å€¼å¹¶ç›´æ¥è¿”å›ï¼Œä½†æ˜¯ç¼–è¯‘å™¨ä¼šè®¤ä¸ºè¿™ä¸ªæ–¹æ³•å¯èƒ½åšä»»ä½•äº‹æƒ…ã€‚

``` rust
use std::hint::black_box;

fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
        black_box(v.as_ptr());
    }
}
```

è¿™æ ·å°±å¯ä»¥å¾—åˆ°å±•å¼€å¾ªç¯çš„[ç»“æœ](https://rust.godbolt.org/z/Ws1GGbY6Y)ï¼š

```text
  mov dword ptr [rbx], 0
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 4], 1
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 8], 2
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 12], 3
  mov qword ptr [rsp + 8], rbx
```

ä½ è¿˜èƒ½å‘ç°ç»“æœé‡Œæœ‰ `black_box` å¸¦æ¥çš„å‰¯ä½œç”¨ï¼Œæ— æ„ä¹‰çš„ `mov qword ptr [rsp + 8], rbx` æŒ‡ä»¤åœ¨æ¯ä¸€æ¬¡å¾ªç¯åå‡ºç°ï¼Œç”¨æ¥è·å– `v.as_ptr()` ä½œä¸ºå‚æ•°ä¼ é€’ç»™å¹¶æœªçœŸæ­£ä½¿ç”¨çš„æ–¹æ³•ã€‚

æ³¨æ„åˆ°ä¸Šé¢çš„ä¾‹å­é‡Œï¼Œ`push` æŒ‡ä»¤éƒ½ä¸ç”¨è€ƒè™‘å†…å­˜åˆ†é…çš„é—®é¢˜ï¼Œè¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨è¿è¡Œåœ¨ `Vec::with_capacity(4)` çš„æ¡ä»¶ä¸‹ã€‚ä½ å¯ä»¥å°è¯•æ”¹åŠ¨ä¸€ä¸‹ `black_box` çš„ä½ç½®æˆ–è€…åœ¨å¤šå¤„ä½¿ç”¨ï¼Œæ¥çœ‹çœ‹å…¶å¯¹ç¼–è¯‘çš„ä¼˜åŒ–è¾“å‡ºçš„å½±å“ã€‚


## `cargo remove`

1.62é‡Œæˆ‘ä»¬å¼•å…¥äº† `cargo add` æ¥é€šè¿‡å‘½ä»¤è¡Œç»™ä½ çš„é¡¹ç›®å¢åŠ ä¾èµ–é¡¹ã€‚ç°åœ¨å¯ä»¥ä½¿ç”¨ `cargo remove` æ¥ç§»é™¤ä¾èµ–äº†ã€‚


## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.67.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.67 | `#[must_use]` in `async fn`

> Rust 1.67 å®˜æ–¹ release doc: [Announcing Rust 1.67.0 | Rust Blog](https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.67 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

2023æ–°å¹´å¥½ï¼å¤§å¹´åˆäº”æ›´æ–°çš„æ–°ç‰ˆæœ¬ï¼Œæ¥çœ‹çœ‹æœ‰ä»€ä¹ˆæ–°å˜åŒ–~

## `#[must_use]` ä½œç”¨äº `async fn` ä¸Š

æ³¨æ˜äº† `#[must_use]` çš„ `async` å‡½æ•°ä¼šæŠŠè¯¥å±æ€§åº”ç”¨åœ¨è¿”å›çš„ `impl Future` ç»“æœä¸Šã€‚`Future` trait å·²ç»æ³¨æ˜äº† `#[must_use]` ï¼Œæ‰€ä»¥æ‰€æœ‰å®ç°äº† `Future` çš„ç±»å‹éƒ½ä¼šè‡ªåŠ¨åŠ ä¸Š `#[must_use]`ã€‚

æ‰€ä»¥åœ¨ 1.67 ç‰ˆæœ¬ï¼Œç¼–è¯‘å™¨ä¼šè­¦å‘Šè¿”å›å€¼æ²¡æœ‰è¢«ä½¿ç”¨ï¼š

```rust
#[must_use]
async fn bar() -> u32 { 0 }

async fn caller() {
    bar().await;
}
```

```text
warning: unused output of future returned by `bar` that must be used
 --> src/lib.rs:5:5
  |
5 |     bar().await;
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
```

## `std::sync::mpsc` å®ç°æ›´æ–°

æ ‡å‡†åº“é‡Œçš„ mpscï¼ˆå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ï¼‰ é€šé“è‡ªä» 1.0 ç‰ˆæœ¬å°±æœ‰äº†ï¼Œè¿™æ¬¡ç‰ˆæœ¬æ›´æ–°å°†å…¶å®ç°ä¿®æ”¹æˆäº†åŸºäº [`crossbeam-channel`](https://crates.io/crates/crossbeam-channel)ã€‚ä¸æ¶‰åŠåˆ°APIçš„å˜æ›´ï¼Œä½†æ˜¯ä¿®æ”¹äº†ä¸€äº›å·²æœ‰çš„bugï¼Œæå‡äº†æ€§èƒ½å’Œä»£ç å¯ç»´æŠ¤æ€§ã€‚ç”¨æˆ·åº”è¯¥ä¸å¤ªä¼šæ„ŸçŸ¥åˆ°æ˜æ˜¾çš„å˜åŒ–ã€‚


## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.68.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.68 | crates index ä¼˜åŒ–

> Rust 1.68 å®˜æ–¹ release doc: [Announcing Rust 1.68.0 | Rust Blog](https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.68 ç‰ˆæœ¬:

```shell
$ rustup update stable
```


## Cargo ç¨€ç–æ³¨å†Œåè®® ï¼ˆsparse protocolï¼‰

Cargoçš„â€œç¨€ç–â€æ³¨å†Œåè®®å·²ç»ç¨³å®šï¼Œå®ƒæ˜¯ç”¨æ¥è¯»å–æ³¨å†Œåœ¨ crates.io ä¸Šçš„ crates çš„ç´¢å¼•çš„åŸºç¡€è®¾æ–½ã€‚ä»¥å‰çš„ git åè®®ï¼ˆç›®å‰ä»ç„¶æ˜¯é»˜è®¤åè®®ï¼‰ä¼šå…‹éš†ä¸€ä¸ªåŒ…æ‹¬æ‰€æœ‰ crates çš„ç´¢å¼•çš„ä»“åº“ï¼Œä½†è¿™å·²ç»å¼€å§‹é‡åˆ°æ‰©å±•é™åˆ¶é—®é¢˜ï¼Œåœ¨æ›´æ–°è¯¥ä»“åº“æ—¶ä¼šå‡ºç°æ˜æ˜¾çš„å»¶è¿Ÿã€‚æ–°åè®®åº”åœ¨è®¿é—® crates.io æ—¶æä¾›æ˜¾ç€çš„æ€§èƒ½æå‡ï¼Œå› ä¸ºå®ƒåªä¼šä¸‹è½½æœ‰å…³å®é™…ç”¨åˆ°çš„ crates çš„ç´¢å¼•ã€‚

è¦ä½¿ç”¨æ–°çš„åè®®ï¼Œéœ€è¦è®¾ç½®ç¯å¢ƒå˜é‡ `CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse` ï¼Œæˆ–è€…ç¼–è¾‘ `.cargo/config.toml` æ–‡ä»¶æ·»åŠ ï¼š

```text
[registries.crates-io]
protocol = "sparse"
```

ç¨€ç–æ³¨å†Œåè®®ç›®å‰è®¡åˆ’äº 1.70.0 ç‰ˆæœ¬æˆä¸ºé»˜è®¤çš„åè®®ã€‚æ›´å¤šç»†èŠ‚å¯ä»¥çœ‹å®˜æ–¹åšå®¢çš„ [announcement](https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html)ï¼Œ [RFC 2789](https://rust-lang.github.io/rfcs/2789-sparse-index.html)ï¼Œ å½“å‰ Cargo Book çš„ [æ–‡æ¡£](https://doc.rust-lang.org/stable/cargo/reference/registry-index.html#sparse-protocol)


## å±€éƒ¨ `Pin` æ„é€ 

æ–°å¢çš„ `pin!` å®èƒ½å¤Ÿç”¨ `T` æ„é€ ä¸€ä¸ª `Pin<&mut T>` ï¼Œä»è€ŒåŒ¿åæ•è·åœ¨å±€éƒ¨çŠ¶æ€å†…ã€‚è¿™é€šå¸¸å«åš å †æ ˆå›ºå®šï¼ˆstack-pinningï¼‰ï¼ŒåŒæ—¶è¿™ä¸ªå †æ ˆä¹Ÿå¯ä»¥è¢« `async fn` æˆ–è€… ä»£ç å— æ¥æ•è·ä½ã€‚è¿™ä¸ªå®å’Œä¸€äº› crates é‡Œæä¾›çš„ï¼ˆæ¯”å¦‚ `tokio::pin!`ï¼‰å¾ˆåƒï¼Œä½†æ˜¯æ ‡å‡†åº“å¯ä»¥åˆ©ç”¨ `Pin` çš„å†…éƒ¨ç»“æ„å’Œ ä¸´æ—¶ç”Ÿå‘½å‘¨æœŸæ‹“å±•([Temporary lifetime extension](https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension))æ¥å®ç°å‡ºæ›´åƒè¡¨è¾¾å¼çš„å®ã€‚

```rust
/// Runs a future to completion.
fn block_on<F: Future>(future: F) -> F::Output {
    let waker_that_unparks_thread = todo!();
    let mut cx = Context::from_waker(&waker_that_unparks_thread);
    // Pin the future so it can be polled.
    let mut pinned_future = pin!(future);
    loop {
        match pinned_future.as_mut().poll(&mut cx) {
            Poll::Pending => thread::park(),
            Poll::Ready(result) => return result,
        }
    }
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒåŸæ¥çš„ `future` å°†è¢«ç§»åŠ¨åˆ°ä¸€ä¸ªä¸´æ—¶çš„å±€éƒ¨åŒºåŸŸï¼Œç”±æ–°çš„ `pinned_future` å¼•ç”¨ï¼Œç±»å‹ä¸º `Pin<&mut F>`ï¼Œå¹¶ä¸”è¯¥ pin å—åˆ¶äºæ­£å¸¸çš„å€Ÿç”¨æ£€æŸ¥å™¨ä»¥ç¡®ä¿å®ƒä¸ä¼šè¶…è¿‡å±€éƒ¨ä½œç”¨åŸŸã€‚


## `alloc` é»˜è®¤é”™è¯¯å¤„ç†

å½“ Rust å†…å­˜åˆ†é…å¤±è´¥æ—¶ï¼Œç±»ä¼¼äº `Box::new` å’Œ `Vec::push` çš„ API æ— æ³•åæ˜ å‡ºè¿™ä¸ªé”™è¯¯ï¼Œä»è€Œé‡‡å–äº†ä¸€äº›ä¸åŒçš„æªæ–½ã€‚å½“ä½¿ç”¨ `std` æ—¶ï¼Œç¨‹åºä¼šæ‰“å° `stderr` ç„¶åä¸­æ­¢ã€‚ä» Rust 1.68.0 å¼€å§‹ï¼ŒåŒ…å« `std` çš„äºŒè¿›åˆ¶ç¨‹åºä»ç„¶ä¼šç»§ç»­è¿™æ ·ï¼Œè€Œä¸ä¿æŠ¤ `std` åªåŒ…å« `alloc` çš„äºŒè¿›åˆ¶ç¨‹åºä¼šå¯¹å†…å­˜åˆ†é…é”™è¯¯è°ƒç”¨ `panic!`ï¼Œå¦‚æœéœ€è¦å¯ä»¥å†è¿›ä¸€æ­¥é€šè¿‡ `#[panic_handler]` æ¥è°ƒæ•´å…¶è¡Œä¸ºã€‚

æœªæ¥ï¼Œ`std` ä¹Ÿå¯èƒ½ä¼šæ”¹æˆè¿™æ ·ã€‚


## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html#stabilized-apis)





================================================
FILE: src/appendix/rust-versions/1.69.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.69 | cargo fix

> Rust 1.69 å®˜æ–¹ release doc: [Announcing Rust 1.69.0 | Rust Blog](https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.69 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## Cargo æä¾›è‡ªåŠ¨ä¿®å¤å»ºè®®

åœ¨ Rust 1.29.0 ç‰ˆæœ¬æ·»åŠ çš„ `cargo fix` å­å‘½ä»¤ï¼Œèƒ½å¤Ÿè‡ªåŠ¨ä¿®å¤ä¸€äº›ç®€å•çš„ç¼–è¯‘é”™è¯¯ã€‚ä»é‚£ä»¥åï¼Œèƒ½å¤Ÿè‡ªåŠ¨ä¿®å¤çš„é”™è¯¯/è­¦å‘ŠåŸå› çš„æ•°é‡ä¸€ç›´åœ¨ç¨³æ­¥å¢åŠ ã€‚æ­¤å¤–ï¼Œè¿˜å¢åŠ äº†å¯¹è‡ªåŠ¨ä¿®å¤ä¸€äº›ç®€å•çš„ Clippy è­¦å‘Šçš„æ”¯æŒã€‚

ä¸ºäº†è®©æ›´å¤šäººæ³¨æ„åˆ°è¿™äº›èƒ½åŠ›ï¼Œç°åœ¨å½“æ£€æµ‹åˆ°å¯è‡ªåŠ¨ä¿®å¤çš„é”™è¯¯æ—¶ï¼ŒCargo ä¼šå»ºè®®è¿è¡Œ `cargo fix` æˆ– `cargo clippy --fix` å‘½ä»¤ï¼š

```shell
warning: unused import: `std::hash::Hash`
 --> src/main.rs:1:5
  |
1 | use std::hash::Hash;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `foo` (bin "foo") generated 1 warning (run `cargo fix --bin "foo"` to apply 1 suggestion)
```

æ³¨æ„ä¸Šé¢çš„å®Œæ•´å‘½ä»¤ï¼ˆå³åŒ…å« `--bin foo`ï¼‰ä»…åœ¨ä½ æƒ³è¦ç²¾ç¡®ä¿®å¤ä¸€ä¸ªå•ç‹¬çš„ crate æ—¶éœ€è¦é™„ä¸Šã€‚é»˜è®¤æ‰§è¡Œ workspace ä¸‹æ‰€æœ‰ fixs åªéœ€è¦ `cargo fix` ã€‚

## æ„å»ºè„šæœ¬é»˜è®¤ä¸å†åŒ…å«è°ƒè¯•ä¿¡æ¯

ä¸ºäº†æé«˜ç¼–è¯‘é€Ÿåº¦ï¼ŒCargo ç°åœ¨é»˜è®¤é¿å…åœ¨æ„å»ºè„šæœ¬ä¸­å‘å‡ºè°ƒè¯•ä¿¡æ¯ã€‚æ„å»ºè„šæœ¬æˆåŠŸæ‰§è¡Œæ—¶ä¸ä¼šæœ‰å¯è§çš„æ•ˆæœï¼Œä½†æ„å»ºè„šæœ¬ä¸­çš„å›æº¯ï¼ˆbacktracesï¼‰å°†åŒ…å«æ›´å°‘çš„ä¿¡æ¯ã€‚

æ‰€ä»¥å¦‚æœæƒ³è¦ debug æ„å»ºè„šæœ¬ï¼Œéœ€è¦é¢å¤–å¼€å¯è°ƒè¯•ä¿¡æ¯ï¼Œåœ¨ `Cargo.toml` æ–‡ä»¶é‡Œæ·»åŠ 

```text
[profile.dev.build-override]
debug = true
[profile.release.build-override]
debug = true
```

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.70.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.71.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.71 | C-unwind API

> Rust 1.71 å®˜æ–¹ release doc: [Announcing Rust 1.71.0 | Rust Blog](https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.71 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## C-unwind API

1.71.0 ç¨³å®šäº† `C-unwind` å’Œå…¶ä»– `-unwind` åç¼€çš„ABIï¼Œå…·ä½“è§[åˆ—è¡¨](https://github.com/rust-lang/rust/issues/74990#issuecomment-1363473645)

éå¼ºåˆ¶unwindingçš„ç»“æœåœ¨è¿™ä¸ªRFCçš„[è¡¨æ ¼](https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#abi-boundaries-and-unforced-unwinding)é‡Œã€‚

å¸¦æœ‰ `-unwind` åç¼€çš„ABIåœ¨ç”±äº `panic` æˆ–è€… C++ çš„å¼‚å¸¸(exception) è€Œæ‰§è¡Œ unwinding æ—¶ï¼Œç©¿è¿‡ ABI è¾¹ç•Œä¼šæ›´å®‰å…¨ï¼Œé™¤æ­¤ä»¥å¤–å’Œæ²¡æœ‰ `-unwind` åç¼€çš„ ABI åŸºæœ¬ç­‰æ•ˆã€‚ä½¿ç”¨ `panic=unwind` å¯ä»¥æœ‰æ•ˆåœ°è®©å¼‚å¸¸ä»ä¸€ç§è¯­è¨€å †æ ˆå±•å¼€(stack unwind)åˆ°å¦ä¸€ç§è¯­è¨€è€Œä¸éœ€è¦ä¸­æ­¢è¿›ç¨‹ï¼ˆåªè¦è¿™ä¸ªå¼‚å¸¸çš„äº§ç”Ÿå’Œæ•è·éƒ½æ˜¯åœ¨åŒä¸€ç§è¯­è¨€å†…è¿›è¡Œçš„ï¼‰ã€‚è€Œ `panic=abort` é€šå¸¸ä¼šç«‹åˆ»ä¸­æ­¢è¿›ç¨‹ã€‚

è¿™æ¬¡ç¨³å®šä¸ä¼šå½±å“å·²æœ‰çš„ABIï¼ˆæ¯”å¦‚ `C`ï¼‰ï¼Œé€šè¿‡è¿™äº›ABIçš„ unwinding ä»ç„¶æ˜¯ UB æœªå®šä¹‰è¡Œä¸ºã€‚æœªæ¥çš„ Rust ç‰ˆæœ¬ä¼šæŒ‰ç…§è¿™ä¸ªRFCæ¥ä¿®å¤è¿™äº›ABIï¼ˆé€šå¸¸ä¼šåœ¨è¾¹ç•Œå¤„abortï¼‰ã€‚æˆ‘ä»¬é¼“åŠ±éœ€è¦unwindç©¿è¿‡ABIè¾¹ç•Œçš„ç”¨æˆ·ä½¿ç”¨æ–°çš„ ABI æ¥ç¡®ä¿æœªæ¥çš„å…¼å®¹æ€§ã€‚

è¯‘è€…æ³¨ï¼šæˆ–è®¸ä»¥ä¸‹ä¸€äº›æ¦‚å¿µå¯¹ç†è§£ä¸Šé¢è¿™ä¸ªæ›´æ–°å†…å®¹æœ‰ä¸€äº›å¸®åŠ©ï¼š

* [FFI](https://doc.rust-lang.org/nomicon/ffi.html)
* [what-is-stack-unwinding](https://stackoverflow.com/questions/2331316/what-is-stack-unwinding)
* [Rust Unwinding](https://doc.rust-lang.org/nomicon/unwinding.html)

## è°ƒè¯•å™¨å¯è§†åŒ–å±æ€§

1.71.0 ç¨³å®šäº†æ–°çš„å±æ€§ï¼š`#[debug_visualizer(natvis_file = "...")]` å’Œ `#[debug_visualizer(gdb_script_file = "...")]`ã€‚å®ƒä»¬å…è®¸æ¤å…¥ Nativis æè¿°å’Œ GDB è„šæœ¬åˆ° Rust åº“é‡Œæ¥æ”¹å–„é€šè¿‡è°ƒè¯•å™¨æŸ¥çœ‹è¿™äº›åº“æ•°æ®ç»“æ„æ—¶çš„è¾“å‡ºç»“æœã€‚Rustæœ¬èº«æœ‰ç»™æ ‡å‡†åº“æ‰“åŒ…ç±»ä¼¼çš„è„šæœ¬ï¼Œå¦‚ä»Šè¿™ä¸ªç‰¹æ€§è®©åº“ä½œè€…ä¹Ÿå¯ä»¥ç»™å…¶ç”¨æˆ·æä¾›ç±»ä¼¼çš„ä½“éªŒäº†ã€‚

å…·ä½“ç»†èŠ‚æŸ¥çœ‹ï¼š[the-debugger_visualizer-attribute](https://doc.rust-lang.org/nightly/reference/attributes/debugger.html#the-debugger_visualizer-attribute)

## raw-dylib åŠ¨æ€åº“é“¾æ¥

åœ¨ Windows å¹³å°ä¸Šï¼Œé€šè¿‡åœ¨ `#[link]` é‡Œä½¿ç”¨æ–°çš„é€‰é¡¹ `kind="raw-dylib"`ï¼ŒRust ç°åœ¨æ”¯æŒä½¿ç”¨åŠ¨æ€åº“ä¸”ç¼–è¯‘æœŸä¸éœ€è¦ä¾èµ–è¿™ä¸ªåŠ¨æ€åº“ã€‚

è¿™é¿å…äº†è¦æ±‚ç”¨æˆ·å®‰è£…è¿™äº›åº“ï¼ˆè¿™åœ¨è·¨å¹³å°äº¤å‰ç¼–è¯‘çš„æ—¶å€™å°¤ä¸ºå›°éš¾ï¼‰ï¼Œä¹Ÿé¿å…äº†åœ¨cratesæŒ‡æ˜éœ€è¦é“¾æ¥çš„åº“çš„å…·ä½“ç‰ˆæœ¬ã€‚

ä½¿ç”¨æ–°çš„å±æ€§ `#[link_ordinal]`ï¼Œ Rust ä¹Ÿæ”¯æŒé€šè¿‡åŠ¨æ€åº“çš„ç¬¦å·é¡ºåºè€Œä¸æ˜¯ç¬¦å·åç§°æ¥è¿›è¡Œç¬¦å·ç»‘å®šã€‚

## çº¿ç¨‹å±€éƒ¨å¸¸é‡åˆå§‹åŒ–

å…¶å®æ˜¯ 1.59 ç¨³å®šè¿›æ ‡å‡†åº“çš„åŠŸèƒ½ï¼ˆæ²¡æœ‰åœ¨æ›´æ–°è¯´æ˜å’Œæ–‡æ¡£é‡Œæè¿‡ï¼‰ã€‚[æ–‡æ¡£](https://doc.rust-lang.org/stable/std/macro.thread_local.html)

```rust
use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// each thread starts out with the initial value of 1
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// wait for the thread to complete and bail out on panic
t.join().unwrap();

// we retain our original value of 2 despite the child thread
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});
```

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.72.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.72 | featureå¯ç”¨æç¤º

> Rust 1.72 å®˜æ–¹ release doc: [Announcing Rust 1.72.0 | Rust Blog](https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.72 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## è­¦å‘Šå¯èƒ½æœ‰ç”¨çš„ `cfg` ç¦ç”¨é¡¹

ä¸€ç›´ä»¥æ¥éƒ½æ”¯æŒçš„é€šè¿‡ `cfg` æ¡ä»¶ç¼–è¯‘éƒ¨åˆ†ä»£ç ï¼Œä¾‹å¦‚åœ¨å¼€å¯ç‰¹å®š feature æ—¶çš„å‡½æ•°ï¼Œæˆ–è€…é’ˆå¯¹ç‰¹å®šå¹³å°çš„é€»è¾‘ã€‚ä¹‹å‰ç¼–è¯‘å™¨ä¼šç›´æ¥æ— è§†æ‰è¿™äº›ä»£ç ï¼Œç°åœ¨ä¼šè®°å½•è¿™äº›ç¬¦å·åç§°å’Œå¯¹åº”çš„ `cfg` æ¡ä»¶ï¼Œå› æ­¤å¯ä»¥è­¦å‘Šä½ æ­£åœ¨è°ƒç”¨ä¸€ä¸ªç‰¹å®š feature ä¸‹çš„å‡½æ•°ï¼Œéœ€è¦å¯ç”¨ featureï¼š

```text
   Compiling my-project v0.1.0 (/tmp/my-project)
error[E0432]: unresolved import `rustix::io_uring`
   --> src/main.rs:1:5
    |
1   | use rustix::io_uring;
    |     ^^^^^^^^^^^^^^^^ no `io_uring` in the root
    |
note: found an item that was configured out
   --> /home/username/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustix-0.38.8/src/lib.rs:213:9
    |
213 | pub mod io_uring;
    |         ^^^^^^^^
    = note: the item is gated behind the `io_uring` feature

For more information about this error, try `rustc --explain E0432`.
error: could not compile `my-project` (bin "my-project") due to previous error
```

## ä¸å—é™åˆ¶çš„å¸¸é‡è®¡ç®—æ—¶é—´

ä¹‹å‰ä¸ºäº†é¿å…ç”¨æˆ·è‡ªå®šä¹‰çš„å¸¸é‡åœ¨ç¼–è¯‘æœŸé—´è¿›è¡Œä¼°ç®—æ—¶ï¼Œé™·å…¥æ­»å¾ªç¯æˆ–å ç”¨æ— é™åˆ¶çš„æ—¶é—´ï¼ŒRust ä¹‹å‰ä¼šé™åˆ¶ç”¨ä½œå¸¸é‡è®¡ç®—çš„è¯­å¥æ•°ç›®ã€‚ç„¶è€Œä¸€äº›ç‰¹æ®Šçš„æœ‰åˆ›é€ æ€§çš„ Rust ä»£ç è¿˜æ˜¯ä¼šè¶…è¿‡è¿™ä¸ªé™åˆ¶ï¼Œè¿›è€Œäº§ç”Ÿç¼–è¯‘é”™è¯¯ï¼›æ›´ç³Ÿç³•çš„æƒ…å†µæ˜¯ï¼Œæ˜¯å¦è¾¾åˆ°é™åˆ¶çš„æ˜¯ä¼šéšç€ç”¨æˆ·è°ƒç”¨åº“çš„ä¸åŒè€Œå˜åŒ–çš„ã€‚

ç°åœ¨ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œæ— é™åˆ¶çš„å¸¸é‡è®¡ç®—ã€‚è€Œä¸ºäº†é¿å…é•¿æ—¶é—´ç¼–è¯‘æ²¡æœ‰åé¦ˆï¼Œç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶ä»£ç è¿è¡Œä¸€æ®µæ—¶é—´åå‘å‡ºä¸€æ¡æ¶ˆæ¯ï¼Œå¹¶åœ¨æ¯æ¬¡ç¿»å€çš„ä¸€æ®µæ—¶é—´åé‡å¤è¯¥æ¶ˆæ¯ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨è¿˜å°†åœ¨æ•è·æ— é™å¾ªç¯çš„å¤§é‡æ­¥éª¤åæŠ¥é”™æç¤º `const_eval_long_run` ï¼Œä½†å¯ä»¥ç”¨ `allow(const_eval_long_run)` å…è®¸ç‰¹åˆ«é•¿çš„å¸¸é‡è®¡ç®—ã€‚

## Clippy lints ä¸Šå‡åˆ° rustc

å‡ ä¸ªåŸæœ¬ç”± Clippy æä¾›çš„ lintsï¼Œæå‡åˆ° rustc é‡Œï¼š

* [`clippy::undropped_manually_drops`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#undropped_manually_drops) => [`undropped-manually-drops`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/deny-by-default.html#undropped-manually-drops) (deny) 
  * æ— ä½œç”¨çš„ `ManullyDrop`
* [`clippy::invalid_utf8_in_unchecked`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#invalid_utf8_in_unchecked) => [`invalid_from_utf8_unchecked`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/deny-by-default.html#invalid-from-utf8-unchecked) (deny) æˆ– [`invalid_from_utf8`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/warn-by-default.html#invalid-from-utf8) (warn)
  * æ£€æŸ¥è°ƒç”¨ `std::str::from_utf8_unchecked` å’Œ `std::str::from_utf8_unchecked_mut` è½¬æ¢ä¸åˆæ³•çš„ UTF-8 å­—é¢é‡ï¼Œè¿™ä¼šè¿åäº† safety å‰æï¼Œå¯¼è‡´æœªå®šä¹‰è¡Œä¸º
  * æ£€æŸ¥ `std::str::from_utf8` å’Œ `std::str::from_utf8_mut` è½¬æ¢ä¸åˆæ³•çš„ UTF-8 å­—é¢é‡ï¼Œè¿™ä¼šæ°¸è¿œè¿”å›é”™è¯¯ã€‚
* [`clippy::cmp_nan`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#cmp_nan) => [`invalid_nan_comparisons`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/warn-by-default.html#invalid-nan-comparisons) (warn)
  * æ£€æŸ¥ä½¿ç”¨ `f32::NAN` æˆ–è€… `f64::NAN` å‚ä¸æ¯”è¾ƒï¼Œ`NAN` åœ¨æ¯”è¾ƒæ—¶æ— ä»»ä½•æ„ä¹‰ï¼Œå³ä½¿ä¸è‡ªå·±æ¯”è¾ƒä¹Ÿæ˜¯æ— æ„ä¹‰è¡Œä¸ºï¼Œå»ºè®®ä½¿ç”¨ `is_nan()` æ–¹æ³•
* [`clippy::cast_ref_to_mut`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#cast_ref_to_mut) => [`invalid_reference_casting`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/allowed-by-default.html#invalid-reference-casting) (allow)
  * æ£€æŸ¥ä¸ä½¿ç”¨å†…éƒ¨å¯å˜æ€§çš„ä» `&T` åˆ° `&mut T` çš„è½¬æ¢ï¼Œè¿™ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚å½“å‰è¿™ä¸ªlintæœ¬èº«è¿˜æœ‰äº›é—®é¢˜ï¼Œæ‰€ä»¥æ˜¯ `allow` çº§åˆ«ï¼Œé¢„è®¡ä¼šåœ¨ 1.73 ç‰ˆæœ¬ä¿®æ­£åå˜ä¸ºé»˜è®¤ `deny` 

## æœªæ¥å¯¹ Windows çš„æ”¯æŒ

æœªæ¥çš„ release ç‰ˆæœ¬é‡Œä¼šæ”¾å¼ƒå¯¹ win10 ä»¥å‰çš„ç³»ç»Ÿçš„å®˜æ–¹æ”¯æŒï¼ŒRust 1.75 å°†æˆä¸ºæœ€åä¸€ä¸ªæ”¯æŒ windows 7,8,8.1çš„ç‰ˆæœ¬ï¼Œ2024 å¹´ 2 æœˆèµ·çš„ rust 1.76 å°†ä»…æ”¯æŒ win10 åŠåç»­ç‰ˆæœ¬ ï¼ˆ target : tier-1 ï¼‰ã€‚è¯¦æƒ…è§ææ¡ˆ [MCP 651](https://github.com/rust-lang/compiler-team/issues/651)


## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.73.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.73 | panic æŠ¥é”™å±•ç¤ºä¼˜åŒ–

> Rust 1.73 å®˜æ–¹ release doc: [Announcing Rust 1.73.0 | Rust Blog](https://blog.rust-lang.org/2023/10/05/Rust-1.73.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.73 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## æ›´ç®€æ´çš„ panic æŠ¥é”™ä¿¡æ¯

é»˜è®¤çš„ panic handler ä¼šæŠŠæŠ¥é”™ä¿¡æ¯å•ç‹¬åˆ—å‡ºä¸€è¡Œï¼Œå½“æŠ¥é”™ä¿¡æ¯å¾ˆé•¿ã€åŒ…å«å¤šè¡Œæˆ–è€…åµŒå¥—ç»“æ„çš„æ—¶å€™å¯è¯»æ€§ä¼šæ›´å¼ºã€‚

```rust
fn main() {
    let file = "ferris.txt";
    panic!("oh no! {file:?} not found!");
}
```

Rust 1.73 ä¹‹å‰çš„ï¼š
```shell
thread 'main' panicked at 'oh no! "ferris.txt" not found!', src/main.rs:3:5
```

Rust 1.73 ä¹‹åçš„ï¼š
```shell
thread 'main' panicked at src/main.rs:3:5:
oh no! "ferris.txt" not found!
```

å¦å¤–ï¼Œç”± `assert_eq` å’Œ `assert_ne` äº§ç”Ÿçš„ panic æ¶ˆæ¯ä¹ŸæŠŠè‡ªå®šä¹‰ä¿¡æ¯éƒ¨åˆ†ï¼ˆç¬¬ä¸‰ä¸ªå‚æ•°ï¼‰çš„å±•ç¤ºä½ç½®æ”¹åŠ¨äº†ä¸€ä¸‹ï¼š

```rust
fn main() {
    assert_eq!("ğŸ¦€", "ğŸŸ", "ferris is not a fish");
}
```

Rust 1.73 ä¹‹å‰çš„ï¼š
```shell
thread 'main' panicked at 'assertion failed: `(left == right)`
 left: `"ğŸ¦€"`,
right: `"ğŸŸ"`: ferris is not a fish', src/main.rs:2:5
```

Rust 1.73 ä¹‹åçš„ï¼š
```shell
thread 'main' panicked at src/main.rs:2:5:
assertion `left == right` failed: ferris is not a fish
 left: "ğŸ¦€"
right: "ğŸŸ"
```

## çº¿ç¨‹å±€éƒ¨åˆå§‹åŒ–

å¦‚ [RFC 3184](https://github.com/rust-lang/rfcs/blob/master/text/3184-thread-local-cell-methods.md) ææ¡ˆï¼Œ `LocalKey<Cell<T>>` å’Œ `LocalKey<RefCell<T>>` ç°åœ¨å¯ä»¥ç›´æ¥ç”¨ `get()`, `set()`, `take()` å’Œ `replace()` æ–¹æ³•æ¥æ“ä½œï¼Œä¸å†éœ€è¦å†™ `with(|inner|...)` çš„é—­åŒ…å½¢å¼ã€‚å£°æ˜çº¿ç¨‹é™æ€å±€éƒ¨å˜é‡çš„å® `thread_local!` å†…éƒ¨å°±æ˜¯ä½¿ç”¨çš„å°±æ˜¯ `LocalKey<T>`ã€‚

æ–°çš„æ–¹æ³•è®©ä»£ç æ›´ç®€æ´ï¼Œä¹Ÿé¿å…äº†é»˜è®¤å€¼åœ¨æ–°çº¿ç¨‹è¿è¡Œé¢å¤–çš„åˆå§‹åŒ–ä»£ç ã€‚

```rust
thread_local! {
    static THINGS: Cell<Vec<i32>> = Cell::new(Vec::new());
}

fn f() {
    // before:
    THINGS.with(|i| i.set(vec![1, 2, 3]));
    // now:
    THINGS.set(vec![1, 2, 3]);

    // ...

    // before:
    let v = THINGS.with(|i| i.take());
    // now:
    let v: Vec<i32> = THINGS.take();
}
```

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2023/10/05/Rust-1.73.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.74.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.75.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.76.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.77.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.78.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.78 | è¯Šæ–­å±æ€§å®

> Rust 1.78 å®˜æ–¹ release doc: [Announcing Rust 1.78.0 | Rust Blog](https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.78 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## è¯Šæ–­å±æ€§å®

Rust ç°åœ¨æ”¯æŒ `#[diagnostic]` å±æ€§å‘½åç©ºé—´ï¼Œç”¨äºå½±å“ç¼–è¯‘å™¨é”™è¯¯æ¶ˆæ¯ã€‚è¿™äº›è¢«è§†ä¸ºæç¤ºï¼Œç¼–è¯‘å™¨ä¸éœ€è¦ä½¿ç”¨å®ƒä»¬ï¼Œä¹Ÿä¸ä¼šå› ä¸ºæä¾›äº†ç¼–è¯‘å™¨ä¸è®¤è¯†çš„è¯Šæ–­è€ŒæŠ¥é”™ã€‚è¿™ç§çµæ´»æ€§å…è®¸æºä»£ç æä¾›è¯Šæ–­ï¼Œå³ä½¿ä¸æ˜¯æ‰€æœ‰ç¼–è¯‘å™¨éƒ½æ”¯æŒï¼Œæ— è®ºæ˜¯ä¸åŒç‰ˆæœ¬è¿˜æ˜¯å®Œå…¨ä¸åŒçš„å®ç°ã€‚

éšç€è¿™ä¸ªå‘½åç©ºé—´çš„å‡ºç°ï¼Œç¬¬ä¸€ä¸ªæ”¯æŒçš„å±æ€§ `#[diagnostic::on_unimplemented]` ä¹Ÿéšä¹‹è€Œæ¥ï¼Œå¯ä»¥æ”¾åœ¨ä¸€ä¸ª trait ä¸Šï¼Œç”¨äºè‡ªå®šä¹‰å½“éœ€è¦ä½†æœªåœ¨ç±»å‹ä¸Šå®ç°è¯¥ trait æ—¶çš„æ¶ˆæ¯ã€‚è€ƒè™‘ä¸‹é¢æ¥è‡ª[ç¨³å®š PR](https://github.com/rust-lang/rust/pull/119888/) é‡Œçš„ç¤ºä¾‹ï¼š

```rust
#[diagnostic::on_unimplemented(
    message = "My Message for `ImportantTrait<{A}>` is not implemented for `{Self}`",
    label = "My Label",
    note = "Note 1",
    note = "Note 2"
)]
trait ImportantTrait<A> {}

fn use_my_trait(_: impl ImportantTrait<i32>) {}

fn main() {
    use_my_trait(String::new());
}
```

æ­¤å‰ï¼Œç¼–è¯‘å™¨ä¼šç»™å‡ºä¸€ä¸ªå†…ç½®é”™è¯¯ï¼Œå¦‚ä¸‹ï¼š

```shell
error[E0277]: the trait bound `String: ImportantTrait<i32>` is not satisfied
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ the trait `ImportantTrait<i32>` is not implemented for `String`
   |     |
   |     required by a bound introduced by this call
   |
```

ç°åœ¨ï¼Œä½¿ç”¨ `#[diagnostic::on_unimplemented]`ï¼Œè‡ªå®šä¹‰æ¶ˆæ¯å¡«å……ä¸»è¦é”™è¯¯è¡Œï¼Œè‡ªå®šä¹‰æ ‡ç­¾æ”¾åœ¨æºè¾“å‡ºä¸Šã€‚åŸå§‹æ ‡ç­¾ä»ç„¶å†™åœ¨å¸®åŠ©è¾“å‡ºä¸­ï¼Œä»»ä½•è‡ªå®šä¹‰æ³¨é‡Šä¹Ÿä¼šè¢«å†™å…¥ã€‚ (è¿™äº›ç»†èŠ‚æœªæ¥å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚)

```shell
error[E0277]: My Message for `ImportantTrait<i32>` is not implemented for `String`
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait<i32>` is not implemented for `String`
   = note: Note 1
   = note: Note 2
```

å¯¹äº trait ä½œè€…æ¥è¯´ï¼Œå¦‚æœä½ èƒ½æä¾›æ›´å¥½çš„æç¤ºï¼Œè€Œä¸æ˜¯ä»…ä»…ç»™å‡ºç¼ºå¤±éƒ¨åˆ†ï¼Œè¿™ç§è¯Šæ–­å°±æ›´æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªç¤ºä¾‹ï¼š

```rust
#[diagnostic::on_unimplemented(
    message = "the size for values of type `{Self}` cannot be known at compilation time",
    label = "doesn't have a size known at compile-time"
)]
pub trait Sized {}
```

æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒ[è¯Šæ–­å·¥å…·å±æ€§å‘½åç©ºé—´](https://doc.rust-lang.org/stable/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace)çš„å‚è€ƒéƒ¨åˆ†ã€‚

## ä¸å®‰å…¨å‰ææ–­è¨€

Rust æ ‡å‡†åº“æœ‰è®¸å¤šç”¨äºä¸å®‰å…¨å‡½æ•°å‰æçš„æ–­è¨€ï¼Œä½†å†å²ä¸Šå®ƒä»¬åªåœ¨æ ‡å‡†åº“çš„ `#[cfg(debug_assertions)]` æ„å»ºä¸­å¯ç”¨ï¼Œä»¥é¿å…å½±å“å‘å¸ƒæ€§èƒ½ã€‚ç„¶è€Œï¼Œç”±äºæ ‡å‡†åº“é€šå¸¸ä»¥å‘å¸ƒæ¨¡å¼ç¼–è¯‘å’Œåˆ†å‘ï¼Œå¤§å¤šæ•° Rust å¼€å‘è€…æ ¹æœ¬æ²¡æœ‰æ‰§è¡Œè¿™äº›æ£€æŸ¥ã€‚

ç°åœ¨ï¼Œè¿™äº›æ–­è¨€çš„æ¡ä»¶è¢«å»¶è¿Ÿåˆ°ä»£ç ç”Ÿæˆï¼Œå› æ­¤å®ƒä»¬å°†æ ¹æ®ç”¨æˆ·è‡ªå·±å¯¹è°ƒè¯•æ–­è¨€çš„è®¾ç½®è¿›è¡Œæ£€æŸ¥ï¼ˆåœ¨è°ƒè¯•å’Œæµ‹è¯•æ„å»ºä¸­é»˜è®¤å¯ç”¨ï¼‰ã€‚è¿™ä¸ªå˜åŒ–æœ‰åŠ©äºç”¨æˆ·æ•è·ä»–ä»¬ä»£ç ä¸­çš„æœªå®šä¹‰è¡Œä¸ºã€‚

ä¾‹å¦‚ï¼Œ`slice::from_raw_parts` éœ€è¦ä¸€ä¸ªå¯¹é½çš„éç©ºæŒ‡é’ˆã€‚ä¸‹é¢æ•…æ„é”™ä½æŒ‡é’ˆçš„ä½¿ç”¨æœ‰æœªå®šä¹‰è¡Œä¸ºï¼Œè™½ç„¶å¦‚æœä½ è¿æ°”ä¸å¥½ï¼Œå®ƒå¯èƒ½åœ¨è¿‡å»çœ‹èµ·æ¥â€œå·¥ä½œâ€ï¼Œä½†è°ƒè¯•æ–­è¨€ç°åœ¨å¯ä»¥æ•è·å®ƒï¼š

```rust
fn main() {
    let slice: &[u8] = &[1, 2, 3, 4, 5];
    let ptr = slice.as_ptr();

    // åˆ›å»ºä¸€ä¸ª `ptr` çš„åç§»é‡ï¼Œå®ƒæ€»æ˜¯æ¯” `u16` çš„æ­£ç¡®å¯¹é½å°‘ä¸€ä¸ª
    let i = usize::from(ptr as usize & 1 == 0);
    
    let slice16: &[u16] = unsafe { std::slice::from_raw_parts(ptr.add(i).cast::<u16>(), 2) };
    dbg!(slice16);
}
```

åœ¨è°ƒè¯•æ„å»ºä¸­ï¼Œè¿™å°†å¯¼è‡´ä¸€ä¸ª panicï¼š

```shell
thread 'main' panicked at library/core/src/panicking.rs:220:5:
unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
thread caused non-unwinding panic. aborting.
```

## ç¡®å®šæ€§é‡æ–°å¯¹é½

æ ‡å‡†åº“æœ‰ä¸€äº›å‡½æ•°å¯ä»¥æ”¹å˜æŒ‡é’ˆå’Œåˆ‡ç‰‡çš„å¯¹é½æ–¹å¼ï¼Œä½†ä»¥å‰å®ƒä»¬æœ‰ä¸€äº›æ³¨æ„äº‹é¡¹ï¼Œä½¿å®ƒä»¬åœ¨å®è·µä¸­éš¾ä»¥ä¾èµ–ï¼Œå¦‚æœä½ ä¸¥æ ¼éµå¾ªå®ƒä»¬çš„æ–‡æ¡£ã€‚è¿™äº›æ³¨æ„äº‹é¡¹ä¸»è¦æ˜¯ä¸ºäº†ä¿æŠ¤å¯¹ `const` çš„åˆ¤æ–­ï¼Œä½†å®ƒä»¬åªå¯¹é `const` ä½¿ç”¨ç¨³å®šã€‚ç°åœ¨å®ƒä»¬æ‰¿è¯ºæ ¹æ®å®é™…è¾“å…¥å…·æœ‰ä¸€è‡´çš„è¿è¡Œæ—¶è¡Œä¸ºã€‚

* [`pointer::align_offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset) è®¡ç®—æ”¹å˜æŒ‡é’ˆåˆ°ç»™å®šå¯¹é½æ–¹å¼æ‰€éœ€çš„åç§»é‡ã€‚å¦‚æœä¸å¯èƒ½ï¼Œå®ƒå°†è¿”å› `usize::MAX`ï¼Œä½†ä»¥å‰å…è®¸å®ƒå§‹ç»ˆè¿”å› `usize::MAX`ï¼Œç°åœ¨è¿™ç§è¡Œä¸ºè¢«ç§»é™¤ã€‚

* [`slice::align_to`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to) å’Œ [`slice::align_to_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut) éƒ½å°†åˆ‡ç‰‡è½¬æ¢ä¸ºå¯¹é½çš„ä¸­é—´åˆ‡ç‰‡å’Œå‰©ä½™çš„ä¸å¯¹é½å¤´å’Œå°¾åˆ‡ç‰‡ã€‚è¿™äº›æ–¹æ³•ç°åœ¨æ‰¿è¯ºè¿”å›æœ€å¤§å¯èƒ½çš„ä¸­é—´éƒ¨åˆ†ï¼Œè€Œä¸å…è®¸å®ç°è¿”å›ä¸é‚£ä¹ˆä¼˜åŒ–çš„ä¸œè¥¿ï¼Œæ¯”å¦‚å°†æ‰€æœ‰ä¸œè¥¿ä½œä¸ºå¤´åˆ‡ç‰‡è¿”å›ã€‚

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„APIåˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.79.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.79 | å†…è” constï¼Œä¸´æ—¶å˜é‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿

> Rust 1.79 å®˜æ–¹ release doc: [Announcing Rust 1.79.0 | Rust Blog](https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.79 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## å†…è” `const` è¡¨è¾¾å¼

å¦‚ä»Šå¯ä»¥å†™å†…è” const å— `const {...}` ä½œä¸ºè¡¨è¾¾å¼ï¼Œæ˜¾å¼åœ°è¿›å…¥ const ä¸Šä¸‹æ–‡ï¼Œè€Œä¸éœ€è¦é¢å¤–çš„å£°æ˜ï¼ˆä¾‹å¦‚ï¼Œå®šä¹‰ `const` å¸¸é‡æˆ– Trait çš„å…³è”å¸¸é‡ï¼‰ã€‚

ä¸ const å¸¸é‡ `const ITEM: ... = ...` ä¸åŒï¼Œå†…è” const é‡Œç±»å‹å¯ä»¥è¢«æ¨æ–­è€Œä¸éœ€è¦æ˜¾å¼å†™å‡ºï¼Œå¹¶ä¸”è¿˜èƒ½ä½¿ç”¨æ³›å‹å‚æ•°ã€‚æ¥çœ‹ä¸€ä¸ªå¾ˆå®ç”¨çš„ä¾‹å­ï¼š

```rust
const EMPTY: Option<Vec<u8>> = None;
let foo = [EMPTY; 100];
```

å¦‚ä»Šå¯ä»¥å†™æˆå¦‚ä¸‹å½¢å¼ï¼Œï¼ˆfoo çš„ç±»å‹ `Option<T>` å¯ä»¥ä¸æ ‡æ³¨ï¼Œå¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡æ¨æ–­å‡ºæ¥ï¼‰

```rust
let foo = [const { None }; 100];
```

æ³›å‹çš„ä¾‹å­ï¼š

```rust
fn create_none_array<T, const N: usize>() -> [Option<T>; N] {
    [const { None }; N]
}
```

æ›´å¤šç»†èŠ‚è§[å‚è€ƒæ–‡æ¡£](https://doc.rust-lang.org/nightly/reference/expressions/block-expr.html#const-blocks)

## å…³è”ç±»å‹çº¦æŸ

Rust 1.79 ç¨³å®šäº†ä¸€äº›å…³è”ç±»å‹çº¦æŸçš„è¯­æ³•ï¼Œå…è®¸æˆ‘ä»¬åœ¨ç±»å‹çº¦æŸé‡Œå†™å…¶å®ƒç±»å‹çº¦æŸï¼Œå³ `T: Trait<Assoc: Bounds...>`ã€‚è¿™é¿å…äº†æä¾›é¢å¤–çš„æ˜¾å¼æ³›å‹ç±»å‹æ¥çº¦æŸå…³è”ç±»å‹ã€‚

è¿™ä¸ªæ–°ç‰¹æ€§å…è®¸æˆ‘ä»¬åœ¨ä¸€äº›æƒ…å†µä¸‹æ›´ç®€å•åœ°æŒ‡å®šå¥½çº¦æŸå…³ç³»ï¼Œè§£å†³äº†ä¸€äº›ä¹‹å‰ä¸å¯èƒ½æˆ–è€…ä¼šå¼•å…¥é¢å¤–ä¸å¿…è¦çº¦æŸçš„åœºæ™¯ã€‚

- **`where` å­å¥** - åœ¨è¿™ä¸ªä½ç½®ï¼Œè¿™ç­‰åŒäºå°†çº¦æŸæ‹†åˆ†ä¸ºä¸¤ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰`where` è¯­å¥ã€‚ä¾‹å¦‚ï¼Œ`where T: Trait<Assoc: Bound>` ç­‰åŒäº `where T: Trait, <T as Trait>::Assoc: Bound`ã€‚
- **Supertraits** - ç±»ä¼¼äºä¸Šé¢ï¼Œ`trait CopyIterator: Iterator<Item: Copy> {}`ã€‚è¿™ä¹Ÿç­‰åŒäºå°†çº¦æŸæ‹†åˆ†ä¸ºä¸¤ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰`where` è¯­å¥ï¼›ä¸è¿‡å½“ trait è¢«ä½¿ç”¨æ—¶ï¼Œè¿™ä¸ªå¯¹å…³è”ç±»å‹ Item çš„çº¦æŸæ˜¯éšå«çš„ã€‚
- **å…³è”ç±»å‹ Item çº¦æŸ** - å…è®¸çº¦æŸä¸ trait çš„å…³è”ç±»å‹ç›¸å…³çš„åµŒå¥—ç±»å‹çº¦æŸã€‚ä¾‹å¦‚ `trait Trait { type Assoc: Trait2<Assoc2: Copy>; }`ã€‚
- **æ¨¡ç³Šç±»å‹çº¦æŸ**ï¼ˆRPIT: return position `impl Trait`, TAIT: type alias `impl Trait`ï¼‰ - å…è®¸çº¦æŸä¸æ¨¡ç³Šç±»å‹ç›¸å…³çš„å…³è”ç±»å‹ã€‚ä¾‹å¦‚ `impl Iterator<Item: Copy>` å®šä¹‰äº† Item æ»¡è¶³ Copy çš„è¿­ä»£å™¨ï¼Œè€Œä¸å¿…å®é™…å‘½åè¯¥çº¦æŸã€‚

æ›´å¤šç»†èŠ‚è§ [issue](https://github.com/rust-lang/rust/pull/122055/#issue-2170532454)

è¯‘æ³¨ï¼šå¾ˆç»•ï¼Œä½†æ˜¯æ•´ä½“ä¸Šå°±æ˜¯ä¸€æ¬¡è®© Rust ç¼–è¯‘å™¨å˜å¾—æ›´ç¬¦åˆä½ æœŸæœ›å®ƒåº”è¯¥æ­£å¸¸å·¥ä½œçš„æ ·å­çš„æ›´æ–°ã€‚

## ä¸´æ—¶å˜é‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿

ç°åœ¨ï¼Œåœ¨ `match` å’Œ `if` ç»“æ„ä¸­æ„é€ å¹¶ç«‹åˆ»è¢«ä½¿ç”¨çš„ä¸´æ—¶å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä¼šè‡ªåŠ¨å»¶é•¿ã€‚è¿™ä¸ä»£ç ç»“æ„ä¸­çš„ä¸´æ—¶å˜é‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿çš„æ•ˆæœä¸€è‡´ã€‚

```rust
let a = if true {
    ..;
    &temp() // used to error, but now gets lifetime extended
} else {
    ..;
    &temp() // used to error, but now gets lifetime extended
};

let a = match () {
    _ => {
        ..;
        &temp() // used to error, but now gets lifetime extended
    }
};

// ä¹‹å‰å·²æœ‰çš„ä»£ç å—ä¸´æ—¶å˜é‡ç”Ÿå‘½å‘¨æœŸå»¶é•¿
let a = {
    ..;
    &temp() // lifetime is extended
};
```

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.80.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.81.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.82.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.82 | è¶…å¤§æ›´æ–°

> Rust 1.82 å®˜æ–¹ release doc: [Announcing Rust 1.82.0 | Rust Blog](https://blog.rust-lang.org/2024/09/05/Rust-1.82.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.82 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## `cargo info` å‘½ä»¤

Cargo ç°åœ¨æœ‰ä¸€ä¸ª [`info` å­å‘½ä»¤](https://doc.rust-lang.org/nightly/cargo/commands/cargo-info.html)ï¼Œç”¨äºæ˜¾ç¤ºæ³¨å†Œè¡¨ä¸­åŒ…çš„ä¿¡æ¯ï¼Œæ»¡è¶³äº†[é•¿æœŸä»¥æ¥çš„è¯·æ±‚](https://github.com/rust-lang/cargo/issues/948)ï¼Œè·ç¦»å…¶åå‘¨å¹´çºªå¿µæ—¥ä»…å·®ä¸€ç‚¹ï¼å¤šå¹´æ¥ï¼Œå·²ç»ç¼–å†™äº†è®¸å¤šç±»ä¼¼çš„ç¬¬ä¸‰æ–¹æ‰©å±•ï¼Œè¿™ä¸ªå®ç°æœ€åˆæ˜¯ä½œä¸º [cargo-information](https://crates.io/crates/cargo-information) å¼€å‘çš„ï¼Œç°åˆå¹¶åˆ° Cargo æœ¬èº«ä¸­ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä½ å¯èƒ½ä¼šçœ‹åˆ°çš„ `cargo info cc` çš„è¾“å‡ºï¼š

```text
cc #build-dependencies
A build-time dependency for Cargo build scripts to assist in invoking the native
C compiler to compile native C code into a static archive to be linked into Rust
code.
version: 1.1.23 (latest 1.1.30)
license: MIT OR Apache-2.0
rust-version: 1.63
documentation: https://docs.rs/cc
homepage: https://github.com/rust-lang/cc-rs
repository: https://github.com/rust-lang/cc-rs
crates.io: https://crates.io/crates/cc/1.1.23
features:
  jobserver = []
  parallel  = [dep:libc, dep:jobserver]
note: to see how you depend on cc, run `cargo tree --invert --package cc@1.1.23`
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`cargo info` æè¿°æœ¬åœ° `Cargo.lock` ä¸­çš„åŒ…ç‰ˆæœ¬ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚å¦‚ä½ æ‰€è§ï¼Œå®ƒè¿˜ä¼šæŒ‡ç¤ºæ˜¯å¦æœ‰æ›´æ–°çš„ç‰ˆæœ¬ï¼Œ`cargo info cc@1.1.30` å°†æŠ¥å‘Šè¯¥ç‰ˆæœ¬çš„ä¿¡æ¯ã€‚

## Apple ç›¸å…³ç¼–è¯‘ç›®æ ‡æ”¯æŒç­‰çº§æå‡

### macOS on 64-bit ARM ç°åœ¨æ˜¯ Tier 1

é€‚ç”¨äº macOS çš„ 64 ä½ ARMï¼ˆM1 ç³»åˆ—æˆ–æ›´é«˜ç‰ˆæœ¬çš„ Apple Silicon CPUï¼‰çš„ Rust ç›®æ ‡ `aarch64-apple-darwin` ç°åœ¨æ˜¯ä¸€ä¸ª Tier 1 ç›®æ ‡ï¼Œè¡¨æ˜æˆ‘ä»¬å¯¹å®ƒçš„å·¥ä½œçŠ¶æ€æœ‰æœ€é«˜çš„ä¿è¯ã€‚æ­£å¦‚ [å¹³å°æ”¯æŒ](https://doc.rust-lang.org/stable/rustc/platform-support.html) é¡µé¢æ‰€è¿°ï¼ŒRust ä»“åº“ä¸­çš„æ¯ä¸ªæ›´æ”¹åœ¨åˆå¹¶ä¹‹å‰å¿…é¡»åœ¨æ¯ä¸ª Tier 1 ç›®æ ‡ä¸Šé€šè¿‡å®Œæ•´çš„æµ‹è¯•ã€‚æ­¤å‰ `darwin` åœ¨ Rust 1.49 ä¸­ä½œä¸º Tier 2 å¼•å…¥ï¼Œä½¿å…¶åœ¨ `rustup` ä¸­å¯ç”¨ã€‚è¿™ä¸€æ–°çš„é‡Œç¨‹ç¢‘ä½¿ `aarch64-apple-darwin` ç›®æ ‡ä¸ 64 ä½ ARM Linux ä»¥åŠ X86 macOSã€Linux å’Œ Windows ç›®æ ‡å¤„äºåŒç­‰åœ°ä½ã€‚

### Mac Catalyst ç›®æ ‡ç°åœ¨æ˜¯ Tier 2

[Mac Catalyst](https://developer.apple.com/mac-catalyst/) æ˜¯è‹¹æœçš„ä¸€é¡¹æŠ€æœ¯ï¼Œå…è®¸åœ¨ Mac ä¸ŠåŸç”Ÿè¿è¡Œ iOS åº”ç”¨ç¨‹åºã€‚è¿™å¯¹äºæµ‹è¯•ç‰¹å®šäº iOS çš„ä»£ç ç‰¹åˆ«æœ‰ç”¨ï¼Œå› ä¸º `cargo test --target=aarch64-apple-ios-macabi --target=x86_64-apple-ios-macabi` åŸºæœ¬ä¸Šå¯ä»¥ç›´æ¥å·¥ä½œï¼ˆä¸é€šå¸¸çš„ iOS ç›®æ ‡ç›¸æ¯”ï¼Œåè€…éœ€è¦åœ¨å¤–éƒ¨å·¥å…·æ‰“åŒ…åæ‰èƒ½åœ¨åŸç”Ÿè®¾å¤‡æˆ–æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œï¼‰ã€‚

[è¿™äº›ç›®æ ‡](https://doc.rust-lang.org/nightly/rustc/platform-support/apple-ios-macabi.html) ç°åœ¨æ˜¯ Tier 2ï¼Œå¯ä»¥é€šè¿‡ `rustup target add aarch64-apple-ios-macabi x86_64-apple-ios-macabi` ä¸‹è½½ï¼Œç°åœ¨æ˜¯æ›´æ–°ä½ çš„ CI ç®¡é“ä»¥æµ‹è¯•ä½ çš„ä»£ç æ˜¯å¦ä¹Ÿèƒ½åœ¨ç±»ä¼¼ iOS çš„ç¯å¢ƒä¸­è¿è¡Œçš„å¥½æ—¶æœºã€‚

## ç²¾ç¡®æ•è· `use<..>` è¯­æ³•

Rust ç°åœ¨æ”¯æŒåœ¨æŸäº› `impl Trait` è¾¹ç•Œä¸­ä½¿ç”¨ `use<..>` è¯­æ³•æ¥æ§åˆ¶å“ªäº›æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«æ•è·ã€‚

Rust ä¸­çš„ `Return-position impl Trait`ï¼ˆRPITï¼‰ç±»å‹ä¼š*æ•è·*æŸäº›æ³›å‹å‚æ•°ã€‚æ•è·ä¸€ä¸ªæ³›å‹å‚æ•°å…è®¸è¯¥å‚æ•°åœ¨éšè—ç±»å‹ä¸­ä½¿ç”¨ã€‚è¿™åè¿‡æ¥ä¼šå½±å“å€Ÿç”¨æ£€æŸ¥ã€‚

åœ¨ Rust 2021 åŠæ›´æ—©ç‰ˆæœ¬ä¸­ï¼Œç”Ÿå‘½å‘¨æœŸå‚æ•°åœ¨è£¸å‡½æ•°å’Œå›ºæœ‰ impl çš„å‡½æ•°å’Œæ–¹æ³•ä¸­çš„ä¸é€æ˜ç±»å‹ä¸­ä¸ä¼šè¢«æ•è·ï¼Œé™¤éè¿™äº›ç”Ÿå‘½å‘¨æœŸå‚æ•°åœ¨è¯­æ³•ä¸Šè¢«æåŠã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯ä¸€ä¸ªé”™è¯¯ï¼š

```rust
//@ edition: 2021
fn f(x: &()) -> impl Sized { x }
```

```text
error[E0700]: hidden type for `impl Sized` captures lifetime that does not appear in bounds
 --> src/main.rs:1:30
  |
1 | fn f(x: &()) -> impl Sized { x }
  |         ---     ----------   ^
  |         |       |
  |         |       opaque type defined here
  |         hidden type `&()` captures the anonymous lifetime defined here
  |
help: add a `use<...>` bound to explicitly capture `'_`
  |
1 | fn f(x: &()) -> impl Sized + use<'_> { x }
  |                            +++++++++
```

é€šè¿‡æ–°çš„ `use<..>` è¯­æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§é”™è¯¯æç¤ºä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn f(x: &()) -> impl Sized + use<'_> { x }
```

ä»¥å‰ï¼Œæ­£ç¡®ä¿®å¤è¿™ç±»é”™è¯¯éœ€è¦å®šä¹‰ä¸€ä¸ªè™šæ‹Ÿç‰¹å¾ï¼Œé€šå¸¸ç§°ä¸º `Captures`ï¼Œå¹¶æŒ‰å¦‚ä¸‹æ–¹å¼ä½¿ç”¨å®ƒï¼š

```rust
trait Captures<T: ?Sized> {}
impl<T: ?Sized, U: ?Sized> Captures<T> for U {}
fn f(x: &()) -> impl Sized + Captures<&'_ ()> { x }
```

è¿™è¢«ç§°ä¸º ["the `Captures` trick"](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md#the-captures-trick)ï¼Œå®ƒæœ‰ç‚¹å¤æ‚å’Œå¾®å¦™ã€‚ç°åœ¨ä¸å†éœ€è¦äº†ã€‚
è¿˜æœ‰ä¸€ç§ä¸å¤ªæ­£ç¡®ä½†æ›´æ–¹ä¾¿çš„ä¿®å¤æ–¹æ³•ï¼Œé€šå¸¸ç§°ä¸º ["the outlives trick"](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md#the-outlives-trick)ã€‚ç¼–è¯‘å™¨ç”šè‡³ä»¥å‰å»ºè®®è¿™æ ·åšã€‚è¿™ä¸ªæŠ€å·§çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust
fn f(x: &()) -> impl Sized + '_ { x }
```

åœ¨è¿™ä¸ªç®€å•çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªæŠ€å·§åœ¨ç»†å¾®çš„åŸå› ä¸Šä¸ `+ use<'_>` å®Œå…¨ç­‰ä»·ï¼ŒåŸå› åœ¨ [RFC 3498](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md) ä¸­æœ‰è§£é‡Šã€‚ç„¶è€Œï¼Œåœ¨å®é™…æƒ…å†µä¸‹ï¼Œè¿™ä¼šè¿‡åº¦çº¦æŸè¿”å›çš„ä¸é€æ˜ç±»å‹çš„è¾¹ç•Œã€‚æ¯”å¦‚å¦‚ä¸‹ä»£ç é‡Œï¼š

```rust
struct Ctx<'cx>(&'cx u8);

fn f<'cx, 'a>(
    cx: Ctx<'cx>,
    x: &'a u8,
) -> impl Iterator<Item = &'a u8> + 'cx {
    core::iter::once_with(move || {
        eprintln!("LOG: {}", cx.0);
        x
    })
//~^ ERROR lifetime may not live long enough
}
```

æˆ‘ä»¬ä¸èƒ½ç§»é™¤ `+ 'cx`ï¼Œå› ä¸ºç”Ÿå‘½å‘¨æœŸè¢«ç”¨äºéšè—ç±»å‹ä¸­ï¼Œå› æ­¤å¿…é¡»è¢«æ•è·ã€‚æˆ‘ä»¬ä¹Ÿä¸èƒ½æ·»åŠ  `'a: 'cx`çš„çº¦æŸï¼Œå› ä¸ºè¿™äº›ç”Ÿå‘½å‘¨æœŸå®é™…ä¸Šå¹¶ä¸ç›¸å…³ï¼Œå¹¶ä¸”é€šå¸¸æƒ…å†µä¸‹ `'a` ä¸ä¼šæ¯” `'cx` æ›´é•¿ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æ”¹ä¸ºå†™ `+ use<'cx, 'a>`ï¼Œè¿™å°†æœ‰æ•ˆå¹¶å…·æœ‰æ­£ç¡®çš„çº¦æŸã€‚


æœ‰ä¸€äº›é™åˆ¶æ­£åœ¨ç¨³å®šåŒ–ã€‚`use<..>` è¯­æ³•ç›®å‰ä¸èƒ½å‡ºç°åœ¨ç‰¹å¾æˆ–ç‰¹å¾å®ç°ä¸­ï¼Œå¹¶ä¸”å¿…é¡»åˆ—å‡ºæ‰€æœ‰åœ¨ä½œç”¨åŸŸå†…çš„æ³›å‹ç±»å‹å’Œå¸¸é‡å‚æ•°ã€‚æˆ‘ä»¬å¸Œæœ›éšç€æ—¶é—´çš„æ¨ç§»è§£é™¤è¿™äº›é™åˆ¶ã€‚

è¯·æ³¨æ„ï¼Œåœ¨ Rust 2024 ä¸­ï¼Œä¸Šé¢çš„ä¾‹å­å°†â€œç›´æ¥å·¥ä½œâ€ï¼Œè€Œä¸éœ€è¦ `use<..>` è¯­æ³•ï¼ˆæˆ–ä»»ä½•æŠ€å·§ï¼‰ã€‚è¿™æ˜¯å› ä¸ºåœ¨æ–°ç‰ˆæœ¬ä¸­ï¼Œä¸é€æ˜ç±»å‹å°†è‡ªåŠ¨æ•è·æ‰€æœ‰åœ¨ä½œç”¨åŸŸå†…çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªæ›´å¥½çš„é»˜è®¤è®¾ç½®ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¾ˆå¤šå…³äºè¿™å¦‚ä½•æ¸…ç†ä»£ç çš„è¯æ®ã€‚åœ¨ Rust 2024 ä¸­ï¼Œ`use<..>` è¯­æ³•å°†ä½œä¸ºä¸€ç§é‡è¦çš„æ–¹å¼æ¥é€‰æ‹©é€€å‡ºè¯¥é»˜è®¤è®¾ç½®ã€‚

æœ‰å…³ `use<..>` è¯­æ³•ã€æ•è·ä»¥åŠè¿™å¦‚ä½•åº”ç”¨äº Rust 2024 çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ç‰ˆæœ¬æŒ‡å—ä¸­çš„ ["RPIT lifetime capture rules"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/rpit-lifetime-capture.html) ç« èŠ‚ã€‚æœ‰å…³æ•´ä½“æ–¹å‘çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æˆ‘ä»¬æœ€è¿‘çš„åšå®¢æ–‡ç«  ["Changes to `impl Trait` in Rust 2024"]([2024-09-05-impl-trait-capture-rules.md](https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html))ã€‚

## åˆ›å»ºåŸå§‹æŒ‡é’ˆçš„åŸç”Ÿè¯­æ³•

ä¸å®‰å…¨ä»£ç æœ‰æ—¶å¿…é¡»å¤„ç†å¯èƒ½æ‚¬ç©ºã€æœªå¯¹é½æˆ–ä¸æŒ‡å‘æœ‰æ•ˆæ•°æ®çš„æŒ‡é’ˆã€‚è¿™ç§æƒ…å†µå¸¸è§äº `repr(packed)` ç»“æ„ä½“ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¿å…åˆ›å»ºå¼•ç”¨éå¸¸é‡è¦ï¼Œå› ä¸ºè¿™ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚è¿™æ„å‘³ç€é€šå¸¸çš„ `&` å’Œ `&mut` æ“ä½œç¬¦ä¸èƒ½ä½¿ç”¨ï¼Œå› ä¸ºå®ƒä»¬ä¼šåˆ›å»ºå¼•ç”¨â€”â€”å³ä½¿å¼•ç”¨ç«‹å³è¢«è½¬æ¢ä¸ºåŸå§‹æŒ‡é’ˆï¼Œä¹Ÿæ— æ³•é¿å…æœªå®šä¹‰è¡Œä¸ºã€‚

å¤šå¹´æ¥ï¼Œå® `std::ptr::addr_of!` å’Œ `std::ptr::addr_of_mut!` ä¸€ç›´æœåŠ¡äºè¿™ä¸ªç›®çš„ã€‚ç°åœ¨æ˜¯ä¸ºè¿™ä¸ªæ“ä½œæä¾›é€‚å½“åŸç”Ÿè¯­æ³•çš„æ—¶å€™äº†ï¼š`addr_of!(expr)` å˜æˆäº† `&raw const expr`ï¼Œè€Œ `addr_of_mut!(expr)` å˜æˆäº† `&raw mut expr`ã€‚ä¾‹å¦‚ï¼š

```rust
#[repr(packed)]
struct Packed {
    not_aligned_field: i32,
}

fn main() {
    let p = Packed { not_aligned_field: 1_82 };

    // This would be undefined behavior!
    // It is rejected by the compiler.
    // let ptr = &p.not_aligned_field as *const i32;

    // This is the old way of creating a pointer.
    let ptr = std::ptr::addr_of!(p.not_aligned_field);

    // This is the new way.
    let ptr = &raw const p.not_aligned_field;

    // Accessing the pointer has not changed.
    // Note that `val = *ptr` would be undefined behavior because
    // the pointer is not aligned!
    let val = unsafe { ptr.read_unaligned() };
}
```

åŸç”Ÿè¯­æ³•æ›´åŠ æ¸…æ™°åœ°å°†è¡¨è¾¾å¼è§£é‡Šä¸º[ä½ç½®è¡¨è¾¾å¼(place expressions)](https://www.ralfj.de/blog/2024/08/14/places.html)ã€‚å®ƒè¿˜é¿å…äº†åœ¨æåˆ°åˆ›å»ºæŒ‡é’ˆçš„æ“ä½œæ—¶ä½¿ç”¨â€œå–åœ°å€â€çš„æœ¯è¯­ã€‚æŒ‡é’ˆ[ä¸ä»…ä»…æ˜¯åœ°å€](https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html)ï¼Œå› æ­¤ Rust æ­£åœ¨æ‘†è„±è¯¸å¦‚â€œå–åœ°å€â€ä¹‹ç±»çš„**å¼ºåŒ–äº†æŒ‡é’ˆå’Œåœ°å€ä¹‹é—´çš„é”™è¯¯ç­‰ä»·å…³ç³»**æœ¯è¯­ã€‚

## `unsafe extern` é‡Œçš„ `safe` éƒ¨åˆ†

Rust ä»£ç å¯ä»¥ä½¿ç”¨æ¥è‡ªå¤–éƒ¨ä»£ç çš„å‡½æ•°å’Œé™æ€å˜é‡ã€‚è¿™äº›å¤–éƒ¨é¡¹çš„ç±»å‹ç­¾ååœ¨ `extern` å—ä¸­æä¾›ã€‚å†å²ä¸Šï¼Œ`extern` å—ä¸­çš„æ‰€æœ‰é¡¹åœ¨è°ƒç”¨æ—¶éƒ½æ˜¯ä¸å®‰å…¨çš„ï¼Œä½†æˆ‘ä»¬ä¸éœ€è¦åœ¨ `extern` å—æœ¬èº«ä¸Šå†™ `unsafe`ã€‚

ç„¶è€Œï¼Œå¦‚æœ `extern` å—ä¸­çš„ç­¾åä¸æ­£ç¡®ï¼Œé‚£ä¹ˆä½¿ç”¨è¯¥é¡¹å°†å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚è¿™æ˜¯ç¼–å†™ `extern` å—çš„äººçš„é”™è¯¯ï¼Œè¿˜æ˜¯ä½¿ç”¨è¯¥é¡¹çš„äººçš„é”™è¯¯ï¼Ÿ

æˆ‘ä»¬å†³å®šï¼Œç¼–å†™ `extern` å—çš„äººæœ‰è´£ä»»ç¡®ä¿å…¶ä¸­åŒ…å«çš„æ‰€æœ‰ç­¾åéƒ½æ˜¯æ­£ç¡®çš„ï¼Œå› æ­¤æˆ‘ä»¬ç°åœ¨å…è®¸ç¼–å†™ `unsafe extern`ï¼š

```rust
unsafe extern {  
    pub safe static TAU: f64;
    pub safe fn sqrt(x: f64) -> f64;
    pub unsafe fn strlen(p: *const u8) -> usize;
}
```

è¿™æ ·åšçš„ä¸€ä¸ªå¥½å¤„æ˜¯ï¼Œ`unsafe extern` å—ä¸­çš„é¡¹å¯ä»¥è¢«æ ‡è®°ä¸ºå®‰å…¨çš„è°ƒç”¨ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸ä½¿ç”¨ `unsafe` çš„æƒ…å†µä¸‹è°ƒç”¨ `sqrt` æˆ–è¯»å– `TAU`ã€‚æ²¡æœ‰æ ‡è®°ä¸º `safe` æˆ– `unsafe` çš„é¡¹ä¼šè¢«ä¿å®ˆåœ°è®¤ä¸ºæ˜¯ `unsafe`ã€‚

åœ¨æœªæ¥çš„ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬å°†é€šè¿‡ lint é¼“åŠ±ä½¿ç”¨ `unsafe extern`ã€‚ä» Rust 2024å¼€å§‹ï¼Œä½¿ç”¨ `unsafe extern` å°†æ˜¯å¿…éœ€çš„ã€‚

æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[RFC 3484](https://github.com/rust-lang/rfcs/blob/master/text/3484-unsafe-extern-blocks.md)å’Œç‰ˆæœ¬æŒ‡å—ä¸­çš„["Unsafe extern blocks"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/unsafe-extern.html)ç« èŠ‚ã€‚

### ä¸å®‰å…¨çš„å±æ€§

ä¸€äº› Rust å±æ€§ï¼Œä¾‹å¦‚[`no_mangle`](https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute)ï¼Œå¯ä»¥åœ¨æ²¡æœ‰ `unsafe` å—çš„æƒ…å†µä¸‹[å¯¼è‡´æœªå®šä¹‰è¡Œä¸º](https://github.com/rust-lang/rust/issues/28179)ã€‚å¦‚æœæ˜¯å¸¸è§„ä»£ç ï¼Œæˆ‘ä»¬ä¼šè¦æ±‚å®ƒä»¬æ”¾åœ¨ `unsafe {}`å—ä¸­ï¼Œä½†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå±æ€§è¿˜æ²¡æœ‰ç±»ä¼¼çš„è¯­æ³•ã€‚ä¸ºäº†åæ˜ è¿™äº›å±æ€§å¯ä»¥ç ´å Rust çš„å®‰å…¨ä¿è¯ï¼Œå®ƒä»¬ç°åœ¨è¢«è®¤ä¸ºæ˜¯â€œä¸å®‰å…¨â€çš„ï¼Œåº”è¯¥å†™æˆå¦‚ä¸‹å½¢å¼ï¼š

```rust
#[unsafe(no_mangle)]
pub fn my_global_function() { }
```

å±æ€§çš„æ—§å½¢å¼ï¼ˆä¸å¸¦ `unsafe`ï¼‰ç›®å‰ä»ç„¶è¢«æ¥å—ï¼Œä½†æœªæ¥å¯èƒ½ä¼šè¢« lint è­¦å‘Šï¼Œå¹¶ä¸”åœ¨ Rust 2024ä¸­å°†æˆä¸ºé”™è¯¯ã€‚

è¿™ä¼šå½±å“ä»¥ä¸‹å±æ€§ï¼š
- `no_mangle`
- `link_section`
- `export_name`

æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ç‰ˆæœ¬æŒ‡å—ä¸­çš„["Unsafe attributes"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/unsafe-attributes.html)ç« èŠ‚ã€‚

## çœç•¥æ¨¡å¼åŒ¹é…ä¸­çš„ç©ºç±»å‹

ç°åœ¨å¯ä»¥çœç•¥é€šè¿‡å€¼åŒ¹é…ç©ºï¼ˆå³æ— æ³•å®ä¾‹åŒ–çš„ï¼‰ç±»å‹çš„æ¨¡å¼ï¼š

```rust
use std::convert::Infallible;
pub fn unwrap_without_panic<T>(x: Result<T, Infallible>) -> T {
    let Ok(x) = x; // the `Err` case does not need to appear
    x
}
```

è¿™é€‚ç”¨äºç©ºç±»å‹ï¼Œä¾‹å¦‚æ²¡æœ‰å˜ä½“çš„ `enum Void {}`ï¼Œæˆ–è€…å…·æœ‰å¯è§ç©ºå­—æ®µä¸”æ²¡æœ‰ `#[non_exhaustive]` å±æ€§çš„ç»“æ„ä½“å’Œæšä¸¾ã€‚å®ƒåœ¨ä¸ `!` ç±»å‹ç»“åˆä½¿ç”¨æ—¶ä¹Ÿç‰¹åˆ«æœ‰ç”¨ï¼Œå°½ç®¡è¯¥ç±»å‹ç›®å‰ä»ä¸ç¨³å®šã€‚

ä»ç„¶æœ‰ä¸€äº›æƒ…å†µä¸‹å¿…é¡»ç¼–å†™ç©ºæ¨¡å¼ã€‚ç”±äºæœªåˆå§‹åŒ–å€¼å’Œ unsafe ä»£ç çš„åŸå› ï¼Œå¦‚æœé€šè¿‡å¼•ç”¨ã€æŒ‡é’ˆæˆ–è”åˆå­—æ®µè®¿é—®ç©ºç±»å‹ï¼Œåˆ™ä¸å…è®¸çœç•¥æ¨¡å¼ï¼š

```rust
pub fn unwrap_ref_without_panic<T>(x: &Result<T, Infallible>) -> &T {
    match x {
        Ok(x) => x,
        // ç”±äºå¼•ç”¨ï¼Œæ­¤åˆ†æ”¯ä¸èƒ½çœç•¥
        Err(infallible) => match *infallible {},
    }
}
```

ä¸ºäº†é¿å…å¹²æ‰°å¸Œæœ›æ”¯æŒå¤šä¸ª Rust ç‰ˆæœ¬çš„ crateï¼Œå°½ç®¡å¯ä»¥åˆ é™¤ï¼Œä½†å¸¦æœ‰ç©ºæ¨¡å¼çš„ `match` åˆ†æ”¯å°šæœªæŠ¥å‘Šä¸ºâ€œä¸å¯è¾¾ä»£ç â€è­¦å‘Šã€‚

## æµ®ç‚¹æ•° NaN è¯­ä¹‰ä¸ `const`

å¯¹æµ®ç‚¹æ•°å€¼ï¼ˆç±»å‹ä¸º `f32` å’Œ `f64`ï¼‰çš„æ“ä½œä»¥å…¶å¾®å¦™æ€§è€Œé—»åã€‚åŸå› ä¹‹ä¸€æ˜¯å­˜åœ¨â€œNaN å€¼â€ï¼šè¿™æ˜¯â€œä¸æ˜¯ä¸€ä¸ªæ•°å­—(not a number)â€çš„ç¼©å†™ï¼Œç”¨äºè¡¨ç¤ºä¾‹å¦‚ `0.0 / 0.0` çš„ç»“æœã€‚NaN å€¼çš„å¾®å¦™ä¹‹å¤„åœ¨äºå­˜åœ¨å¤šä¸ªå¯èƒ½çš„ NaN å€¼ï¼šNaN å€¼æœ‰ä¸€ä¸ªç¬¦å·ï¼Œå¯ä»¥é€šè¿‡ `f.is_sign_positive()` æ£€æŸ¥ï¼Œå®ƒè¿˜æœ‰ä¸€ä¸ªå¯ä»¥é€šè¿‡ `f.to_bits()` æå–çš„â€œæœ‰æ•ˆè½½è·â€â€”â€”ç„¶è€Œï¼Œè¿™ä¸¤è€…éƒ½è¢« `==` å®Œå…¨å¿½ç•¥ï¼ˆåœ¨ NaN ä¸Šæ€»æ˜¯è¿”å› `false`ï¼‰ã€‚å°½ç®¡åœ¨ç¡¬ä»¶æ¶æ„ä¹‹é—´æ ‡å‡†åŒ–æµ®ç‚¹æ“ä½œçš„è¡Œä¸ºå–å¾—äº†éå¸¸æˆåŠŸçš„åŠªåŠ›ï¼Œä½†ä½•æ—¶ NaN æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ä»¥åŠå…¶ç¡®åˆ‡æœ‰æ•ˆè½½è·çš„ç»†èŠ‚åœ¨ä¸åŒæ¶æ„ä¹‹é—´æœ‰æ‰€ä¸åŒã€‚æ›´å¤æ‚çš„æ˜¯ï¼ŒRust åŠå…¶ LLVM åç«¯åœ¨ä¿è¯æ•°å€¼ç»“æœä¸å˜çš„æƒ…å†µä¸‹å¯¹æµ®ç‚¹æ“ä½œè¿›è¡Œä¼˜åŒ–ï¼Œä½†è¿™äº›ä¼˜åŒ–å¯ä»¥æ”¹å˜äº§ç”Ÿçš„ NaN å€¼ã€‚ä¾‹å¦‚ï¼Œ`f * 1.0` å¯èƒ½ä¼šä¼˜åŒ–ä¸º `f`ã€‚ç„¶è€Œï¼Œå¦‚æœ `f` æ˜¯ NaNï¼Œè¿™å¯èƒ½ä¼šæ”¹å˜ç»“æœçš„ç¡®åˆ‡ä½æ¨¡å¼ï¼

åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼ŒRust æ ‡å‡†åŒ–äº†ä¸€å¥— NaN å€¼çš„è¡Œä¸ºè§„åˆ™ã€‚è¿™å¥—è§„åˆ™å¹¶ä¸æ˜¯å®Œå…¨ç¡®å®šçš„ï¼Œè¿™æ„å‘³ç€åƒ `(0.0 / 0.0).is_sign_positive()` è¿™æ ·çš„æ“ä½œç»“æœå¯èƒ½ä¼šæ ¹æ®ç¡¬ä»¶æ¶æ„ã€ä¼˜åŒ–çº§åˆ«å’Œå‘¨å›´ä»£ç çš„ä¸åŒè€Œæœ‰æ‰€ä¸åŒã€‚æ—¨åœ¨å®Œå…¨å¯ç§»æ¤çš„ä»£ç åº”é¿å…ä½¿ç”¨ `to_bits`ï¼Œå¹¶åº”ä½¿ç”¨ `f.signum() == 1.0` è€Œä¸æ˜¯ `f.is_sign_positive()`ã€‚ç„¶è€Œï¼Œè¿™äº›è§„åˆ™ç»è¿‡ç²¾å¿ƒé€‰æ‹©ï¼Œä»ç„¶å…è®¸åœ¨ Rust ä»£ç ä¸­å®ç°é«˜çº§æ•°æ®è¡¨ç¤ºæŠ€æœ¯ï¼Œå¦‚ *NaN boxing*ã€‚æœ‰å…³ç¡®åˆ‡è§„åˆ™çš„æ›´å¤šç»†èŠ‚ï¼Œè¯·æŸ¥çœ‹æˆ‘ä»¬çš„[æ–‡æ¡£](https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns)ã€‚

éšç€ NaN å€¼çš„è¯­ä¹‰ç¡®å®šï¼Œæ­¤ç‰ˆæœ¬è¿˜å…è®¸åœ¨ `const fn` ä¸­ä½¿ç”¨æµ®ç‚¹æ•°æ“ä½œã€‚ç”±äºä¸Šè¿°åŸå› ï¼Œåƒ `(0.0 / 0.0).is_sign_positive()` è¿™æ ·çš„æ“ä½œåœ¨ç¼–è¯‘æ—¶å’Œè¿è¡Œæ—¶å¯èƒ½ä¼šäº§ç”Ÿä¸åŒçš„ç»“æœï¼›è¿™ä¸æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä»£ç ä¸èƒ½ä¾èµ– `const fn` æ€»æ˜¯äº§ç”Ÿå®Œå…¨ç›¸åŒçš„ç»“æœã€‚

## å¸¸é‡ä½œä¸ºæ±‡ç¼–ç«‹å³æ•°

`const` æ±‡ç¼–æ“ä½œæ•°ç°åœ¨æä¾›äº†ä¸€ç§ä½¿ç”¨æ•´æ•°ä½œä¸ºç«‹å³æ•°çš„æ–¹æ³•ï¼Œè€Œæ— éœ€å…ˆå°†å®ƒä»¬å­˜å‚¨åœ¨å¯„å­˜å™¨ä¸­ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æ‰‹åŠ¨å®ç°ä¸€ä¸ª [`write`](https://man7.org/linux/man-pages/man2/write.2.html) ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
const WRITE_SYSCALL: c_int = 0x01; // ç³»ç»Ÿè°ƒç”¨ 1 æ˜¯ `write`
const STDOUT_HANDLE: c_int = 0x01; // `stdout` çš„æ–‡ä»¶å¥æŸ„æ˜¯ 1
const MSG: &str = "Hello, world!\n";

let written: usize;

// ç­¾å: `ssize_t write(int fd, const void buf[], size_t count)`
unsafe {
    core::arch::asm!(
        "mov rax, {SYSCALL} // rax ä¿å­˜ç³»ç»Ÿè°ƒç”¨å·",
        "mov rdi, {OUTPUT}  // rdi æ˜¯ `fd` (ç¬¬ä¸€ä¸ªå‚æ•°)",
        "mov rdx, {LEN}     // rdx æ˜¯ `count` (ç¬¬ä¸‰ä¸ªå‚æ•°)",
        "syscall            // è°ƒç”¨ç³»ç»Ÿè°ƒç”¨",
        "mov {written}, rax // ä¿å­˜è¿”å›å€¼",
        SYSCALL = const WRITE_SYSCALL,
        OUTPUT = const STDOUT_HANDLE,
        LEN = const MSG.len(),
        in("rsi") MSG.as_ptr(), // rsi æ˜¯ `buf *` (ç¬¬äºŒä¸ªå‚æ•°)
        written = out(reg) written,
    );
}

assert_eq!(written, MSG.len());
```

è¾“å‡º:

```text
Hello, world!
```

[Playground é“¾æ¥](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cf8e21335b38011b49156c6c65929bc).

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œ`LEN = const MSG.len()` è¿™æ ·çš„è¯­å¥å°†æ ¼å¼è¯´æ˜ç¬¦ `LEN` å¡«å……ä¸ºä¸€ä¸ªç«‹å³æ•°ï¼Œå…¶å€¼ä¸º `MSG.len()`ã€‚è¿™å¯ä»¥åœ¨ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ä¸­çœ‹åˆ°ï¼ˆå€¼ä¸º `14`ï¼‰ï¼š

```asm
lea     rsi, [rip + .L__unnamed_3]
mov     rax, 1    # rax ä¿å­˜ç³»ç»Ÿè°ƒç”¨å·
mov     rdi, 1    # rdi æ˜¯ `fd` (ç¬¬ä¸€ä¸ªå‚æ•°)
mov     rdx, 14   # rdx æ˜¯ `count` (ç¬¬ä¸‰ä¸ªå‚æ•°)
syscall # è°ƒç”¨ç³»ç»Ÿè°ƒç”¨
mov     rax, rax  # ä¿å­˜è¿”å›å€¼
```

æ›´å¤šè¯¦æƒ…è¯·å‚è§ [å‚è€ƒæ–‡æ¡£](https://doc.rust-lang.org/reference/inline-assembly.html)ã€‚

## å®‰å…¨åœ°è®¿é—®ä¸å®‰å…¨çš„ `static`

ç°åœ¨å…è®¸ä»¥ä¸‹ä»£ç ï¼š

```rust
static mut STATIC_MUT: Type = Type::new();
extern "C" {
    static EXTERN_STATIC: Type;
}
fn main() {
     let static_mut_ptr = &raw mut STATIC_MUT;
     let extern_static_ptr = &raw const EXTERN_STATIC;
}
```

åœ¨è¡¨è¾¾å¼ä¸Šä¸‹æ–‡ä¸­ï¼Œ`STATIC_MUT` å’Œ `EXTERN_STATIC` æ˜¯ [ä½ç½®è¡¨è¾¾å¼](https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions)ã€‚ä»¥å‰ï¼Œç¼–è¯‘å™¨çš„å®‰å…¨æ£€æŸ¥ä¸çŸ¥é“åŸå§‹å¼•ç”¨æ“ä½œç¬¦å®é™…ä¸Šå¹¶ä¸å½±å“æ“ä½œæ•°çš„ä½ç½®ï¼Œå°†å…¶è§†ä¸ºå¯èƒ½å¯¹æŒ‡é’ˆè¿›è¡Œè¯»æˆ–å†™ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šå®ƒåªæ˜¯åˆ›å»ºäº†ä¸€ä¸ªæŒ‡é’ˆï¼Œå¹¶æ²¡æœ‰ä¸å®‰å…¨çš„è¡Œä¸ºã€‚

æ”¾å®½è¿™ä¸€é™åˆ¶å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›ä¸å®‰å…¨çš„å—ç°åœ¨è¢«æŠ¥å‘Šä¸ºæœªä½¿ç”¨ï¼Œå¦‚æœä½ æ‹’ç» `unused_unsafe` æç¤ºï¼Œä½†å®ƒä»¬ç°åœ¨åªåœ¨æ—§ç‰ˆæœ¬ä¸­æ‰æœ‰ç”¨ã€‚å¦‚æœä½ æƒ³æ”¯æŒå¤šä¸ªç‰ˆæœ¬çš„ Rustï¼Œå¯ä»¥åœ¨è¿™äº›ä¸å®‰å…¨çš„å—ä¸Šæ·»åŠ  `#[allow(unused_unsafe)]` æ³¨è§£ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```diff
 static mut STATIC_MUT: Type = Type::new();
 fn main() {
+    #[allow(unused_unsafe)]
     let static_mut_ptr = unsafe { std::ptr::addr_of_mut!(STATIC_MUT) };
 }
```

æœªæ¥çš„ Rust ç‰ˆæœ¬é¢„è®¡ä¼šå°†æ­¤åŠŸèƒ½æ¨å¹¿åˆ°å…¶ä»–åœ¨æ­¤ä½ç½®å®‰å…¨çš„è¡¨è¾¾å¼ï¼Œè€Œä¸ä»…ä»…æ˜¯é™æ€å˜é‡ã€‚

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2024/10/17/Rust-1.82.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.83.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.84.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.84 | Const èƒ½åŠ›æ‹“å±•

> Rust 1.84 å®˜æ–¹ release doc: [Announcing Rust 1.84.0 | Rust Blog](https://blog.rust-lang.org/2025/01/09/Rust-1.84.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.84 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## Cargo åœ¨ä¾èµ–ç‰ˆæœ¬é€‰æ‹©ä¸­è€ƒè™‘ Rust ç‰ˆæœ¬

1.84.0 ç¨³å®šäº†æ”¯æŒæœ€ä½ Rust ç‰ˆæœ¬ï¼ˆMSRV, minimum supported Rust versionï¼‰çš„è§£æå™¨ï¼Œè¯¥è§£æå™¨ä¼˜å…ˆé€‰æ‹©ä¸é¡¹ç›®å£°æ˜çš„ MSRV ï¼ˆ`Cargo.toml` é‡Œçš„ `package.rust_version`ï¼‰ å…¼å®¹çš„ä¾èµ–ç‰ˆæœ¬ã€‚é€šè¿‡æ”¯æŒ MSRV çš„ç‰ˆæœ¬é€‰æ‹©ï¼Œç»´æŠ¤è€…å¯ä»¥å‡å°‘æ”¯æŒæ—§å·¥å…·é“¾çš„å·¥ä½œé‡ï¼Œå› ä¸ºä¸å†éœ€è¦ä¸ºæ¯ä¸ªä¾èµ–æ‰‹åŠ¨é€‰æ‹©æ—§ç‰ˆæœ¬ã€‚

ä½ å¯ä»¥é€šè¿‡ `.cargo/config.toml` å¯ç”¨æ”¯æŒ MSRV çš„è§£æå™¨ï¼š

```toml
[resolver]
incompatible-rust-versions = "fallback"
```

ç„¶ååœ¨æ·»åŠ ä¾èµ–æ—¶ï¼š

```bash
$ cargo add clap
    Updating crates.io index
warning: ignoring clap@4.5.23 (which requires rustc 1.74) to maintain demo's rust-version of 1.60
      Adding clap v4.0.32 to dependencies
    Updating crates.io index
     Locking 33 packages to latest Rust 1.60 compatible versions
      Adding clap v4.0.32 (available: v4.5.23, requires Rust 1.74)
```

åœ¨ CI ä¸­[éªŒè¯æœ€æ–°ä¾èµ–](https://doc.rust-lang.org/cargo/guide/continuous-integration.html#verifying-latest-dependencies)æ—¶ï¼Œä½ å¯ä»¥è¦†ç›–æ­¤è¡Œä¸ºï¼š

```bash
$ CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS=allow cargo update
    Updating crates.io index
     Locking 12 packages to latest compatible versions
    Updating clap v4.0.32 -> v4.5.23
```

ä½ ä¹Ÿå¯ä»¥é€šè¿‡åœ¨ `Cargo.toml` æ¸…å•æ–‡ä»¶ä¸­è®¾ç½® [`package.resolver = "3"`](https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions) æ¥å¯ç”¨æ­¤åŠŸèƒ½ï¼Œä½†è¿™éœ€è¦å°† MSRV æå‡åˆ° 1.84ã€‚å¯¹äºä½¿ç”¨ Rust 2024 çš„é¡¹ç›®ï¼ˆå°†åœ¨ 1.85 ä¸­ç¨³å®šï¼‰ï¼Œæ–°çš„è§£æå™¨å°†é»˜è®¤å¯ç”¨ã€‚

è¿™ä¸ºåº“ä½œè€…åœ¨å†³å®šé‡‡ç”¨æ–° Rust å·¥å…·é“¾åŠŸèƒ½çš„ç­–ç•¥æ—¶æä¾›äº†æ›´å¤§çš„çµæ´»æ€§ã€‚ä»¥å‰ï¼Œåº“é‡‡ç”¨æ–° Rust å·¥å…·é“¾çš„åŠŸèƒ½ä¼šè¿«ä½¿ä½¿ç”¨æ—§ Rust ç‰ˆæœ¬çš„ä¸‹æ¸¸ç”¨æˆ·è¦ä¹ˆå‡çº§å·¥å…·é“¾ï¼Œè¦ä¹ˆæ‰‹åŠ¨é€‰æ‹©ä¸å·¥å…·é“¾å…¼å®¹çš„æ—§ç‰ˆæœ¬åº“ï¼ˆå¹¶é¿å…è¿è¡Œ `cargo update`ï¼‰ã€‚ç°åœ¨ï¼Œè¿™äº›ç”¨æˆ·å°†èƒ½å¤Ÿè‡ªåŠ¨ä½¿ç”¨ä¸å…¶æ—§å·¥å…·é“¾å…¼å®¹çš„æ—§åº“ç‰ˆæœ¬ã€‚

æœ‰å…³å†³å®š MSRV ç­–ç•¥æ—¶çš„æ›´å¤šæ³¨æ„äº‹é¡¹ï¼Œè¯·å‚é˜…[æ–‡æ¡£](https://doc.rust-lang.org/cargo/reference/rust-version.html#setting-and-updating-rust-version)ã€‚

## æ–° trait æ±‚è§£å™¨çš„è¿ç§»å¼€å§‹

Rust ç¼–è¯‘å™¨æ­£åœ¨è¿ç§»åˆ°æ–°çš„ trait æ±‚è§£å™¨å®ç°ã€‚ä¸‹ä¸€ä»£ trait æ±‚è§£å™¨æ˜¯ Rust ç±»å‹ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶çš„é‡æ–°å®ç°ã€‚å®ƒä¸ä»…è´Ÿè´£æ£€æŸ¥ trait è¾¹ç•Œï¼ˆä¾‹å¦‚ `Vec<T>: Clone`ï¼‰æ˜¯å¦æˆç«‹ï¼Œè¿˜è¢«ç±»å‹ç³»ç»Ÿçš„è®¸å¤šå…¶ä»–éƒ¨åˆ†ä½¿ç”¨ï¼Œä¾‹å¦‚è§„èŒƒåŒ–ï¼ˆç¡®å®š `<Vec<T> as IntoIterator>::Item` çš„åŸºç¡€ç±»å‹ï¼‰å’Œç±»å‹ç­‰ä»·ï¼ˆæ£€æŸ¥ `T` å’Œ `U` æ˜¯å¦ç›¸åŒï¼‰ã€‚

åœ¨ 1.84 ä¸­ï¼Œæ–°æ±‚è§£å™¨ç”¨äºæ£€æŸ¥ trait å®ç°çš„ä¸€è‡´æ€§ã€‚ä»é«˜å±‚æ¬¡æ¥çœ‹ï¼Œä¸€è‡´æ€§è´Ÿè´£ç¡®ä¿åœ¨è€ƒè™‘å…¶ä»– crate ä¸­å°šæœªç¼–å†™æˆ–ä¸å¯è§çš„ä»£ç æ—¶ï¼Œç»™å®šç±»å‹çš„ trait å®ç°æœ€å¤šåªæœ‰ä¸€ä¸ªã€‚

æ­¤ç¨³å®šåŒ–ä¿®å¤äº†æ—§å®ç°ä¸­çš„ä¸€äº›ä¸»è¦ç†è®ºä¸Šçš„æ­£ç¡®æ€§é—®é¢˜ï¼Œå¯¼è‡´å¯èƒ½ä¼šæŠ¥å‘Šä»¥å‰æœªæŠ¥å‘Šçš„â€œtrait å†²çªå®ç°â€é”™è¯¯ã€‚æ ¹æ® [Crater](https://github.com/rust-lang/crater/) å¯¹å¯ç”¨ä»£ç çš„è¯„ä¼°ï¼Œæˆ‘ä»¬é¢„è®¡å—å½±å“çš„æ¨¡å¼éå¸¸ç½•è§ã€‚æ­¤æ¬¡ç¨³å®šç‰ˆæœ¬è¿˜æé«˜äº†æˆ‘ä»¬è¯æ˜å®ç°ä¸é‡å çš„èƒ½åŠ›ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹å…è®¸ç¼–å†™æ›´å¤šä»£ç ã€‚

æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä¹‹å‰çš„[åšå®¢æ–‡ç« ](https://blog.rust-lang.org/inside-rust/2024/12/04/trait-system-refactor-initiative.html)å’Œ[ç¨³å®šæŠ¥å‘Š](https://github.com/rust-lang/rust/pull/130654)ã€‚

## ä¸¥æ ¼æ¥æº API

åœ¨ Rust ä¸­ï¼Œ[æŒ‡é’ˆä¸ä»…ä»…æ˜¯â€œæ•´æ•°â€æˆ–â€œåœ°å€â€](https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html)ã€‚ä¾‹å¦‚ï¼Œâ€œé‡Šæ”¾åä½¿ç”¨â€æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼Œå³ä½¿ä½ â€œå¹¸è¿â€å¹¶ä¸”åœ¨è¯»å–/å†™å…¥ä¹‹å‰é‡æ–°åˆ†é…äº†é‡Šæ”¾çš„å†…å­˜ã€‚å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼Œé€šè¿‡ä» `&i32` å¼•ç”¨æ´¾ç”Ÿçš„æŒ‡é’ˆå†™å…¥æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼Œå³ä½¿é€šè¿‡ä¸åŒæŒ‡é’ˆå†™å…¥åŒä¸€åœ°å€æ˜¯åˆæ³•çš„ã€‚è¿™é‡Œçš„åº•å±‚æ¨¡å¼æ˜¯ï¼ŒæŒ‡é’ˆçš„è®¡ç®—æ–¹å¼å¾ˆé‡è¦ï¼Œè€Œä¸ä»…ä»…æ˜¯è®¡ç®—ç»“æœçš„åœ°å€ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¯´æŒ‡é’ˆå…·æœ‰**æ¥æº**ï¼šè¦å®Œå…¨æè¿° Rust ä¸­ä¸æŒ‡é’ˆç›¸å…³çš„æœªå®šä¹‰è¡Œä¸ºï¼Œæˆ‘ä»¬ä¸ä»…éœ€è¦çŸ¥é“æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ï¼Œè¿˜éœ€è¦è·Ÿè¸ªå®ƒæ˜¯ä»å“ªäº›å…¶ä»–æŒ‡é’ˆâ€œæ´¾ç”Ÿâ€çš„ã€‚

å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç¨‹åºå‘˜ä¸éœ€è¦è¿‡å¤šæ‹…å¿ƒæ¥æºï¼ŒæŒ‡é’ˆçš„æ´¾ç”Ÿæ–¹å¼éå¸¸æ¸…æ™°ã€‚ç„¶è€Œï¼Œå½“å°†æŒ‡é’ˆè½¬æ¢ä¸ºæ•´æ•°å¹¶è¿”å›æ—¶ï¼Œç»“æœæŒ‡é’ˆçš„æ¥æºæ˜¯ä¸æ˜ç¡®çš„ã€‚åœ¨æ­¤ç‰ˆæœ¬ä¸­ï¼ŒRust æ·»åŠ äº†ä¸€ç»„ APIï¼Œå¯ä»¥åœ¨è®¸å¤šæƒ…å†µä¸‹æ›¿ä»£æ•´æ•°æŒ‡é’ˆè½¬æ¢çš„ä½¿ç”¨ï¼Œä»è€Œé¿å…æ­¤ç±»è½¬æ¢å›ºæœ‰çš„æ­§ä¹‰ã€‚ç‰¹åˆ«æ˜¯ï¼Œç°åœ¨å¯ä»¥åœ¨ä¸å°†æŒ‡é’ˆè½¬æ¢ä¸ºæ•´æ•°(æˆ–åæ–¹å‘å°†æ•´æ•°è½¬æ¢æˆæŒ‡é’ˆ)çš„æƒ…å†µä¸‹å®ç°ä½¿ç”¨å¯¹é½æŒ‡é’ˆçš„æœ€ä½æœ‰æ•ˆä½å­˜å‚¨é¢å¤–ä¿¡æ¯çš„æ¨¡å¼ã€‚è¿™ä½¿å¾—ä»£ç æ›´æ˜“äºæ¨ç†ï¼Œæ›´æ˜“äºç¼–è¯‘å™¨åˆ†æï¼Œå¹¶ä¸”è¿˜æœ‰ç›Šäºåƒ [Miri](https://github.com/rust-lang/miri) è¿™æ ·çš„å·¥å…·å’Œåƒ [CHERI](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/) è¿™æ ·çš„æ¶æ„ï¼Œæ—¨åœ¨æ£€æµ‹å’Œè¯Šæ–­æŒ‡é’ˆæ»¥ç”¨ã€‚

æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æ ‡å‡†åº“ä¸­å…³äº[æ¥æº](https://doc.rust-lang.org/std/ptr/index.html#provenance)çš„æ–‡æ¡£ã€‚

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼ŒåŒ…æ‹¬ä¸Šè¿° `provenance` ç›¸å…³ APIï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2025/01/09/Rust-1.84.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.85.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.85 | Rust 2024 ç¨³å®šç‰ˆã€`async` é—­åŒ…

> Rust 1.85 å®˜æ–¹ release doc: [Announcing Rust 1.85.0 | Rust Blog](https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.85 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## Rust 2024

æˆ‘ä»¬å¾ˆé«˜å…´åœ°å®£å¸ƒï¼ŒRust 2024 ç‰ˆç°å·²ç¨³å®šï¼
å¤§çš„æ–°ç‰ˆæœ¬ä¹Ÿæ˜¯ä¸€ç§ç”¨äºé€‰æ‹©å¯èƒ½å¸¦æ¥å‘åå…¼å®¹æ€§é£é™©çš„æ›´æ”¹çš„æœºåˆ¶ã€‚æœ‰å…³å¦‚ä½•å®ç°æ­¤ç›®æ ‡çš„è¯¦ç»†ä¿¡æ¯ä»¥åŠè¿ç§»çš„è¯¦ç»†è¯´æ˜ï¼Œè¯·å‚é˜…[ç‰ˆæœ¬æŒ‡å—](https://doc.rust-lang.org/edition-guide/editions/index.html)ã€‚

[ç‰ˆæœ¬æŒ‡å—](https://doc.rust-lang.org/edition-guide/rust-2024/index.html)é‡ŒåŒ…å«äº†æ¯ä¸ªæ›´æ”¹çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¿™é‡Œæœ‰ä¸€ä»½ç®€è¦æ€»ç»“ï¼š

- è¯­è¨€
  - [RPIT ç”Ÿå‘½å‘¨æœŸæ•è·è§„åˆ™](https://doc.rust-lang.org/edition-guide/rust-2024/rpit-lifetime-capture.html) â€” å½“ `use<..>` ä¸å­˜åœ¨æ—¶ï¼Œæ›´æ”¹ `impl Trait` ç±»å‹å¯¹å‚æ•°çš„é»˜è®¤æ•è·ã€‚
  - [`if let` ä¸´æ—¶ä½œç”¨åŸŸ](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) â€” æ›´æ”¹ `if let` è¡¨è¾¾å¼çš„ä¸´æ—¶ä½œç”¨åŸŸã€‚
  - [å°¾è¡¨è¾¾å¼ä¸´æ—¶ä½œç”¨åŸŸ](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-tail-expr-scope.html) â€” æ›´æ”¹å—ä¸­å°¾è¡¨è¾¾å¼çš„ä¸´æ—¶ä½œç”¨åŸŸã€‚
  - [é¢„ç•™æ¨¡å¼åŒ¹é…çš„äººæ€§åŒ–æ”¹è¿›](https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html) â€” ç¦æ­¢æŸäº›æ¨¡å¼ç»„åˆä»¥é¿å…æ··æ·†å¹¶ä¸ºæœªæ¥çš„æ”¹è¿›ç•™å‡ºç©ºé—´ã€‚
  - [ä¸å®‰å…¨çš„ `extern` å—](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-extern.html) â€” `extern` å—ç°åœ¨éœ€è¦ `unsafe` å…³é”®å­—ã€‚
  - [ä¸å®‰å…¨å±æ€§](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-attributes.html) â€” `export_name`ã€`link_section` å’Œ `no_mangle` å±æ€§ç°åœ¨å¿…é¡»æ ‡è®°ä¸º `unsafe`ã€‚
  - [`unsafe_op_in_unsafe_fn` è­¦å‘Š](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html) â€” [`unsafe_op_in_unsafe_fn`](https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint ç°åœ¨é»˜è®¤è­¦å‘Šï¼Œè¦æ±‚åœ¨ `unsafe` å‡½æ•°ä¸­æ˜¾å¼ä½¿ç”¨ `unsafe {}` å—ã€‚
  - [ç¦æ­¢å¼•ç”¨ `static mut`](https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html) â€” å¯¹ `static mut` é¡¹çš„å¼•ç”¨ç°åœ¨ä¼šç”Ÿæˆé»˜è®¤æ‹’ç»çš„é”™è¯¯ã€‚
  - [Never ç±»å‹ fallback æ›´æ”¹](https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html) â€” æ›´æ”¹äº† never ç±»å‹ `!` çš„å¼ºåˆ¶è½¬æ¢æ–¹å¼ï¼Œå¹¶å°† [`never_type_fallback_flowing_into_unsafe`](https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-unsafe) lint çº§åˆ«æ›´æ”¹ä¸ºâ€œæ‹’ç»â€ã€‚
  - [å®ç‰‡æ®µè¯´æ˜ç¬¦](https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html) â€” `macro_rules!` å®ä¸­çš„ `expr` å®ç‰‡æ®µè¯´æ˜ç¬¦ç°åœ¨ä¹ŸåŒ¹é… `const` å’Œ `_` è¡¨è¾¾å¼ã€‚
  - [ç¼ºå¤±çš„å®ç‰‡æ®µè¯´æ˜ç¬¦](https://doc.rust-lang.org/edition-guide/rust-2024/missing-macro-fragment-specifiers.html) â€” [`missing_fragment_specifier`](https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#missing-fragment-specifier) lint ç°åœ¨æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œæ‹’ç»æ²¡æœ‰ç‰‡æ®µè¯´æ˜ç¬¦ç±»å‹çš„å®å…ƒå˜é‡ã€‚
  - [`gen` å…³é”®å­—](https://doc.rust-lang.org/edition-guide/rust-2024/gen-keyword.html) â€” ä¿ç•™ `gen` å…³é”®å­—ï¼Œä»¥ä¾¿å°†æ¥æ·»åŠ ç”Ÿæˆå™¨å—ã€‚
  - [ä¿ç•™è¯­æ³•](https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html) â€” ä¿ç•™ `#"foo"#` é£æ ¼çš„å­—ç¬¦ä¸²å’Œ `##` æ ‡è®°ï¼Œä»¥ä¾¿å°†æ¥æ›´æ”¹å¦‚ä½•è§£æå—ä¿æŠ¤çš„å­—ç¬¦ä¸²å­—é¢é‡ã€‚
- æ ‡å‡†åº“
  - [prelude çš„æ›´æ”¹](https://doc.rust-lang.org/edition-guide/rust-2024/prelude.html) â€” å°† `Future` å’Œ `IntoFuture` æ·»åŠ åˆ° prelude ä¸­ã€‚
  - [ä¸º `Box<[T]>` æ·»åŠ  `IntoIterator`](https://doc.rust-lang.org/edition-guide/rust-2024/intoiterator-box-slice.html) â€” æ›´æ”¹äº†è¿­ä»£å™¨ä¸ `Box<[T]>` çš„å·¥ä½œæ–¹å¼ã€‚
  - [æ–°ä¸å®‰å…¨çš„å‡½æ•°](https://doc.rust-lang.org/edition-guide/rust-2024/newly-unsafe-functions.html) â€” `std::env::set_var`ã€`std::env::remove_var` å’Œ `std::os::unix::process::CommandExt::before_exec` ç°åœ¨æ˜¯ä¸å®‰å…¨çš„å‡½æ•°ã€‚
- Cargo
  - [Cargo: Rust ç‰ˆæœ¬æ„ŸçŸ¥è§£æå™¨](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-resolver.html) â€” æ›´æ”¹é»˜è®¤ä¾èµ–è§£æå™¨è¡Œä¸ºä»¥è€ƒè™‘ `rust-version` å­—æ®µã€‚
  - [Cargo: è¡¨å’Œé”®åä¸€è‡´æ€§](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-table-key-names.html) â€” åˆ é™¤äº†ä¸€äº›è¿‡æ—¶çš„ `Cargo.toml` é”®ã€‚
  - [Cargo: æŠ¥é”™é”™è¯¯ä½¿ç”¨é»˜è®¤ç‰¹æ€§å¼€å…³çš„ç»§æ‰¿æƒ…å†µ](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-inherited-default-features.html) â€” æ›´æ”¹äº† `default-features = false` ä¸ç»§æ‰¿çš„å·¥ä½œåŒºä¾èµ–é¡¹çš„å·¥ä½œæ–¹å¼ã€‚
- Rustdoc
  - [Rustdoc ç»„åˆæµ‹è¯•](https://doc.rust-lang.org/edition-guide/rust-2024/rustdoc-doctests.html) â€” æ–‡æ¡£æµ‹è¯•ç°åœ¨ç»„åˆæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ˜¾è‘—æé«˜äº†æ€§èƒ½ã€‚
  - [Rustdoc åµŒå¥— `include!` æ›´æ”¹](https://doc.rust-lang.org/edition-guide/rust-2024/rustdoc-nested-includes.html) â€” æ›´æ”¹äº†åµŒå¥— `include!` æ–‡ä»¶çš„ç›¸å¯¹è·¯å¾„è¡Œä¸ºã€‚
- Rustfmt
  - [Rustfmt: æ ·å¼ç‰ˆæœ¬](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-style-edition.html) â€” å¼•å…¥äº†â€œæ ·å¼ç‰ˆæœ¬â€çš„æ¦‚å¿µï¼Œå…è®¸ä½ åˆ†å¼€æ§åˆ¶æ ¼å¼åŒ–ç‰ˆæœ¬ä¸ Rust ç‰ˆæœ¬ã€‚
  - [Rustfmt: æ ¼å¼åŒ–ä¿®å¤](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-formatting-fixes.html) â€” å¤§é‡ä¿®å¤äº†å„ç§æƒ…å†µçš„æ ¼å¼åŒ–é—®é¢˜ã€‚
  - [Rustfmt: åŸå§‹æ ‡è¯†ç¬¦æ’åº](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-raw-identifier-sorting.html) â€” æ›´æ”¹äº†è¯¸å¦‚ `r#async` å¸¦æœ‰ `r#` æ ‡è¯†ç¬¦çš„æ’åºæ–¹å¼ã€‚
  - [Rustfmt: å¸¦æ•°å­—çš„æ’åº](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-version-sorting.html) â€” æ›´æ”¹äº†åŒ…å«æ•´æ•°çš„æ ‡è¯†ç¬¦çš„æ’åºæ–¹å¼ã€‚

### è¿ç§»åˆ° 2024

æŒ‡å—åŒ…å«äº†æ‰€æœ‰æ–°åŠŸèƒ½çš„è¿ç§»è¯´æ˜ï¼Œä»¥åŠ[å°†ç°æœ‰é¡¹ç›®è¿ç§»åˆ°æ–°ç‰ˆæœ¬](https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html)çš„ä¸€èˆ¬è¯´æ˜ã€‚
åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œ`cargo fix` å¯ä»¥è‡ªåŠ¨å®Œæˆå¿…è¦çš„æ›´æ”¹ã€‚ä½ ç”šè‡³å¯èƒ½ä¼šå‘ç°ï¼Œ2024 ç‰ˆä¸éœ€è¦å¯¹ä½ çš„ä»£ç è¿›è¡Œä»»ä½•æ›´æ”¹ï¼

è¯·æ³¨æ„ï¼Œé€šè¿‡ `cargo fix` è¿›è¡Œçš„è‡ªåŠ¨ä¿®å¤éå¸¸ä¿å®ˆï¼Œä»¥é¿å…æ›´æ”¹ä»£ç çš„è¯­ä¹‰ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œä½ å¯èƒ½å¸Œæœ›ä¿æŒä»£ç ä¸å˜å¹¶ä½¿ç”¨ Rust 2024 çš„æ–°è¯­ä¹‰ï¼›ä¾‹å¦‚ï¼Œç»§ç»­ä½¿ç”¨ `expr` å®åŒ¹é…å™¨ï¼Œå¹¶å¿½ç•¥æ¡ä»¶è¡¨è¾¾å¼çš„è½¬æ¢ï¼Œå› ä¸ºä½ å¸Œæœ›ä½¿ç”¨æ–°çš„ 2024 ç‰ˆ drop é¡ºåºè¯­ä¹‰ã€‚`cargo fix` çš„ç»“æœä¸åº”è¢«è§†ä¸ºå»ºè®®ï¼Œè€Œåªæ˜¯ä¿æŒè¡Œä¸ºçš„ä¿å®ˆè½¬æ¢ã€‚

## `async` é—­åŒ…

Rust ç°åœ¨æ”¯æŒå¼‚æ­¥é—­åŒ…ï¼Œå¦‚ `async || {}`ï¼Œå®ƒåœ¨è°ƒç”¨æ—¶è¿”å› futureã€‚è¿™ç±»ä¼¼äº `async fn`ï¼Œå®ƒä¹Ÿå¯ä»¥ä»æœ¬åœ°ç¯å¢ƒä¸­æ•è·å€¼ï¼Œå°±åƒæ™®é€šé—­åŒ…å’Œå‡½æ•°ä¹‹é—´çš„åŒºåˆ«ä¸€æ ·ã€‚æ ‡å‡†åº“ prelude ä¸­è¿˜æä¾›äº† 3 ä¸ªç±»ä¼¼çš„ traitï¼š`AsyncFn`ã€`AsyncFnMut` å’Œ `AsyncFnOnce`ã€‚

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥é€šè¿‡æ™®é€šé—­åŒ…å’Œå¼‚æ­¥å—æ¥è¿‘ä¼¼å®ç°è¿™ä¸€ç‚¹ï¼Œä¾‹å¦‚ `|| async {}`ã€‚ç„¶è€Œï¼Œè¿™ç§å†…éƒ¨å—è¿”å›çš„ future æ— æ³•ä»é—­åŒ…æ•è·ä¸­å€Ÿç”¨ï¼Œä½† `async` é—­åŒ…å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

```rust
let mut vec: Vec<String> = vec![];

let closure = async || {
    vec.push(ready(String::from("")).await);
};
```

æ­¤å¤–ï¼Œä½¿ç”¨ `Fn` trait è¿”å› `Future` æ—¶ï¼Œæ— æ³•æ­£ç¡®è¡¨è¾¾å‡½æ•°ç­¾åï¼Œä½†ä½ å¯ä»¥ä½¿ç”¨ `AsyncFn` trait æ¥ç¼–å†™ï¼š

```rust
use core::future::Future;
async fn f<Fut>(_: impl for<'a> Fn(&'a u8) -> Fut)
where
    Fut: Future<Output = ()>,
{ todo!() }

async fn f2(_: impl for<'a> AsyncFn(&'a u8))
{ todo!() }

async fn main() {
    async fn g(_: &u8) { todo!() }
    f(g).await;
    //~^ ERROR ç±»å‹ä¸åŒ¹é…
    //~| ERROR ä¸€ä¸ªç±»å‹æ¯”å¦ä¸€ä¸ªæ›´é€šç”¨

    f2(g).await; // æ²¡é—®é¢˜ï¼
}
```

å› æ­¤ï¼Œ`async` é—­åŒ…ä¸ºè¿™ä¸¤ä¸ªé—®é¢˜æä¾›äº†ä¸€æµçš„è§£å†³æ–¹æ¡ˆï¼æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… [RFC 3668](https://rust-lang.github.io/rfcs/3668-async-closures.html) å’Œ[ç¨³å®šæŠ¥å‘Š](https://github.com/rust-lang/rust/pull/132706)ã€‚

## ä»è¯Šæ–­ä¸­éšè— trait å®ç°

æ–°çš„ `#[diagnostic::do_not_recommend]` å±æ€§æ˜¯ç»™ç¼–è¯‘å™¨çš„ä¸€ä¸ªæç¤ºï¼Œä¸è¦å°†æ³¨é‡Šçš„ trait å®ç°æ˜¾ç¤ºä¸ºè¯Šæ–­æ¶ˆæ¯çš„ä¸€éƒ¨åˆ†ã€‚å¯¹äºåº“ä½œè€…æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§é˜²æ­¢ç¼–è¯‘å™¨æå‡ºå¯èƒ½æ— ç›Šæˆ–è¯¯å¯¼çš„å»ºè®®çš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼š

```rust
pub trait Foo {}
pub trait Bar {}

impl<T: Foo> Bar for T {}

struct MyType;

fn main() {
    let _object: &dyn Bar = &MyType;
}
```

```text
error[E0277]: æœªæ»¡è¶³ trait ç»‘å®š `MyType: Bar`
 --> src/main.rs:9:29
  |
9 |     let _object: &dyn Bar = &MyType;
  |                             ^^^^ trait `Foo` æœªä¸º `MyType` å®ç°
  |
note: éœ€è¦ `MyType` å®ç° `Bar`
 --> src/main.rs:4:14
  |
4 | impl<T: Foo> Bar for T {}
  |         ---  ^^^     ^
  |         |
  |         åœ¨æ­¤å¤„å¼•å…¥çš„æœªæ»¡è¶³çš„ trait ç»‘å®š
  = note: éœ€è¦å°† `&MyType` è½¬æ¢ä¸º `&dyn Bar`
```

å¯¹äºæŸäº› APIï¼Œå®ç° `Foo` å¹¶é€šè¿‡è¯¥æ³›å‹å®ç°é—´æ¥è·å¾— `Bar` å¯èƒ½æ˜¯æœ‰æ„ä¹‰çš„ã€‚å¯¹äºå…¶ä»– APIï¼Œå¯èƒ½æœŸæœ›å¤§å¤šæ•°ç”¨æˆ·ç›´æ¥å®ç° `Bar`ï¼Œå› æ­¤ `Foo` å»ºè®®æ˜¯ä¸€ä¸ªè¯¯å¯¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ·»åŠ è¯Šæ–­æç¤ºå°†æ›´æ”¹é”™è¯¯æ¶ˆæ¯å¦‚ä¸‹ï¼š

```rust
#[diagnostic::do_not_recommend]
impl<T: Foo> Bar for T {}
```

```text
error[E0277]: æœªæ»¡è¶³ trait ç»‘å®š `MyType: Bar`
  --> src/main.rs:10:29
   |
10 |     let _object: &dyn Bar = &MyType;
   |                             ^^^^ trait `Bar` æœªä¸º `MyType` å®ç°
   |
   = note: éœ€è¦å°† `&MyType` è½¬æ¢ä¸º `&dyn Bar`
```

æœ‰å…³åŸå§‹åŠ¨æœºï¼Œè¯·å‚é˜… [RFC 2397](https://rust-lang.github.io/rfcs/2397-do-not-recommend.html)ï¼Œä»¥åŠå½“å‰çš„[å‚è€ƒ](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-diagnosticdo_not_recommend-attribute)ä»¥è·å–æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚

## å…ƒç»„çš„ `FromIterator` å’Œ `Extend`

æ—©æœŸç‰ˆæœ¬çš„ Rust ä¸º `(T, U)` å…ƒç»„å¯¹çš„è¿­ä»£å™¨å®ç°äº†ä¾¿åˆ©çš„ traitï¼Œä½¿å…¶è¡Œä¸ºç±»ä¼¼äº `Iterator::unzip`ï¼Œå…¶ä¸­ `Extend` åœ¨ 1.56 ç‰ˆä¸­å®ç°ï¼Œ`FromIterator` åœ¨ 1.79 ç‰ˆä¸­å®ç°ã€‚è¿™äº›ç°åœ¨å·²*æ‰©å±•*åˆ°æ›´å¤šçš„å…ƒç»„é•¿åº¦ï¼Œä»å•ä¾‹ `(T,)` åˆ° 12 ä¸ªå…ƒç´ é•¿çš„ `(T1, T2, .., T11, T12)`ã€‚ä¾‹å¦‚ï¼Œä½ ç°åœ¨å¯ä»¥ä½¿ç”¨ `collect()` ä¸€æ¬¡æ€§åˆ†å‘åˆ°å¤šä¸ªé›†åˆä¸­ï¼š

```rust
use std::collections::{LinkedList, VecDeque};
fn main() {
    let (squares, cubes, tesseracts): (Vec<_>, VecDeque<_>, LinkedList<_>) =
        (0i32..10).map(|i| (i * i, i.pow(3), i.pow(4))).collect();
    println!("{squares:?}");
    println!("{cubes:?}");
    println!("{tesseracts:?}");
}
```

```text
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
[0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561]
```

## `std::env::home_dir()` çš„æ›´æ–°

`std::env::home_dir()` å·²è¢«å¼ƒç”¨å¤šå¹´ï¼Œå› ä¸ºå¦‚æœè®¾ç½®äº† `HOME` ç¯å¢ƒå˜é‡ï¼ˆè¿™ä¸æ˜¯ Windows ä¸Šçš„æ ‡å‡†é…ç½®ï¼‰ï¼Œå®ƒå¯èƒ½ä¼šåœ¨æŸäº› Windows é…ç½®ä¸­ç»™å‡ºä»¤äººæƒŠè®¶çš„ç»“æœã€‚æˆ‘ä»¬ä¹‹å‰é¿å…æ›´æ”¹å…¶è¡Œä¸ºï¼Œå› ä¸ºæ‹…å¿ƒä¸ä¾èµ–æ­¤éæ ‡å‡†é…ç½®çš„ä»£ç çš„å…¼å®¹æ€§ã€‚é‰´äºè¯¥å‡½æ•°å·²è¢«å¼ƒç”¨å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ç°åœ¨å°†å…¶è¡Œä¸ºæ›´æ–°ä¸ºé”™è¯¯ä¿®å¤ï¼Œåç»­ç‰ˆæœ¬å°†å–æ¶ˆå¯¹è¯¥å‡½æ•°çš„å¼ƒç”¨ã€‚

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.86.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.86 | Trait upcasting

> Rust 1.86 å®˜æ–¹ release doc: [Announcing Rust 1.86.0 | Rust Blog](https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.86 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## ç‰¹å¾å‘ä¸Šè½¬å‹(Trait upcasting)

æœ¬æ¬¡æ›´æ–°åŒ…å«äº†ä¸€ä¸ªæœŸå¾…å·²ä¹…çš„åŠŸèƒ½â€”â€”â€”â€”ç‰¹å¾å¯¹è±¡çš„å‘ä¸Šè½¬å‹èƒ½åŠ›ã€‚å¦‚æœä¸€ä¸ªç‰¹å¾æ‹¥æœ‰ [supertrait](https://doc.rust-lang.org/reference/items/traits.html#supertraits)ï¼Œä½ å¯ä»¥å°†æŒ‡å‘è¯¥ç‰¹å¾å¯¹è±¡çš„å¼•ç”¨å¼ºåˆ¶è½¬æ¢ä¸ºæŒ‡å‘ supertrait å¯¹è±¡çš„å¼•ç”¨ï¼š

```rust
trait Trait: Supertrait {}
trait Supertrait {}

fn upcast(x: &dyn Trait) -> &dyn Supertrait {
    x
}
```

è¯¥åŠŸèƒ½åŒæ ·é€‚ç”¨äºå…¶ä»–ç±»å‹çš„ï¼ˆæ™ºèƒ½ï¼‰æŒ‡é’ˆï¼Œä¾‹å¦‚ `Arc<dyn Trait> -> Arc<dyn Supertrait>` æˆ– `*const dyn Trait -> *const dyn Supertrait`ã€‚

æ­¤å‰éœ€è¦é€šè¿‡ç‰¹å¾å†…éƒ¨å®šä¹‰ `upcast` æ–¹æ³•ï¼ˆå¦‚ `fn as_supertrait(&self) -> &dyn Supertrait` ï¼‰æ¥å®ç°ï¼Œä¸”ä»…é€‚ç”¨äºå•ä¸€å¼•ç”¨/æŒ‡é’ˆç±»å‹ã€‚ç°åœ¨ä¸å†éœ€è¦æ­¤ç±»å˜é€šæ–¹æ¡ˆã€‚

éœ€æ³¨æ„ï¼šè¿™æ„å‘³ç€ç‰¹å¾å¯¹è±¡çš„è£¸æŒ‡é’ˆå…·æœ‰ä¸€ä¸ªç‰¹åˆ«çš„çº¦æŸï¼šâ€œæ³„æ¼â€ä¸€ä¸ªæŒ‡å‘æ— æ•ˆè™šè¡¨çš„è£¸æŒ‡é’ˆåˆ°å®‰å…¨ä»£ç å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚å½“å‰å°šä¸æ¸…æ¥šåœ¨ä¸¥æ ¼å—æ§ç¯å¢ƒä¸‹ä¸´æ—¶åˆ›å»ºæ­¤ç±»è£¸æŒ‡é’ˆæ˜¯å¦ä¼šç«‹å³å¼•å‘æœªå®šä¹‰è¡Œä¸ºï¼Œå› æ­¤åº”é¿å…åœ¨ä»»ä½•æ¡ä»¶ä¸‹åˆ›å»ºæ­¤ç±»æŒ‡é’ˆï¼ˆMiri ä¼šå¼ºåˆ¶æ‰§è¡Œæ­¤çº¦æŸï¼‰ã€‚

ç‰¹å¾å‘ä¸Šè½¬å‹åœ¨ä¸ `Any` ç‰¹å¾ç»“åˆæ—¶å°¤ä¸ºå®ç”¨ï¼Œæ— éœ€æ·»åŠ ç‰¹å¾æ–¹æ³•æˆ–ä½¿ç”¨å¤–éƒ¨crateå³å¯å°†ç‰¹å¾å¯¹è±¡å‘ä¸Šè½¬å‹ä¸º `dyn Any` æ¥è°ƒç”¨ `Any` çš„å‘ä¸‹è½¬å‹æ–¹æ³•ï¼š

```rust
use std::any::Any;

trait MyAny: Any {}

impl dyn MyAny {
    fn downcast_ref<T>(&self) -> Option<&T> {
        (self as &dyn Any).downcast_ref()
    }
}
```

æ›´å¤šç»†èŠ‚è¯·å‚é˜…[Rustå‚è€ƒæ–‡æ¡£ä¸­å…³äºç‰¹å¾å‘ä¸Šè½¬å‹çš„å†…å®¹](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions)ã€‚

## HashMapå’Œåˆ‡ç‰‡ç°æ”¯æŒå¯å˜ç´¢å¼•å¤šä¸ªå…ƒç´ 

å€Ÿç”¨æ£€æŸ¥å™¨åŸå…ˆä¼šé˜»æ­¢é€šè¿‡é‡å¤è°ƒç”¨ `get_mut` æ–¹æ³•è·å–çš„å€Ÿç”¨åŒæ—¶ä½¿ç”¨ã€‚ä¸ºå®‰å…¨åœ°æ”¯æŒè·å–å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œæ ‡å‡†åº“ç°åœ¨ä¸ºåˆ‡ç‰‡å’Œ `HashMap` æä¾› `get_disjoint_mut` è¾…åŠ©æ–¹æ³•ï¼Œå¯åŒæ—¶è·å–å¤šä¸ªå…ƒç´ çš„å¯å˜å¼•ç”¨ã€‚ç¤ºä¾‹å–è‡ª [`slice::get_disjoint_mut` API æ–‡æ¡£](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_disjoint_mut)ï¼š

```rust
let v = &mut [1, 2, 3];
if let Ok([a, b]) = v.get_disjoint_mut([0, 2]) {
    *a = 413;
    *b = 612;
}
assert_eq!(v, &[413, 2, 612]);

if let Ok([a, b]) = v.get_disjoint_mut([0..1, 1..3]) {
    a[0] = 8;
    b[0] = 88;
    b[1] = 888;
}
assert_eq!(v, &[8, 88, 888]);

if let Ok([a, b]) = v.get_disjoint_mut([1..=2, 0..=0]) {
    a[0] = 11;
    a[1] = 111;
    b[0] = 1;
}
assert_eq!(v, &[1, 11, 111]);
```

## å…è®¸å®‰å…¨å‡½æ•°æ ‡è®° `#[target_feature]` å±æ€§

æ­¤å‰ä»… `unsafe` å‡½æ•°å¯æ ‡è®° `#[target_feature]` å±æ€§ï¼Œå› æœªå¯ç”¨ç›®æ ‡ç‰¹æ€§æ—¶è°ƒç”¨æ­¤ç±»å‡½æ•°ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚æœ¬æ¬¡æ›´æ–°ç¨³å®šäº† `target_feature_11` ç‰¹æ€§ï¼Œå…è®¸*å®‰å…¨*å‡½æ•°æ ‡è®°è¯¥å±æ€§ã€‚

æ ‡è®°ç›®æ ‡ç‰¹æ€§çš„å®‰å…¨å‡½æ•°ä»…å¯è¢«åŒæ ‡è®°å‡½æ•°å®‰å…¨è°ƒç”¨ï¼Œä½†ä¸å¯ä¼ é€’ç»™ä»¥ `Fn*` ç‰¹å¾çº¦æŸçš„æ³›å‹å‡½æ•°ï¼Œä¸”ä»…æ”¯æŒåœ¨æ ‡è®°å‡½æ•°å†…éƒ¨å¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°æŒ‡é’ˆã€‚

åœ¨æœªæ ‡è®°å‡½æ•°å†…éƒ¨å¯é€šè¿‡ `unsafe` å—è°ƒç”¨ï¼Œä½†è°ƒç”¨è€…éœ€ç¡®ä¿ç›®æ ‡ç‰¹æ€§å¯ç”¨ï¼š

```rust
#[target_feature(enable = "avx2")]
fn requires_avx2() {
    // ... çœç•¥
}

#[target_feature(enable = "avx2")]
fn safe_callsite() {
    requires_avx2(); // å®‰å…¨è°ƒç”¨
}

fn unsafe_callsite() {
    if is_x86_feature_detected!("avx2") {
        unsafe { requires_avx2() }; // éœ€æ‰‹åŠ¨éªŒè¯
    }
}
```

è¯¦æƒ…å‚é˜… [`target_features_11` RFC](https://github.com/rust-lang/rfcs/blob/master/text/2396-target-feature-1.1.md)ã€‚

## ä¸ºä¿éšœå†…å­˜å®‰å…¨æ·»åŠ æŒ‡é’ˆéç©ºè°ƒè¯•æ–­è¨€

ç¼–è¯‘å™¨ç°ä¼šåœ¨ä»¥ä¸‹åœºæ™¯æ’å…¥è°ƒè¯•æ–­è¨€ï¼šå¯¹éé›¶å¤§å°ç±»å‹çš„è¯»å†™æ“ä½œå‰ï¼Œä»¥åŠå°†æŒ‡é’ˆé‡æ–°å€Ÿç”¨ä¸ºå¼•ç”¨æ—¶ã€‚ä¾‹å¦‚ä»¥ä¸‹ä»£ç åœ¨å¯ç”¨è°ƒè¯•æ–­è¨€æ—¶å°†è§¦å‘ panicï¼š

```rust
let _x = *std::ptr::null::<u8>();
let _x = &*std::ptr::null::<u8>();
```

è‡ªRust 1.53.0èµ·ç®€å•æ¡ˆä¾‹å·²äº§ç”Ÿè­¦å‘Šï¼Œæ–°è¿è¡Œæ—¶æ£€æŸ¥å¯æ£€æµ‹ä»»æ„å¤æ‚åœºæ™¯ã€‚è¿™äº›æ–­è¨€ä»…åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ç”Ÿæ•ˆï¼Œå› æ­¤**ä¸åº”è¯¥**ä¾èµ–å…¶ä¿éšœå†…å­˜å®‰å…¨ã€‚ä¸”è°ƒè¯•æ¨¡å¼ç¦ç”¨çš„ä¾èµ–é¡¹ï¼ˆå¦‚æ ‡å‡†åº“ï¼‰å³ä½¿è¢«è°ƒè¯•æ¨¡å¼ä»£ç è°ƒç”¨ä¹Ÿä¸ä¼šè§¦å‘æ–­è¨€ã€‚

## é»˜è®¤å¯ç”¨ `missing_abi` lint è­¦å‘Š

åœ¨ extern å—å’Œå‡½æ•°ä¸­çœç•¥ ABIï¼ˆå¦‚ `extern {}` å’Œ `extern fn`ï¼‰ç°åœ¨ä¼šè§¦å‘ `missing_abi` lint è­¦å‘Šã€‚`extern` å…³é”®å­—åçœç•¥ ABI å§‹ç»ˆéšå¼é‡‡ç”¨ `"C"` ABIï¼Œç°å»ºè®®æ˜¾å¼æŒ‡å®šï¼ˆå¦‚ `extern "C" {}` å’Œ `extern "C" fn`ï¼‰ã€‚

å‚é˜…[æ˜¾å¼å¤–éƒ¨ ABI RFC](https://rust-lang.github.io/rfcs/3722-explicit-extern-abis.html)è·å–è¯¦æƒ…ã€‚

## 1.87.0ç‰ˆæœ¬ç›®æ ‡å¼ƒç”¨è­¦å‘Š

Tier-2 ç›®æ ‡ `i586-pc-windows-msvc` å°†åœ¨Rust 1.87.0ç§»é™¤ã€‚è¯¥ç›®æ ‡ä¸æ›´æµè¡Œçš„`i686-pc-windows-msvc`çš„åŒºåˆ«åœ¨äºä¸è¦æ±‚SSE2æŒ‡ä»¤æ”¯æŒï¼Œæ‰€æœ‰`windows`ç›®æ ‡ï¼ˆé™¤`win7`ç›®æ ‡å¤–ï¼‰çš„æœ€ä½è¦æ±‚ç³»ç»Ÿç‰ˆæœ¬ï¼Œå³ Windows 10 æœ¬èº«å°±éœ€è¦SSE2æŒ‡ä»¤ã€‚

å½“å‰ä½¿ç”¨è¯¥ç›®æ ‡çš„ç”¨æˆ·åº”åœ¨1.87.0å‘å¸ƒå‰è¿ç§»è‡³`i686-pc-windows-msvc`ã€‚è¯¦æƒ…å‚è§[é‡å¤§å˜æ›´ææ¡ˆ](https://github.com/rust-lang/compiler-team/issues/840)ã€‚

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2025/04/03/Rust-1.86.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.87.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.87 | åå‘¨å¹´ğŸ‰

[Rust 1.0](https://blog.rust-lang.org/2015/05/15/Rust-1.0/) åå‘¨å¹´ğŸ‰

> Rust 1.87 å®˜æ–¹ release doc: [Announcing Rust 1.87.0 | Rust Blog](https://blog.rust-lang.org/2025/05/15/Rust-1.87.0/)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.87 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## åŒ¿åç®¡é“

1.87 ç‰ˆæœ¬ä¸ºæ ‡å‡†åº“æ·»åŠ äº†åŒ¿åç®¡é“æ”¯æŒï¼ŒåŒ…æ‹¬ä¸ `std::process::Command` è¾“å…¥/è¾“å‡ºæ–¹æ³•çš„é›†æˆã€‚ä¾‹å¦‚ï¼Œç°åœ¨å¯ä»¥ç›¸å¯¹ç®€å•åœ°åˆå¹¶æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯æµï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œè€Œè¿‡å»éœ€è¦é¢å¤–çº¿ç¨‹æˆ–å¹³å°ç‰¹å®šå‡½æ•°æ‰èƒ½å®ç°ã€‚

```rust
use std::process::Command;
use std::io::Read;

let (mut recv, send) = std::io::pipe()?;

let mut command = Command::new("path/to/bin")
    // æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯éƒ½ä¼šå†™å…¥åŒä¸€ä¸ªç®¡é“ï¼Œå®ç°åˆå¹¶
    .stdout(send.try_clone()?)
    .stderr(send)
    .spawn()?;

let mut output = Vec::new();
recv.read_to_end(&mut output)?;

// å¿…é¡»åœ¨è¿›ç¨‹é€€å‡ºå‰è¯»å–ç®¡é“å†…å®¹ï¼Œé¿å…ç¨‹åºè¾“å‡ºè¿‡å¤šæ—¶å¡«æ»¡ç³»ç»Ÿç¼“å†²åŒº
assert!(command.wait()?.success());
```

## å®‰å…¨çš„æ¶æ„å†…ç½®å‡½æ•°

å¤§å¤šæ•°ä»…å› éœ€è¦å¯ç”¨ç›®æ ‡ç‰¹æ€§è€Œè¢«æ ‡è®°ä¸ºä¸å®‰å…¨çš„ `std::arch` å†…ç½®å‡½æ•°ï¼Œç°åœ¨å¯ä»¥åœ¨å·²å¯ç”¨ç›¸åº”ç‰¹æ€§çš„å®‰å…¨ä»£ç ä¸­è°ƒç”¨ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä½¿ç”¨æ‰‹åŠ¨å†…ç½®å‡½æ•°å®ç°æ•°ç»„æ±‚å’Œçš„ç¤ºä¾‹ç¨‹åºï¼Œç°åœ¨æ ¸å¿ƒå¾ªç¯å¯ä»¥ä½¿ç”¨å®‰å…¨ä»£ç ã€‚

```rust
#![forbid(unsafe_op_in_unsafe_fn)]

use std::arch::x86_64::*;

fn sum(slice: &[u32]) -> u32 {
    #[cfg(target_arch = "x86_64")]
    {
        if is_x86_feature_detected!("avx2") {
            // å®‰å…¨æ€§ï¼šæˆ‘ä»¬å·²æ£€æµ‹åˆ°è¿è¡Œæ—¶å¯ç”¨äº†è¯¥ç‰¹æ€§ï¼Œå› æ­¤è°ƒç”¨æ­¤å‡½æ•°æ˜¯å®‰å…¨çš„
            return unsafe { sum_avx2(slice) };
        }
    }

    slice.iter().sum()
}

#[target_feature(enable = "avx2")]
#[cfg(target_arch = "x86_64")]
fn sum_avx2(slice: &[u32]) -> u32 {
    // å®‰å…¨æ€§ï¼š__m256i å’Œ u32 å…·æœ‰ç›¸åŒçš„æœ‰æ•ˆæ€§
    let (prefix, middle, tail) = unsafe { slice.align_to::<__m256i>() };
    
    let mut sum = prefix.iter().sum::<u32>();
    sum += tail.iter().sum::<u32>();
    
    // åœ¨ 1.87 ä¸­æ ¸å¿ƒå¾ªç¯ç°åœ¨æ˜¯å®Œå…¨å®‰å…¨çš„ä»£ç ï¼Œå› ä¸ºå†…ç½®å‡½æ•°è¦æ±‚ä¸å‡½æ•°å®šä¹‰åŒ¹é…çš„ç›®æ ‡ç‰¹æ€§ (avx2)
    let mut base = _mm256_setzero_si256();
    for e in middle.iter() {
        base = _mm256_add_epi32(base, *e);
    }
    
    // å®‰å…¨æ€§ï¼š__m256i å’Œ u32 å…·æœ‰ç›¸åŒçš„æœ‰æ•ˆæ€§
    let base: [u32; 8] = unsafe { std::mem::transmute(base) };
    sum += base.iter().sum::<u32>();
    
    sum
}
```

## `asm!` è·³è½¬åˆ° Rust ä»£ç 

å†…è”æ±‡ç¼– (`asm!`) ç°åœ¨å¯ä»¥è·³è½¬åˆ° Rust ä»£ç ä¸­çš„ labeled ä»£ç å—ã€‚è¿™ä¸ºåº•å±‚ç¼–ç¨‹æä¾›äº†æ›´å¤§çµæ´»æ€§ï¼Œä¾‹å¦‚åœ¨æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­å®ç°ä¼˜åŒ–æ§åˆ¶æµï¼Œæˆ–æ›´é«˜æ•ˆåœ°ä¸ç¡¬ä»¶äº¤äº’ã€‚

- `asm!` å®ç°åœ¨æ”¯æŒ label æ ‡ç­¾è¯­æ³•ï¼Œä½œä¸ºè·³è½¬ç›®æ ‡
- label å¿…é¡»æ˜¯è¿”å›ç±»å‹ä¸º `()` æˆ– `!` çš„å—è¡¨è¾¾å¼
- è·³è½¬æ—¶ä¼šæ‰§è¡Œè¯¥å—ï¼Œç„¶åç»§ç»­æ‰§è¡Œ `asm!` å—ä¹‹åçš„ä»£ç 
- åœ¨åŒä¸€ `asm!` é‡Œä½¿ç”¨è°ƒç”¨ä¸­ä½¿ç”¨ output å’Œ label ä»å¤„äº[unstable](https://github.com/rust-lang/rust/issues/119364)çš„

```rust
unsafe {
    asm!(
        "jmp {}",
        label {
            println!("ä»æ±‡ç¼–è·³è½¬è€Œæ¥ï¼");
        }
    );
}
```

æ›´å¤šç»†èŠ‚è¯·å‚é˜…[å‚è€ƒæ–‡æ¡£](https://doc.rust-lang.org/nightly/reference/inline-assembly.html#r-asm.operand-type.supported-operands.label)ã€‚

## ç‰¹å¾å®šä¹‰ä¸­ `impl Trait` çš„ç²¾ç¡®æ•è· (`+ use<...>`)

æœ¬ç‰ˆæœ¬ç¨³å®šäº†åœ¨ç‰¹å¾å®šä¹‰ä¸­ä½¿ç”¨ `impl Trait` è¿”å›ç±»å‹æ—¶æŒ‡å®šå…·ä½“æ•è·çš„æ³›å‹ç±»å‹å’Œç”Ÿå‘½å‘¨æœŸçš„åŠŸèƒ½ã€‚è¿™æ‰©å±•äº† [1.82](https://blog.rust-lang.org/2024/10/17/Rust-1.82.0/#precise-capturing-use-syntax) ç‰ˆæœ¬ä¸­å¯¹éç‰¹å¾å‡½æ•°çš„ç¨³å®šæ”¯æŒã€‚

ä¸€äº›ç¤ºä¾‹è§£è¯­æ³•ï¼š

```rust
trait Foo {
    fn method<'a>(&'a self) -> impl Sized;
    
    // ... è§£è¯­æ³•åç±»ä¼¼ï¼š
    type Implicit1<'a>: Sized;
    fn method_desugared<'a>(&'a self) -> Self::Implicit1<'a>;
    
    // ... è€Œä½¿ç”¨ç²¾ç¡®æ•è·æ—¶ ...
    fn precise<'a>(&'a self) -> impl Sized + use<Self>;
    
    // ... è§£è¯­æ³•åç±»ä¼¼ï¼š
    type Implicit2: Sized;
    fn precise_desugared<'a>(&'a self) -> Self::Implicit2;
}
```

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2025/05/15/Rust-1.87.0/#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.88.md
================================================
# Rust æ–°ç‰ˆè§£è¯» | 1.88 | let_chains

> Rust 1.88 å®˜æ–¹ release doc: [Announcing Rust 1.88.0 | Rust Blog](https://blog.rust-lang.org/2025/06/26/Rust-1.88.0/)

é€šè¿‡ [rustup](https://www.rust-lang.org/tools/install) å®‰è£…çš„åŒå­¦å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å‡çº§åˆ° 1.88 ç‰ˆæœ¬:

```shell
$ rustup update stable
```

## let é“¾å¼è¡¨è¾¾å¼

è¯¥ç‰¹æ€§å…è®¸åœ¨ `if` å’Œ `while` æ¡ä»¶ä¸­ä½¿ç”¨ `&&` è¿æ¥çš„ `let` è¯­å¥ï¼Œç”šè‡³å¯ä»¥ä¸å¸ƒå°”è¡¨è¾¾å¼æ··åˆä½¿ç”¨ï¼Œä»è€Œå‡å°‘ `if`/`if let` å’Œ `while`/`while let` ä¹‹é—´çš„å·®å¼‚ã€‚`let` å­è¡¨è¾¾å¼ä¸­çš„æ¨¡å¼å¯ä»¥æ˜¯ä¸å¯åé©³æˆ–å¯åé©³çš„ï¼Œç»‘å®šå˜é‡å¯ä»¥åœ¨é“¾å¼åç»­éƒ¨åˆ†å’Œä»£ç ä½“ä¸­ä½¿ç”¨ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ç‰‡æ®µç»„åˆäº†å¤šä¸ªæ¡ä»¶ï¼Œä¹‹å‰éœ€è¦åµŒå¥— `if let` å’Œ `if` å—æ‰èƒ½å®ç°ï¼š

```rust
if let Channel::Stable(v) = release_info()
    && let Semver { major, minor, .. } = v
    && major == 1
    && minor == 88
{
    println!("`let_chains` åœ¨æ­¤ç‰ˆæœ¬ä¸­å·²ç¨³å®š");
}
```

ç”±äºä¸€äº›è¾¹ç•Œåœºæ™¯éš¾ä»¥å…¼å®¹ï¼Œlet é“¾å¼è¡¨è¾¾å¼ä»…åœ¨ Rust 2024 ç‰ˆæœ¬ä¸­å¯ç”¨ï¼Œå› ä¸ºè¯¥ç‰¹æ€§ä¾èµ–äº [`if let` ä¸´æ—¶ä½œç”¨åŸŸ](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) å˜æ›´ä»¥å®ç°æ›´ä¸€è‡´çš„ææ„é¡ºåºã€‚

## è£¸å‡½æ•°

Rust ç°åœ¨æ”¯æŒç¼–å†™æ²¡æœ‰ç¼–è¯‘å™¨ç”Ÿæˆçš„æ”¶å°¾ä»£ç å’Œåºè¨€çš„è£¸å‡½æ•°ï¼Œå…è®¸å®Œå…¨æ§åˆ¶ç‰¹å®šå‡½æ•°çš„ç”Ÿæˆæ±‡ç¼–ä»£ç ã€‚è¿™æ˜¯åœ¨ `global_asm!` å—ä¸­å®šä¹‰å‡½æ•°çš„æ›´ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„æ›¿ä»£æ–¹æ¡ˆã€‚è£¸å‡½æ•°ä½¿ç”¨ `#[unsafe(naked)]` å±æ€§æ ‡è®°ï¼Œå…¶å‡½æ•°ä½“ç”±å•ä¸ª `naked_asm!` è°ƒç”¨ç»„æˆã€‚

ä¾‹å¦‚ï¼š

```rust
#[unsafe(naked)]
pub unsafe extern "sysv64" fn wrapping_add(a: u64, b: u64) -> u64 {
    // ç­‰åŒäº `a.wrapping_add(b)`ã€‚
    core::arch::naked_asm!(
        "lea rax, [rdi + rsi]",
        "ret"
    );
}
```

æ‰‹å†™çš„æ±‡ç¼–å—å®šä¹‰äº†æ•´ä¸ªå‡½æ•°ä½“ï¼šä¸éè£¸å‡½æ•°ä¸åŒï¼Œç¼–è¯‘å™¨ä¸ä¼šå¯¹å‚æ•°æˆ–è¿”å›å€¼æ·»åŠ ä»»ä½•ç‰¹æ®Šå¤„ç†ã€‚è£¸å‡½æ•°ç”¨äº Rust çš„ [compiler-builtins](https://github.com/rust-lang/compiler-builtins)ã€æ“ä½œç³»ç»Ÿå’ŒåµŒå…¥å¼åº”ç”¨ç¨‹åºç­‰åœºæ™¯ã€‚

## å¸ƒå°”é…ç½®

`cfg` è°“è¯ç°åœ¨æ”¯æŒå¸ƒå°”å­—é¢é‡ `true` å’Œ `false`ï¼Œåˆ†åˆ«ä½œä¸ºå§‹ç»ˆå¯ç”¨æˆ–ç¦ç”¨çš„é…ç½®ã€‚è¿™é€‚ç”¨äº Rust çš„[æ¡ä»¶ç¼–è¯‘](https://doc.rust-lang.org/reference/conditional-compilation.html)ä¸­çš„ `cfg` å’Œ `cfg_attr` å±æ€§ä»¥åŠå†…ç½®çš„ `cfg!` å®ï¼Œä¹Ÿé€‚ç”¨äº Cargo `[target]` è¡¨ä¸­çš„[é…ç½®](https://doc.rust-lang.org/cargo/reference/config.html#target)å’Œ[æ¸…å•](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#platform-specific-dependencies)ã€‚

æ­¤å‰ï¼Œç©ºè°“è¯åˆ—è¡¨å¯ä»¥ç”¨äºæ— æ¡ä»¶é…ç½®ï¼Œä¾‹å¦‚ `cfg(all())` ç”¨äºå¯ç”¨ï¼Œ`cfg(any())` ç”¨äºç¦ç”¨ï¼Œä½†è¿™ç§å«ä¹‰ç›¸å½“éšå¼ä¸”å®¹æ˜“æåã€‚`cfg(true)` å’Œ `cfg(false)` æä¾›äº†ä¸€ç§æ›´ç›´æ¥çš„æ–¹å¼æ¥è¡¨è¾¾ä½ çš„æ„å›¾ã€‚

å…·ä½“èƒŒæ™¯ç»†èŠ‚å¯ä»¥å‚è€ƒ [RFC-3695](https://rust-lang.github.io/rfcs/3695-cfg-boolean-literals.html)

## Cargo è‡ªåŠ¨ç¼“å­˜æ¸…ç†

ä» 1.88.0 å¼€å§‹ï¼ŒCargo å°†è‡ªåŠ¨å¯¹å…¶ä¸»ç›®å½•ä¸­çš„ç¼“å­˜è¿è¡Œåƒåœ¾å›æ”¶ï¼

æ„å»ºæ—¶ï¼ŒCargo ä¼šä¸‹è½½å¹¶ç¼“å­˜æ‰€éœ€çš„ä¾èµ–é¡¹ã€‚å†å²ä¸Šï¼Œè¿™äº›ä¸‹è½½çš„æ–‡ä»¶æ°¸è¿œä¸ä¼šè¢«æ¸…ç†ï¼Œå¯¼è‡´ Cargo ä¸»ç›®å½•ä¸­çš„ç£ç›˜ä½¿ç”¨é‡æ— é™å¢é•¿ã€‚åœ¨æ­¤ç‰ˆæœ¬ä¸­ï¼ŒCargo å¼•å…¥äº†åƒåœ¾å›æ”¶æœºåˆ¶æ¥è‡ªåŠ¨æ¸…ç†æ—§æ–‡ä»¶ï¼ˆä¾‹å¦‚ `.crate` æ–‡ä»¶ï¼‰ã€‚Cargo å°†åˆ é™¤ä»ç½‘ç»œä¸‹è½½ä¸” 3 ä¸ªæœˆå†…æœªè®¿é—®çš„æ–‡ä»¶ï¼Œä»¥åŠä»æœ¬åœ°ç³»ç»Ÿè·å–ä¸” 1 ä¸ªæœˆå†…æœªè®¿é—®çš„æ–‡ä»¶ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœåœ¨ç¦»çº¿çŠ¶æ€ä¸‹è¿è¡Œï¼ˆä½¿ç”¨ `--offline` æˆ– `--frozen`ï¼‰ï¼Œåˆ™ä¸ä¼šè¿›è¡Œæ­¤è‡ªåŠ¨åƒåœ¾å›æ”¶ã€‚

Cargo 1.78 ä»¥åä¼šè·Ÿè¸ªæ‰€éœ€çš„è®¿é—®ä¿¡æ¯ä»¥è¿›è¡Œæ­¤åƒåœ¾å›æ”¶ã€‚è¿™æ˜¯åœ¨å®é™…æ¸…ç†å¼€å§‹ä¹‹å‰å¼•å…¥çš„ï¼Œä»¥å‡å°‘ä»ä½¿ç”¨æ—©æœŸç‰ˆæœ¬çš„ç”¨æˆ·çš„ç¼“å­˜æ›´æ¢ã€‚å¦‚æœä½ ç»å¸¸ä½¿ç”¨æ¯” 1.78 ç‰ˆæœ¬æ›´æ—©çš„ Cargo ç‰ˆæœ¬ï¼Œå¹¶ä¸”å¸Œæœ›æŸäº›ä»…ç”±æ—§ç‰ˆæœ¬è®¿é—®çš„ crate ä¸è¢«é‡æ–°ä¸‹è½½ï¼Œä½ å¯ä»¥åœ¨ Cargo é…ç½®ä¸­è®¾ç½® `cache.auto-clean-frequency = "never"`ï¼Œå¦‚[æ–‡æ¡£](https://doc.rust-lang.org/nightly/cargo/reference/config.html#cache)æ‰€è¿°ã€‚

æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ­¤åŠŸèƒ½çš„åŸå§‹[ä¸ç¨³å®šå…¬å‘Š](https://blog.rust-lang.org/2023/12/11/cargo-cache-cleaning/)ã€‚è¯¥è®¾è®¡çš„æŸäº›éƒ¨åˆ†ä»ä¸ç¨³å®šï¼Œä¾‹å¦‚ [cargo#13060](https://github.com/rust-lang/cargo/issues/13060) ä¸­è·Ÿè¸ªçš„ `gc` å­å‘½ä»¤ï¼Œå› æ­¤ä»æœ‰æ›´å¤šå€¼å¾—æœŸå¾…çš„å†…å®¹ï¼

## Others

å…¶å®ƒæ›´æ–°ç»†èŠ‚ï¼Œå’Œç¨³å®šçš„ API åˆ—è¡¨ï¼Œå‚è€ƒ[åŸBlog](https://blog.rust-lang.org/2025/06/26/Rust-1.88.0/#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.89.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/intro.md
================================================
# é™„å½• Gï¼šRust æ›´æ–°ç‰ˆæœ¬åˆ—è¡¨

æœ¬ç›®å½•åŒ…å«äº† Rust å†æ¬¡ç‰ˆæœ¬æ›´æ–°çš„é‡è¦å†…å®¹è§£è¯»ï¼Œéœ€è¦æ³¨æ„ï¼Œæ¯ä¸ªç‰ˆæœ¬å®é™…æ›´æ–°çš„å†…å®¹è¦æ¯”è¿™é‡Œè®°å½•çš„æ›´å¤šï¼Œå…¨éƒ¨å†…å®¹è¯·è®¿é—®æ¯èŠ‚å¼€å¤´çš„å®˜æ–¹é“¾æ¥æŸ¥çœ‹ã€‚



================================================
FILE: src/basic/comment.md
================================================
# æ³¨é‡Šå’Œæ–‡æ¡£

å¥½çš„ä»£ç ä¼šè¯´è¯ï¼Œå¥½çš„ç¨‹åºå‘˜ä¸å†™æ³¨é‡Šï¼Œè¿™äº›éƒ½æ˜¯çƒ‚å¤§è¡—çš„â€œç¼–ç¨‹ç•Œä¿šè¯­â€ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ çœŸçš„é‡åˆ°ä¸€ä¸ªä¸å†™æ³¨é‡Šçš„é¡¹ç›®æˆ–ç¨‹åºå‘˜ï¼Œé‚£ä¸€å®šä¼šå¯¹å®ƒ/ä»–â€œåˆ®ç›®ç›¸çœ‹â€ã€‚

åœ¨ä¹‹å‰çš„ç« èŠ‚æˆ‘ä»¬å­¦ä¹ äº†åŒ…å’Œæ¨¡å—å¦‚ä½•ä½¿ç”¨ï¼Œåœ¨æ­¤ç« èŠ‚å°†è¿›ä¸€æ­¥å­¦ä¹ å¦‚ä½•ä¹¦å†™æ–‡æ¡£æ³¨é‡Šï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ `cargo doc` ç”Ÿæˆé¡¹ç›®çš„æ–‡æ¡£ï¼Œæœ€åå°†ä»¥ä¸€ä¸ªåŒ…ã€æ¨¡å—å’Œæ–‡æ¡£çš„ç»¼åˆæ€§ä¾‹å­ï¼Œæ¥å°†è¿™äº›çŸ¥è¯†èä¼šè´¯é€šã€‚

## æ³¨é‡Šçš„ç§ç±»

åœ¨ Rust ä¸­ï¼Œæ³¨é‡Šåˆ†ä¸ºä¸‰ç±»ï¼š

- ä»£ç æ³¨é‡Šï¼Œç”¨äºè¯´æ˜æŸä¸€å—ä»£ç çš„åŠŸèƒ½ï¼Œè¯»è€…å¾€å¾€æ˜¯åŒä¸€ä¸ªé¡¹ç›®çš„åä½œå¼€å‘è€…
- æ–‡æ¡£æ³¨é‡Šï¼Œæ”¯æŒ `Markdown`ï¼Œå¯¹é¡¹ç›®æè¿°ã€å…¬å…± API ç­‰ç”¨æˆ·å…³å¿ƒçš„åŠŸèƒ½è¿›è¡Œä»‹ç»ï¼ŒåŒæ—¶è¿˜èƒ½æä¾›ç¤ºä¾‹ä»£ç ï¼Œç›®æ ‡è¯»è€…å¾€å¾€æ˜¯æƒ³è¦äº†è§£ä½ é¡¹ç›®çš„äºº
- åŒ…å’Œæ¨¡å—æ³¨é‡Šï¼Œä¸¥æ ¼æ¥è¯´è¿™ä¹Ÿæ˜¯æ–‡æ¡£æ³¨é‡Šä¸­çš„ä¸€ç§ï¼Œå®ƒä¸»è¦ç”¨äºè¯´æ˜å½“å‰åŒ…å’Œæ¨¡å—çš„åŠŸèƒ½ï¼Œæ–¹ä¾¿ç”¨æˆ·è¿…é€Ÿäº†è§£ä¸€ä¸ªé¡¹ç›®

é€šè¿‡è¿™äº›æ³¨é‡Šï¼Œå®ç°äº† Rust æå…¶ä¼˜ç§€çš„æ–‡æ¡£åŒ–æ”¯æŒï¼Œç”šè‡³ä½ è¿˜èƒ½åœ¨æ–‡æ¡£æ³¨é‡Šä¸­å†™æµ‹è¯•ç”¨ä¾‹ï¼Œçœå»äº†å•ç‹¬å†™æµ‹è¯•ç”¨ä¾‹çš„ç¯èŠ‚ï¼Œæˆ‘ç›´å‘¼å¥½å®¶ä¼™ï¼

## ä»£ç æ³¨é‡Š

æ˜¾ç„¶ä¹‹å‰çš„åˆ®ç›®ç›¸çœ‹æ˜¯æ‰“äº†å¼•å·çš„ï¼Œæƒ³è¦å»æ‰å¼•å·ï¼Œè¯¥å†™æ³¨é‡Šçš„æ—¶å€™ï¼Œå°±è€è€å®å®çš„ï¼Œä¸è¿‡å†™æ—¶éœ€è¦éµå¾ªå…«å­—åŸåˆ™ï¼š**å›´ç»•ç›®æ ‡ï¼Œè¨€ç®€æ„èµ…**ï¼Œè®°ä½ï¼Œæ´‹æ´‹æ´’æ´’é‚£æ˜¯ç”¨æ¥å½¢å®¹æ–‡ç« çš„ï¼Œä¸æ˜¯å½¢å®¹æ³¨é‡Šï¼

ä»£ç æ³¨é‡Šæ–¹å¼æœ‰ä¸¤ç§ï¼š

#### è¡Œæ³¨é‡Š `//`

```rust
fn main() {
    // æˆ‘æ˜¯Sun...
    // face
    let name = "sunface";
    let age = 18; // ä»Šå¹´å¥½åƒæ˜¯18å²
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œè¡Œæ³¨é‡Šå¯ä»¥æ”¾åœ¨æŸä¸€è¡Œä»£ç çš„ä¸Šæ–¹ï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨å½“å‰ä»£ç è¡Œçš„åæ–¹ã€‚å¦‚æœè¶…å‡ºä¸€è¡Œçš„é•¿åº¦ï¼Œéœ€è¦åœ¨æ–°è¡Œçš„å¼€å¤´ä¹ŸåŠ ä¸Š `//`ã€‚

å½“æ³¨é‡Šè¡Œæ•°è¾ƒå¤šæ—¶ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨**å—æ³¨é‡Š**

#### å—æ³¨é‡Š`/* ..... */`

```rust
fn main() {
    /*
        æˆ‘
        æ˜¯
        S
        u
        n
        ... å“ï¼Œå¥½é•¿!
    */
    let name = "sunface";
    let age = "???"; // ä»Šå¹´å…¶å®ã€‚ã€‚ã€‚æŒºå¤§äº†
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œåªéœ€è¦å°†æ³¨é‡Šå†…å®¹ä½¿ç”¨ `/* */` è¿›è¡ŒåŒ…è£¹å³å¯ã€‚

ä½ ä¼šå‘ç°ï¼ŒRust çš„ä»£ç æ³¨é‡Šè·Ÿå…¶å®ƒè¯­è¨€å¹¶æ²¡æœ‰åŒºåˆ«ï¼Œä¸»è¦åŒºåˆ«å…¶å®åœ¨äºæ–‡æ¡£æ³¨é‡Šè¿™ä¸€å—ï¼Œä¹Ÿæ˜¯æœ¬ç« èŠ‚å†…å®¹çš„é‡ç‚¹ã€‚

## æ–‡æ¡£æ³¨é‡Š

å½“æŸ¥çœ‹ä¸€ä¸ª `crates.io` ä¸Šçš„åŒ…æ—¶ï¼Œå¾€å¾€éœ€è¦é€šè¿‡å®ƒæä¾›çš„æ–‡æ¡£æ¥æµè§ˆç›¸å…³çš„åŠŸèƒ½ç‰¹æ€§ã€ä½¿ç”¨æ–¹å¼ï¼Œè¿™ç§æ–‡æ¡£å°±æ˜¯é€šè¿‡æ–‡æ¡£æ³¨é‡Šå®ç°çš„ã€‚

Rust æä¾›äº† `cargo doc` çš„å‘½ä»¤ï¼Œå¯ä»¥ç”¨äºæŠŠè¿™äº›æ–‡æ¡£æ³¨é‡Šè½¬æ¢æˆ `HTML` ç½‘é¡µæ–‡ä»¶ï¼Œæœ€ç»ˆå±•ç¤ºç»™ç”¨æˆ·æµè§ˆï¼Œè¿™æ ·ç”¨æˆ·å°±çŸ¥é“è¿™ä¸ªåŒ…æ˜¯åšä»€ä¹ˆçš„ä»¥åŠè¯¥å¦‚ä½•ä½¿ç”¨ã€‚

#### æ–‡æ¡£è¡Œæ³¨é‡Š `///`

æœ¬ä¹¦çš„ä¸€å¤§ç‰¹ç‚¹å°±æ˜¯åºŸè¯ä¸å¤šï¼Œå› æ­¤æˆ‘ä»¬å¼€é—¨è§å±±ï¼š

````rust
/// `add_one` å°†æŒ‡å®šå€¼åŠ 1
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

ä»¥ä¸Šä»£ç æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š

- æ–‡æ¡£æ³¨é‡Šéœ€è¦ä½äº `lib` ç±»å‹çš„åŒ…ä¸­ï¼Œä¾‹å¦‚ `src/lib.rs` ä¸­
- æ–‡æ¡£æ³¨é‡Šå¯ä»¥ä½¿ç”¨ `markdown`è¯­æ³•ï¼ä¾‹å¦‚ `# Examples` çš„æ ‡é¢˜ï¼Œä»¥åŠä»£ç å—é«˜äº®
- è¢«æ³¨é‡Šçš„å¯¹è±¡éœ€è¦ä½¿ç”¨ `pub` å¯¹å¤–å¯è§ï¼Œè®°ä½ï¼šæ–‡æ¡£æ³¨é‡Šæ˜¯ç»™ç”¨æˆ·çœ‹çš„ï¼Œ**å†…éƒ¨å®ç°ç»†èŠ‚ä¸åº”è¯¥è¢«æš´éœ²å‡ºå»**

å’¦ï¼Ÿæ–‡æ¡£æ³¨é‡Šä¸­çš„ä¾‹å­ï¼Œä¸ºä»€çœ‹ä¸Šå»åƒæ˜¯èƒ½è¿è¡Œçš„æ ·å­ï¼Ÿç«Ÿç„¶è¿˜æ˜¯æœ‰ `assert_eq` è¿™ç§å¸¸ç”¨äºæµ‹è¯•ç›®çš„çš„å®ã€‚ å—¯ï¼Œä½ çš„æ„Ÿè§‰æ²¡é”™ï¼Œè¯¦ç»†å†…å®¹ä¼šåœ¨æœ¬ç« åé¢è®²è§£ï¼Œå®¹æˆ‘å…ˆå–ä¸ªå…³å­ã€‚

#### æ–‡æ¡£å—æ³¨é‡Š `/** ... */`

ä¸ä»£ç æ³¨é‡Šä¸€æ ·ï¼Œæ–‡æ¡£ä¹Ÿæœ‰å—æ³¨é‡Šï¼Œå½“æ³¨é‡Šå†…å®¹å¤šæ—¶ï¼Œä½¿ç”¨å—æ³¨é‡Šå¯ä»¥å‡å°‘ `///` çš„ä½¿ç”¨ï¼š

````rust
/** `add_two` å°†æŒ‡å®šå€¼åŠ 2

# Examples

```
let arg = 5;
let answer = my_crate::add_two(arg);

assert_eq!(7, answer);
```
*/
pub fn add_two(x: i32) -> i32 {
    x + 2
}
````

#### æŸ¥çœ‹æ–‡æ¡£ cargo doc

é”¦è¡£ä¸å¤œè¡Œï¼Œè¿™æ˜¯ä¸­å›½äººçš„ä¼ ç»Ÿç¾å¾·ã€‚æˆ‘ä»¬å†™äº†è¿™ä¹ˆæ¼‚äº®çš„æ–‡æ¡£æ³¨é‡Šï¼Œå½“ç„¶è¦çœ‹çœ‹ç½‘é¡µä¸­æ˜¯ä»€ä¹ˆæ•ˆæœå’¯ã€‚

å¾ˆç®€å•ï¼Œè¿è¡Œ `cargo doc` å¯ä»¥ç›´æ¥ç”Ÿæˆ `HTML` æ–‡ä»¶ï¼Œæ”¾å…¥*target/doc*ç›®å½•ä¸‹ã€‚

å½“ç„¶ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ä½¿ç”¨ `cargo doc --open` å‘½ä»¤ï¼Œå¯ä»¥åœ¨ç”Ÿæˆæ–‡æ¡£åï¼Œè‡ªåŠ¨åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ç½‘é¡µï¼Œæœ€ç»ˆæ•ˆæœå¦‚å›¾æ‰€ç¤ºï¼š

<img alt="" src="https://pic2.zhimg.com/80/v2-926c91d429e2933a6a3ae3233fc56b1c_1440w.png" class="center"  />

éå¸¸æ£’ï¼Œè€Œä¸”éå¸¸ç®€å•ï¼Œè¿™å°±æ˜¯ Rust å·¥å…·é“¾çš„å¼ºå¤§ä¹‹å¤„ã€‚

#### å¸¸ç”¨æ–‡æ¡£æ ‡é¢˜

ä¹‹å‰æˆ‘ä»¬è§åˆ°äº†åœ¨æ–‡æ¡£æ³¨é‡Šä¸­è¯¥å¦‚ä½•ä½¿ç”¨ `markdown`ï¼Œå…¶ä¸­åŒ…æ‹¬ `# Examples` æ ‡é¢˜ã€‚é™¤äº†è¿™ä¸ªæ ‡é¢˜ï¼Œè¿˜æœ‰ä¸€äº›å¸¸ç”¨çš„ï¼Œä½ å¯ä»¥åœ¨é¡¹ç›®ä¸­é…Œæƒ…ä½¿ç”¨ï¼š

- **Panics**ï¼šå‡½æ•°å¯èƒ½ä¼šå‡ºç°çš„å¼‚å¸¸çŠ¶å†µï¼Œè¿™æ ·è°ƒç”¨å‡½æ•°çš„äººå°±å¯ä»¥æå‰è§„é¿
- **Errors**ï¼šæè¿°å¯èƒ½å‡ºç°çš„é”™è¯¯åŠä»€ä¹ˆæƒ…å†µä¼šå¯¼è‡´é”™è¯¯ï¼Œæœ‰åŠ©äºè°ƒç”¨è€…é’ˆå¯¹ä¸åŒçš„é”™è¯¯é‡‡å–ä¸åŒçš„å¤„ç†æ–¹å¼
- **Safety**ï¼šå¦‚æœå‡½æ•°ä½¿ç”¨ `unsafe` ä»£ç ï¼Œé‚£ä¹ˆè°ƒç”¨è€…å°±éœ€è¦æ³¨æ„ä¸€äº›ä½¿ç”¨æ¡ä»¶ï¼Œä»¥ç¡®ä¿ `unsafe` ä»£ç å—çš„æ­£å¸¸å·¥ä½œ

è¯è¯´å›æ¥ï¼Œè¿™äº›æ ‡é¢˜æ›´å¤šçš„æ˜¯ä¸€ç§æƒ¯ä¾‹ï¼Œå¦‚æœä½ éè¦ç”¨ä¸­æ–‡æ ‡é¢˜ä¹Ÿæ²¡é—®é¢˜ï¼Œä½†æ˜¯æœ€å¥½åœ¨å›¢é˜Ÿä¸­ä¿æŒåŒæ ·çš„é£æ ¼ :)

## åŒ…å’Œæ¨¡å—çº§åˆ«çš„æ³¨é‡Š

é™¤äº†å‡½æ•°ã€ç»“æ„ä½“ç­‰ Rust é¡¹çš„æ³¨é‡Šï¼Œä½ è¿˜å¯ä»¥ç»™åŒ…å’Œæ¨¡å—æ·»åŠ æ³¨é‡Šï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**è¿™äº›æ³¨é‡Šè¦æ·»åŠ åˆ°åŒ…ã€æ¨¡å—çš„æœ€ä¸Šæ–¹**ï¼

ä¸ä¹‹å‰çš„ä»»ä½•æ³¨é‡Šä¸€æ ·ï¼ŒåŒ…çº§åˆ«çš„æ³¨é‡Šä¹Ÿåˆ†ä¸ºä¸¤ç§ï¼šè¡Œæ³¨é‡Š `//!` å’Œå—æ³¨é‡Š `/*! ... */`ã€‚

ç°åœ¨ï¼Œä¸ºæˆ‘ä»¬çš„åŒ…å¢åŠ æ³¨é‡Šï¼Œåœ¨ `src/lib.rs` åŒ…æ ¹çš„æœ€ä¸Šæ–¹ï¼Œæ·»åŠ ï¼š

```rust
/*! libåŒ…æ˜¯world_helloäºŒè¿›åˆ¶åŒ…çš„ä¾èµ–åŒ…ï¼Œ
 é‡Œé¢åŒ…å«äº†computeç­‰æœ‰ç”¨æ¨¡å— */

pub mod compute;
```

ç„¶åå†ä¸ºè¯¥åŒ…æ ¹çš„å­æ¨¡å— `src/compute.rs` æ·»åŠ æ³¨é‡Šï¼š

```rust
//! è®¡ç®—ä¸€äº›ä½ å£ç®—ç®—ä¸å‡ºæ¥çš„å¤æ‚ç®—æœ¯é¢˜


/// `add_one`å°†æŒ‡å®šå€¼åŠ 1
///
```

è¿è¡Œ `cargo doc --open` æŸ¥çœ‹ä¸‹æ•ˆæœï¼š

<img alt="" src="https://pic3.zhimg.com/80/v2-38dbea938884c159e74f777c6f49e3af_1440w.png" class="center"  />

åŒ…æ¨¡å—æ³¨é‡Šï¼Œå¯ä»¥è®©ç”¨æˆ·ä»æ•´ä½“çš„è§’åº¦ç†è§£åŒ…çš„ç”¨é€”ï¼Œå¯¹äºç”¨æˆ·æ¥è¯´æ˜¯éå¸¸å‹å¥½çš„ï¼Œå°±å’Œä¸€ç¯‡æ–‡ç« çš„å¼€å¤´ä¸€æ ·ï¼Œæ€»æ˜¯è¦å¯¹æ–‡ç« çš„å†…å®¹è¿›è¡Œå¤§è‡´çš„ä»‹ç»ï¼Œè®©ç”¨æˆ·åœ¨çœ‹çš„æ—¶å€™å¿ƒä¸­æœ‰æ•°ã€‚

è‡³æ­¤ï¼Œå…³äºå¦‚ä½•æ³¨é‡Šçš„å†…å®¹ï¼Œå°±ç»“æŸäº†ï¼Œé‚£ä¹ˆæ³¨é‡Šè¿˜èƒ½ç”¨æ¥åšä»€ä¹ˆï¼Ÿå¯ä»¥ç©å‡ºèŠ±æ¥å—ï¼Ÿç­”æ¡ˆæ˜¯`Yes`.

## æ–‡æ¡£æµ‹è¯•(Doc Test)

ç›¸ä¿¡è¯»è€…ä¹‹å‰éƒ½å†™è¿‡å•å…ƒæµ‹è¯•ç”¨ä¾‹ï¼Œå…¶ä¸­ä¸€ä¸ªå¾ˆè›‹ç–¼çš„é—®é¢˜å°±æ˜¯ï¼Œéšç€ä»£ç çš„è¿›åŒ–ï¼Œå•å…ƒæµ‹è¯•ç”¨ä¾‹ç»å¸¸ä¼šå¤±æ•ˆï¼Œè¿‡æ®µæ—¶é—´åï¼ˆä¸ºä½•æ˜¯è¿‡æ®µæ—¶é—´ï¼Ÿåº”è¯¥è¿™ä¹ˆé—®ï¼Œæœ‰å‡ ä¸ªå¼€å‘å–œæ¬¢å†™æµ‹è¯•ç”¨ä¾‹ =,=ï¼‰ï¼Œä½ å‘ç°éœ€è¦è¿ç»­ä¿®æ”¹ä¸å°‘å¤„ä»£ç ï¼Œæ‰èƒ½è®©æµ‹è¯•é‡æ–°å·¥ä½œèµ·æ¥ã€‚ç„¶è€Œï¼Œåœ¨ Rust ä¸­ï¼Œå¤§å¯ä¸å¿…ã€‚

åœ¨ä¹‹å‰çš„ `add_one` ä¸­ï¼Œæˆ‘ä»¬å†™çš„ç¤ºä¾‹ä»£ç éå¸¸åƒæ˜¯ä¸€ä¸ªå•å…ƒæµ‹è¯•çš„ç”¨ä¾‹ï¼Œè¿™æ˜¯å¶ç„¶å—ï¼Ÿå¹¶ä¸æ˜¯ã€‚å› ä¸º Rust å…è®¸æˆ‘ä»¬åœ¨æ–‡æ¡£æ³¨é‡Šä¸­å†™å•å…ƒæµ‹è¯•ç”¨ä¾‹ï¼æ–¹æ³•å°±å¦‚åŒä¹‹å‰åšçš„ï¼š

````rust
/// `add_one` å°†æŒ‡å®šå€¼åŠ 1
///
/// # Examples11
///
/// ```
/// let arg = 5;
/// let answer = world_hello::compute::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

ä»¥ä¸Šçš„æ³¨é‡Šä¸ä»…ä»…æ˜¯æ–‡æ¡£ï¼Œè¿˜å¯ä»¥ä½œä¸ºå•å…ƒæµ‹è¯•çš„ç”¨ä¾‹è¿è¡Œï¼Œä½¿ç”¨ `cargo test` è¿è¡Œæµ‹è¯•ï¼š

```console
Doc-tests world_hello

running 2 tests
test src/compute.rs - compute::add_one (line 8) ... ok
test src/compute.rs - compute::add_two (line 22) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.00s
```

å¯ä»¥çœ‹åˆ°ï¼Œæ–‡æ¡£ä¸­çš„æµ‹è¯•ç”¨ä¾‹è¢«å®Œç¾è¿è¡Œï¼Œè€Œä¸”è¾“å‡ºä¸­ä¹Ÿæ˜ç¡®æç¤ºäº† `Doc-tests world_hello`ï¼Œæ„å‘³ç€è¿™äº›æµ‹è¯•çš„åå­—å« `Doc test` æ–‡æ¡£æµ‹è¯•ã€‚

> éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½ å¯èƒ½éœ€è¦ä½¿ç”¨ç±»å¦‚ `world_hello::compute::add_one(arg)` çš„å®Œæ•´è·¯å¾„æ¥è°ƒç”¨å‡½æ•°ï¼Œå› ä¸ºæµ‹è¯•æ˜¯åœ¨å¦å¤–ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä¸­è¿è¡Œçš„

#### é€ æˆ panic çš„æ–‡æ¡£æµ‹è¯•

æ–‡æ¡£æµ‹è¯•ä¸­çš„ç”¨ä¾‹è¿˜å¯ä»¥é€ æˆ `panic`ï¼š

````rust
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}
````

ä»¥ä¸Šæµ‹è¯•è¿è¡Œåä¼š `panic`ï¼š

```console
---- src/compute.rs - compute::div (line 38) stdout ----
Test executable failed (exit code 101).

stderr:
thread 'main' panicked at 'Divide-by-zero error', src/compute.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

å¦‚æœæƒ³è¦é€šè¿‡è¿™ç§æµ‹è¯•ï¼Œå¯ä»¥æ·»åŠ  `should_panic`ï¼š

````rust
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
````

é€šè¿‡ `should_panic`ï¼Œå‘Šè¯‰ Rust æˆ‘ä»¬è¿™ä¸ªç”¨ä¾‹ä¼šå¯¼è‡´ `panic`ï¼Œè¿™æ ·æµ‹è¯•ç”¨ä¾‹å°±èƒ½é¡ºåˆ©é€šè¿‡ã€‚

#### ä¿ç•™æµ‹è¯•ï¼Œéšè—æ–‡æ¡£

åœ¨æŸäº›æ—¶å€™ï¼Œæˆ‘ä»¬å¸Œæœ›ä¿ç•™æ–‡æ¡£æµ‹è¯•çš„åŠŸèƒ½ï¼Œä½†æ˜¯åˆè¦å°†æŸäº›æµ‹è¯•ç”¨ä¾‹çš„å†…å®¹ä»æ–‡æ¡£ä¸­éšè—èµ·æ¥ï¼š

````rust
/// ```
/// # // ä½¿ç”¨#å¼€å¤´çš„è¡Œä¼šåœ¨æ–‡æ¡£ä¸­è¢«éšè—èµ·æ¥ï¼Œä½†æ˜¯ä¾ç„¶ä¼šåœ¨æ–‡æ¡£æµ‹è¯•ä¸­è¿è¡Œ
/// # fn try_main() -> Result<(), String> {
/// let res = world_hello::compute::try_div(10, 0)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() {
/// #    try_main().unwrap();
/// #
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}
````

ä»¥ä¸Šæ–‡æ¡£æ³¨é‡Šä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `#` å°†ä¸æƒ³è®©ç”¨æˆ·çœ‹åˆ°çš„å†…å®¹éšè—èµ·æ¥ï¼Œä½†æ˜¯åˆä¸å½±å“æµ‹è¯•ç”¨ä¾‹çš„è¿è¡Œï¼Œæœ€ç»ˆç”¨æˆ·å°†åªèƒ½çœ‹åˆ°é‚£è¡Œæ²¡æœ‰éšè—çš„ `let res = world_hello::compute::try_div(10, 0)?;`ï¼š

<img alt="" src="https://pic1.zhimg.com/80/v2-d1b98f5e70b7f8c8fb9aecce325dba0e_1440w.png" class="center"  />

## æ–‡æ¡£æ³¨é‡Šä¸­çš„ä»£ç è·³è½¬

Rust åœ¨æ–‡æ¡£æ³¨é‡Šä¸­è¿˜æä¾›äº†ä¸€ä¸ªéå¸¸å¼ºå¤§çš„åŠŸèƒ½ï¼Œé‚£å°±æ˜¯å¯ä»¥å®ç°å¯¹å¤–éƒ¨é¡¹çš„é“¾æ¥ï¼š

#### è·³è½¬åˆ°æ ‡å‡†åº“

```rust
/// `add_one` è¿”å›ä¸€ä¸ª[`Option`]ç±»å‹
pub fn add_one(x: i32) -> Option<i32> {
    Some(x + 1)
}
```

æ­¤å¤„çš„ **[`Option`]** å°±æ˜¯ä¸€ä¸ªé“¾æ¥ï¼ŒæŒ‡å‘äº†æ ‡å‡†åº“ä¸­çš„ `Option` æšä¸¾ç±»å‹ï¼Œæœ‰ä¸¤ç§æ–¹å¼å¯ä»¥è¿›è¡Œè·³è½¬:

- åœ¨ IDE ä¸­ï¼Œä½¿ç”¨ `Command + é¼ æ ‡å·¦é”®`(macOS)ï¼Œ`CTRL + é¼ æ ‡å·¦é”®`(Windows)
- åœ¨æ–‡æ¡£ä¸­ç›´æ¥ç‚¹å‡»é“¾æ¥

å†æ¯”å¦‚ï¼Œè¿˜å¯ä»¥ä½¿ç”¨è·¯å¾„çš„æ–¹å¼è·³è½¬ï¼š

```rust
use std::sync::mpsc::Receiver;

/// [`Receiver<T>`]   [`std::future`].
///
///  [`std::future::Future`] [`Self::recv()`].
pub struct AsyncReceiver<T> {
    sender: Receiver<T>,
}

impl<T> AsyncReceiver<T> {
    pub async fn recv() -> T {
        unimplemented!()
    }
}
```

#### ä½¿ç”¨å®Œæ•´è·¯å¾„è·³è½¬åˆ°æŒ‡å®šé¡¹

é™¤äº†è·³è½¬åˆ°æ ‡å‡†åº“ï¼Œä½ è¿˜å¯ä»¥é€šè¿‡æŒ‡å®šå…·ä½“çš„è·¯å¾„è·³è½¬åˆ°è‡ªå·±ä»£ç æˆ–è€…å…¶å®ƒåº“çš„æŒ‡å®šé¡¹ï¼Œä¾‹å¦‚åœ¨ `lib.rs` ä¸­æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š

```rust
pub mod a {
    /// `add_one` è¿”å›ä¸€ä¸ª[`Option`]ç±»å‹
    /// è·³è½¬åˆ°[`crate::MySpecialFormatter`]
    pub fn add_one(x: i32) -> Option<i32> {
        Some(x + 1)
    }
}

pub struct MySpecialFormatter;
```

ä½¿ç”¨ `crate::MySpecialFormatter` è¿™ç§è·¯å¾„å°±å¯ä»¥å®ç°è·³è½¬åˆ° `lib.rs` ä¸­å®šä¹‰çš„ç»“æ„ä½“ä¸Šã€‚

#### åŒåé¡¹çš„è·³è½¬

å¦‚æœé‡åˆ°åŒåé¡¹ï¼Œå¯ä»¥ä½¿ç”¨æ ‡ç¤ºç±»å‹çš„æ–¹å¼è¿›è¡Œè·³è½¬ï¼š

```rust
/// è·³è½¬åˆ°ç»“æ„ä½“  [`Foo`](struct@Foo)
pub struct Bar;

/// è·³è½¬åˆ°åŒåå‡½æ•° [`Foo`](fn@Foo)
pub struct Foo {}

/// è·³è½¬åˆ°åŒåå® [`foo!`]
pub fn Foo() {}

#[macro_export]
macro_rules! foo {
  () => {}
}
```

## æ–‡æ¡£æœç´¢åˆ«å

Rust æ–‡æ¡£æ”¯æŒæœç´¢åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºè‡ªå·±çš„ç±»å‹å®šä¹‰å‡ ä¸ªåˆ«åï¼Œä»¥å®ç°æ›´å¥½çš„æœç´¢å±•ç°ï¼Œå½“åˆ«åå‘½ä¸­æ—¶ï¼Œæœç´¢ç»“æœä¼šè¢«æ”¾åœ¨ç¬¬ä¸€ä½ï¼š

```rust
#[doc(alias = "x")]
#[doc(alias = "big")]
pub struct BigX;

#[doc(alias("y", "big"))]
pub struct BigY;
```

ç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
<img alt="" src="https://pic1.zhimg.com/80/v2-1ab5b19d2bd06f3d83204d062b399bcd_1440w.png" class="center"  />

## ä¸€ä¸ªç»¼åˆä¾‹å­

è¿™ä¸ªä¾‹å­æˆ‘ä»¬å°†é‡ç‚¹åº”ç”¨å‡ ä¸ªçŸ¥è¯†ç‚¹ï¼š

- æ–‡æ¡£æ³¨é‡Š
- ä¸€ä¸ªé¡¹ç›®å¯ä»¥åŒ…å«ä¸¤ä¸ªåŒ…ï¼šäºŒè¿›åˆ¶å¯æ‰§è¡ŒåŒ…å’Œ `lib` åŒ…ï¼ˆåº“åŒ…ï¼‰ï¼Œå®ƒä»¬çš„åŒ…æ ¹åˆ†åˆ«æ˜¯ `src/main.rs` å’Œ `src/lib.rs`
- åœ¨äºŒè¿›åˆ¶åŒ…ä¸­å¼•ç”¨ `lib` åŒ…
- ä½¿ç”¨ `pub use` å†å¯¼å‡º APIï¼Œå¹¶è§‚å¯Ÿæ–‡æ¡£

é¦–å…ˆï¼Œä½¿ç”¨ `cargo new art` åˆ›å»ºä¸€ä¸ª Package `art`ï¼š

```console
Created binary (application) `art` package
```

ç³»ç»Ÿæç¤ºæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªäºŒè¿›åˆ¶ `Package`ï¼Œæ ¹æ®[ä¹‹å‰ç« èŠ‚](https://course.rs/basic/crate-module/crate.html)å­¦è¿‡çš„å†…å®¹ï¼Œå¯ä»¥çŸ¥é“è¯¥ `Package` åŒ…å«ä¸€ä¸ªåŒåçš„äºŒè¿›åˆ¶åŒ…ï¼šåŒ…åä¸º `art`ï¼ŒåŒ…æ ¹ä¸º `src/main.rs`ï¼Œè¯¥åŒ…å¯ä»¥ç¼–è¯‘æˆäºŒè¿›åˆ¶ç„¶åè¿è¡Œã€‚

ç°åœ¨ï¼Œåœ¨ `src` ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ª `lib.rs` æ–‡ä»¶ï¼ŒåŒæ ·ï¼Œæ ¹æ®ä¹‹å‰å­¦ä¹ çš„çŸ¥è¯†ï¼Œåˆ›å»ºè¯¥æ–‡ä»¶ç­‰äºåˆåˆ›å»ºäº†ä¸€ä¸ªåº“ç±»å‹çš„åŒ…ï¼ŒåŒ…åä¹Ÿæ˜¯ `art`ï¼ŒåŒ…æ ¹ä¸º `src/lib.rs`ï¼Œè¯¥åŒ…æ˜¯æ˜¯åº“ç±»å‹çš„ï¼Œå› æ­¤å¾€å¾€ä½œä¸ºä¾èµ–åº“è¢«å¼•å…¥ã€‚

å°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ° `src/lib.rs` ä¸­ï¼š

````rust
//! # Art
//!
//!  æœªæ¥çš„è‰ºæœ¯å»ºæ¨¡åº“ï¼Œç°åœ¨çš„è°ƒè‰²åº“

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    //! å®šä¹‰é¢œè‰²çš„ç±»å‹

    /// ä¸»è‰²
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// å‰¯è‰²
    #[derive(Debug,PartialEq)]
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    //! å®ç”¨å·¥å…·ï¼Œç›®å‰åªå®ç°äº†è°ƒè‰²æ¿
    use crate::kinds::*;

    /// å°†ä¸¤ç§ä¸»è‰²è°ƒæˆå‰¯è‰²
    /// ```rust
    /// use art::utils::mix;
    /// use art::kinds::{PrimaryColor,SecondaryColor};
    /// assert!(matches!(mix(PrimaryColor::Yellow, PrimaryColor::Blue), SecondaryColor::Green));
    /// ```
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        SecondaryColor::Green
    }
}
````

åœ¨åº“åŒ…çš„åŒ…æ ¹ `src/lib.rs` ä¸‹ï¼Œæˆ‘ä»¬åˆå®šä¹‰äº†å‡ ä¸ªå­æ¨¡å—ï¼ŒåŒæ—¶å°†å­æ¨¡å—ä¸­çš„ä¸‰ä¸ªé¡¹é€šè¿‡ `pub use` è¿›è¡Œäº†å†å¯¼å‡ºã€‚

æ¥ç€ï¼Œå°†ä¸‹é¢å†…å®¹æ·»åŠ åˆ° `src/main.rs` ä¸­ï¼š

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let blue = PrimaryColor::Blue;
    let yellow = PrimaryColor::Yellow;
    println!("{:?}",mix(blue, yellow));
}
```

åœ¨äºŒè¿›åˆ¶å¯æ‰§è¡ŒåŒ…çš„åŒ…æ ¹ `src/main.rs` ä¸‹ï¼Œæˆ‘ä»¬å¼•å…¥äº†åº“åŒ… `art` ä¸­çš„æ¨¡å—é¡¹ï¼ŒåŒæ—¶ä½¿ç”¨ `main` å‡½æ•°ä½œä¸ºç¨‹åºçš„å…¥å£ï¼Œè¯¥äºŒè¿›åˆ¶åŒ…å¯ä»¥ä½¿ç”¨ `cargo run` è¿è¡Œï¼š

```console
Green
```

è‡³æ­¤ï¼Œåº“åŒ…å®Œç¾æä¾›äº†ç”¨äºè°ƒè‰²çš„ APIï¼ŒäºŒè¿›åˆ¶åŒ…å¼•å…¥è¿™äº› API å®Œç¾çš„å®ç°äº†è°ƒè‰²å¹¶æ‰“å°è¾“å‡ºã€‚

æœ€åï¼Œå†æ¥çœ‹çœ‹æ–‡æ¡£é•¿å•¥æ ·ï¼š

<img alt="" src="https://pic1.zhimg.com/80/v2-e9ef7351458fd01020b35990c3daf222_1440w.png" class="center"  />

## æ€»ç»“

åœ¨ Rust ä¸­ï¼Œæ³¨é‡Šåˆ†ä¸ºä¸‰ä¸ªä¸»è¦ç±»å‹ï¼šä»£ç æ³¨é‡Šã€æ–‡æ¡£æ³¨é‡Šã€åŒ…å’Œæ¨¡å—æ³¨é‡Šï¼Œæ¯ä¸ªæ³¨é‡Šç±»å‹éƒ½æ‹¥æœ‰ä¸¤ç§å½¢å¼ï¼šè¡Œæ³¨é‡Šå’Œå—æ³¨é‡Šï¼Œç†Ÿç»ƒæŒæ¡åŒ…æ¨¡å—å’Œæ³¨é‡Šçš„çŸ¥è¯†ï¼Œéå¸¸æœ‰åŠ©äºæˆ‘ä»¬åˆ›å»ºå·¥ç¨‹æ€§æ›´å¼ºçš„é¡¹ç›®ã€‚

å¦‚æœè¯»è€…çœ‹åˆ°è¿™é‡Œå¯¹äºåŒ…æ¨¡å—è¿˜æ˜¯æœ‰äº›æ¨¡ç³Šï¼Œå¼ºçƒˆå»ºè®®å›å¤´çœ‹çœ‹ç›¸å…³çš„ç« èŠ‚ä»¥åŠæœ¬ç« èŠ‚çš„æœ€åä¸€ä¸ªç»¼åˆä¾‹å­ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/comments-docs.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„ä¹ é¢˜è§£ç­”ã€‚ï¼ˆæœ¬èŠ‚æš‚æ— ä¹ é¢˜è§£ç­”ï¼‰


================================================
FILE: src/basic/flow-control.md
================================================
# æµç¨‹æ§åˆ¶

80 ååº”è¯¥éƒ½å¯¹å­¦æ ¡çš„å°æ··æ··è®°å¿†çŠ¹æ–°ï¼Œåœ¨é‚£ä¸ªæ—¶ä»£ï¼Œå°æ··æ··ä»¬å¾€å¾€éƒ½è®¤ä¸ºè‡ªå·±æ˜¯åœ°ä¸‹ç‹è€…ï¼Œç®¡æ§ç€åœ°ä¸‹äº‹åŠ¡çš„æµç¨‹ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼Œä»–ä»¬å°±åƒä»£ç ä¸­çš„æµç¨‹æ§åˆ¶ä¸€æ ·ï¼Œæ— å¤„ä¸åœ¨ï¼Œå¾ˆæ˜¾çœ¼ï¼Œä½†æ˜¯åˆè®©äººæ‡’å¾—é‡è§†ã€‚

è¨€å½’æ­£ä¼ ï¼ŒRust ç¨‹åºæ˜¯ä»ä¸Šè€Œä¸‹é¡ºåºæ‰§è¡Œçš„ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¾ªç¯ã€åˆ†æ”¯ç­‰æµç¨‹æ§åˆ¶æ–¹å¼ï¼Œæ›´å¥½çš„å®ç°ç›¸åº”çš„åŠŸèƒ½ã€‚

## ä½¿ç”¨ if æ¥åšåˆ†æ”¯æ§åˆ¶

> if else æ— å¤„ä¸åœ¨ -- é²è¿…

ä½†å‡¡ä½ èƒ½æ‰¾åˆ°ä¸€é—¨ç¼–ç¨‹è¯­è¨€æ²¡æœ‰ `if else`ï¼Œé‚£ä¹ˆä¸€å®šæ›´è¦åé¦ˆç»™é²è¿…ï¼Œåæ­£ä¸æ˜¯æˆ‘è¯´çš„ :) æ€»ä¹‹ï¼Œåªè¦ä½ æ‹¥æœ‰å…¶å®ƒè¯­è¨€çš„ç¼–ç¨‹ç»éªŒï¼Œå°±ä¸€å®šä¼šæœ‰ä»¥ä¸‹è®¤çŸ¥ï¼š`if else` **è¡¨è¾¾å¼**æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„ä»£ç åˆ†æ”¯ï¼š

```rust
if condition == true {
    // A...
} else {
    // B...
}
```

è¯¥ä»£ç è¯»ä½œï¼šè‹¥ `condition` çš„å€¼ä¸º `true`ï¼Œåˆ™æ‰§è¡Œ `A` ä»£ç ï¼Œå¦åˆ™æ‰§è¡Œ `B` ä»£ç ã€‚

å…ˆçœ‹ä¸‹é¢ä»£ç ï¼š

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

ä»¥ä¸Šä»£ç æœ‰ä»¥ä¸‹å‡ ç‚¹è¦æ³¨æ„ï¼š

- **`if` è¯­å¥å—æ˜¯è¡¨è¾¾å¼**ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ `if` è¡¨è¾¾å¼çš„è¿”å›å€¼æ¥ç»™ `number` è¿›è¡Œèµ‹å€¼ï¼š`number` çš„å€¼æ˜¯ `5`
- ç”¨ `if` æ¥èµ‹å€¼æ—¶ï¼Œè¦ä¿è¯æ¯ä¸ªåˆ†æ”¯è¿”å›çš„ç±»å‹ä¸€æ ·ï¼ˆäº‹å®ä¸Šï¼Œè¿™ç§è¯´æ³•ä¸å®Œå…¨å‡†ç¡®ï¼Œè§[è¿™é‡Œ](https://course.rs/appendix/expressions.html#ifè¡¨è¾¾å¼)ï¼‰ï¼Œæ­¤å¤„è¿”å›çš„ `5` å’Œ `6` å°±æ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œå¦‚æœè¿”å›ç±»å‹ä¸ä¸€è‡´å°±ä¼šæŠ¥é”™

```console
error[E0308]: if and else have incompatible types
 --> src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         "six"
8 | |     };
  | |_____^ expected integer, found &str // æœŸæœ›æ•´æ•°ç±»å‹ï¼Œä½†å´å‘ç°&strå­—ç¬¦ä¸²åˆ‡ç‰‡
  |
  = note: expected type `{integer}`
             found type `&str`
```

## ä½¿ç”¨ else if æ¥å¤„ç†å¤šé‡æ¡ä»¶

å¯ä»¥å°† `else if` ä¸ `if`ã€`else` ç»„åˆåœ¨ä¸€èµ·å®ç°æ›´å¤æ‚çš„æ¡ä»¶åˆ†æ”¯åˆ¤æ–­ï¼š

```rust
fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!("number is divisible by 4");
    } else if n % 3 == 0 {
        println!("number is divisible by 3");
    } else if n % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

ç¨‹åºæ‰§è¡Œæ—¶ï¼Œä¼šæŒ‰ç…§è‡ªä¸Šè‡³ä¸‹çš„é¡ºåºæ‰§è¡Œæ¯ä¸€ä¸ªåˆ†æ”¯åˆ¤æ–­ï¼Œä¸€æ—¦æˆåŠŸï¼Œåˆ™è·³å‡º `if` è¯­å¥å—ï¼Œæœ€ç»ˆæœ¬ç¨‹åºä¼šåŒ¹é…æ‰§è¡Œ `else if n % 3 == 0` çš„åˆ†æ”¯ï¼Œè¾“å‡º `"number is divisible by 3"`ã€‚

æœ‰ä¸€ç‚¹è¦æ³¨æ„ï¼Œå°±ç®—æœ‰å¤šä¸ªåˆ†æ”¯èƒ½åŒ¹é…ï¼Œä¹Ÿåªæœ‰ç¬¬ä¸€ä¸ªåŒ¹é…çš„åˆ†æ”¯ä¼šè¢«æ‰§è¡Œï¼

å¦‚æœä»£ç ä¸­æœ‰å¤§é‡çš„ `else if ` ä¼šè®©ä»£ç å˜å¾—æå…¶ä¸‘é™‹ï¼Œä¸è¿‡ä¸ç”¨æ‹…å¿ƒï¼Œä¸‹ä¸€ç« çš„ `match` ä¸“é—¨ç”¨ä»¥è§£å†³å¤šåˆ†æ”¯æ¨¡å¼åŒ¹é…çš„é—®é¢˜ã€‚

# å¾ªç¯æ§åˆ¶

å¾ªç¯æ— å¤„ä¸åœ¨ï¼Œä¸Šåˆ°æ•°é’±ï¼Œä¸‹åˆ°æ•°å¹´ï¼Œä½ èƒ½æƒ³è±¡çš„å¾ˆå¤šåœºæ™¯éƒ½å­˜åœ¨å¾ªç¯ï¼Œå› æ­¤å®ƒä¹Ÿæ˜¯æµç¨‹æ§åˆ¶ä¸­æœ€é‡è¦çš„ç»„æˆéƒ¨åˆ†ä¹‹ä¸€ã€‚

åœ¨ Rust è¯­è¨€ä¸­æœ‰ä¸‰ç§å¾ªç¯æ–¹å¼ï¼š`for`ã€`while` å’Œ `loop`ï¼Œå…¶ä¸­ `for` å¾ªç¯æ˜¯ Rust å¾ªç¯ç‹å† ä¸Šçš„æ˜ç ã€‚

## for å¾ªç¯

`for` å¾ªç¯æ˜¯ Rust çš„å¤§æ€å™¨ï¼š

```rust
fn main() {
    for i in 1..=5 {
        println!("{}", i);
    }
}
```

ä»¥ä¸Šä»£ç å¾ªç¯è¾“å‡ºä¸€ä¸ªä» 1 åˆ° 5 çš„åºåˆ—ï¼Œç®€å•ç²—æš´ï¼Œæ ¸å¿ƒå°±åœ¨äº `for` å’Œ `in` çš„è”åŠ¨ï¼Œè¯­ä¹‰è¡¨è¾¾å¦‚ä¸‹ï¼š

```rust
for å…ƒç´  in é›†åˆ {
  // ä½¿ç”¨å…ƒç´ å¹²ä¸€äº›ä½ æ‡‚æˆ‘ä¸æ‡‚çš„äº‹æƒ…
}
```

è¿™ä¸ªè¯­æ³•è·Ÿ JavaScript è¿˜è›®åƒï¼Œåº”è¯¥æŒºå¥½ç†è§£ã€‚

æ³¨æ„ï¼Œä½¿ç”¨ `for` æ—¶æˆ‘ä»¬å¾€å¾€ä½¿ç”¨é›†åˆçš„å¼•ç”¨å½¢å¼ï¼Œé™¤éä½ ä¸æƒ³åœ¨åé¢çš„ä»£ç ä¸­ç»§ç»­ä½¿ç”¨è¯¥é›†åˆï¼ˆæ¯”å¦‚æˆ‘ä»¬è¿™é‡Œä½¿ç”¨äº† `container` çš„å¼•ç”¨ï¼‰ã€‚å¦‚æœä¸ä½¿ç”¨å¼•ç”¨çš„è¯ï¼Œæ‰€æœ‰æƒä¼šè¢«è½¬ç§»ï¼ˆmoveï¼‰åˆ° `for` è¯­å¥å—ä¸­ï¼Œåé¢å°±æ— æ³•å†ä½¿ç”¨è¿™ä¸ªé›†åˆäº†)ï¼š

```rust
for item in &container {
  // ...
}
```

> å¯¹äºå®ç°äº† `copy` ç‰¹å¾çš„æ•°ç»„ï¼ˆä¾‹å¦‚ [i32; 10]ï¼‰è€Œè¨€ï¼Œ `for item in arr` å¹¶ä¸ä¼šæŠŠ `arr` çš„æ‰€æœ‰æƒè½¬ç§»ï¼Œè€Œæ˜¯ç›´æ¥å¯¹å…¶è¿›è¡Œäº†æ‹·è´ï¼Œå› æ­¤å¾ªç¯ä¹‹åä»ç„¶å¯ä»¥ä½¿ç”¨ `arr` ã€‚

å¦‚æœæƒ³åœ¨å¾ªç¯ä¸­ï¼Œ**ä¿®æ”¹è¯¥å…ƒç´ **ï¼Œå¯ä»¥ä½¿ç”¨ `mut` å…³é”®å­—ï¼š

```rust
for item in &mut collection {
  // ...
}
```

æ€»ç»“å¦‚ä¸‹ï¼š

| ä½¿ç”¨æ–¹æ³•                      | ç­‰ä»·ä½¿ç”¨æ–¹å¼                                      | æ‰€æœ‰æƒ     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | è½¬ç§»æ‰€æœ‰æƒ |
| `for item in &collection`     | `for item in collection.iter()`                   | ä¸å¯å˜å€Ÿç”¨ |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | å¯å˜å€Ÿç”¨   |

å¦‚æœæƒ³åœ¨å¾ªç¯ä¸­**è·å–å…ƒç´ çš„ç´¢å¼•**ï¼š

```rust
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` æ–¹æ³•æŠŠ `a` æ•°ç»„å˜æˆä¸€ä¸ªè¿­ä»£å™¨
    for (i, v) in a.iter().enumerate() {
        println!("ç¬¬{}ä¸ªå…ƒç´ æ˜¯{}", i + 1, v);
    }
}
```

æœ‰åŒå­¦å¯èƒ½ä¼šæƒ³åˆ°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç”¨ `for` å¾ªç¯æ§åˆ¶æŸä¸ªè¿‡ç¨‹æ‰§è¡Œ 10 æ¬¡ï¼Œä½†æ˜¯åˆä¸æƒ³å•ç‹¬å£°æ˜ä¸€ä¸ªå˜é‡æ¥æ§åˆ¶è¿™ä¸ªæµç¨‹ï¼Œè¯¥æ€ä¹ˆå†™ï¼Ÿ

```rust
for _ in 0..10 {
  // ...
}
```

å¯ä»¥ç”¨ `_` æ¥æ›¿ä»£ `i` ç”¨äº `for` å¾ªç¯ä¸­ï¼Œåœ¨ Rust ä¸­ `_` çš„å«ä¹‰æ˜¯å¿½ç•¥è¯¥å€¼æˆ–è€…ç±»å‹çš„æ„æ€ï¼Œå¦‚æœä¸ä½¿ç”¨ `_`ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šç»™ä½ ä¸€ä¸ª `å˜é‡æœªä½¿ç”¨çš„` çš„è­¦å‘Šã€‚

**ä¸¤ç§å¾ªç¯æ–¹å¼ä¼˜åŠ£å¯¹æ¯”**

ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨äº†ä¸¤ç§å¾ªç¯æ–¹å¼ï¼š

```rust
// ç¬¬ä¸€ç§
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// ç¬¬äºŒç§
for item in collection {

}
```

ç¬¬ä¸€ç§æ–¹å¼æ˜¯å¾ªç¯ç´¢å¼•ï¼Œç„¶åé€šè¿‡ç´¢å¼•ä¸‹æ ‡å»è®¿é—®é›†åˆï¼Œç¬¬äºŒç§æ–¹å¼æ˜¯ç›´æ¥å¾ªç¯é›†åˆä¸­çš„å…ƒç´ ï¼Œä¼˜åŠ£å¦‚ä¸‹ï¼š

- **æ€§èƒ½**ï¼šç¬¬ä¸€ç§ä½¿ç”¨æ–¹å¼ä¸­ `collection[index]` çš„ç´¢å¼•è®¿é—®ï¼Œä¼šå› ä¸ºè¾¹ç•Œæ£€æŸ¥(Bounds Checking)å¯¼è‡´è¿è¡Œæ—¶çš„æ€§èƒ½æŸè€— â€”â€” Rust ä¼šæ£€æŸ¥å¹¶ç¡®è®¤ `index` æ˜¯å¦è½åœ¨é›†åˆå†…ï¼Œä½†æ˜¯ç¬¬äºŒç§ç›´æ¥è¿­ä»£çš„æ–¹å¼å°±ä¸ä¼šè§¦å‘è¿™ç§æ£€æŸ¥ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶å°±å®Œæˆåˆ†æå¹¶è¯æ˜è¿™ç§è®¿é—®æ˜¯åˆæ³•çš„
- **å®‰å…¨**ï¼šç¬¬ä¸€ç§æ–¹å¼é‡Œå¯¹ `collection` çš„ç´¢å¼•è®¿é—®æ˜¯éè¿ç»­çš„ï¼Œå­˜åœ¨ä¸€å®šå¯èƒ½æ€§åœ¨ä¸¤æ¬¡è®¿é—®ä¹‹é—´ï¼Œ`collection` å‘ç”Ÿäº†å˜åŒ–ï¼Œå¯¼è‡´è„æ•°æ®äº§ç”Ÿã€‚è€Œç¬¬äºŒç§ç›´æ¥è¿­ä»£çš„æ–¹å¼æ˜¯è¿ç»­è®¿é—®ï¼Œå› æ­¤ä¸å­˜åœ¨è¿™ç§é£é™©( ç”±äºæ‰€æœ‰æƒé™åˆ¶ï¼Œåœ¨è®¿é—®è¿‡ç¨‹ä¸­ï¼Œæ•°æ®å¹¶ä¸ä¼šå‘ç”Ÿå˜åŒ–)ã€‚

ç”±äº `for` å¾ªç¯æ— éœ€ä»»ä½•æ¡ä»¶é™åˆ¶ï¼Œä¹Ÿä¸éœ€è¦é€šè¿‡ç´¢å¼•æ¥è®¿é—®ï¼Œå› æ­¤æ˜¯æœ€å®‰å…¨ä¹Ÿæ˜¯æœ€å¸¸ç”¨çš„ï¼Œé€šè¿‡ä¸ä¸‹é¢çš„ `while` çš„å¯¹æ¯”ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ä¸ºä»€ä¹ˆ `for` ä¼šæ›´åŠ å®‰å…¨ã€‚

## `continue`

ä½¿ç”¨ `continue` å¯ä»¥è·³è¿‡å½“å‰å½“æ¬¡çš„å¾ªç¯ï¼Œå¼€å§‹ä¸‹æ¬¡çš„å¾ªç¯ï¼š

```rust
 for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!("{}", i);
 }
```

ä¸Šé¢ä»£ç å¯¹ 1 åˆ° 3 çš„åºåˆ—è¿›è¡Œè¿­ä»£ï¼Œä¸”è·³è¿‡å€¼ä¸º 2 æ—¶çš„å¾ªç¯ï¼Œè¾“å‡ºå¦‚ä¸‹ï¼š

```console
1
3
```

## `break`

ä½¿ç”¨ `break` å¯ä»¥ç›´æ¥è·³å‡ºå½“å‰æ•´ä¸ªå¾ªç¯ï¼š

```rust
 for i in 1..4 {
     if i == 2 {
         break;
     }
     println!("{}", i);
 }
```

ä¸Šé¢ä»£ç å¯¹ 1 åˆ° 3 çš„åºåˆ—è¿›è¡Œè¿­ä»£ï¼Œåœ¨é‡åˆ°å€¼ä¸º 2 æ—¶çš„è·³å‡ºæ•´ä¸ªå¾ªç¯ï¼Œåé¢çš„å¾ªç¯ä¸å†æ‰§è¡Œï¼Œè¾“å‡ºå¦‚ä¸‹ï¼š

```console
1
```

## while å¾ªç¯

å¦‚æœä½ éœ€è¦ä¸€ä¸ªæ¡ä»¶æ¥å¾ªç¯ï¼Œå½“è¯¥æ¡ä»¶ä¸º `true` æ—¶ï¼Œç»§ç»­å¾ªç¯ï¼Œæ¡ä»¶ä¸º `false`ï¼Œè·³å‡ºå¾ªç¯ï¼Œé‚£ä¹ˆ `while` å°±éå¸¸é€‚ç”¨ï¼š

```rust
fn main() {
    let mut n = 0;

    while n <= 5  {
        println!("{}!", n);

        n = n + 1;
    }

    println!("æˆ‘å‡ºæ¥äº†ï¼");
}
```

è¯¥ `while` å¾ªç¯ï¼Œåªæœ‰å½“ `n` å°äºç­‰äº `5` æ—¶ï¼Œæ‰æ‰§è¡Œï¼Œå¦åˆ™å°±ç«‹åˆ»è·³å‡ºå¾ªç¯ï¼Œå› æ­¤åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œå®ƒä¼šå…ˆä» `0` å¼€å§‹ï¼Œæ»¡è¶³æ¡ä»¶ï¼Œè¿›è¡Œå¾ªç¯ï¼Œç„¶åæ˜¯ `1`ï¼Œæ»¡è¶³æ¡ä»¶ï¼Œè¿›è¡Œå¾ªç¯ï¼Œæœ€ç»ˆåˆ° `6` çš„æ—¶å€™ï¼Œå¤§äº 5ï¼Œä¸æ»¡è¶³æ¡ä»¶ï¼Œè·³å‡º `while` å¾ªç¯ï¼Œæ‰§è¡Œ `æˆ‘å‡ºæ¥äº†` çš„æ‰“å°ï¼Œç„¶åç¨‹åºç»“æŸï¼š

```console
0!
1!
2!
3!
4!
5!
æˆ‘å‡ºæ¥äº†ï¼
```

å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥ç”¨å…¶å®ƒæ–¹å¼ç»„åˆå®ç°ï¼Œä¾‹å¦‚ `loop`ï¼ˆæ— æ¡ä»¶å¾ªç¯ï¼Œå°†åœ¨ä¸‹é¢ä»‹ç»ï¼‰ + `if` + `break`ï¼š

```rust
fn main() {
    let mut n = 0;

    loop {
        if n > 5 {
            break
        }
        println!("{}", n);
        n+=1;
    }

    println!("æˆ‘å‡ºæ¥äº†ï¼");
}
```

å¯ä»¥çœ‹å‡ºï¼Œåœ¨è¿™ç§å¾ªç¯åœºæ™¯ä¸‹ï¼Œ`while` è¦ç®€æ´çš„å¤šã€‚

**while vs for**

æˆ‘ä»¬ä¹Ÿèƒ½ç”¨ `while` æ¥å®ç° `for` çš„åŠŸèƒ½ï¼š

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index = index + 1;
    }
}
```

è¿™é‡Œï¼Œä»£ç å¯¹æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œè®¡æ•°ã€‚å®ƒä»ç´¢å¼• `0` å¼€å§‹ï¼Œå¹¶æ¥ç€å¾ªç¯ç›´åˆ°é‡åˆ°æ•°ç»„çš„æœ€åä¸€ä¸ªç´¢å¼•ï¼ˆè¿™æ—¶ï¼Œ`index < 5` ä¸å†ä¸ºçœŸï¼‰ã€‚è¿è¡Œè¿™æ®µä»£ç ä¼šæ‰“å°å‡ºæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼š

```console
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

æ•°ç»„ä¸­çš„æ‰€æœ‰äº”ä¸ªå…ƒç´ éƒ½å¦‚æœŸè¢«æ‰“å°å‡ºæ¥ã€‚å°½ç®¡ `index` åœ¨æŸä¸€æ—¶åˆ»ä¼šåˆ°è¾¾å€¼ 5ï¼Œä¸è¿‡å¾ªç¯åœ¨å…¶å°è¯•ä»æ•°ç»„è·å–ç¬¬å…­ä¸ªå€¼ï¼ˆä¼šè¶Šç•Œï¼‰ä¹‹å‰å°±åœæ­¢äº†ã€‚

ä½†è¿™ä¸ªè¿‡ç¨‹å¾ˆå®¹æ˜“å‡ºé”™ï¼›å¦‚æœç´¢å¼•é•¿åº¦ä¸æ­£ç¡®ä¼šå¯¼è‡´ç¨‹åº **_panic_**ã€‚è¿™ä¹Ÿä½¿ç¨‹åºæ›´æ…¢ï¼Œå› ä¸ºç¼–è¯‘å™¨å¢åŠ äº†è¿è¡Œæ—¶ä»£ç æ¥å¯¹æ¯æ¬¡å¾ªç¯çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œæ¡ä»¶æ£€æŸ¥ã€‚

`for`å¾ªç¯ä»£ç å¦‚ä¸‹ï¼š

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

å¯ä»¥çœ‹å‡ºï¼Œ`for` å¹¶ä¸ä¼šä½¿ç”¨ç´¢å¼•å»è®¿é—®æ•°ç»„ï¼Œå› æ­¤æ›´å®‰å…¨ä¹Ÿæ›´ç®€æ´ï¼ŒåŒæ—¶é¿å… `è¿è¡Œæ—¶çš„è¾¹ç•Œæ£€æŸ¥`ï¼Œæ€§èƒ½æ›´é«˜ã€‚

## loop å¾ªç¯

å¯¹äºå¾ªç¯è€Œè¨€ï¼Œ`loop` å¾ªç¯æ¯‹åº¸ç½®ç–‘ï¼Œæ˜¯é€‚ç”¨é¢æœ€é«˜çš„ï¼Œå®ƒå¯ä»¥é€‚ç”¨äºæ‰€æœ‰å¾ªç¯åœºæ™¯ï¼ˆè™½ç„¶èƒ½ç”¨ï¼Œä½†æ˜¯åœ¨å¾ˆå¤šåœºæ™¯ä¸‹ï¼Œ `for` å’Œ `while` æ‰æ˜¯æœ€ä¼˜é€‰æ‹©ï¼‰ï¼Œå› ä¸º `loop` å°±æ˜¯ä¸€ä¸ªç®€å•çš„æ— é™å¾ªç¯ï¼Œä½ å¯ä»¥åœ¨å†…éƒ¨å®ç°é€»è¾‘é€šè¿‡ `break` å…³é”®å­—æ¥æ§åˆ¶å¾ªç¯ä½•æ—¶ç»“æŸã€‚

ä½¿ç”¨ `loop` å¾ªç¯ä¸€å®šè¦æ‰“èµ·ç²¾ç¥ï¼Œå¦åˆ™ä½ ä¼šå†™å‡ºä¸‹é¢çš„è·‘æ»¡ä½ ä¸€ä¸ª CPU æ ¸å¿ƒçš„ç–¯å­ä»£ç ï¼š

```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```

è¯¥å¾ªç¯ä¼šä¸åœçš„åœ¨ç»ˆç«¯æ‰“å°è¾“å‡ºï¼Œç›´åˆ°ä½ ä½¿ç”¨ `Ctrl-C` ç»“æŸç¨‹åºï¼š

```console
again!
again!
again!
again!
^Cagain!
```

**æ³¨æ„**ï¼Œä¸è¦è½»æ˜“å°è¯•ä¸Šè¿°ä»£ç ï¼Œå¦‚æœä½ ç”µè„‘é…ç½®ä¸è¡Œï¼Œå¯èƒ½ä¼šæ­»æœºï¼ï¼ï¼

å› æ­¤ï¼Œå½“ä½¿ç”¨ `loop` æ—¶ï¼Œå¿…ä¸å¯å°‘çš„ä¼™ä¼´æ˜¯ `break` å…³é”®å­—ï¼Œå®ƒèƒ½è®©å¾ªç¯åœ¨æ»¡è¶³æŸä¸ªæ¡ä»¶æ—¶è·³å‡ºï¼š

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

ä»¥ä¸Šä»£ç å½“ `counter` é€’å¢åˆ° `10` æ—¶ï¼Œå°±ä¼šé€šè¿‡ `break` è¿”å›ä¸€ä¸ª `counter * 2` çš„å€¼ï¼Œæœ€åèµ‹ç»™ `result` å¹¶æ‰“å°å‡ºæ¥ã€‚

è¿™é‡Œæœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- **break å¯ä»¥å•ç‹¬ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥å¸¦ä¸€ä¸ªè¿”å›å€¼**ï¼Œæœ‰äº›ç±»ä¼¼ `return`
- **loop æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼**ï¼Œå› æ­¤å¯ä»¥è¿”å›ä¸€ä¸ªå€¼

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/flow-control.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/flow-control.md)ã€‚



================================================
FILE: src/basic/formatted-output.md
================================================
# æ ¼å¼åŒ–è¾“å‡º

æåˆ°æ ¼å¼åŒ–è¾“å‡ºï¼Œå¯èƒ½å¾ˆå¤šäººç«‹åˆ»å°±æƒ³åˆ° `"{}"`ï¼Œä½†æ˜¯ Rust èƒ½åšåˆ°çš„è¿œæ¯”è¿™ä¸ªå¤šçš„å¤šï¼Œæœ¬ç« èŠ‚æˆ‘ä»¬å°†æ·±å…¥è®²è§£æ ¼å¼åŒ–è¾“å‡ºçš„å„ä¸ªæ–¹é¢ã€‚

## æ»¡åˆ†åˆå°è±¡

å…ˆæ¥ä¸€æ®µä»£ç ï¼Œçœ‹çœ‹æ ¼å¼åŒ–è¾“å‡ºçš„åˆå°è±¡ï¼š

```rust
println!("Hello");                 // => "Hello"
println!("Hello, {}!", "world");   // => "Hello, world!"
println!("The number is {}", 1);   // => "The number is 1"
println!("{:?}", (3, 4));          // => "(3, 4)"
println!("{value}", value=4);      // => "4"
println!("{} {}", 1, 2);           // => "1 2"
println!("{:04}", 42);             // => "0042" with leading zeros
```

å¯ä»¥çœ‹åˆ° `println!` å®æ¥å—çš„æ˜¯å¯å˜å‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å¸¸é‡ï¼Œå®ƒè¡¨ç¤ºæœ€ç»ˆè¾“å‡ºå­—ç¬¦ä¸²çš„æ ¼å¼ï¼ŒåŒ…å«å…¶ä¸­å½¢å¦‚ `{}` çš„ç¬¦å·æ˜¯**å ä½ç¬¦**ï¼Œä¼šè¢« `println!` åé¢çš„å‚æ•°ä¾æ¬¡æ›¿æ¢ã€‚

## `print!`ï¼Œ`println!`ï¼Œ`format!`

å®ƒä»¬æ˜¯ Rust ä¸­ç”¨æ¥æ ¼å¼åŒ–è¾“å‡ºçš„ä¸‰å¤§é‡‘åˆšï¼Œç”¨é€”å¦‚ä¸‹ï¼š

- `print!` å°†æ ¼å¼åŒ–æ–‡æœ¬è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼Œä¸å¸¦æ¢è¡Œç¬¦
- `println!` åŒä¸Šï¼Œä½†æ˜¯åœ¨è¡Œçš„æœ«å°¾æ·»åŠ æ¢è¡Œç¬¦
- `format!` å°†æ ¼å¼åŒ–æ–‡æœ¬è¾“å‡ºåˆ° `String` å­—ç¬¦ä¸²

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œæœ€å¸¸ç”¨çš„æ˜¯ `println!` åŠ `format!`ï¼Œå‰è€…å¸¸ç”¨æ¥è°ƒè¯•è¾“å‡ºï¼Œåè€…å¸¸ç”¨æ¥ç”Ÿæˆæ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼š

```rust
fn main() {
    let s = "hello";
    println!("{}, world", s);
    let s1 = format!("{}, world", s);
    print!("{}", s1);
    print!("{}\n", "!");
}
```

å…¶ä¸­ï¼Œ`s1` æ˜¯é€šè¿‡ `format!` ç”Ÿæˆçš„ `String` å­—ç¬¦ä¸²ï¼Œæœ€ç»ˆè¾“å‡ºå¦‚ä¸‹ï¼š

```console
hello, world
hello, world!
```

#### `eprint!`ï¼Œ`eprintln!`

é™¤äº†ä¸‰å¤§é‡‘åˆšå¤–ï¼Œè¿˜æœ‰ä¸¤å¤§æŠ¤æ³•ï¼Œä½¿ç”¨æ–¹å¼è·Ÿ `print!`ï¼Œ`println!` å¾ˆåƒï¼Œä½†æ˜¯å®ƒä»¬è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡ºï¼š

```rust
eprintln!("Error: Could not complete task")
```

å®ƒä»¬ä»…åº”è¯¥è¢«ç”¨äºè¾“å‡ºé”™è¯¯ä¿¡æ¯å’Œè¿›åº¦ä¿¡æ¯ï¼Œå…¶å®ƒåœºæ™¯éƒ½åº”è¯¥ä½¿ç”¨ `print!` ç³»åˆ—ã€‚

## `{}` ä¸ `{:?}`

ä¸å…¶å®ƒè¯­è¨€å¸¸ç”¨çš„ `%d`ï¼Œ`%s` ä¸åŒï¼ŒRust ç‰¹ç«‹ç‹¬è¡Œåœ°é€‰æ‹©äº† `{}` ä½œä¸ºæ ¼å¼åŒ–å ä½ç¬¦ï¼ˆè¯´åˆ°è¿™ä¸ªï¼Œæœ‰ç‚¹æƒ³åæ§½ä¸‹ï¼ŒRust ä¸­è‡ªåˆ›çš„æ¦‚å¿µå…¶å®è¿˜æŒºå¤šçš„ï¼ŒçœŸä¸çŸ¥é“è¯¥å¤¸å¥–è¿˜æ˜¯è¯¥åæ§½-,-ï¼‰ï¼Œäº‹å®è¯æ˜ï¼Œè¿™ç§é€‰æ‹©éå¸¸æ­£ç¡®ï¼Œå®ƒå¸®åŠ©ç”¨æˆ·å‡å°‘äº†å¾ˆå¤šä½¿ç”¨æˆæœ¬ï¼Œä½ æ— éœ€å†ä¸ºç‰¹å®šçš„ç±»å‹é€‰æ‹©ç‰¹å®šçš„å ä½ç¬¦ï¼Œç»Ÿä¸€ç”¨ `{}` æ¥æ›¿ä»£å³å¯ï¼Œå‰©ä¸‹çš„ç±»å‹æ¨å¯¼ç­‰ç»†èŠ‚åªè¦äº¤ç»™ Rust å»åšã€‚

ä¸ `{}` ç±»ä¼¼ï¼Œ`{:?}` ä¹Ÿæ˜¯å ä½ç¬¦ï¼š

- `{}` é€‚ç”¨äºå®ç°äº† `std::fmt::Display` ç‰¹å¾çš„ç±»å‹ï¼Œç”¨æ¥ä»¥æ›´ä¼˜é›…ã€æ›´å‹å¥½çš„æ–¹å¼æ ¼å¼åŒ–æ–‡æœ¬ï¼Œä¾‹å¦‚å±•ç¤ºç»™ç”¨æˆ·
- `{:?}` é€‚ç”¨äºå®ç°äº† `std::fmt::Debug` ç‰¹å¾çš„ç±»å‹ï¼Œç”¨äºè°ƒè¯•åœºæ™¯

å…¶å®ä¸¤è€…çš„é€‰æ‹©å¾ˆç®€å•ï¼Œå½“ä½ åœ¨å†™ä»£ç éœ€è¦è°ƒè¯•æ—¶ï¼Œä½¿ç”¨ `{:?}`ï¼Œå‰©ä¸‹çš„åœºæ™¯ï¼Œé€‰æ‹© `{}`ã€‚

#### `Debug` ç‰¹å¾

äº‹å®ä¸Šï¼Œä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬è°ƒè¯•ï¼Œå¤§å¤šæ•° Rust ç±»å‹éƒ½å®ç°äº† `Debug` ç‰¹å¾æˆ–è€…æ”¯æŒæ´¾ç”Ÿè¯¥ç‰¹å¾ï¼š

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

fn main() {
    let i = 3.1415926;
    let s = String::from("hello");
    let v = vec![1, 2, 3];
    let p = Person{name: "sunface".to_string(), age: 18};
    println!("{:?}, {:?}, {:?}, {:?}", i, s, v, p);
}
```

å¯¹äºæ•°å€¼ã€å­—ç¬¦ä¸²ã€æ•°ç»„ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ `{:?}` è¿›è¡Œè¾“å‡ºï¼Œä½†æ˜¯å¯¹äºç»“æ„ä½“ï¼Œéœ€è¦[æ´¾ç”Ÿ`Debug`](https://course.rs/appendix/derive.html)ç‰¹å¾åï¼Œæ‰èƒ½è¿›è¡Œè¾“å‡ºï¼Œæ€»ä¹‹å¾ˆç®€å•ã€‚

#### `Display` ç‰¹å¾

ä¸å¤§éƒ¨åˆ†ç±»å‹å®ç°äº† `Debug` ä¸åŒï¼Œå®ç°äº† `Display` ç‰¹å¾çš„ Rust ç±»å‹å¹¶æ²¡æœ‰é‚£ä¹ˆå¤šï¼Œå¾€å¾€éœ€è¦æˆ‘ä»¬è‡ªå®šä¹‰æƒ³è¦çš„æ ¼å¼åŒ–æ–¹å¼ï¼š

```rust
let i = 3.1415926;
let s = String::from("hello");
let v = vec![1, 2, 3];
let p = Person {
    name: "sunface".to_string(),
    age: 18,
};
println!("{}, {}, {}, {}", i, s, v, p);
```

è¿è¡Œåå¯ä»¥çœ‹åˆ° `v` å’Œ `p` éƒ½æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºæ²¡æœ‰å®ç° `Display` ç‰¹å¾ï¼Œä½†æ˜¯ä½ åˆä¸èƒ½åƒæ´¾ç”Ÿ `Debug` ä¸€èˆ¬æ´¾ç”Ÿ `Display`ï¼Œåªèƒ½å¦å¯»ä»–æ³•ï¼š

- ä½¿ç”¨ `{:?}` æˆ– `{:#?}`
- ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `Display` ç‰¹å¾
- ä½¿ç”¨ `newtype` ä¸ºå¤–éƒ¨ç±»å‹å®ç° `Display` ç‰¹å¾

ä¸‹é¢æ¥ä¸€ä¸€çœ‹çœ‹è¿™ä¸‰ç§æ–¹å¼ã€‚

#### `{:#?}`

`{:#?}` ä¸ `{:?}` å‡ ä¹ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«åœ¨äºå®ƒèƒ½æ›´ä¼˜ç¾åœ°è¾“å‡ºå†…å®¹ï¼š

```console
// {:?}
[1, 2, 3], Person { name: "sunface", age: 18 }

// {:#?}
[
    1,
    2,
    3,
], Person {
    name: "sunface",
}
```

å› æ­¤å¯¹äº `Display` ä¸æ”¯æŒçš„ç±»å‹ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ `{:#?}` è¿›è¡Œæ ¼å¼åŒ–ï¼Œè™½ç„¶ç†è®ºä¸Šå®ƒæ›´é€‚åˆè¿›è¡Œè°ƒè¯•è¾“å‡ºã€‚

#### ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `Display` ç‰¹å¾

å¦‚æœä½ çš„ç±»å‹æ˜¯å®šä¹‰åœ¨å½“å‰ä½œç”¨åŸŸä¸­çš„ï¼Œé‚£ä¹ˆå¯ä»¥ä¸ºå…¶å®ç° `Display` ç‰¹å¾ï¼Œå³å¯ç”¨äºæ ¼å¼åŒ–è¾“å‡ºï¼š

```rust
struct Person {
    name: String,
    age: u8,
}

use std::fmt;
impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "å¤§ä½¬åœ¨ä¸Šï¼Œè¯·å—æˆ‘ä¸€æ‹œï¼Œå°å¼Ÿå§“å{}ï¼Œå¹´èŠ³{}ï¼Œå®¶é‡Œæ— ç”°åˆæ— è½¦ï¼Œç”Ÿæ´»è‹¦å“ˆå“ˆ",
            self.name, self.age
        )
    }
}
fn main() {
    let p = Person {
        name: "sunface".to_string(),
        age: 18,
    };
    println!("{}", p);
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œåªè¦å®ç° `Display` ç‰¹å¾ä¸­çš„ `fmt` æ–¹æ³•ï¼Œå³å¯ä¸ºè‡ªå®šä¹‰ç»“æ„ä½“ `Person` æ·»åŠ è‡ªå®šä¹‰è¾“å‡ºï¼š

```console
å¤§ä½¬åœ¨ä¸Šï¼Œè¯·å—æˆ‘ä¸€æ‹œï¼Œå°å¼Ÿå§“åsunfaceï¼Œå¹´èŠ³18ï¼Œå®¶é‡Œæ— ç”°åˆæ— è½¦ï¼Œç”Ÿæ´»è‹¦å“ˆå“ˆ
```

#### ä¸ºå¤–éƒ¨ç±»å‹å®ç° `Display` ç‰¹å¾

åœ¨ Rust ä¸­ï¼Œæ— æ³•ç›´æ¥ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ç‰¹å¾ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨[`newtype`](https://course.rs/advance/into-types/custom-type.html#newtype)è§£å†³æ­¤é—®é¢˜ï¼š

```rust
struct Array(Vec<i32>);

use std::fmt;
impl fmt::Display for Array {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "æ•°ç»„æ˜¯ï¼š{:?}", self.0)
    }
}
fn main() {
    let arr = Array(vec![1, 2, 3]);
    println!("{}", arr);
}
```

`Array` å°±æ˜¯æˆ‘ä»¬çš„ `newtype`ï¼Œå®ƒå°†æƒ³è¦æ ¼å¼åŒ–è¾“å‡ºçš„ `Vec` åŒ…è£¹åœ¨å†…ï¼Œæœ€ååªè¦ä¸º `Array` å®ç° `Display` ç‰¹å¾ï¼Œå³å¯è¿›è¡Œæ ¼å¼åŒ–è¾“å‡ºï¼š

```console
æ•°ç»„æ˜¯ï¼š[1, 2, 3]
```

è‡³æ­¤ï¼Œå…³äº `{}` ä¸ `{:?}` çš„å†…å®¹å·²ä»‹ç»å®Œæ¯•ï¼Œä¸‹é¢è®©æˆ‘ä»¬æ­£å¼å¼€å§‹æ ¼å¼åŒ–è¾“å‡ºçš„æ—…ç¨‹ã€‚

## ä½ç½®å‚æ•°

é™¤äº†æŒ‰ç…§ä¾æ¬¡é¡ºåºä½¿ç”¨å€¼å»æ›¿æ¢å ä½ç¬¦ä¹‹å¤–ï¼Œè¿˜èƒ½è®©æŒ‡å®šä½ç½®çš„å‚æ•°å»æ›¿æ¢æŸä¸ªå ä½ç¬¦ï¼Œä¾‹å¦‚ `{1}`ï¼Œè¡¨ç¤ºç”¨ç¬¬äºŒä¸ªå‚æ•°æ›¿æ¢è¯¥å ä½ç¬¦ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ï¼š

```rust
fn main() {
    println!("{}{}", 1, 2); // =>"12"
    println!("{1}{0}", 1, 2); // =>"21"
    // => Alice, this is Bob. Bob, this is Alice
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
    println!("{1}{}{0}{}", 1, 2); // => 2112
}
```

## å…·åå‚æ•°

é™¤äº†åƒä¸Šé¢é‚£æ ·æŒ‡å®šä½ç½®å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä¸ºå‚æ•°æŒ‡å®šåç§°ï¼š

```rust
fn main() {
    println!("{argument}", argument = "test"); // => "test"
    println!("{name} {}", 1, name = 2); // => "2 1"
    println!("{a} {c} {b}", a = "a", b = 'b', c = 3); // => "a 3 b"
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼š**å¸¦åç§°çš„å‚æ•°å¿…é¡»æ”¾åœ¨ä¸å¸¦åç§°å‚æ•°çš„åé¢**ï¼Œä¾‹å¦‚ä¸‹é¢ä»£ç å°†æŠ¥é”™ï¼š

```rust
println!("{abc} {1}", abc = "def", 2);
```

```rust
error: positional arguments cannot follow named arguments
 --> src/main.rs:4:36
   |
 4 | println!("{abc} {1}", abc = "def", 2);
   |                             -----  ^ positional arguments must be before named arguments
   |                             |
   |                             named argument
```

## æ ¼å¼åŒ–å‚æ•°

æ ¼å¼åŒ–è¾“å‡ºï¼Œæ„å‘³ç€å¯¹è¾“å‡ºæ ¼å¼ä¼šæœ‰æ›´å¤šçš„è¦æ±‚ï¼Œä¾‹å¦‚åªè¾“å‡ºæµ®ç‚¹æ•°çš„å°æ•°ç‚¹åä¸¤ä½ï¼š

```rust
fn main() {
    let v = 3.1415926;
    // Display => 3.14
    println!("{:.2}", v);
    // Debug => 3.14
    println!("{:.2?}", v);
}
```

ä¸Šé¢ä»£ç åªè¾“å‡ºå°æ•°ç‚¹åä¸¤ä½ã€‚åŒæ—¶æˆ‘ä»¬è¿˜å±•ç¤ºäº† `{}` å’Œ `{:?}` çš„ç”¨æ³•ï¼Œåé¢å¦‚æ— ç‰¹æ®ŠåŒºåˆ«ï¼Œå°±åªé’ˆå¯¹ `{}` æä¾›æ ¼å¼åŒ–å‚æ•°è¯´æ˜ã€‚

æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹ Rust ä¸­æœ‰å“ªäº›æ ¼å¼åŒ–å‚æ•°ã€‚

### å®½åº¦

å®½åº¦ç”¨æ¥æŒ‡ç¤ºè¾“å‡ºç›®æ ‡çš„é•¿åº¦ï¼Œå¦‚æœé•¿åº¦ä¸å¤Ÿï¼Œåˆ™è¿›è¡Œå¡«å……å’Œå¯¹é½ï¼š

#### å­—ç¬¦ä¸²å¡«å……

å­—ç¬¦ä¸²æ ¼å¼åŒ–é»˜è®¤ä½¿ç”¨ç©ºæ ¼è¿›è¡Œå¡«å……ï¼Œå¹¶ä¸”è¿›è¡Œå·¦å¯¹é½ã€‚

```rust
fn main() {
    //-----------------------------------
    // ä»¥ä¸‹å…¨éƒ¨è¾“å‡º "Hello x    !"
    // ä¸º"x"åé¢å¡«å……ç©ºæ ¼ï¼Œè¡¥é½å®½åº¦5
    println!("Hello {:5}!", "x");
    // ä½¿ç”¨å‚æ•°5æ¥æŒ‡å®šå®½åº¦
    println!("Hello {:1$}!", "x", 5);
    // ä½¿ç”¨xä½œä¸ºå ä½ç¬¦è¾“å‡ºå†…å®¹ï¼ŒåŒæ—¶ä½¿ç”¨5ä½œä¸ºå®½åº¦
    println!("Hello {1:0$}!", 5, "x");
    // ä½¿ç”¨æœ‰åç§°çš„å‚æ•°ä½œä¸ºå®½åº¦
    println!("Hello {:width$}!", "x", width = 5);
    //-----------------------------------

    // ä½¿ç”¨å‚æ•°5ä¸ºå‚æ•°xæŒ‡å®šå®½åº¦ï¼ŒåŒæ—¶åœ¨ç»“å°¾è¾“å‡ºå‚æ•°5 => Hello x    !5
    println!("Hello {:1$}!{}", "x", 5);
}
```

#### æ•°å­—å¡«å……:ç¬¦å·å’Œ 0

æ•°å­—æ ¼å¼åŒ–é»˜è®¤ä¹Ÿæ˜¯ä½¿ç”¨ç©ºæ ¼è¿›è¡Œå¡«å……ï¼Œä½†ä¸å­—ç¬¦ä¸²å·¦å¯¹é½ä¸åŒçš„æ˜¯ï¼Œæ•°å­—æ˜¯å³å¯¹é½ã€‚

```rust
fn main() {
    // å®½åº¦æ˜¯5 => Hello     5!
    println!("Hello {:5}!", 5);
    // æ˜¾å¼çš„è¾“å‡ºæ­£å· => Hello +5!
    println!("Hello {:+}!", 5);
    // å®½åº¦5ï¼Œä½¿ç”¨0è¿›è¡Œå¡«å…… => Hello 00005!
    println!("Hello {:05}!", 5);
    // è´Ÿå·ä¹Ÿè¦å ç”¨ä¸€ä½å®½åº¦ => Hello -0005!
    println!("Hello {:05}!", -5);
}
```

### å¯¹é½

```rust
fn main() {
    // ä»¥ä¸‹å…¨éƒ¨éƒ½ä¼šè¡¥é½5ä¸ªå­—ç¬¦çš„é•¿åº¦
    // å·¦å¯¹é½ => Hello x    !
    println!("Hello {:<5}!", "x");
    // å³å¯¹é½ => Hello     x!
    println!("Hello {:>5}!", "x");
    // å±…ä¸­å¯¹é½ => Hello   x  !
    println!("Hello {:^5}!", "x");

    // å¯¹é½å¹¶ä½¿ç”¨æŒ‡å®šç¬¦å·å¡«å…… => Hello x&&&&!
    // æŒ‡å®šç¬¦å·å¡«å……çš„å‰ææ¡ä»¶æ˜¯å¿…é¡»æœ‰å¯¹é½å­—ç¬¦
    println!("Hello {:&<5}!", "x");
}
```

### ç²¾åº¦

ç²¾åº¦å¯ä»¥ç”¨äºæ§åˆ¶æµ®ç‚¹æ•°çš„ç²¾åº¦æˆ–è€…å­—ç¬¦ä¸²çš„é•¿åº¦

```rust
fn main() {
    let v = 3.1415926;
    // ä¿ç•™å°æ•°ç‚¹åä¸¤ä½ => 3.14
    println!("{:.2}", v);
    // å¸¦ç¬¦å·ä¿ç•™å°æ•°ç‚¹åä¸¤ä½ => +3.14
    println!("{:+.2}", v);
    // ä¸å¸¦å°æ•° => 3
    println!("{:.0}", v);
    // é€šè¿‡å‚æ•°æ¥è®¾å®šç²¾åº¦ => 3.1416ï¼Œç›¸å½“äº{:.4}
    println!("{:.1$}", v, 4);

    let s = "hiæˆ‘æ˜¯Sunfaceå­™é£";
    // ä¿ç•™å­—ç¬¦ä¸²å‰ä¸‰ä¸ªå­—ç¬¦ => hiæˆ‘
    println!("{:.3}", s);
    // {:.*}æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯ç²¾åº¦ï¼Œç¬¬äºŒä¸ªæ˜¯è¢«æ ¼å¼åŒ–çš„å€¼ => Hello abc!
    println!("Hello {:.*}!", 3, "abcdefg");
}
```

### è¿›åˆ¶

å¯ä»¥ä½¿ç”¨ `#` å·æ¥æ§åˆ¶æ•°å­—çš„è¿›åˆ¶è¾“å‡ºï¼š

- `#b`, äºŒè¿›åˆ¶
- `#o`, å…«è¿›åˆ¶
- `#x`, å°å†™åå…­è¿›åˆ¶
- `#X`, å¤§å†™åå…­è¿›åˆ¶
- `x`, ä¸å¸¦å‰ç¼€çš„å°å†™åå…­è¿›åˆ¶

```rust
fn main() {
    // äºŒè¿›åˆ¶ => 0b11011!
    println!("{:#b}!", 27);
    // å…«è¿›åˆ¶ => 0o33!
    println!("{:#o}!", 27);
    // åè¿›åˆ¶ => 27!
    println!("{}!", 27);
    // å°å†™åå…­è¿›åˆ¶ => 0x1b!
    println!("{:#x}!", 27);
    // å¤§å†™åå…­è¿›åˆ¶ => 0x1B!
    println!("{:#X}!", 27);

    // ä¸å¸¦å‰ç¼€çš„åå…­è¿›åˆ¶ => 1b!
    println!("{:x}!", 27);

    // ä½¿ç”¨0å¡«å……äºŒè¿›åˆ¶ï¼Œå®½åº¦ä¸º10 => 0b00011011!
    println!("{:#010b}!", 27);
}
```

### æŒ‡æ•°

```rust
fn main() {
    println!("{:2e}", 1000000000); // => 1e9
    println!("{:2E}", 1000000000); // => 1E9
}
```

### æŒ‡é’ˆåœ°å€

```rust
let v= vec![1, 2, 3];
println!("{:p}", v.as_ptr()) // => 0x600002324050
```

### è½¬ä¹‰

æœ‰æ—¶éœ€è¦è¾“å‡º `{`å’Œ`}`ï¼Œä½†è¿™ä¸¤ä¸ªå­—ç¬¦æ˜¯ç‰¹æ®Šå­—ç¬¦ï¼Œéœ€è¦è¿›è¡Œè½¬ä¹‰ï¼š

```rust
fn main() {
    // "{{" è½¬ä¹‰ä¸º '{'   "}}" è½¬ä¹‰ä¸º '}'   "\"" è½¬ä¹‰ä¸º '"'
    // => Hello "{World}" 
    println!(" Hello \"{{World}}\" ");

    // ä¸‹é¢ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸ºå ä½ç¬¦{}åªæœ‰ä¸€ä¸ªå³æ‹¬å·}ï¼Œå·¦æ‹¬å·è¢«è½¬ä¹‰æˆå­—ç¬¦ä¸²çš„å†…å®¹
    // println!(" {{ Hello } ");
    // ä¹Ÿä¸å¯ä½¿ç”¨ '\' æ¥è½¬ä¹‰ "{}"
    // println!(" \{ Hello \} ")
}
```

## åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¶æ•è·ç¯å¢ƒä¸­çš„å€¼ï¼ˆRust 1.58 æ–°å¢ï¼‰

åœ¨ä»¥å‰ï¼Œæƒ³è¦è¾“å‡ºä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œä½ éœ€è¦è¿™ä¹ˆåšï¼š

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let p = get_person();
    println!("Hello, {}!", p);                // implicit position
    println!("Hello, {0}!", p);               // explicit index
    println!("Hello, {person}!", person = p);
}
```

é—®é¢˜å€’ä¹Ÿä¸å¤§ï¼Œä½†æ˜¯ä¸€æ—¦æ ¼å¼åŒ–å­—ç¬¦ä¸²é•¿äº†åï¼Œå°±ä¼šéå¸¸å†—ä½™ï¼Œè€Œåœ¨ 1.58 åï¼Œæˆ‘ä»¬å¯ä»¥è¿™ä¹ˆå†™ï¼š

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    println!("Hello, {person}!");
}
```

æ˜¯ä¸æ˜¯æ¸…æ™°ã€ç®€æ´äº†å¾ˆå¤šï¼Ÿç”šè‡³è¿˜å¯ä»¥å°†ç¯å¢ƒä¸­çš„å€¼ç”¨äºæ ¼å¼åŒ–å‚æ•°:

```rust
let (width, precision) = get_format();
for (name, score) in get_scores() {
  println!("{name}: {score:width$.precision$}");
}
```

ä½†ä¹Ÿæœ‰å±€é™ï¼Œå®ƒåªèƒ½æ•è·æ™®é€šçš„å˜é‡ï¼Œå¯¹äºæ›´å¤æ‚çš„ç±»å‹ï¼ˆä¾‹å¦‚è¡¨è¾¾å¼ï¼‰ï¼Œå¯ä»¥å…ˆå°†å®ƒèµ‹å€¼ç»™ä¸€ä¸ªå˜é‡æˆ–ä½¿ç”¨ä»¥å‰çš„ `name = expression` å½¢å¼çš„æ ¼å¼åŒ–å‚æ•°ã€‚
ç›®å‰é™¤äº† `panic!` å¤–ï¼Œå…¶å®ƒæ¥æ”¶æ ¼å¼åŒ–å‚æ•°çš„å®ï¼Œéƒ½å¯ä»¥ä½¿ç”¨æ–°çš„ç‰¹æ€§ã€‚å¯¹äº `panic!` è€Œè¨€ï¼Œå¦‚æœè¿˜åœ¨ä½¿ç”¨ `2015ç‰ˆæœ¬` æˆ– `2018ç‰ˆæœ¬`ï¼Œé‚£ `panic!("{ident}")` ä¾ç„¶ä¼šè¢«å½“æˆ æ­£å¸¸çš„å­—ç¬¦ä¸²æ¥å¤„ç†ï¼ŒåŒæ—¶ç¼–è¯‘å™¨ä¼šç»™äºˆ `warn` æç¤ºã€‚è€Œå¯¹äº `2021ç‰ˆæœ¬` ï¼Œåˆ™å¯ä»¥æ­£å¸¸ä½¿ç”¨:

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    panic!("Hello, {person}!");
}
```

è¾“å‡º:

```console
thread 'main' panicked at 'Hello, sunface!', src/main.rs:6:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/formatted-output.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„ä¹ é¢˜è§£ç­”ã€‚ï¼ˆæœ¬èŠ‚æš‚æ— ä¹ é¢˜è§£ç­”ï¼‰

## æ€»ç»“

æŠŠè¿™äº›æ ¼å¼åŒ–éƒ½ç‰¢è®°åœ¨è„‘ä¸­æ˜¯ä¸å¤ªç°å®çš„ï¼Œä¹Ÿæ²¡å¿…è¦ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯çŸ¥é“ Rust æ”¯æŒç›¸åº”çš„æ ¼å¼åŒ–è¾“å‡ºï¼Œåœ¨éœ€è¦ä¹‹æ—¶ï¼Œè¯»è€…å†æ¥æŸ¥é˜…æœ¬æ–‡å³å¯ã€‚

è¿˜æ˜¯é‚£å¥è¯ï¼Œ[<<Rust è¯­è¨€åœ£ç»>>](https://github.com/sunface/rust-course)ä¸ä»…ä»…æ˜¯ Rust å­¦ä¹ ä¹¦ç±ï¼Œè¿˜æ˜¯ä¸€æœ¬åšé‡çš„å·¥å…·ä¹¦ï¼

è‡³æ­¤ï¼ŒRust çš„åŸºç¡€å†…å®¹å­¦ä¹ å·²ç»å…¨éƒ¨å®Œæˆï¼Œä¸‹é¢æˆ‘ä»¬å°†å­¦ä¹  Rust çš„é«˜çº§è¿›é˜¶å†…å®¹ï¼Œæ­£å¼å¼€å¯ä½ çš„é«˜æ‰‹ä¹‹è·¯ã€‚



================================================
FILE: src/basic/intro.md
================================================
# Rust åŸºæœ¬æ¦‚å¿µ

ä»ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä»¬æ­£å¼è¸å…¥äº† Rust å¤§é™†ï¼Œè¿™ç‰‡å¹¿è¢¤è€Œç¥ç§˜çš„ä¸–ç•Œï¼Œåœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œå°†æ¥è§¦åˆ°å¾ˆå¤šä¹‹å‰éƒ½æ²¡æœ‰å¬è¿‡çš„æ¦‚å¿µï¼š

- æ‰€æœ‰æƒã€å€Ÿç”¨ã€ç”Ÿå‘½å‘¨æœŸ
- å®ç¼–ç¨‹
- æ¨¡å¼åŒ¹é…

ç±»ä¼¼çš„è¿˜æœ‰å¾ˆå¤šï¼Œä¸è¿‡ä¸ç”¨æ€•ï¼Œå¼•ç”¨æ­¦æ—å¤–ä¼ ä¸€å¥è¯ï¼šå’±ä¸Šé¢æœ‰äººã€‚æœ‰æœ¬ä¹¦åœ¨ï¼Œä¸€åˆ‡è™šå¦„ç»ˆå°†çƒŸæ¶ˆäº‘æ•£ã€‚

æœ¬ç« ä¸»è¦ä»‹ç» Rust çš„åŸºç¡€è¯­æ³•ã€æ•°æ®ç±»å‹ã€é¡¹ç›®ç»“æ„ç­‰ï¼Œå­¦å®Œæœ¬ç« ï¼Œä½ å°†å¯¹ Rust ä»£ç æœ‰ä¸€ä¸ªæ¸…æ™°ã€å®Œæ•´çš„è®¤è¯†ã€‚

å¼€å§‹ä¹‹å‰å…ˆé€šè¿‡ä¸€æ®µä»£ç æ¥ç®€å•æµè§ˆä¸‹ Rust çš„è¯­æ³•ï¼š

```rust
// Rust ç¨‹åºå…¥å£å‡½æ•°ï¼Œè·Ÿå…¶å®ƒè¯­è¨€ä¸€æ ·ï¼Œéƒ½æ˜¯ mainï¼Œè¯¥å‡½æ•°ç›®å‰æ— è¿”å›å€¼
fn main() {
    // ä½¿ç”¨letæ¥å£°æ˜å˜é‡ï¼Œè¿›è¡Œç»‘å®šï¼Œaæ˜¯ä¸å¯å˜çš„
    // æ­¤å¤„æ²¡æœ‰æŒ‡å®šaçš„ç±»å‹ï¼Œç¼–è¯‘å™¨ä¼šé»˜è®¤æ ¹æ®açš„å€¼ä¸ºaæ¨æ–­ç±»å‹ï¼ši32ï¼Œæœ‰ç¬¦å·32ä½æ•´æ•°
    // è¯­å¥çš„æœ«å°¾å¿…é¡»ä»¥åˆ†å·ç»“å°¾
    let a = 10;
    // ä¸»åŠ¨æŒ‡å®šbçš„ç±»å‹ä¸ºi32
    let b: i32 = 20;
    // è¿™é‡Œæœ‰ä¸¤ç‚¹å€¼å¾—æ³¨æ„ï¼š
    // 1. å¯ä»¥åœ¨æ•°å€¼ä¸­å¸¦ä¸Šç±»å‹:30i32è¡¨ç¤ºæ•°å€¼æ˜¯30ï¼Œç±»å‹æ˜¯i32
    // 2. cæ˜¯å¯å˜çš„ï¼Œmutæ˜¯mutableçš„ç¼©å†™
    let mut c = 30i32;
    // è¿˜èƒ½åœ¨æ•°å€¼å’Œç±»å‹ä¸­é—´æ·»åŠ ä¸€ä¸ªä¸‹åˆ’çº¿ï¼Œè®©å¯è¯»æ€§æ›´å¥½
    let d = 30_i32;
    // è·Ÿå…¶å®ƒè¯­è¨€ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼æ¥ä½œä¸ºå¦ä¸€ä¸ªå‡½æ•°çš„å‚æ•°
    let e = add(add(a, b), add(c, d));

    // println!æ˜¯å®è°ƒç”¨ï¼Œçœ‹èµ·æ¥åƒæ˜¯å‡½æ•°ä½†æ˜¯å®ƒè¿”å›çš„æ˜¯å®å®šä¹‰çš„ä»£ç å—
    // è¯¥å‡½æ•°å°†æŒ‡å®šçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºä¸­(æ§åˆ¶å°)
    // {}æ˜¯å ä½ç¬¦ï¼Œåœ¨å…·ä½“æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¼šæŠŠeçš„å€¼ä»£å…¥è¿›æ¥
    println!("( a + b ) + ( c + d ) = {}", e);
}

// å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸¤ä¸ªi32ç±»å‹çš„32ä½æœ‰ç¬¦å·æ•´æ•°ï¼Œè¿”å›å®ƒä»¬çš„å’Œ
fn add(i: i32, j: i32) -> i32 {
    // è¿”å›ç›¸åŠ å€¼ï¼Œè¿™é‡Œå¯ä»¥çœç•¥return
    i + j
}
```

> æ³¨æ„
> åœ¨ä¸Šé¢çš„ `add` å‡½æ•°ä¸­ï¼Œä¸è¦ä¸º `i+j` æ·»åŠ  `;`ï¼Œè¿™ä¼šæ”¹å˜è¯­æ³•å¯¼è‡´å‡½æ•°è¿”å› `()` è€Œä¸æ˜¯ `i32`ï¼Œå…·ä½“å‚è§[è¯­å¥å’Œè¡¨è¾¾å¼](https://course.rs/basic/base-type/statement-expression.html)ã€‚

æœ‰å‡ ç‚¹å¯ä»¥ç•™æ„ä¸‹ï¼š

- å­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å· `""` è€Œä¸æ˜¯å•å¼•å· `''`ï¼ŒRust ä¸­å•å¼•å·æ˜¯ç•™ç»™å•ä¸ªå­—ç¬¦ç±»å‹ï¼ˆ`char`ï¼‰ä½¿ç”¨çš„
- Rust ä½¿ç”¨ `{}` æ¥ä½œä¸ºæ ¼å¼åŒ–è¾“å‡ºå ä½ç¬¦ï¼Œå…¶å®ƒè¯­è¨€å¯èƒ½ä½¿ç”¨çš„æ˜¯ `%s`ï¼Œ`%d`ï¼Œ`%p` ç­‰ï¼Œç”±äº `println!` ä¼šè‡ªåŠ¨æ¨å¯¼å‡ºå…·ä½“çš„ç±»å‹ï¼Œå› æ­¤æ— éœ€æ‰‹åŠ¨æŒ‡å®š



================================================
FILE: src/basic/lifetime.md
================================================
[Binary file]


================================================
FILE: src/basic/method.md
================================================
# æ–¹æ³• Method

ä»é¢å‘å¯¹è±¡è¯­è¨€è¿‡æ¥çš„åŒå­¦å¯¹äºæ–¹æ³•è‚¯å®šä¸é™Œç”Ÿï¼Œ`class` é‡Œé¢å°±å……æ–¥ç€æ–¹æ³•çš„æ¦‚å¿µã€‚åœ¨ Rust ä¸­ï¼Œæ–¹æ³•çš„æ¦‚å¿µä¹Ÿå¤§å·®ä¸å·®ï¼Œå¾€å¾€å’Œå¯¹è±¡æˆå¯¹å‡ºç°ï¼š

```rust
object.method()
```

ä¾‹å¦‚è¯»å–ä¸€ä¸ªæ–‡ä»¶å†™å…¥ç¼“å†²åŒºï¼Œå¦‚æœç”¨å‡½æ•°çš„å†™æ³• `read(f, buffer)`ï¼Œç”¨æ–¹æ³•çš„å†™æ³• `f.read(buffer)`ã€‚ä¸è¿‡ä¸å…¶å®ƒè¯­è¨€ `class` è·Ÿæ–¹æ³•çš„è”åŠ¨ä½¿ç”¨ä¸åŒï¼ˆè¿™é‡Œå¯èƒ½è¦ä¿®æ”¹ä¸‹ï¼‰ï¼ŒRust çš„æ–¹æ³•å¾€å¾€è·Ÿç»“æ„ä½“ã€æšä¸¾ã€ç‰¹å¾(Trait)ä¸€èµ·ä½¿ç”¨ï¼Œç‰¹å¾å°†åœ¨åé¢å‡ ç« è¿›è¡Œä»‹ç»ã€‚

## å®šä¹‰æ–¹æ³•

Rust ä½¿ç”¨ `impl` æ¥å®šä¹‰æ–¹æ³•ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç ï¼š

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // newæ˜¯Circleçš„å…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯selfï¼Œä¸”newå¹¶ä¸æ˜¯å…³é”®å­—
    // è¿™ç§æ–¹æ³•å¾€å¾€ç”¨äºåˆå§‹åŒ–å½“å‰ç»“æ„ä½“çš„å®ä¾‹
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circleçš„æ–¹æ³•ï¼Œ&selfè¡¨ç¤ºå€Ÿç”¨å½“å‰çš„Circleç»“æ„ä½“
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```

æˆ‘ä»¬è¿™é‡Œå…ˆä¸è¯¦ç»†å±•å¼€è®²è§£ï¼Œåªæ˜¯å…ˆå»ºç«‹å¯¹æ–¹æ³•å®šä¹‰çš„å¤§è‡´å°è±¡ã€‚ä¸‹é¢çš„å›¾ç‰‡å°† Rust æ–¹æ³•å®šä¹‰ä¸å…¶å®ƒè¯­è¨€çš„æ–¹æ³•å®šä¹‰åšäº†å¯¹æ¯”ï¼š

<img alt="" src="https://pica.zhimg.com/80/v2-0d848e960f3279999eab4b1317f6538e_1440w.png" class="center"/>

å¯ä»¥çœ‹å‡ºï¼Œå…¶å®ƒè¯­è¨€ä¸­æ‰€æœ‰å®šä¹‰éƒ½åœ¨ `class` ä¸­ï¼Œä½†æ˜¯ Rust çš„å¯¹è±¡å®šä¹‰å’Œæ–¹æ³•å®šä¹‰æ˜¯åˆ†ç¦»çš„ï¼Œè¿™ç§æ•°æ®å’Œä½¿ç”¨åˆ†ç¦»çš„æ–¹å¼ï¼Œä¼šç»™äºˆä½¿ç”¨è€…æé«˜çš„çµæ´»åº¦ã€‚

å†æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

è¯¥ä¾‹å­å®šä¹‰äº†ä¸€ä¸ª `Rectangle` ç»“æ„ä½“ï¼Œå¹¶ä¸”åœ¨å…¶ä¸Šå®šä¹‰äº†ä¸€ä¸ª `area` æ–¹æ³•ï¼Œç”¨äºè®¡ç®—è¯¥çŸ©å½¢çš„é¢ç§¯ã€‚

`impl Rectangle {}` è¡¨ç¤ºä¸º `Rectangle` å®ç°æ–¹æ³•ï¼ˆ`impl` æ˜¯å®ç° _implementation_ çš„ç¼©å†™ï¼‰ï¼Œè¿™æ ·çš„å†™æ³•è¡¨æ˜ `impl` è¯­å¥å—ä¸­çš„ä¸€åˆ‡éƒ½æ˜¯è·Ÿ `Rectangle` ç›¸å…³è”çš„ã€‚

#### selfã€&self å’Œ &mut self

æ¥ä¸‹æ¥çš„å†…å®¹éå¸¸é‡è¦ï¼Œè¯·å¤§å®¶ä»”ç»†çœ‹ã€‚åœ¨ `area` çš„ç­¾åä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `&self` æ›¿ä»£ `rectangle: &Rectangle`ï¼Œ`&self` å…¶å®æ˜¯ `self: &Self` çš„ç®€å†™ï¼ˆæ³¨æ„å¤§å°å†™ï¼‰ã€‚åœ¨ä¸€ä¸ª `impl` å—å†…ï¼Œ`Self` æŒ‡ä»£è¢«å®ç°æ–¹æ³•çš„ç»“æ„ä½“ç±»å‹ï¼Œ`self` æŒ‡ä»£æ­¤ç±»å‹çš„å®ä¾‹ï¼Œæ¢å¥è¯è¯´ï¼Œ`self` æŒ‡ä»£çš„æ˜¯ `Rectangle` ç»“æ„ä½“å®ä¾‹ï¼Œè¿™æ ·çš„å†™æ³•ä¼šè®©æˆ‘ä»¬çš„ä»£ç ç®€æ´å¾ˆå¤šï¼Œè€Œä¸”éå¸¸ä¾¿äºç†è§£ï¼šæˆ‘ä»¬ä¸ºå“ªä¸ªç»“æ„ä½“å®ç°æ–¹æ³•ï¼Œé‚£ä¹ˆ `self` å°±æ˜¯æŒ‡ä»£å“ªä¸ªç»“æ„ä½“çš„å®ä¾‹ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`self` ä¾ç„¶æœ‰æ‰€æœ‰æƒçš„æ¦‚å¿µï¼š

- `self` è¡¨ç¤º `Rectangle` çš„æ‰€æœ‰æƒè½¬ç§»åˆ°è¯¥æ–¹æ³•ä¸­ï¼Œè¿™ç§å½¢å¼ç”¨çš„è¾ƒå°‘
- `&self` è¡¨ç¤ºè¯¥æ–¹æ³•å¯¹ `Rectangle` çš„ä¸å¯å˜å€Ÿç”¨
- `&mut self` è¡¨ç¤ºå¯å˜å€Ÿç”¨

æ€»ä¹‹ï¼Œ`self` çš„ä½¿ç”¨å°±è·Ÿå‡½æ•°å‚æ•°ä¸€æ ·ï¼Œè¦ä¸¥æ ¼éµå®ˆ Rust çš„æ‰€æœ‰æƒè§„åˆ™ã€‚

å›åˆ°ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œé€‰æ‹© `&self` çš„ç†ç”±è·Ÿåœ¨å‡½æ•°ä¸­ä½¿ç”¨ `&Rectangle` æ˜¯ç›¸åŒçš„ï¼šæˆ‘ä»¬å¹¶ä¸æƒ³è·å–æ‰€æœ‰æƒï¼Œä¹Ÿæ— éœ€å»æ”¹å˜å®ƒï¼Œåªæ˜¯å¸Œæœ›èƒ½å¤Ÿè¯»å–ç»“æ„ä½“ä¸­çš„æ•°æ®ã€‚å¦‚æœæƒ³è¦åœ¨æ–¹æ³•ä¸­å»æ”¹å˜å½“å‰çš„ç»“æ„ä½“ï¼Œéœ€è¦å°†ç¬¬ä¸€ä¸ªå‚æ•°æ”¹ä¸º `&mut self`ã€‚ä»…ä»…é€šè¿‡ä½¿ç”¨ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ¥ä½¿æ–¹æ³•è·å–å®ä¾‹çš„æ‰€æœ‰æƒæ˜¯å¾ˆå°‘è§çš„ï¼Œè¿™ç§ä½¿ç”¨æ–¹å¼å¾€å¾€ç”¨äºæŠŠå½“å‰çš„å¯¹è±¡è½¬æˆå¦å¤–ä¸€ä¸ªå¯¹è±¡æ—¶ä½¿ç”¨ï¼Œè½¬æ¢å®Œåï¼Œå°±ä¸å†å…³æ³¨ä¹‹å‰çš„å¯¹è±¡ï¼Œä¸”å¯ä»¥é˜²æ­¢å¯¹ä¹‹å‰å¯¹è±¡çš„è¯¯è°ƒç”¨ã€‚

ç®€å•æ€»ç»“ä¸‹ï¼Œä½¿ç”¨æ–¹æ³•ä»£æ›¿å‡½æ•°æœ‰ä»¥ä¸‹å¥½å¤„ï¼š

- ä¸ç”¨åœ¨å‡½æ•°ç­¾åä¸­é‡å¤ä¹¦å†™ `self` å¯¹åº”çš„ç±»å‹
- ä»£ç çš„ç»„ç»‡æ€§å’Œå†…èšæ€§æ›´å¼ºï¼Œå¯¹äºä»£ç ç»´æŠ¤å’Œé˜…è¯»æ¥è¯´ï¼Œå¥½å¤„å·¨å¤§

#### æ–¹æ³•åè·Ÿç»“æ„ä½“å­—æ®µåç›¸åŒ

åœ¨ Rust ä¸­ï¼Œå…è®¸æ–¹æ³•åè·Ÿç»“æ„ä½“çš„å­—æ®µåç›¸åŒï¼š

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

å½“æˆ‘ä»¬ä½¿ç”¨ `rect1.width()` æ—¶ï¼ŒRust çŸ¥é“æˆ‘ä»¬è°ƒç”¨çš„æ˜¯å®ƒçš„æ–¹æ³•ï¼Œå¦‚æœä½¿ç”¨ `rect1.width`ï¼Œåˆ™æ˜¯è®¿é—®å®ƒçš„å­—æ®µã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œæ–¹æ³•è·Ÿå­—æ®µåŒåï¼Œå¾€å¾€é€‚ç”¨äºå®ç° `getter` è®¿é—®å™¨ï¼Œä¾‹å¦‚:

```rust
mod my {
    pub struct Rectangle {
        width: u32,
        pub height: u32,
    }

    impl Rectangle {
        pub fn new(width: u32, height: u32) -> Self {
            Rectangle { width, height }
        }
        pub fn width(&self) -> u32 {
            return self.width;
        }
        pub fn height(&self) -> u32 {
            return self.height;
        }
    }
}

fn main() {
    let rect1 = my::Rectangle::new(30, 50);

    println!("{}", rect1.width()); // OK
    println!("{}", rect1.height()); // OK
    // println!("{}", rect1.width); // Error - the visibility of field defaults to private
    println!("{}", rect1.height); // OK
}
```

å½“ä»æ¨¡å—å¤–éƒ¨è®¿é—®ç»“æ„ä½“æ—¶ï¼Œç»“æ„ä½“çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œå…¶ç›®çš„æ˜¯éšè—ä¿¡æ¯ï¼ˆå°è£…ï¼‰ã€‚æˆ‘ä»¬å¦‚æœæƒ³è¦ä»æ¨¡å—å¤–éƒ¨è·å– `Rectangle` çš„å­—æ®µï¼Œåªéœ€æŠŠå®ƒçš„ `new`ï¼Œ `width` å’Œ `height` æ–¹æ³•è®¾ç½®ä¸ºå…¬å¼€å¯è§ï¼Œé‚£ä¹ˆç”¨æˆ·å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªçŸ©å½¢ï¼ŒåŒæ—¶é€šè¿‡è®¿é—®å™¨ `rect1.width()` å’Œ `rect1.height()` æ–¹æ³•æ¥è·å–çŸ©å½¢çš„å®½åº¦å’Œé«˜åº¦ã€‚

å› ä¸º `width` å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œå½“ç”¨æˆ·è®¿é—® `rect1.width` å­—æ®µæ—¶ï¼Œå°±ä¼šæŠ¥é”™ã€‚æ³¨æ„åœ¨æ­¤ä¾‹ä¸­ï¼Œ`Self` æŒ‡ä»£çš„å°±æ˜¯è¢«å®ç°æ–¹æ³•çš„ç»“æ„ä½“ `Rectangle`ã€‚

ç‰¹åˆ«çš„æ˜¯ï¼Œè¿™ç§é»˜è®¤çš„å¯è§æ€§ï¼ˆç§æœ‰çš„ï¼‰å¯ä»¥é€šè¿‡ `pub` è¿›è¡Œè¦†ç›–ï¼Œè¿™æ ·å¯¹äºæ¨¡å—å¤–éƒ¨æ¥è¯´ï¼Œå°±å¯ä»¥ç›´æ¥è®¿é—®ä½¿ç”¨ `pub` ä¿®é¥°çš„å­—æ®µè€Œæ— éœ€é€šè¿‡è®¿é—®å™¨ã€‚è¿™ç§å¯è§æ€§ä»…å½“ä»å®šä¹‰ç»“æ„çš„æ¨¡å—å¤–éƒ¨è®¿é—®æ—¶æ‰é‡è¦ï¼Œå¹¶ä¸”å…·æœ‰éšè—ä¿¡æ¯ï¼ˆå°è£…ï¼‰çš„ç›®çš„ã€‚

> ### `->` è¿ç®—ç¬¦åˆ°å“ªå»äº†ï¼Ÿ
>
> åœ¨ C/C++ è¯­è¨€ä¸­ï¼Œæœ‰ä¸¤ä¸ªä¸åŒçš„è¿ç®—ç¬¦æ¥è°ƒç”¨æ–¹æ³•ï¼š`.` ç›´æ¥åœ¨å¯¹è±¡ä¸Šè°ƒç”¨æ–¹æ³•ï¼Œè€Œ `->` åœ¨ä¸€ä¸ªå¯¹è±¡çš„æŒ‡é’ˆä¸Šè°ƒç”¨æ–¹æ³•ï¼Œè¿™æ—¶éœ€è¦å…ˆè§£å¼•ç”¨æŒ‡é’ˆã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœ `object` æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œé‚£ä¹ˆ `object->something()` å’Œ `(*object).something()` æ˜¯ä¸€æ ·çš„ã€‚
>
> Rust å¹¶æ²¡æœ‰ä¸€ä¸ªä¸ `->` ç­‰æ•ˆçš„è¿ç®—ç¬¦ï¼›ç›¸åï¼ŒRust æœ‰ä¸€ä¸ªå« **è‡ªåŠ¨å¼•ç”¨å’Œè§£å¼•ç”¨**çš„åŠŸèƒ½ã€‚æ–¹æ³•è°ƒç”¨æ˜¯ Rust ä¸­å°‘æ•°å‡ ä¸ªæ‹¥æœ‰è¿™ç§è¡Œä¸ºçš„åœ°æ–¹ã€‚
>
> ä»–æ˜¯è¿™æ ·å·¥ä½œçš„ï¼šå½“ä½¿ç”¨ `object.something()` è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒRust ä¼šè‡ªåŠ¨ä¸º `object` æ·»åŠ  `&`ï¼ˆè§†å¯è§æ€§æ·»åŠ `&mut`)ã€ `*` ä»¥ä¾¿ä½¿ `object` ä¸æ–¹æ³•ç­¾ååŒ¹é…ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™äº›ä»£ç æ˜¯ç­‰ä»·çš„ï¼š
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> ç¬¬ä¸€è¡Œçœ‹èµ·æ¥ç®€æ´çš„å¤šã€‚è¿™ç§è‡ªåŠ¨å¼•ç”¨çš„è¡Œä¸ºä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºæ–¹æ³•æœ‰ä¸€ä¸ªæ˜ç¡®çš„æ¥æ”¶è€…â€”â€”â€”â€” `self` çš„ç±»å‹ã€‚åœ¨ç»™å‡ºæ¥æ”¶è€…å’Œæ–¹æ³•åçš„å‰æä¸‹ï¼ŒRust å¯ä»¥æ˜ç¡®åœ°è®¡ç®—å‡ºæ–¹æ³•æ˜¯ä»…ä»…è¯»å–ï¼ˆ`&self`ï¼‰ï¼Œåšå‡ºä¿®æ”¹ï¼ˆ`&mut self`ï¼‰æˆ–è€…æ˜¯è·å–æ‰€æœ‰æƒï¼ˆ`self`ï¼‰ã€‚äº‹å®ä¸Šï¼ŒRust å¯¹æ–¹æ³•æ¥æ”¶è€…çš„éšå¼å€Ÿç”¨è®©æ‰€æœ‰æƒåœ¨å®è·µä¸­æ›´å‹å¥½ã€‚

## å¸¦æœ‰å¤šä¸ªå‚æ•°çš„æ–¹æ³•

æ–¹æ³•å’Œå‡½æ•°ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªå‚æ•°ï¼š

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

## å…³è”å‡½æ•°

ç°åœ¨å¤§å®¶å¯ä»¥æ€è€ƒä¸€ä¸ªé—®é¢˜ï¼Œå¦‚ä½•ä¸ºä¸€ä¸ªç»“æ„ä½“å®šä¹‰ä¸€ä¸ªæ„é€ å™¨æ–¹æ³•ï¼Ÿä¹Ÿå°±æ˜¯æ¥å—å‡ ä¸ªå‚æ•°ï¼Œç„¶åæ„é€ å¹¶è¿”å›è¯¥ç»“æ„ä½“çš„å®ä¾‹ã€‚å…¶å®ç­”æ¡ˆåœ¨å¼€å¤´çš„ä»£ç ç‰‡æ®µä¸­å°±ç»™å‡ºäº†ï¼Œå¾ˆç®€å•ï¼Œå‚æ•°ä¸­ä¸åŒ…å« `self` å³å¯ã€‚

è¿™ç§å®šä¹‰åœ¨ `impl` ä¸­ä¸”æ²¡æœ‰ `self` çš„å‡½æ•°è¢«ç§°ä¹‹ä¸º**å…³è”å‡½æ•°**ï¼š å› ä¸ºå®ƒæ²¡æœ‰ `self`ï¼Œä¸èƒ½ç”¨ `f.read()` çš„å½¢å¼è°ƒç”¨ï¼Œå› æ­¤å®ƒæ˜¯ä¸€ä¸ªå‡½æ•°è€Œä¸æ˜¯æ–¹æ³•ï¼Œå®ƒåˆåœ¨ `impl` ä¸­ï¼Œä¸ç»“æ„ä½“ç´§å¯†å…³è”ï¼Œå› æ­¤ç§°ä¸ºå…³è”å‡½æ•°ã€‚

åœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬å·²ç»å¤šæ¬¡ä½¿ç”¨è¿‡å…³è”å‡½æ•°ï¼Œä¾‹å¦‚ `String::from`ï¼Œç”¨äºåˆ›å»ºä¸€ä¸ªåŠ¨æ€å­—ç¬¦ä¸²ã€‚

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn new(w: u32, h: u32) -> Rectangle {
        Rectangle { width: w, height: h }
    }
}
```

> Rust ä¸­æœ‰ä¸€ä¸ªçº¦å®šä¿—æˆçš„è§„åˆ™ï¼Œä½¿ç”¨ `new` æ¥ä½œä¸ºæ„é€ å™¨çš„åç§°ï¼Œå‡ºäºè®¾è®¡ä¸Šçš„è€ƒè™‘ï¼ŒRust ç‰¹åœ°æ²¡æœ‰ç”¨ `new` ä½œä¸ºå…³é”®å­—ã€‚

å› ä¸ºæ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨ `.` çš„æ–¹å¼æ¥è°ƒç”¨ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ `::` æ¥è°ƒç”¨ï¼Œä¾‹å¦‚ `let sq = Rectangle::new(3, 3);`ã€‚è¿™ä¸ªæ–¹æ³•ä½äºç»“æ„ä½“çš„å‘½åç©ºé—´ä¸­ï¼š`::` è¯­æ³•ç”¨äºå…³è”å‡½æ•°å’Œæ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´ã€‚

## å¤šä¸ª impl å®šä¹‰

Rust å…è®¸æˆ‘ä»¬ä¸ºä¸€ä¸ªç»“æ„ä½“å®šä¹‰å¤šä¸ª `impl` å—ï¼Œç›®çš„æ˜¯æä¾›æ›´å¤šçš„çµæ´»æ€§å’Œä»£ç ç»„ç»‡æ€§ï¼Œä¾‹å¦‚å½“æ–¹æ³•å¤šäº†åï¼Œå¯ä»¥æŠŠç›¸å…³çš„æ–¹æ³•ç»„ç»‡åœ¨åŒä¸€ä¸ª `impl` å—ä¸­ï¼Œé‚£ä¹ˆå°±å¯ä»¥å½¢æˆå¤šä¸ª `impl` å—ï¼Œå„è‡ªå®Œæˆä¸€å—å„¿ç›®æ ‡ï¼š

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

å½“ç„¶ï¼Œå°±è¿™ä¸ªä¾‹å­è€Œè¨€ï¼Œæˆ‘ä»¬æ²¡å¿…è¦ä½¿ç”¨ä¸¤ä¸ª `impl` å—ï¼Œè¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤ºæ–¹ä¾¿ã€‚

## ä¸ºæšä¸¾å®ç°æ–¹æ³•

æšä¸¾ç±»å‹ä¹‹æ‰€ä»¥å¼ºå¤§ï¼Œä¸ä»…ä»…åœ¨äºå®ƒå¥½ç”¨ã€å¯ä»¥[åŒä¸€åŒ–ç±»å‹](https://course.rs/basic/compound-type/enum.html#åŒä¸€åŒ–ç±»å‹)ï¼Œè¿˜åœ¨äºï¼Œæˆ‘ä»¬å¯ä»¥åƒç»“æ„ä½“ä¸€æ ·ï¼Œä¸ºæšä¸¾å®ç°æ–¹æ³•ï¼š

```rust
#![allow(unused)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // åœ¨è¿™é‡Œå®šä¹‰æ–¹æ³•ä½“
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

é™¤äº†ç»“æ„ä½“å’Œæšä¸¾ï¼Œæˆ‘ä»¬è¿˜èƒ½ä¸ºç‰¹å¾(trait)å®ç°æ–¹æ³•ï¼Œè¿™å°†åœ¨ä¸‹ä¸€ç« è¿›è¡Œè®²è§£ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹æ³›å‹ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/method.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/method.md)ã€‚



================================================
FILE: src/basic/variable.md
================================================
# å˜é‡ç»‘å®šä¸è§£æ„

é‰´äºæœ¬ä¹¦çš„ç›®æ ‡è¯»è€…ï¼ˆåˆ«æ…Œï¼Œæ¥åˆ°è¿™é‡Œå°±è¯´æ˜ä½ å°±æ˜¯ç›®æ ‡è¯»è€…ï¼‰å·²ç»ç†Ÿç»ƒæŒæ¡å…¶å®ƒä»»æ„ä¸€é—¨ç¼–ç¨‹è¯­è¨€ï¼Œå› æ­¤è¿™é‡Œå°±ä¸å†å¯¹ä½•ä¸ºå˜é‡è¿›è¡Œèµ˜è¿°ï¼Œè®©æˆ‘ä»¬å¼€é—¨è§å±±æ¥è°ˆè°ˆï¼Œä¸ºä½• Rust é€‰æ‹©äº†æ‰‹åŠ¨è®¾å®šå˜é‡çš„å¯å˜æ€§ã€‚

## ä¸ºä½•è¦æ‰‹åŠ¨è®¾ç½®å˜é‡çš„å¯å˜æ€§ï¼Ÿ

åœ¨å…¶å®ƒå¤§å¤šæ•°è¯­è¨€ä¸­ï¼Œè¦ä¹ˆåªæ”¯æŒå£°æ˜å¯å˜çš„å˜é‡ï¼Œè¦ä¹ˆåªæ”¯æŒå£°æ˜ä¸å¯å˜çš„å˜é‡ï¼ˆä¾‹å¦‚å‡½æ•°å¼è¯­è¨€ï¼‰ï¼Œå‰è€…ä¸ºç¼–ç¨‹æä¾›äº†çµæ´»æ€§ï¼Œåè€…ä¸ºç¼–ç¨‹æä¾›äº†å®‰å…¨æ€§ï¼Œè€Œ Rust æ¯”è¾ƒé‡ï¼Œé€‰æ‹©äº†ä¸¤è€…æˆ‘éƒ½è¦ï¼Œæ—¢è¦çµæ´»æ€§åˆè¦å®‰å…¨æ€§ã€‚

èƒ½æƒ³è¦å­¦ä¹  Rustï¼Œè¯´æ˜æˆ‘ä»¬çš„è¯»è€…éƒ½æ˜¯ç›¸å½“æœ‰æ°´å¹³çš„ç¨‹åºå‘˜äº†ï¼Œä½ ä»¬åº”è¯¥èƒ½ç†è§£**ä¸€åˆ‡é€‰æ‹©çš†æ˜¯æƒè¡¡**ï¼Œé‚£ä¹ˆä¸¤è€…éƒ½è¦çš„æƒè¡¡æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿè¿™å°±æ˜¯ Rust å¼€å‘å›¢é˜Ÿä¸ºæˆ‘ä»¬åšå‡ºçš„è´¡çŒ®ï¼Œä¸¤è€…éƒ½è¦æ„å‘³ç€ Rust è¯­è¨€åº•å±‚ä»£ç çš„å®ç°å¤æ‚åº¦å¤§å¹…æå‡ï¼Œå› æ­¤ Salute to The Rust Team!

é™¤äº†ä»¥ä¸Šä¸¤ä¸ªä¼˜ç‚¹ï¼Œè¿˜æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¼˜ç‚¹ï¼Œé‚£å°±æ˜¯è¿è¡Œæ€§èƒ½ä¸Šçš„æå‡ï¼Œå› ä¸ºå°†æœ¬èº«æ— éœ€æ”¹å˜çš„å˜é‡å£°æ˜ä¸ºä¸å¯å˜åœ¨è¿è¡ŒæœŸä¼šé¿å…ä¸€äº›å¤šä½™çš„ `runtime` æ£€æŸ¥ã€‚

## å˜é‡å‘½å

åœ¨å‘½åæ–¹é¢ï¼Œå’Œå…¶å®ƒè¯­è¨€æ²¡æœ‰åŒºåˆ«ï¼Œä¸è¿‡å½“ç»™å˜é‡å‘½åæ—¶ï¼Œéœ€è¦éµå¾ª [Rust å‘½åè§„èŒƒ](https://course.rs/practice/naming.html)ã€‚

> Rust è¯­è¨€æœ‰ä¸€äº›**å…³é”®å­—**ï¼ˆ_keywords_ï¼‰ï¼Œå’Œå…¶ä»–è¯­è¨€ä¸€æ ·ï¼Œè¿™äº›å…³é”®å­—éƒ½æ˜¯è¢«ä¿ç•™ç»™ Rust è¯­è¨€ä½¿ç”¨çš„ï¼Œå› æ­¤ï¼Œå®ƒä»¬ä¸èƒ½è¢«ç”¨ä½œå˜é‡æˆ–å‡½æ•°çš„åç§°ã€‚åœ¨ [é™„å½• A](https://course.rs/appendix/keywords.html) ä¸­å¯æ‰¾åˆ°å…³é”®å­—åˆ—è¡¨ã€‚

## å˜é‡ç»‘å®š

åœ¨å…¶å®ƒè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ç”¨ `var a = "hello world"` çš„æ–¹å¼ç»™ `a` èµ‹å€¼ï¼Œä¹Ÿå°±æ˜¯æŠŠç­‰å¼å³è¾¹çš„ `"hello world"` å­—ç¬¦ä¸²èµ‹å€¼ç»™å˜é‡ `a` ï¼Œè€Œåœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬è¿™æ ·å†™ï¼š `let a = "hello world"` ï¼ŒåŒæ—¶ç»™è¿™ä¸ªè¿‡ç¨‹èµ·äº†å¦ä¸€ä¸ªåå­—ï¼š**å˜é‡ç»‘å®š**ã€‚

ä¸ºä½•ä¸ç”¨èµ‹å€¼è€Œç”¨ç»‘å®šå‘¢ï¼ˆå…¶å®ä½ ä¹Ÿå¯ä»¥ç§°ä¹‹ä¸ºèµ‹å€¼ï¼Œä½†æ˜¯ç»‘å®šçš„å«ä¹‰æ›´æ¸…æ™°å‡†ç¡®ï¼‰ï¼Ÿè¿™é‡Œå°±æ¶‰åŠ Rust æœ€æ ¸å¿ƒçš„åŸåˆ™â€”â€”**æ‰€æœ‰æƒ**ï¼Œç®€å•æ¥è®²ï¼Œä»»ä½•å†…å­˜å¯¹è±¡éƒ½æ˜¯æœ‰ä¸»äººçš„ï¼Œè€Œä¸”ä¸€èˆ¬æƒ…å†µä¸‹å®Œå…¨å±äºå®ƒçš„ä¸»äººï¼Œç»‘å®šå°±æ˜¯æŠŠè¿™ä¸ªå¯¹è±¡ç»‘å®šç»™ä¸€ä¸ªå˜é‡ï¼Œè®©è¿™ä¸ªå˜é‡æˆä¸ºå®ƒçš„ä¸»äººï¼ˆèªæ˜çš„è¯»è€…åº”è¯¥èƒ½çŒœåˆ°ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯¥å¯¹è±¡ä¹‹å‰çš„ä¸»äººå°±ä¼šä¸§å¤±å¯¹è¯¥å¯¹è±¡çš„æ‰€æœ‰æƒï¼‰ï¼Œåƒæäº†æˆ‘ä»¬çš„ç°å®ä¸–ç•Œï¼Œä¸æ˜¯å—ï¼Ÿ

é‚£ä¸ºä»€ä¹ˆè¦å¼•è¿›â€œæ‰€æœ‰æƒâ€è¿™ä¸ªæ–°çš„æ¦‚å¿µå‘¢ï¼Ÿè¯·ç¨å®‰å‹¿èºï¼Œæ—¶æœºä¸€æ—¦æˆç†Ÿï¼Œæˆ‘ä»¬å°±å›æ¥ç»§ç»­è®¨è®ºè¿™ä¸ªè¯é¢˜ã€‚

## å˜é‡å¯å˜æ€§

Rust çš„å˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯**ä¸å¯å˜çš„**ã€‚å‰æ–‡æåˆ°ï¼Œè¿™æ˜¯ Rust å›¢é˜Ÿä¸ºæˆ‘ä»¬ç²¾å¿ƒè®¾è®¡çš„è¯­è¨€ç‰¹æ€§ä¹‹ä¸€ï¼Œè®©æˆ‘ä»¬ç¼–å†™çš„ä»£ç æ›´å®‰å…¨ï¼Œæ€§èƒ½ä¹Ÿæ›´å¥½ã€‚å½“ç„¶ä½ å¯ä»¥é€šè¿‡ `mut` å…³é”®å­—è®©å˜é‡å˜ä¸º**å¯å˜çš„**ï¼Œè®©è®¾è®¡æ›´çµæ´»ã€‚

å¦‚æœå˜é‡ `a` ä¸å¯å˜ï¼Œé‚£ä¹ˆä¸€æ—¦ä¸ºå®ƒç»‘å®šå€¼ï¼Œå°±ä¸èƒ½å†ä¿®æ”¹ `a`ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨æˆ‘ä»¬çš„å·¥ç¨‹ç›®å½•ä¸‹ä½¿ç”¨ `cargo new variables` æ–°å»ºä¸€ä¸ªé¡¹ç›®ï¼Œå«åš _variables_ ã€‚

ç„¶ååœ¨æ–°å»ºçš„ _variables_ ç›®å½•ä¸‹ï¼Œç¼–è¾‘ _src/main.rs_ ï¼Œæ”¹ä¸ºä¸‹é¢ä»£ç ï¼š

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

ä¿å­˜æ–‡ä»¶ï¼Œå†ä½¿ç”¨ `cargo run` è¿è¡Œå®ƒï¼Œè¿é¢è€Œæ¥çš„æ˜¯ä¸€æ¡é”™è¯¯æç¤ºï¼š

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
```

å…·ä½“çš„é”™è¯¯åŸå› æ˜¯ `cannot assign twice to immutable variable x`ï¼ˆæ— æ³•å¯¹ä¸å¯å˜çš„å˜é‡è¿›è¡Œé‡å¤èµ‹å€¼ï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ä¸ºä¸å¯å˜çš„ `x` å˜é‡å†æ¬¡èµ‹å€¼ã€‚

è¿™ç§é”™è¯¯æ˜¯ä¸ºäº†é¿å…æ— æ³•é¢„æœŸçš„é”™è¯¯å‘ç”Ÿåœ¨æˆ‘ä»¬çš„å˜é‡ä¸Šï¼šä¸€ä¸ªå˜é‡å¾€å¾€è¢«å¤šå¤„ä»£ç æ‰€ä½¿ç”¨ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†ä»£ç å‡å®šè¯¥å˜é‡çš„å€¼æ°¸è¿œä¸ä¼šæ”¹å˜ï¼Œè€Œå¦å¤–ä¸€éƒ¨åˆ†ä»£ç å´æ— æƒ…çš„æ”¹å˜äº†è¿™ä¸ªå€¼ï¼Œåœ¨å®é™…å¼€å‘è¿‡ç¨‹ä¸­ï¼Œè¿™ä¸ªé”™è¯¯æ˜¯å¾ˆéš¾è¢«å‘ç°çš„ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ã€‚

è¿™ç§è§„åˆ™è®©æˆ‘ä»¬çš„ä»£ç å˜å¾—éå¸¸æ¸…æ™°ï¼Œåªæœ‰ä½ æƒ³è®©ä½ çš„å˜é‡æ”¹å˜æ—¶ï¼Œå®ƒæ‰èƒ½æ”¹å˜ï¼Œè¿™æ ·å°±ä¸ä¼šé€ æˆå¿ƒæ™ºä¸Šçš„è´Ÿæ‹…ï¼Œä¹Ÿç»™åˆ«äººé˜…è¯»ä»£ç å¸¦æ¥ä¾¿åˆ©ã€‚

ä½†æ˜¯å¯å˜æ€§ä¹Ÿéå¸¸é‡è¦ï¼Œå¦åˆ™æˆ‘ä»¬å°±è¦åƒ ClojureScript é‚£æ ·ï¼Œæ¯æ¬¡è¦æ”¹å˜ï¼Œå°±è¦é‡æ–°ç”Ÿæˆä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨æ‹¥æœ‰å¤§é‡å¯¹è±¡çš„åœºæ™¯ï¼Œæ€§èƒ½ä¼šå˜å¾—éå¸¸ä½ä¸‹ï¼Œå†…å­˜æ‹·è´çš„æˆæœ¬å¼‚å¸¸çš„é«˜ã€‚

åœ¨ Rust ä¸­ï¼Œå¯å˜æ€§å¾ˆç®€å•ï¼Œåªè¦åœ¨å˜é‡åå‰åŠ ä¸€ä¸ª `mut` å³å¯, è€Œä¸”è¿™ç§æ˜¾å¼çš„å£°æ˜æ–¹å¼è¿˜ä¼šç»™åæ¥äººä¼ è¾¾è¿™æ ·çš„ä¿¡æ¯ï¼šå—¯ï¼Œè¿™ä¸ªå˜é‡åœ¨åé¢ä»£ç éƒ¨åˆ†ä¼šå‘ç”Ÿæ”¹å˜ã€‚

ä¸ºäº†è®©å˜é‡å£°æ˜ä¸ºå¯å˜,å°† _src/main.rs_ æ”¹ä¸ºä»¥ä¸‹å†…å®¹ï¼š

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

è¿è¡Œç¨‹åºå°†å¾—åˆ°ä¸‹é¢ç»“æœï¼š

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

é€‰æ‹©å¯å˜è¿˜æ˜¯ä¸å¯å˜ï¼Œæ›´å¤šçš„è¿˜æ˜¯å–å†³äºä½ çš„ä½¿ç”¨åœºæ™¯ï¼Œä¾‹å¦‚ä¸å¯å˜å¯ä»¥å¸¦æ¥å®‰å…¨æ€§ï¼Œä½†æ˜¯ä¸§å¤±äº†çµæ´»æ€§å’Œæ€§èƒ½ï¼ˆå¦‚æœä½ è¦æ”¹å˜ï¼Œå°±è¦é‡æ–°åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œè¿™é‡Œæ¶‰åŠåˆ°å†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼‰ã€‚è€Œå¯å˜å˜é‡æœ€å¤§çš„å¥½å¤„å°±æ˜¯ä½¿ç”¨ä¸Šçš„çµæ´»æ€§å’Œæ€§èƒ½ä¸Šçš„æå‡ã€‚

ä¾‹å¦‚ï¼Œåœ¨ä½¿ç”¨å¤§å‹æ•°æ®ç»“æ„æˆ–è€…çƒ­ç‚¹ä»£ç è·¯å¾„ï¼ˆè¢«å¤§é‡é¢‘ç¹è°ƒç”¨ï¼‰çš„æƒ…å½¢ä¸‹ï¼Œåœ¨åŒä¸€å†…å­˜ä½ç½®æ›´æ–°å®ä¾‹å¯èƒ½æ¯”å¤åˆ¶å¹¶è¿”å›æ–°åˆ†é…çš„å®ä¾‹è¦æ›´å¿«ã€‚ä½¿ç”¨è¾ƒå°çš„æ•°æ®ç»“æ„æ—¶ï¼Œé€šå¸¸åˆ›å»ºæ–°çš„å®ä¾‹å¹¶ä»¥æ›´å…·å‡½æ•°å¼çš„é£æ ¼æ¥ç¼–å†™ç¨‹åºï¼Œå¯èƒ½ä¼šæ›´å®¹æ˜“ç†è§£ï¼Œæ‰€ä»¥å€¼å¾—ä»¥è¾ƒä½çš„æ€§èƒ½å¼€é”€æ¥ç¡®ä¿ä»£ç æ¸…æ™°ã€‚

## ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡

å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªå˜é‡å´ä¸åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨å®ƒï¼ŒRust é€šå¸¸ä¼šç»™ä½ ä¸€ä¸ªè­¦å‘Šï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ˜¯ä¸ª BUGã€‚ä½†æ˜¯æœ‰æ—¶åˆ›å»ºä¸€ä¸ªä¸ä¼šè¢«ä½¿ç”¨çš„å˜é‡æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚ä½ æ­£åœ¨è®¾è®¡åŸå‹æˆ–åˆšåˆšå¼€å§‹ä¸€ä¸ªé¡¹ç›®ã€‚è¿™æ—¶**ä½ å¸Œæœ›å‘Šè¯‰ Rust ä¸è¦è­¦å‘Šæœªä½¿ç”¨çš„å˜é‡ï¼Œä¸ºæ­¤å¯ä»¥ç”¨ä¸‹åˆ’çº¿ä½œä¸ºå˜é‡åçš„å¼€å¤´**ï¼š

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

ä½¿ç”¨ `cargo run` è¿è¡Œä¸‹è¯•è¯•:

```shell
warning: unused variable: `y`
 --> src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: å¦‚æœ y æ•…æ„ä¸è¢«ä½¿ç”¨ï¼Œè¯·æ·»åŠ ä¸€ä¸ªä¸‹åˆ’çº¿å‰ç¼€: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
```

å¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªå˜é‡éƒ½æ˜¯åªæœ‰å£°æ˜ï¼Œæ²¡æœ‰ä½¿ç”¨ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å´ç‹¬ç‹¬ç»™å‡ºäº† `y` æœªè¢«ä½¿ç”¨çš„è­¦å‘Šï¼Œå……åˆ†è¯´æ˜äº† `_` å˜é‡åå‰ç¼€åœ¨è¿™é‡Œå‘æŒ¥çš„ä½œç”¨ã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œç¼–è¯‘å™¨è¿˜å¾ˆå–„æ„çš„ç»™å‡ºäº†æç¤ºï¼ˆRust çš„ç¼–è¯‘å™¨éå¸¸å¼ºå¤§ï¼Œè¿™é‡Œçš„æç¤ºåªæ˜¯å°æ„æ€ï¼‰ï¼šå°† `y` ä¿®æ”¹ `_y` å³å¯ã€‚è¿™é‡Œå°±ä¸å†ç»™å‡ºä»£ç ï¼Œç•™ç»™å¤§å®¶æ‰‹åŠ¨å°è¯•å¹¶è§‚å¯Ÿä¸‹è¿è¡Œç»“æœã€‚

æ›´å¤šå…³äº `_x` çš„ä½¿ç”¨ä¿¡æ¯ï¼Œè¯·é˜…è¯»åé¢çš„[æ¨¡å¼åŒ¹é…ç« èŠ‚](https://course.rs/basic/match-pattern/all-patterns.html?highlight=_#ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡)ã€‚

## å˜é‡è§£æ„

`let` è¡¨è¾¾å¼ä¸ä»…ä»…ç”¨äºå˜é‡çš„ç»‘å®šï¼Œè¿˜èƒ½è¿›è¡Œå¤æ‚å˜é‡çš„è§£æ„ï¼šä»ä¸€ä¸ªç›¸å¯¹å¤æ‚çš„å˜é‡ä¸­ï¼ŒåŒ¹é…å‡ºè¯¥å˜é‡çš„ä¸€éƒ¨åˆ†å†…å®¹ï¼š

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### è§£æ„å¼èµ‹å€¼

åœ¨ [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) ç‰ˆæœ¬åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨èµ‹å€¼è¯­å¥çš„å·¦å¼ä¸­ä½¿ç”¨å…ƒç»„ã€åˆ‡ç‰‡å’Œç»“æ„ä½“æ¨¡å¼äº†ã€‚

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ ä»£è¡¨åŒ¹é…ä¸€ä¸ªå€¼ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸å…³å¿ƒå…·ä½“çš„å€¼æ˜¯ä»€ä¹ˆï¼Œå› æ­¤æ²¡æœ‰ä½¿ç”¨ä¸€ä¸ªå˜é‡åè€Œæ˜¯ä½¿ç”¨äº† _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

è¿™ç§ä½¿ç”¨æ–¹å¼è·Ÿä¹‹å‰çš„ `let` ä¿æŒäº†ä¸€è‡´æ€§ï¼Œä½†æ˜¯ `let` ä¼šé‡æ–°ç»‘å®šï¼Œè€Œè¿™é‡Œä»…ä»…æ˜¯å¯¹ä¹‹å‰ç»‘å®šçš„å˜é‡è¿›è¡Œå†èµ‹å€¼ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨ `+=` çš„èµ‹å€¼è¯­å¥è¿˜ä¸æ”¯æŒè§£æ„å¼èµ‹å€¼ã€‚

> è¿™é‡Œç”¨åˆ°äº†æ¨¡å¼åŒ¹é…çš„ä¸€äº›è¯­æ³•ï¼Œå¦‚æœå¤§å®¶çœ‹ä¸æ‡‚æ²¡å…³ç³»ï¼Œå¯ä»¥åœ¨å­¦å®Œæ¨¡å¼åŒ¹é…ç« èŠ‚åï¼Œå†å›å¤´æ¥çœ‹ã€‚

## å˜é‡å’Œå¸¸é‡ä¹‹é—´çš„å·®å¼‚

å˜é‡çš„å€¼ä¸èƒ½æ›´æ”¹å¯èƒ½è®©ä½ æƒ³èµ·å…¶ä»–å¦ä¸€ä¸ªå¾ˆå¤šè¯­è¨€éƒ½æœ‰çš„ç¼–ç¨‹æ¦‚å¿µï¼š**å¸¸é‡**(_constant_)ã€‚ä¸ä¸å¯å˜å˜é‡ä¸€æ ·ï¼Œå¸¸é‡ä¹Ÿæ˜¯ç»‘å®šåˆ°ä¸€ä¸ªå¸¸é‡åä¸”ä¸å…è®¸æ›´æ”¹çš„å€¼ï¼Œä½†æ˜¯å¸¸é‡å’Œå˜é‡ä¹‹é—´å­˜åœ¨ä¸€äº›å·®å¼‚ï¼š

- å¸¸é‡ä¸å…è®¸ä½¿ç”¨ `mut`ã€‚**å¸¸é‡ä¸ä»…ä»…é»˜è®¤ä¸å¯å˜ï¼Œè€Œä¸”è‡ªå§‹è‡³ç»ˆä¸å¯å˜**ï¼Œå› ä¸ºå¸¸é‡åœ¨ç¼–è¯‘å®Œæˆåï¼Œå·²ç»ç¡®å®šå®ƒçš„å€¼ã€‚
- å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—è€Œä¸æ˜¯ `let` å…³é”®å­—æ¥å£°æ˜ï¼Œå¹¶ä¸”å€¼çš„ç±»å‹**å¿…é¡»**æ ‡æ³¨ã€‚

æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚[æ•°æ®ç±»å‹](https://course.rs/basic/base-type/index.html)ä¸­ä»‹ç»ï¼Œå› æ­¤ç°åœ¨æš‚æ—¶æ— éœ€å…³å¿ƒç»†èŠ‚ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªå¸¸é‡å£°æ˜çš„ä¾‹å­ï¼Œå…¶å¸¸é‡åä¸º `MAX_POINTS`ï¼Œå€¼è®¾ç½®ä¸º `100,000`ã€‚ï¼ˆRust å¸¸é‡çš„å‘½åçº¦å®šæ˜¯å…¨éƒ¨å­—æ¯éƒ½ä½¿ç”¨å¤§å†™ï¼Œå¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯ï¼Œå¦å¤–å¯¹æ•°å­—å­—é¢é‡å¯æ’å…¥ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§ï¼‰ï¼š

```rust
const MAX_POINTS: u32 = 100_000;
```

å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸå†…å£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸï¼Œåœ¨å£°æ˜çš„ä½œç”¨åŸŸå†…ï¼Œå¸¸é‡åœ¨ç¨‹åºè¿è¡Œçš„æ•´ä¸ªè¿‡ç¨‹ä¸­éƒ½æœ‰æ•ˆã€‚å¯¹äºéœ€è¦åœ¨å¤šå¤„ä»£ç å…±äº«ä¸€ä¸ªä¸å¯å˜çš„å€¼æ—¶éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚æ¸¸æˆä¸­å…è®¸ç©å®¶èµšå–çš„æœ€å¤§ç‚¹æ•°æˆ–å…‰é€Ÿã€‚

> åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œæœ€å¥½å°†ç¨‹åºä¸­ç”¨åˆ°çš„ç¡¬ç¼–ç å€¼éƒ½å£°æ˜ä¸ºå¸¸é‡ï¼Œå¯¹äºä»£ç åç»­çš„ç»´æŠ¤æœ‰è«å¤§çš„å¸®åŠ©ã€‚å¦‚æœå°†æ¥éœ€è¦æ›´æ”¹ç¡¬ç¼–ç çš„å€¼ï¼Œä½ ä¹Ÿåªéœ€è¦åœ¨ä»£ç ä¸­æ›´æ”¹ä¸€å¤„å³å¯ã€‚

## å˜é‡é®è”½(shadowing)

Rust å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåœ¨åé¢å£°æ˜çš„å˜é‡ä¼šé®è”½æ‰å‰é¢å£°æ˜çš„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let x = 5;
    // åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

è¿™ä¸ªç¨‹åºé¦–å…ˆå°†æ•°å€¼ `5` ç»‘å®šåˆ° `x`ï¼Œç„¶åé€šè¿‡é‡å¤ä½¿ç”¨ `let x =` æ¥é®è”½ä¹‹å‰çš„ `x`ï¼Œå¹¶å–åŸæ¥çš„å€¼åŠ ä¸Š `1`ï¼Œæ‰€ä»¥ `x` çš„å€¼å˜æˆäº† `6`ã€‚ç¬¬ä¸‰ä¸ª `let` è¯­å¥åŒæ ·é®è”½å‰é¢çš„ `x`ï¼Œå–ä¹‹å‰çš„å€¼å¹¶ä¹˜ä¸Š `2`ï¼Œå¾—åˆ°çš„ `x` æœ€ç»ˆå€¼ä¸º `12`ã€‚å½“è¿è¡Œæ­¤ç¨‹åºï¼Œå°†è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
   ...
The value of x in the inner scope is: 12
The value of x is: 6
```

è¿™å’Œ `mut` å˜é‡çš„ä½¿ç”¨æ˜¯ä¸åŒçš„ï¼Œç¬¬äºŒä¸ª `let` ç”Ÿæˆäº†å®Œå…¨ä¸åŒçš„æ–°å˜é‡ï¼Œä¸¤ä¸ªå˜é‡åªæ˜¯æ°å¥½æ‹¥æœ‰åŒæ ·çš„åç§°ï¼Œæ¶‰åŠä¸€æ¬¡å†…å­˜å¯¹è±¡çš„å†åˆ†é…
ï¼Œè€Œ `mut` å£°æ˜çš„å˜é‡ï¼Œå¯ä»¥ä¿®æ”¹åŒä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œå¹¶ä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½è¦æ›´å¥½ã€‚

å˜é‡é®è”½çš„ç”¨å¤„åœ¨äºï¼Œå¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå°±å¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—ï¼Œè€Œä¸ç”¨ç»å°½è„‘æ±å»æƒ³æ›´å¤šçš„åå­—ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æœ‰ä¸€ä¸ªç¨‹åºè¦ç»Ÿè®¡ä¸€ä¸ªç©ºæ ¼å­—ç¬¦ä¸²çš„ç©ºæ ¼æ•°é‡ï¼š

```rust
// å­—ç¬¦ä¸²ç±»å‹
let spaces = "   ";
// usizeæ•°å€¼ç±»å‹
let spaces = spaces.len();
```

è¿™ç§ç»“æ„æ˜¯å…è®¸çš„ï¼Œå› ä¸ºç¬¬ä¸€ä¸ª `spaces` å˜é‡æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼Œç¬¬äºŒä¸ª `spaces` å˜é‡æ˜¯ä¸€ä¸ªå…¨æ–°çš„å˜é‡ä¸”å’Œç¬¬ä¸€ä¸ªå…·æœ‰ç›¸åŒçš„å˜é‡åï¼Œä¸”æ˜¯ä¸€ä¸ªæ•°å€¼ç±»å‹ã€‚æ‰€ä»¥å˜é‡é®è”½å¯ä»¥å¸®æˆ‘ä»¬èŠ‚çœäº›è„‘ç»†èƒï¼Œä¸ç”¨å»æƒ³å¦‚ `spaces_str` å’Œ `spaces_num` æ­¤ç±»çš„å˜é‡åï¼›ç›¸åæˆ‘ä»¬å¯ä»¥é‡å¤ä½¿ç”¨æ›´ç®€å•çš„ `spaces` å˜é‡åã€‚å¦‚æœä½ ä¸ç”¨ `let` :

```rust,
let mut spaces = "   ";
spaces = spaces.len();
```

è¿è¡Œä¸€ä¸‹ï¼Œä½ å°±ä¼šå‘ç°ç¼–è¯‘å™¨æŠ¥é”™ï¼š

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error
```

æ˜¾ç„¶ï¼ŒRust å¯¹ç±»å‹çš„è¦æ±‚å¾ˆä¸¥æ ¼ï¼Œä¸å…è®¸å°†æ•´æ•°ç±»å‹ `usize` èµ‹å€¼ç»™å­—ç¬¦ä¸²ç±»å‹ã€‚`usize` æ˜¯ä¸€ç§ CPU ç›¸å…³çš„æ•´æ•°ç±»å‹ï¼Œåœ¨[æ•°å€¼ç±»å‹](https://course.rs/basic/base-type/numbers.html#æ•´æ•°ç±»å‹)ä¸­æœ‰è¯¦ç»†ä»‹ç»ã€‚

ä¸‡äº‹å¼€å¤´éš¾ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œéƒ½è¿›å±•å¾ˆé¡ºåˆ©ï¼Œé‚£ä¸‹é¢å¼€å§‹ï¼Œå’±ä»¬æ­£å¼è¿›å…¥ Rust çš„ç±»å‹ä¸–ç•Œï¼Œçœ‹çœ‹æœ‰å“ªäº›æŒ‘æˆ˜åœ¨å‰é¢ç­‰ç€å¤§å®¶ã€‚


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/variables.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/variables.md)ã€‚




================================================
FILE: src/basic/base-type/char-bool.md
================================================
[Binary file]


================================================
FILE: src/basic/base-type/function.md
================================================
[Binary file]


================================================
FILE: src/basic/base-type/index.md
================================================
# åŸºæœ¬ç±»å‹

å½“ä¸€é—¨è¯­è¨€ä¸è°ˆç±»å‹æ—¶ï¼Œä½ å¾—å°å¿ƒï¼Œè¿™å¤§æ¦‚ç‡æ˜¯åŠ¨æ€è¯­è¨€ï¼ˆåˆ«æ‹æˆ‘ï¼Œæˆ‘æ‰¿è®¤æ˜¯åºŸè¯ï¼‰ã€‚ä½†æ˜¯æŠŠç±»å‹å¤§å¼ æ——é¼“çš„ç”¨å¤šä¸ªç« èŠ‚å»è®²çš„ï¼ŒRust æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚

Rust æ¯ä¸ªå€¼éƒ½æœ‰å…¶ç¡®åˆ‡çš„æ•°æ®ç±»å‹ï¼Œæ€»çš„æ¥è¯´å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šåŸºæœ¬ç±»å‹å’Œå¤åˆç±»å‹ã€‚ åŸºæœ¬ç±»å‹æ„å‘³ç€å®ƒä»¬å¾€å¾€æ˜¯ä¸€ä¸ªæœ€å°åŒ–åŸå­ç±»å‹ï¼Œæ— æ³•è§£æ„ä¸ºå…¶å®ƒç±»å‹ï¼ˆä¸€èˆ¬æ„ä¹‰ä¸Šæ¥è¯´ï¼‰ï¼Œç”±ä»¥ä¸‹ç»„æˆï¼š

- æ•°å€¼ç±»å‹ï¼šæœ‰ç¬¦å·æ•´æ•° (`i8`, `i16`, `i32`, `i64`, `isize`)ã€ æ— ç¬¦å·æ•´æ•° (`u8`, `u16`, `u32`, `u64`, `usize`) ã€æµ®ç‚¹æ•° (`f32`, `f64`)ã€ä»¥åŠæœ‰ç†æ•°ã€å¤æ•°
- å­—ç¬¦ä¸²ï¼šå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
- å¸ƒå°”ç±»å‹ï¼š`true` å’Œ `false`
- å­—ç¬¦ç±»å‹ï¼šè¡¨ç¤ºå•ä¸ª Unicode å­—ç¬¦ï¼Œå­˜å‚¨ä¸º 4 ä¸ªå­—èŠ‚
- å•å…ƒç±»å‹ï¼šå³ `()` ï¼Œå…¶å”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()`

## ç±»å‹æ¨å¯¼ä¸æ ‡æ³¨

ä¸ Pythonã€JavaScript ç­‰åŠ¨æ€è¯­è¨€ä¸åŒï¼ŒRust æ˜¯ä¸€é—¨é™æ€ç±»å‹è¯­è¨€ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å¿…é¡»åœ¨ç¼–è¯‘æœŸçŸ¥é“æˆ‘ä»¬æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œä½†è¿™ä¸æ„å‘³ç€ä½ éœ€è¦ä¸ºæ¯ä¸ªå˜é‡æŒ‡å®šç±»å‹ï¼Œå› ä¸º **Rust ç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œå®ƒå¯ä»¥æ ¹æ®å˜é‡çš„å€¼å’Œä¸Šä¸‹æ–‡ä¸­çš„ä½¿ç”¨æ–¹å¼æ¥è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹**ï¼ŒåŒæ—¶ç¼–è¯‘å™¨ä¹Ÿä¸å¤Ÿèªæ˜ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒæ— æ³•æ¨å¯¼å‡ºå˜é‡ç±»å‹ï¼Œéœ€è¦æ‰‹åŠ¨å»ç»™äºˆä¸€ä¸ªç±»å‹æ ‡æ³¨ï¼Œå…³äºè¿™ä¸€ç‚¹åœ¨ [Rust è¯­è¨€åˆå°è±¡](https://course.rs/first-try/hello-world.html#rust-è¯­è¨€åˆå°è±¡) ä¸­æœ‰è¿‡å±•ç¤ºã€‚

æ¥çœ‹æ®µä»£ç ï¼š

```rust
let guess = "42".parse().expect("Not a number!");
```

å…ˆå¿½ç•¥ `.parse().expect..` éƒ¨åˆ†ï¼Œè¿™æ®µä»£ç çš„ç›®çš„æ˜¯å°†å­—ç¬¦ä¸² `"42"` è¿›è¡Œè§£æï¼Œè€Œç¼–è¯‘å™¨åœ¨è¿™é‡Œæ— æ³•æ¨å¯¼å‡ºæˆ‘ä»¬æƒ³è¦çš„ç±»å‹ï¼šæ•´æ•°ï¼Ÿæµ®ç‚¹æ•°ï¼Ÿå­—ç¬¦ä¸²ï¼Ÿå› æ­¤ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š

```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
```

å› æ­¤æˆ‘ä»¬éœ€è¦æä¾›ç»™ç¼–è¯‘å™¨æ›´å¤šçš„ä¿¡æ¯ï¼Œä¾‹å¦‚ç»™ `guess` å˜é‡ä¸€ä¸ª**æ˜¾å¼çš„ç±»å‹æ ‡æ³¨**ï¼š`let guess: i32 = ...` æˆ–è€… `"42".parse::<i32>()`ã€‚



================================================
FILE: src/basic/base-type/numbers.md
================================================
# æ•°å€¼ç±»å‹

æˆ‘æœ‹å‹æœ‰ä¸€ä¸ªé¢†å¯¼ï¼ˆè¯»è€…ï¼šä½ æœ‹å‹ï¼Ÿé»‘äººé—®å·ï¼‰è¯´è¿‡ä¸€å¥è¯ï¼šæ‰€æœ‰ä»£ç å°±æ˜¯ 0 å’Œ 1 ï¼Œç®€å•çš„å¾ˆã€‚å’±ä¸è¯„ä»·è¿™å¥è¯çš„æ­£ç¡®æ€§ï¼Œä½†æ˜¯è®¡ç®—æœºåº•å±‚ç”± 01 ç»„æˆå€’æ˜¯çœŸçš„ã€‚

è®¡ç®—æœºå’Œæ•°å€¼å…³è”åœ¨ä¸€èµ·çš„æ—¶é—´ï¼Œè¿œæ¯”æˆ‘ä»¬æƒ³è±¡çš„è¦é•¿ï¼Œå› æ­¤æ•°å€¼ç±»å‹å¯ä»¥è¯´æ˜¯æœ‰è®¡ç®—æœºä»¥æ¥å°±æœ‰çš„ç±»å‹ï¼Œä¸‹é¢å†…å®¹å°†æ·±å…¥è®¨è®º Rust çš„æ•°å€¼ç±»å‹ä»¥åŠç›¸å…³çš„è¿ç®—ç¬¦ã€‚


Rust ä½¿ç”¨ä¸€ä¸ªç›¸å¯¹ä¼ ç»Ÿçš„è¯­æ³•æ¥åˆ›å»ºæ•´æ•°ï¼ˆ`1`ï¼Œ`2`ï¼Œ...ï¼‰å’Œæµ®ç‚¹æ•°ï¼ˆ`1.0`ï¼Œ`1.1`ï¼Œ...ï¼‰ã€‚æ•´æ•°ã€æµ®ç‚¹æ•°çš„è¿ç®—å’Œä½ åœ¨å…¶å®ƒè¯­è¨€ä¸Šè§è¿‡çš„ä¸€è‡´ï¼Œéƒ½æ˜¯é€šè¿‡å¸¸è§çš„è¿ç®—ç¬¦æ¥å®Œæˆã€‚

> ä¸ä»…ä»…æ˜¯æ•°å€¼ç±»å‹ï¼ŒRust ä¹Ÿå…è®¸åœ¨å¤æ‚ç±»å‹ä¸Šå®šä¹‰è¿ç®—ç¬¦ï¼Œä¾‹å¦‚åœ¨è‡ªå®šä¹‰ç±»å‹ä¸Šå®šä¹‰ `+` è¿ç®—ç¬¦ï¼Œè¿™ç§è¡Œä¸ºè¢«ç§°ä¸ºè¿ç®—ç¬¦é‡è½½ï¼ŒRust å…·ä½“æ”¯æŒçš„å¯é‡è½½è¿ç®—ç¬¦è§[é™„å½• B](https://course.rs/appendix/operators.html#è¿ç®—ç¬¦)ã€‚

## æ•´æ•°ç±»å‹

**æ•´æ•°**æ˜¯æ²¡æœ‰å°æ•°éƒ¨åˆ†çš„æ•°å­—ã€‚ä¹‹å‰ä½¿ç”¨è¿‡çš„ `i32` ç±»å‹ï¼Œè¡¨ç¤ºæœ‰ç¬¦å·çš„ 32 ä½æ•´æ•°ï¼ˆ `i` æ˜¯è‹±æ–‡å•è¯ _integer_ çš„é¦–å­—æ¯ï¼Œä¸ä¹‹ç›¸åçš„æ˜¯ `u`ï¼Œä»£è¡¨æ— ç¬¦å· `unsigned` ç±»å‹ï¼‰ã€‚ä¸‹è¡¨æ˜¾ç¤ºäº† Rust ä¸­çš„å†…ç½®çš„æ•´æ•°ç±»å‹ï¼š

| é•¿åº¦       | æœ‰ç¬¦å·ç±»å‹ | æ— ç¬¦å·ç±»å‹ |
| ---------- | ---------- | ---------- |
| 8 ä½       | `i8`       | `u8`       |
| 16 ä½      | `i16`      | `u16`      |
| 32 ä½      | `i32`      | `u32`      |
| 64 ä½      | `i64`      | `u64`      |
| 128 ä½     | `i128`     | `u128`     |
| è§†æ¶æ„è€Œå®š | `isize`    | `usize`    |

ç±»å‹å®šä¹‰çš„å½¢å¼ç»Ÿä¸€ä¸ºï¼š`æœ‰æ— ç¬¦å· + ç±»å‹å¤§å°(ä½æ•°)`ã€‚**æ— ç¬¦å·æ•°**è¡¨ç¤ºæ•°å­—åªèƒ½å–æ­£æ•°å’Œ 0ï¼Œè€Œ**æœ‰ç¬¦å·**åˆ™è¡¨ç¤ºæ•°å­—å¯ä»¥å–æ­£æ•°ã€è´Ÿæ•°è¿˜æœ‰ 0ã€‚å°±åƒåœ¨çº¸ä¸Šå†™æ•°å­—ä¸€æ ·ï¼šå½“è¦å¼ºè°ƒç¬¦å·æ—¶ï¼Œæ•°å­—å‰é¢å¯ä»¥å¸¦ä¸Šæ­£å·æˆ–è´Ÿå·ï¼›ç„¶è€Œï¼Œå½“å¾ˆæ˜æ˜¾ç¡®å®šæ•°å­—ä¸ºæ­£æ•°æ—¶ï¼Œå°±ä¸éœ€è¦åŠ ä¸Šæ­£å·äº†ã€‚æœ‰ç¬¦å·æ•°å­—ä»¥[è¡¥ç ](https://en.wikipedia.org/wiki/Two%27s_complement)å½¢å¼å­˜å‚¨ã€‚

æ¯ä¸ªæœ‰ç¬¦å·ç±»å‹è§„å®šçš„æ•°å­—èŒƒå›´æ˜¯ -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1ï¼Œå…¶ä¸­ `n` æ˜¯è¯¥å®šä¹‰å½¢å¼çš„ä½é•¿åº¦ã€‚å› æ­¤ `i8` å¯å­˜å‚¨æ•°å­—èŒƒå›´æ˜¯ -(2<sup>7</sup>) ~ 2<sup>7</sup> - 1ï¼Œå³ -128 ~ 127ã€‚æ— ç¬¦å·ç±»å‹å¯ä»¥å­˜å‚¨çš„æ•°å­—èŒƒå›´æ˜¯ 0 ~ 2<sup>n</sup> - 1ï¼Œæ‰€ä»¥ `u8` èƒ½å¤Ÿå­˜å‚¨çš„æ•°å­—ä¸º 0 ~ 2<sup>8</sup> - 1ï¼Œå³ 0 ~ 255ã€‚

æ­¤å¤–ï¼Œ`isize` å’Œ `usize` ç±»å‹å–å†³äºç¨‹åºè¿è¡Œçš„è®¡ç®—æœº CPU ç±»å‹ï¼š è‹¥ CPU æ˜¯ 32 ä½çš„ï¼Œåˆ™è¿™ä¸¤ä¸ªç±»å‹æ˜¯ 32 ä½çš„ï¼ŒåŒç†ï¼Œè‹¥ CPU æ˜¯ 64 ä½ï¼Œé‚£ä¹ˆå®ƒä»¬åˆ™æ˜¯ 64 ä½ã€‚

æ•´å‹å­—é¢é‡å¯ä»¥ç”¨ä¸‹è¡¨çš„å½¢å¼ä¹¦å†™ï¼š

| æ•°å­—å­—é¢é‡         | ç¤ºä¾‹          |
| ------------------ | ------------- |
| åè¿›åˆ¶             | `98_222`      |
| åå…­è¿›åˆ¶           | `0xff`        |
| å…«è¿›åˆ¶             | `0o77`        |
| äºŒè¿›åˆ¶             | `0b1111_0000` |
| å­—èŠ‚ (ä»…é™äº `u8`) | `b'A'`        |

è¿™ä¹ˆå¤šç±»å‹ï¼Œæœ‰æ²¡æœ‰ä¸€ä¸ªç®€å•çš„ä½¿ç”¨å‡†åˆ™ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œ Rust æ•´å‹é»˜è®¤ä½¿ç”¨ `i32`ï¼Œä¾‹å¦‚ `let i = 1`ï¼Œé‚£ `i` å°±æ˜¯ `i32` ç±»å‹ï¼Œå› æ­¤ä½ å¯ä»¥é¦–é€‰å®ƒï¼ŒåŒæ—¶è¯¥ç±»å‹ä¹Ÿå¾€å¾€æ˜¯æ€§èƒ½æœ€å¥½çš„ã€‚`isize` å’Œ `usize` çš„ä¸»è¦åº”ç”¨åœºæ™¯æ˜¯ç”¨ä½œé›†åˆçš„ç´¢å¼•ã€‚


#### æ•´å‹æº¢å‡º

å‡è®¾æœ‰ä¸€ä¸ª `u8` ï¼Œå®ƒå¯ä»¥å­˜æ”¾ä» 0 åˆ° 255 çš„å€¼ã€‚é‚£ä¹ˆå½“ä½ å°†å…¶ä¿®æ”¹ä¸ºèŒƒå›´ä¹‹å¤–çš„å€¼ï¼Œæ¯”å¦‚ 256ï¼Œåˆ™ä¼šå‘ç”Ÿ**æ•´å‹æº¢å‡º**ã€‚å…³äºè¿™ä¸€è¡Œä¸º Rust æœ‰ä¸€äº›æœ‰è¶£çš„è§„åˆ™ï¼šå½“åœ¨ debug æ¨¡å¼ç¼–è¯‘æ—¶ï¼ŒRust ä¼šæ£€æŸ¥æ•´å‹æº¢å‡ºï¼Œè‹¥å­˜åœ¨è¿™äº›é—®é¢˜ï¼Œåˆ™ä½¿ç¨‹åºåœ¨ç¼–è¯‘æ—¶ _panic_(å´©æºƒ,Rust ä½¿ç”¨è¿™ä¸ªæœ¯è¯­æ¥è¡¨æ˜ç¨‹åºå› é”™è¯¯è€Œé€€å‡º)ã€‚

åœ¨å½“ä½¿ç”¨ `--release` å‚æ•°è¿›è¡Œ release æ¨¡å¼æ„å»ºæ—¶ï¼ŒRust **ä¸**æ£€æµ‹æº¢å‡ºã€‚ç›¸åï¼Œå½“æ£€æµ‹åˆ°æ•´å‹æº¢å‡ºæ—¶ï¼ŒRust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ_twoâ€™s complement wrapping_ï¼‰çš„è§„åˆ™å¤„ç†ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå¤§äºè¯¥ç±»å‹æœ€å¤§å€¼çš„æ•°å€¼ä¼šè¢«è¡¥ç è½¬æ¢æˆè¯¥ç±»å‹èƒ½å¤Ÿæ”¯æŒçš„å¯¹åº”æ•°å­—çš„æœ€å°å€¼ã€‚æ¯”å¦‚åœ¨ `u8` çš„æƒ…å†µä¸‹ï¼Œ256 å˜æˆ 0ï¼Œ257 å˜æˆ 1ï¼Œä¾æ­¤ç±»æ¨ã€‚ç¨‹åºä¸ä¼š _panic_ï¼Œä½†æ˜¯è¯¥å˜é‡çš„å€¼å¯èƒ½ä¸æ˜¯ä½ æœŸæœ›çš„å€¼ã€‚ä¾èµ–è¿™ç§é»˜è®¤è¡Œä¸ºçš„ä»£ç éƒ½åº”è¯¥è¢«è®¤ä¸ºæ˜¯é”™è¯¯çš„ä»£ç ã€‚

è¦æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„è¿™äº›æ–¹æ³•ï¼š

- ä½¿ç”¨ `wrapping_*` æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
- å¦‚æœä½¿ç”¨ `checked_*` æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› `None` å€¼
- ä½¿ç”¨ `overflowing_*` æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
- ä½¿ç”¨ `saturating_*` æ–¹æ³•ï¼Œå¯ä»¥é™å®šè®¡ç®—åçš„ç»“æœä¸è¶…è¿‡ç›®æ ‡ç±»å‹çš„æœ€å¤§å€¼æˆ–ä½äºæœ€å°å€¼ï¼Œä¾‹å¦‚:

```rust
assert_eq!(100u8.saturating_add(1), 101);
assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
```

ä¸‹é¢æ˜¯ä¸€ä¸ªæ¼”ç¤º`wrapping_*`æ–¹æ³•çš„ç¤ºä¾‹ï¼š

```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

## æµ®ç‚¹ç±»å‹

**æµ®ç‚¹ç±»å‹æ•°å­—** æ˜¯å¸¦æœ‰å°æ•°ç‚¹çš„æ•°å­—ï¼Œåœ¨ Rust ä¸­æµ®ç‚¹ç±»å‹æ•°å­—ä¹Ÿæœ‰ä¸¤ç§åŸºæœ¬ç±»å‹ï¼š `f32` å’Œ `f64`ï¼Œåˆ†åˆ«ä¸º 32 ä½å’Œ 64 ä½å¤§å°ã€‚é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ `f64`ï¼Œåœ¨ç°ä»£çš„ CPU ä¸­å®ƒçš„é€Ÿåº¦ä¸ `f32` å‡ ä¹ç›¸åŒï¼Œä½†ç²¾åº¦æ›´é«˜ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªæ¼”ç¤ºæµ®ç‚¹æ•°çš„ç¤ºä¾‹ï¼š

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

æµ®ç‚¹æ•°æ ¹æ® `IEEE-754` æ ‡å‡†å®ç°ã€‚`f32` ç±»å‹æ˜¯å•ç²¾åº¦æµ®ç‚¹å‹ï¼Œ`f64` ä¸ºåŒç²¾åº¦ã€‚

#### æµ®ç‚¹æ•°é™·é˜±

æµ®ç‚¹æ•°ç”±äºåº•å±‚æ ¼å¼çš„ç‰¹æ®Šæ€§ï¼Œå¯¼è‡´äº†å¦‚æœåœ¨ä½¿ç”¨æµ®ç‚¹æ•°æ—¶ä¸å¤Ÿè°¨æ…ï¼Œå°±å¯èƒ½é€ æˆå±é™©ï¼Œæœ‰ä¸¤ä¸ªåŸå› ï¼š

1. **æµ®ç‚¹æ•°å¾€å¾€æ˜¯ä½ æƒ³è¦æ•°å­—çš„è¿‘ä¼¼è¡¨è¾¾**
   æµ®ç‚¹æ•°ç±»å‹æ˜¯åŸºäºäºŒè¿›åˆ¶å®ç°çš„ï¼Œä½†æ˜¯æˆ‘ä»¬æƒ³è¦è®¡ç®—çš„æ•°å­—å¾€å¾€æ˜¯åŸºäºåè¿›åˆ¶ï¼Œä¾‹å¦‚ `0.1` åœ¨äºŒè¿›åˆ¶ä¸Šå¹¶ä¸å­˜åœ¨ç²¾ç¡®çš„è¡¨è¾¾å½¢å¼ï¼Œä½†æ˜¯åœ¨åè¿›åˆ¶ä¸Šå°±å­˜åœ¨ã€‚è¿™ç§ä¸åŒ¹é…æ€§å¯¼è‡´ä¸€å®šçš„æ­§ä¹‰æ€§ï¼Œæ›´å¤šçš„ï¼Œè™½ç„¶æµ®ç‚¹æ•°èƒ½ä»£è¡¨çœŸå®çš„æ•°å€¼ï¼Œä½†æ˜¯ç”±äºåº•å±‚æ ¼å¼é—®é¢˜ï¼Œå®ƒå¾€å¾€å—é™äºå®šé•¿çš„æµ®ç‚¹æ•°ç²¾åº¦ï¼Œå¦‚æœä½ æƒ³è¦è¡¨è¾¾å®Œå…¨ç²¾å‡†çš„çœŸå®æ•°å­—ï¼Œåªæœ‰ä½¿ç”¨æ— é™ç²¾åº¦çš„æµ®ç‚¹æ•°æ‰è¡Œ

2. **æµ®ç‚¹æ•°åœ¨æŸäº›ç‰¹æ€§ä¸Šæ˜¯åç›´è§‰çš„**
   ä¾‹å¦‚å¤§å®¶éƒ½ä¼šè§‰å¾—æµ®ç‚¹æ•°å¯ä»¥è¿›è¡Œæ¯”è¾ƒï¼Œå¯¹å§ï¼Ÿæ˜¯çš„ï¼Œå®ƒä»¬ç¡®å®å¯ä»¥ä½¿ç”¨ `>`ï¼Œ`>=` ç­‰è¿›è¡Œæ¯”è¾ƒï¼Œä½†æ˜¯åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œè¿™ç§ç›´è§‰ä¸Šçš„æ¯”è¾ƒç‰¹æ€§åè€Œä¼šå®³äº†ä½ ã€‚å› ä¸º `f32` ï¼Œ `f64` ä¸Šçš„æ¯”è¾ƒè¿ç®—å®ç°çš„æ˜¯ `std::cmp::PartialEq` ç‰¹å¾(ç±»ä¼¼å…¶ä»–è¯­è¨€çš„æ¥å£)ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å®ç° `std::cmp::Eq` ç‰¹å¾ï¼Œä½†æ˜¯åè€…åœ¨å…¶å®ƒæ•°å€¼ç±»å‹ä¸Šéƒ½æœ‰å®šä¹‰ï¼Œè¯´äº†è¿™ä¹ˆå¤šï¼Œå¯èƒ½å¤§å®¶è¿˜æ˜¯äº‘é‡Œé›¾é‡Œï¼Œç”¨ä¸€ä¸ªä¾‹å­æ¥ä¸¾ä¾‹ï¼š

Rust çš„ `HashMap` æ•°æ®ç»“æ„ï¼Œæ˜¯ä¸€ä¸ª KV ç±»å‹çš„ Hash Map å®ç°ï¼Œå®ƒå¯¹äº `K` æ²¡æœ‰ç‰¹å®šç±»å‹çš„é™åˆ¶ï¼Œä½†æ˜¯è¦æ±‚èƒ½ç”¨ä½œ `K` çš„ç±»å‹å¿…é¡»å®ç°äº† `std::cmp::Eq` ç‰¹å¾ï¼Œå› æ­¤è¿™æ„å‘³ç€ä½ æ— æ³•ä½¿ç”¨æµ®ç‚¹æ•°ä½œä¸º `HashMap` çš„ `Key`ï¼Œæ¥å­˜å‚¨é”®å€¼å¯¹ï¼Œä½†æ˜¯ä½œä¸ºå¯¹æ¯”ï¼ŒRust çš„æ•´æ•°ç±»å‹ã€å­—ç¬¦ä¸²ç±»å‹ã€å¸ƒå°”ç±»å‹éƒ½å®ç°äº†è¯¥ç‰¹å¾ï¼Œå› æ­¤å¯ä»¥ä½œä¸º `HashMap` çš„ `Key`ã€‚

ä¸ºäº†é¿å…ä¸Šé¢è¯´çš„ä¸¤ä¸ªé™·é˜±ï¼Œä½ éœ€è¦éµå®ˆä»¥ä¸‹å‡†åˆ™ï¼š

- é¿å…åœ¨æµ®ç‚¹æ•°ä¸Šæµ‹è¯•ç›¸ç­‰æ€§
- å½“ç»“æœåœ¨æ•°å­¦ä¸Šå¯èƒ½å­˜åœ¨æœªå®šä¹‰æ—¶ï¼Œéœ€è¦æ ¼å¤–çš„å°å¿ƒ

æ¥çœ‹ä¸ªå°ä¾‹å­:

```rust
fn main() {
  // æ–­è¨€0.1 + 0.2ä¸0.3ç›¸ç­‰
  assert!(0.1 + 0.2 == 0.3);
}
```

ä½ å¯èƒ½ä»¥ä¸ºï¼Œè¿™æ®µä»£ç æ²¡å•¥é—®é¢˜å§ï¼Œå®é™…ä¸Šå®ƒä¼š _panic_ï¼ˆç¨‹åºå´©æºƒï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼‰ï¼Œå› ä¸ºäºŒè¿›åˆ¶ç²¾åº¦é—®é¢˜ï¼Œå¯¼è‡´äº† 0.1 + 0.2 å¹¶ä¸ä¸¥æ ¼ç­‰äº 0.3ï¼Œå®ƒä»¬å¯èƒ½åœ¨å°æ•°ç‚¹ N ä½åå­˜åœ¨è¯¯å·®ã€‚

é‚£å¦‚æœéè¦è¿›è¡Œæ¯”è¾ƒå‘¢ï¼Ÿå¯ä»¥è€ƒè™‘ç”¨è¿™ç§æ–¹å¼ `(0.1_f64 + 0.2 - 0.3).abs() < 0.00001` ï¼Œå…·ä½“å°äºå¤šå°‘ï¼Œå–å†³äºä½ å¯¹ç²¾åº¦çš„éœ€æ±‚ã€‚

è®²åˆ°è¿™é‡Œï¼Œç›¸ä¿¡å¤§å®¶åŸºæœ¬å·²ç»æ˜ç™½äº†ï¼Œä¸ºä»€ä¹ˆæ“ä½œæµ®ç‚¹æ•°æ—¶è¦æ ¼å¤–çš„å°å¿ƒï¼Œä½†æ˜¯è¿˜ä¸å¤Ÿï¼Œä¸‹é¢å†æ¥ä¸€æ®µä»£ç ï¼Œç›´æ¥éœ‡æ’¼ä½ çš„çµé­‚ï¼š

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

è¿è¡Œè¯¥ç¨‹åºï¼Œè¾“å‡ºå¦‚ä¸‹:

```console
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
â¥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
â¥a backtrace
```

ä»”ç»†çœ‹ï¼Œå¯¹ `f32` ç±»å‹åšåŠ æ³•æ—¶ï¼Œ`0.1 + 0.2` çš„ç»“æœæ˜¯ `3e99999a`ï¼Œ`0.3` ä¹Ÿæ˜¯ `3e99999a`ï¼Œå› æ­¤ `f32` ä¸‹çš„ `0.1 + 0.2 == 0.3` é€šè¿‡æµ‹è¯•ï¼Œä½†æ˜¯åˆ°äº† `f64` ç±»å‹æ—¶ï¼Œç»“æœå°±ä¸ä¸€æ ·äº†ï¼Œå› ä¸º `f64` ç²¾åº¦é«˜å¾ˆå¤šï¼Œå› æ­¤åœ¨å°æ•°ç‚¹éå¸¸åé¢å‘ç”Ÿäº†ä¸€ç‚¹å¾®å°çš„å˜åŒ–ï¼Œ`0.1 + 0.2` ä»¥ `4` ç»“å°¾ï¼Œä½†æ˜¯ `0.3` ä»¥`3`ç»“å°¾ï¼Œè¿™ä¸ªç»†å¾®åŒºåˆ«å¯¼è‡´ `f64` ä¸‹çš„æµ‹è¯•å¤±è´¥äº†ï¼Œå¹¶ä¸”æŠ›å‡ºäº†å¼‚å¸¸ã€‚

æ˜¯ä¸æ˜¯**blow your mind away**? æ²¡å…³ç³»ï¼Œåœ¨æœ¬ä¹¦çš„åç»­ç« èŠ‚ä¸­ç±»ä¼¼çš„ç›´å‡»çµé­‚çš„åœ°æ–¹è¿˜å¾ˆå¤šï¼Œè¿™å°±æ˜¯æ•¢å·ç§° `Rustè¯­è¨€åœ£ç»ï¼ˆRust Courseï¼‰` çš„åº•æ°”ï¼

#### NaN

å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä¾‹å¦‚å¯¹è´Ÿæ•°å–å¹³æ–¹æ ¹ `-42.1.sqrt()` ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªç‰¹æ®Šçš„ç»“æœï¼šRust çš„æµ®ç‚¹æ•°ç±»å‹ä½¿ç”¨ `NaN` (not a number) æ¥å¤„ç†è¿™äº›æƒ…å†µã€‚

**æ‰€æœ‰è·Ÿ `NaN` äº¤äº’çš„æ“ä½œï¼Œéƒ½ä¼šè¿”å›ä¸€ä¸ª `NaN`**ï¼Œè€Œä¸” `NaN` ä¸èƒ½ç”¨æ¥æ¯”è¾ƒï¼Œä¸‹é¢çš„ä»£ç ä¼šå´©æºƒï¼š

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

å‡ºäºé˜²å¾¡æ€§ç¼–ç¨‹çš„è€ƒè™‘ï¼Œå¯ä»¥ä½¿ç”¨ `is_nan()` ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ `NaN` ï¼š

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("æœªå®šä¹‰çš„æ•°å­¦è¡Œä¸º")
    }
}
```

## æ•°å­—è¿ç®—

Rust æ”¯æŒæ‰€æœ‰æ•°å­—ç±»å‹çš„åŸºæœ¬æ•°å­¦è¿ç®—ï¼šåŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ã€é™¤æ³•å’Œå–æ¨¡è¿ç®—ã€‚ä¸‹é¢ä»£ç å„ä½¿ç”¨ä¸€æ¡ `let` è¯­å¥æ¥è¯´æ˜ç›¸åº”è¿ç®—çš„ç”¨æ³•ï¼š

```rust
fn main() {
    // åŠ æ³•
    let sum = 5 + 10;

    // å‡æ³•
    let difference = 95.5 - 4.3;

    // ä¹˜æ³•
    let product = 4 * 30;

    // é™¤æ³•
    let quotient = 56.7 / 32.2;

    // æ±‚ä½™
    let remainder = 43 % 5;
}
```

è¿™äº›è¯­å¥ä¸­çš„æ¯ä¸ªè¡¨è¾¾å¼éƒ½ä½¿ç”¨äº†æ•°å­¦è¿ç®—ç¬¦ï¼Œå¹¶ä¸”è®¡ç®—ç»“æœä¸ºä¸€ä¸ªå€¼ï¼Œç„¶åç»‘å®šåˆ°ä¸€ä¸ªå˜é‡ä¸Šã€‚[é™„å½• B](https://course.rs/appendix/operators.html#è¿ç®—ç¬¦) ä¸­ç»™å‡ºäº† Rust æä¾›çš„æ‰€æœ‰è¿ç®—ç¬¦çš„åˆ—è¡¨ã€‚

å†æ¥çœ‹ä¸€ä¸ªç»¼åˆæ€§çš„ç¤ºä¾‹ï¼š

```rust
fn main() {
  // ç¼–è¯‘å™¨ä¼šè¿›è¡Œè‡ªåŠ¨æ¨å¯¼ï¼Œç»™äºˆtwenty i32çš„ç±»å‹
  let twenty = 20;
  // ç±»å‹æ ‡æ³¨
  let twenty_one: i32 = 21;
  // é€šè¿‡ç±»å‹åç¼€çš„æ–¹å¼è¿›è¡Œç±»å‹æ ‡æ³¨ï¼š22æ˜¯i32ç±»å‹
  let twenty_two = 22i32;

  // åªæœ‰åŒæ ·ç±»å‹ï¼Œæ‰èƒ½è¿ç®—
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // å¯¹äºè¾ƒé•¿çš„æ•°å­—ï¼Œå¯ä»¥ç”¨_è¿›è¡Œåˆ†å‰²ï¼Œæå‡å¯è¯»æ€§
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­42.0ä¼šè‡ªåŠ¨è¢«æ¨å¯¼ä¸ºf32ç±»å‹
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // æ‰“å°æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶æ§åˆ¶å°æ•°ä½ä¸º2ä½
  println!("{:.2}", forty_twos[0]);
}
```



## ä½è¿ç®—

Rust çš„ä½è¿ç®—åŸºæœ¬ä¸Šå’Œå…¶ä»–è¯­è¨€ä¸€æ ·

| è¿ç®—ç¬¦  | è¯´æ˜                                                   |
| ------- | ------------------------------------------------------ |
| & ä½ä¸  | ç›¸åŒä½ç½®å‡ä¸º1æ—¶åˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0                          |
| \| ä½æˆ– | ç›¸åŒä½ç½®åªè¦æœ‰1æ—¶åˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0                        |
| ^ å¼‚æˆ–  | ç›¸åŒä½ç½®ä¸ç›¸åŒåˆ™ä¸º1ï¼Œç›¸åŒåˆ™ä¸º0                         |
| ! ä½é  | æŠŠä½ä¸­çš„0å’Œ1ç›¸äº’å–åï¼Œå³0ç½®ä¸º1ï¼Œ1ç½®ä¸º0                 |
| << å·¦ç§» | æ‰€æœ‰ä½å‘å·¦ç§»åŠ¨æŒ‡å®šä½æ•°ï¼Œå³ä½è¡¥0                        |
| >> å³ç§» | æ‰€æœ‰ä½å‘å³ç§»åŠ¨æŒ‡å®šä½æ•°ï¼Œå¸¦ç¬¦å·ç§»åŠ¨ï¼ˆæ­£æ•°è¡¥0ï¼Œè´Ÿæ•°è¡¥1ï¼‰ |



```rust
fn main() {
    // æ— ç¬¦å·8ä½æ•´æ•°ï¼ŒäºŒè¿›åˆ¶ä¸º00000010
    let a: u8 = 2; // ä¹Ÿå¯ä»¥å†™ let a: u8 = 0b_0000_0010;

    // äºŒè¿›åˆ¶ä¸º00000011
    let b: u8 = 3;

    // {:08b}ï¼šå·¦é«˜å³ä½è¾“å‡ºäºŒè¿›åˆ¶01ï¼Œä¸è¶³8ä½åˆ™é«˜ä½è¡¥0
    println!("a value is        {:08b}", a);

    println!("b value is        {:08b}", b);

    println!("(a & b) value is  {:08b}", a & b);

    println!("(a | b) value is  {:08b}", a | b);

    println!("(a ^ b) value is  {:08b}", a ^ b);

    println!("(!b) value is     {:08b}", !b);

    println!("(a << b) value is {:08b}", a << b);

    println!("(a >> b) value is {:08b}", a >> b);

    let mut a = a;
    // æ³¨æ„è¿™äº›è®¡ç®—ç¬¦é™¤äº†!ä¹‹å¤–éƒ½å¯ä»¥åŠ ä¸Š=è¿›è¡Œèµ‹å€¼ (å› ä¸º!=è¦ç”¨æ¥åˆ¤æ–­ä¸ç­‰äº)
    a <<= b;
    println!("(a << b) value is {:08b}", a);
}
```


å¯¹äºç§»ä½è¿ç®—ï¼ŒRust ä¼šæ£€æŸ¥å®ƒæ˜¯å¦è¶…å‡ºè¯¥æ•´å‹çš„ä½æ•°èŒƒå›´ï¼Œå¦‚æœè¶…å‡ºï¼Œåˆ™ä¼šæŠ¥é”™ overflowã€‚æ¯”å¦‚ï¼Œä¸€ä¸ª 8 ä½çš„æ•´å‹ï¼Œå¦‚æœè¯•å›¾ç§»ä½ 8 ä½ï¼Œå°±ä¼šæŠ¥é”™ï¼Œä½†å¦‚æœç§»ä½ 7 ä½å°±ä¸ä¼šã€‚Rust è¿™æ ·åšçš„ç†ç”±ä¹Ÿå¾ˆç®€å•ï¼Œå¦‚æœç§»ä½å¤ªå¤šï¼Œé‚£ä¹ˆè¿™ä¸ªç§»ä½åçš„æ•°å­—å°±æ˜¯å…¨ 0 æˆ–è€…å…¨ 1ï¼Œæ‰€ä»¥ç§»ä½æ“ä½œä¸å¦‚ç›´æ¥å†™ 0 æˆ–è€… -1ï¼Œè¿™å¾ˆå¯èƒ½æ„å‘³ç€è¿™é‡Œçš„ä»£ç æ˜¯æœ‰é—®é¢˜çš„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸è®º debug æ¨¡å¼è¿˜æ˜¯ release æ¨¡å¼ï¼ŒRust éƒ½ä¼šæ£€æŸ¥æº¢å‡ºã€‚

```rust
fn main() {
   let a: u8 = 255;
   let b = a>>7; // ok
   let b = a<<7; // ok
   let b = a>>8; // overflow
   let b = a<<8; // overflow
}
```

## åºåˆ—(Range)

Rust æä¾›äº†ä¸€ä¸ªéå¸¸ç®€æ´çš„æ–¹å¼ï¼Œç”¨æ¥ç”Ÿæˆè¿ç»­çš„æ•°å€¼ï¼Œä¾‹å¦‚ `1..5`ï¼Œç”Ÿæˆä» 1 åˆ° 4 çš„è¿ç»­æ•°å­—ï¼Œä¸åŒ…å« 5 ï¼›`1..=5`ï¼Œç”Ÿæˆä» 1 åˆ° 5 çš„è¿ç»­æ•°å­—ï¼ŒåŒ…å« 5ï¼Œå®ƒçš„ç”¨é€”å¾ˆç®€å•ï¼Œå¸¸å¸¸ç”¨äºå¾ªç¯ä¸­ï¼š

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

æœ€ç»ˆç¨‹åºè¾“å‡º:

```console
1
2
3
4
5
```

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­ï¼ŒåŒæ—¶ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå­—ç¬¦å’Œæ•°å­—å€¼æ˜¯ Rust ä¸­ä»…æœ‰çš„å¯ä»¥ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹ã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å­—ç¬¦ç±»å‹åºåˆ—çš„ä¾‹å­ï¼š

```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```

## ä½¿ç”¨ As å®Œæˆç±»å‹è½¬æ¢
Rust ä¸­å¯ä»¥ä½¿ç”¨ As æ¥å®Œæˆä¸€ä¸ªç±»å‹åˆ°å¦ä¸€ä¸ªç±»å‹çš„è½¬æ¢ï¼Œå…¶æœ€å¸¸ç”¨äºå°†åŸå§‹ç±»å‹è½¬æ¢ä¸ºå…¶ä»–åŸå§‹ç±»å‹ï¼Œä½†æ˜¯å®ƒä¹Ÿå¯ä»¥å®Œæˆè¯¸å¦‚å°†æŒ‡é’ˆè½¬æ¢ä¸ºåœ°å€ã€åœ°å€è½¬æ¢ä¸ºæŒ‡é’ˆä»¥åŠå°†æŒ‡é’ˆè½¬æ¢ä¸ºå…¶ä»–æŒ‡é’ˆç­‰åŠŸèƒ½ã€‚ä½ å¯ä»¥åœ¨[è¿™é‡Œ](../../advance/into-types/converse.md)äº†è§£æ›´å¤šç›¸å…³çš„çŸ¥è¯†ã€‚

## æœ‰ç†æ•°å’Œå¤æ•°

Rust çš„æ ‡å‡†åº“ç›¸æ¯”å…¶å®ƒè¯­è¨€ï¼Œå‡†å…¥é—¨æ§›è¾ƒé«˜ï¼Œå› æ­¤æœ‰ç†æ•°å’Œå¤æ•°å¹¶æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼š

- æœ‰ç†æ•°å’Œå¤æ•°
- ä»»æ„å¤§å°çš„æ•´æ•°å’Œä»»æ„ç²¾åº¦çš„æµ®ç‚¹æ•°
- å›ºå®šç²¾åº¦çš„åè¿›åˆ¶å°æ•°ï¼Œå¸¸ç”¨äºè´§å¸ç›¸å…³çš„åœºæ™¯

å¥½åœ¨ç¤¾åŒºå·²ç»å¼€å‘å‡ºé«˜è´¨é‡çš„ Rust æ•°å€¼åº“ï¼š[num](https://crates.io/crates/num)ã€‚

æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ¥å¼•å…¥ `num` åº“ï¼š

1. åˆ›å»ºæ–°å·¥ç¨‹ `cargo new complex-num && cd complex-num`
2. åœ¨ `Cargo.toml` ä¸­çš„ `[dependencies]` ä¸‹æ·»åŠ ä¸€è¡Œ `num = "0.4.0"`
3. å°† `src/main.rs` æ–‡ä»¶ä¸­çš„ `main` å‡½æ•°æ›¿æ¢ä¸ºä¸‹é¢çš„ä»£ç 
4. è¿è¡Œ `cargo run`

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```

## æ€»ç»“

ä¹‹å‰æåˆ°è¿‡ Rust çš„æ•°å€¼ç±»å‹å’Œè¿ç®—è·Ÿå…¶ä»–è¯­è¨€ç›¸ä¼¼ï¼Œäº‹å®ä¸Šè¿˜æ˜¯å­˜åœ¨ä¸€äº›å·®å¼‚ï¼Œä¾‹å¦‚è¯­æ³•å·®å¼‚ï¼Œå†æ¯”å¦‚ï¼š

- **Rust æ‹¥æœ‰ç›¸å½“å¤šçš„æ•°å€¼ç±»å‹**. å› æ­¤ä½ éœ€è¦ç†Ÿæ‚‰è¿™äº›ç±»å‹æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼Œè¿™æ ·å°±çŸ¥é“è¯¥ç±»å‹å…è®¸çš„å¤§å°èŒƒå›´ä»¥åŠä½ é€‰æ‹©çš„ç±»å‹æ˜¯å¦èƒ½è¡¨è¾¾è´Ÿæ•°
- **ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„**. Rust æ°¸è¿œä¹Ÿä¸ä¼šå·å·æŠŠä½ çš„ 16bit æ•´æ•°è½¬æ¢æˆ 32bit æ•´æ•°
- **Rust çš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•**. ä¾‹å¦‚ä½ å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ¥å°† `13.14` å–æ•´ï¼š`13.14_f32.round()`ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ç±»å‹åç¼€ï¼Œå› ä¸ºç¼–è¯‘å™¨éœ€è¦çŸ¥é“ `13.14` çš„å…·ä½“ç±»å‹

æ•°å€¼ç±»å‹çš„è®²è§£å·²ç»åŸºæœ¬ç»“æŸï¼Œæ¥ä¸‹æ¥ï¼Œæ¥çœ‹çœ‹å­—ç¬¦å’Œå¸ƒå°”ç±»å‹ã€‚


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/basic-types/numbers.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/numbers.md)ã€‚






================================================
FILE: src/basic/base-type/statement-expression.md
================================================
# è¯­å¥å’Œè¡¨è¾¾å¼ 

Rust çš„å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œæœ€åç”±ä¸€ä¸ªè¡¨è¾¾å¼æ¥è¿”å›å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // è¯­å¥
    let y = y + 5; // è¯­å¥
    x + y // è¡¨è¾¾å¼
}
```

è¯­å¥ä¼šæ‰§è¡Œä¸€äº›æ“ä½œä½†æ˜¯ä¸ä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œè€Œè¡¨è¾¾å¼ä¼šåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼ï¼Œå› æ­¤åœ¨ä¸Šè¿°å‡½æ•°ä½“çš„ä¸‰è¡Œä»£ç ä¸­ï¼Œå‰ä¸¤è¡Œæ˜¯è¯­å¥ï¼Œæœ€åä¸€è¡Œæ˜¯è¡¨è¾¾å¼ã€‚



å¯¹äº Rust è¯­è¨€è€Œè¨€ï¼Œ**è¿™ç§åŸºäºè¯­å¥ï¼ˆstatementï¼‰å’Œè¡¨è¾¾å¼ï¼ˆexpressionï¼‰çš„æ–¹å¼æ˜¯éå¸¸é‡è¦çš„ï¼Œä½ éœ€è¦èƒ½æ˜ç¡®çš„åŒºåˆ†è¿™ä¸¤ä¸ªæ¦‚å¿µ**ï¼Œä½†æ˜¯å¯¹äºå¾ˆå¤šå…¶å®ƒè¯­è¨€è€Œè¨€ï¼Œè¿™ä¸¤ä¸ªå¾€å¾€æ— éœ€åŒºåˆ†ã€‚åŸºäºè¡¨è¾¾å¼æ˜¯å‡½æ•°å¼è¯­è¨€çš„é‡è¦ç‰¹å¾ï¼Œ**è¡¨è¾¾å¼æ€»è¦è¿”å›å€¼**ã€‚


å…¶å®ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å·²ç»å¤šæ¬¡ä½¿ç”¨è¿‡è¯­å¥å’Œè¡¨è¾¾å¼ã€‚

## è¯­å¥

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

ä»¥ä¸Šéƒ½æ˜¯è¯­å¥ï¼Œå®ƒä»¬å®Œæˆäº†ä¸€ä¸ªå…·ä½“çš„æ“ä½œï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¿”å›å€¼ï¼Œå› æ­¤æ˜¯è¯­å¥ã€‚

ç”±äº `let` æ˜¯è¯­å¥ï¼Œå› æ­¤ä¸èƒ½å°† `let` è¯­å¥èµ‹å€¼ç»™å…¶å®ƒå€¼ï¼Œå¦‚ä¸‹å½¢å¼æ˜¯é”™è¯¯çš„ï¼š

```rust
let b = (let a = 8);
```

é”™è¯¯å¦‚ä¸‹:

```console
error: expected expression, found statement (`let`) // æœŸæœ›è¡¨è¾¾å¼ï¼Œå´å‘ç°`let`è¯­å¥
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`æ˜¯ä¸€æ¡è¯­å¥

error[E0658]: `let` expressions in this position are experimental
          // ä¸‹é¢çš„ `let` ç”¨æ³•ç›®å‰æ˜¯è¯•éªŒæ€§çš„ï¼Œåœ¨ç¨³å®šç‰ˆä¸­å°šä¸èƒ½ä½¿ç”¨
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`

```

ä»¥ä¸Šçš„é”™è¯¯å‘Šè¯‰æˆ‘ä»¬ `let` æ˜¯è¯­å¥ï¼Œä¸æ˜¯è¡¨è¾¾å¼ï¼Œå› æ­¤å®ƒä¸è¿”å›å€¼ï¼Œä¹Ÿå°±ä¸èƒ½ç»™å…¶å®ƒå˜é‡èµ‹å€¼ã€‚ä½†æ˜¯è¯¥é”™è¯¯è¿˜é€æ¼äº†ä¸€ä¸ªé‡è¦çš„ä¿¡æ¯ï¼Œ `let` ä½œä¸ºè¡¨è¾¾å¼å·²ç»æ˜¯è¯•éªŒåŠŸèƒ½äº†ï¼Œä¹Ÿè®¸ä¸ä¹…çš„å°†æ¥ï¼Œæˆ‘ä»¬åœ¨ [`stable rust`](https://course.rs/appendix/rust-version.html) ä¸‹å¯ä»¥è¿™æ ·ä½¿ç”¨ã€‚

## è¡¨è¾¾å¼

è¡¨è¾¾å¼ä¼šè¿›è¡Œæ±‚å€¼ï¼Œç„¶åè¿”å›ä¸€ä¸ªå€¼ã€‚ä¾‹å¦‚ `5 + 6`ï¼Œåœ¨æ±‚å€¼åï¼Œè¿”å›å€¼ `11`ï¼Œå› æ­¤å®ƒå°±æ˜¯ä¸€æ¡è¡¨è¾¾å¼ã€‚

è¡¨è¾¾å¼å¯ä»¥æˆä¸ºè¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œä¾‹å¦‚ `let y = 6` ä¸­ï¼Œ`6` å°±æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼ `6`ï¼ˆæœ‰äº›åç›´è§‰ï¼Œä½†æ˜¯ç¡®å®æ˜¯è¡¨è¾¾å¼ï¼‰ã€‚

è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ˜¯è¡¨è¾¾å¼ï¼Œå› ä¸ºä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œè°ƒç”¨å®ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œç”¨èŠ±æ‹¬å·åŒ…è£¹æœ€ç»ˆè¿”å›ä¸€ä¸ªå€¼çš„è¯­å¥å—ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œæ€»ä¹‹ï¼Œèƒ½è¿”å›å€¼ï¼Œå®ƒå°±æ˜¯è¡¨è¾¾å¼:

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

ä¸Šé¢ä½¿ç”¨ä¸€ä¸ªè¯­å¥å—è¡¨è¾¾å¼å°†å€¼èµ‹ç»™ `y` å˜é‡ï¼Œè¯­å¥å—é•¿è¿™æ ·ï¼š

```rust
{
    let x = 3;
    x + 1
}
```

è¯¥è¯­å¥å—æ˜¯è¡¨è¾¾å¼çš„åŸå› æ˜¯ï¼šå®ƒçš„æœ€åä¸€è¡Œæ˜¯è¡¨è¾¾å¼ï¼Œè¿”å›äº† `x + 1` çš„å€¼ï¼Œæ³¨æ„ `x + 1` ä¸èƒ½ä»¥åˆ†å·ç»“å°¾ï¼Œå¦åˆ™å°±ä¼šä»è¡¨è¾¾å¼å˜æˆè¯­å¥ï¼Œ **è¡¨è¾¾å¼ä¸èƒ½åŒ…å«åˆ†å·**ã€‚è¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼Œä¸€æ—¦ä½ åœ¨è¡¨è¾¾å¼ååŠ ä¸Šåˆ†å·ï¼Œå®ƒå°±ä¼šå˜æˆä¸€æ¡è¯­å¥ï¼Œå†ä¹Ÿ**ä¸ä¼š**è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯·ç‰¢è®°ï¼

æœ€åï¼Œè¡¨è¾¾å¼å¦‚æœä¸è¿”å›ä»»ä½•å€¼ï¼Œä¼šéšå¼åœ°è¿”å›ä¸€ä¸ª [`()`](https://course.rs/basic/base-type/char-bool.html#å•å…ƒç±»å‹) ã€‚

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if è¯­å¥å—ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨äºèµ‹å€¼ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å›
    // ç±»ä¼¼ä¸‰å…ƒè¿ç®—ç¬¦ï¼Œåœ¨Rusté‡Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // æˆ–è€…å†™æˆä¸€è¡Œ
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/basic-types/statements-expressions.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/statements.md)ã€‚




================================================
FILE: src/basic/collections/hashmap.md
================================================
[Binary file]


================================================
FILE: src/basic/collections/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/collections/vector.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/array.md
================================================
# æ•°ç»„

åœ¨æ—¥å¸¸å¼€å‘ä¸­ï¼Œä½¿ç”¨æœ€å¹¿çš„æ•°æ®ç»“æ„ä¹‹ä¸€å°±æ˜¯æ•°ç»„ï¼Œåœ¨ Rust ä¸­ï¼Œæœ€å¸¸ç”¨çš„æ•°ç»„æœ‰ä¸¤ç§ï¼Œç¬¬ä¸€ç§æ˜¯é€Ÿåº¦å¾ˆå¿«ä½†æ˜¯é•¿åº¦å›ºå®šçš„ `array`ï¼Œç¬¬äºŒç§æ˜¯å¯åŠ¨æ€å¢é•¿çš„ä½†æ˜¯æœ‰æ€§èƒ½æŸè€—çš„ `Vector`ï¼Œåœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬ç§° `array` ä¸ºæ•°ç»„ï¼Œ`Vector` ä¸ºåŠ¨æ€æ•°ç»„ã€‚

ä¸çŸ¥é“ä½ ä»¬å‘ç°æ²¡ï¼Œè¿™ä¸¤ä¸ªæ•°ç»„çš„å…³ç³»è·Ÿ `&str` ä¸ `String` çš„å…³ç³»å¾ˆåƒï¼Œå‰è€…æ˜¯é•¿åº¦å›ºå®šçš„å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œåè€…æ˜¯å¯åŠ¨æ€å¢é•¿çš„å­—ç¬¦ä¸²ã€‚å…¶å®ï¼Œåœ¨ Rust ä¸­æ— è®ºæ˜¯ `String` è¿˜æ˜¯ `Vector`ï¼Œå®ƒä»¬éƒ½æ˜¯ Rust çš„é«˜çº§ç±»å‹ï¼šé›†åˆç±»å‹ï¼Œåœ¨åé¢ç« èŠ‚ä¼šæœ‰è¯¦ç»†ä»‹ç»ã€‚

å¯¹äºæœ¬ç« èŠ‚ï¼Œæˆ‘ä»¬çš„é‡ç‚¹è¿˜æ˜¯æ”¾åœ¨æ•°ç»„ `array` ä¸Šã€‚æ•°ç»„çš„å…·ä½“å®šä¹‰å¾ˆç®€å•ï¼šå°†å¤šä¸ªç±»å‹ç›¸åŒçš„å…ƒç´ ä¾æ¬¡ç»„åˆåœ¨ä¸€èµ·ï¼Œå°±æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚ç»“åˆä¸Šé¢çš„å†…å®¹ï¼Œå¯ä»¥å¾—å‡ºæ•°ç»„çš„ä¸‰è¦ç´ ï¼š

- é•¿åº¦å›ºå®š
- å…ƒç´ å¿…é¡»æœ‰ç›¸åŒçš„ç±»å‹
- ä¾æ¬¡çº¿æ€§æ’åˆ—

è¿™é‡Œå†å•°å—¦ä¸€å¥ï¼Œ**æˆ‘ä»¬è¿™é‡Œè¯´çš„æ•°ç»„æ˜¯ Rust çš„åŸºæœ¬ç±»å‹ï¼Œæ˜¯å›ºå®šé•¿åº¦çš„ï¼Œè¿™ç‚¹ä¸å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸åŒï¼Œå…¶å®ƒç¼–ç¨‹è¯­è¨€çš„æ•°ç»„å¾€å¾€æ˜¯å¯å˜é•¿åº¦çš„ï¼Œä¸ Rust ä¸­çš„åŠ¨æ€æ•°ç»„ `Vector` ç±»ä¼¼**ï¼Œå¸Œæœ›è¯»è€…å¤§å¤§ç‰¢è®°æ­¤ç‚¹ã€‚

### åˆ›å»ºæ•°ç»„

åœ¨ Rust ä¸­ï¼Œæ•°ç»„æ˜¯è¿™æ ·å®šä¹‰çš„ï¼š

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

æ•°ç»„è¯­æ³•è·Ÿ JavaScript å¾ˆåƒï¼Œä¹Ÿè·Ÿå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€å¾ˆåƒã€‚ç”±äºå®ƒçš„å…ƒç´ ç±»å‹å¤§å°å›ºå®šï¼Œä¸”é•¿åº¦ä¹Ÿæ˜¯å›ºå®šï¼Œå› æ­¤**æ•°ç»„ `array` æ˜¯å­˜å‚¨åœ¨æ ˆä¸Š**ï¼Œæ€§èƒ½ä¹Ÿä¼šéå¸¸ä¼˜ç§€ã€‚ä¸æ­¤å¯¹åº”ï¼Œ**åŠ¨æ€æ•°ç»„ `Vector` æ˜¯å­˜å‚¨åœ¨å †ä¸Š**ï¼Œå› æ­¤é•¿åº¦å¯ä»¥åŠ¨æ€æ”¹å˜ã€‚å½“ä½ ä¸ç¡®å®šæ˜¯ä½¿ç”¨æ•°ç»„è¿˜æ˜¯åŠ¨æ€æ•°ç»„æ—¶ï¼Œé‚£å°±åº”è¯¥ä½¿ç”¨åè€…ï¼Œå…·ä½“è§[åŠ¨æ€æ•°ç»„ Vector](https://course.rs/basic/collections/vector.html)ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨éœ€è¦çŸ¥é“ä¸€å¹´ä¸­å„ä¸ªæœˆä»½åç§°çš„ç¨‹åºä¸­ï¼Œä½ å¾ˆå¯èƒ½å¸Œæœ›ä½¿ç”¨çš„æ˜¯æ•°ç»„è€Œä¸æ˜¯åŠ¨æ€æ•°ç»„ã€‚å› ä¸ºæœˆä»½æ˜¯å›ºå®šçš„ï¼Œå®ƒæ€»æ˜¯åªåŒ…å« 12 ä¸ªå…ƒç´ ï¼š

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

åœ¨ä¸€äº›æ—¶å€™ï¼Œè¿˜éœ€è¦ä¸º**æ•°ç»„å£°æ˜ç±»å‹**ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

è¿™é‡Œï¼Œæ•°ç»„ç±»å‹æ˜¯é€šè¿‡æ–¹æ‹¬å·è¯­æ³•å£°æ˜ï¼Œ`i32` æ˜¯å…ƒç´ ç±»å‹ï¼Œåˆ†å·åé¢çš„æ•°å­— `5` æ˜¯æ•°ç»„é•¿åº¦ï¼Œæ•°ç»„ç±»å‹ä¹Ÿä»ä¾§é¢è¯´æ˜äº†**æ•°ç»„çš„å…ƒç´ ç±»å‹è¦ç»Ÿä¸€ï¼Œé•¿åº¦è¦å›ºå®š**ã€‚

è¿˜å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„è¯­æ³•åˆå§‹åŒ–ä¸€ä¸ª**æŸä¸ªå€¼é‡å¤å‡ºç° N æ¬¡çš„æ•°ç»„**ï¼š

```rust
let a = [3; 5];
```

`a` æ•°ç»„åŒ…å« `5` ä¸ªå…ƒç´ ï¼Œè¿™äº›å…ƒç´ çš„åˆå§‹åŒ–å€¼ä¸º `3`ï¼Œèªæ˜çš„è¯»è€…å·²ç»å‘ç°ï¼Œè¿™ç§è¯­æ³•è·Ÿæ•°ç»„ç±»å‹çš„å£°æ˜è¯­æ³•å…¶å®æ˜¯ä¿æŒä¸€è‡´çš„ï¼š`[3; 5]` å’Œ `[ç±»å‹; é•¿åº¦]`ã€‚

åœ¨å…ƒç´ é‡å¤çš„åœºæ™¯ï¼Œè¿™ç§å†™æ³•è¦ç®€å•çš„å¤šï¼Œå¦åˆ™ä½ å°±å¾—ç–¯ç‹‚æ•²å‡»é”®ç›˜ï¼š`let a = [3, 3, 3, 3, 3];`ï¼Œä¸è¿‡è€æ¿å¯èƒ½å¾ˆå–œæ¬¢ä½ çš„è¿™ç§ç–¯ç‹‚ç¼–ç¨‹çš„çŠ¶æ€ã€‚

### è®¿é—®æ•°ç»„å…ƒç´ 

å› ä¸ºæ•°ç»„æ˜¯è¿ç»­å­˜æ”¾å…ƒç´ çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡ç´¢å¼•çš„æ–¹å¼æ¥è®¿é—®å­˜æ”¾å…¶ä¸­çš„å…ƒç´ ï¼š

```rust
fn main() {
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // è·å–aæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ 
    let second = a[1]; // è·å–ç¬¬äºŒä¸ªå…ƒç´ 
}
```

ä¸è®¸å¤šè¯­è¨€ç±»ä¼¼ï¼Œæ•°ç»„çš„ç´¢å¼•ä¸‹æ ‡æ˜¯ä» 0 å¼€å§‹çš„ã€‚æ­¤å¤„ï¼Œ`first` è·å–åˆ°çš„å€¼æ˜¯ `9`ï¼Œ`second` æ˜¯ `8`ã€‚

#### è¶Šç•Œè®¿é—®

å¦‚æœä½¿ç”¨è¶…å‡ºæ•°ç»„èŒƒå›´çš„ç´¢å¼•è®¿é—®æ•°ç»„å…ƒç´ ï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿä¸‹é¢æ˜¯ä¸€ä¸ªæ¥æ”¶ç”¨æˆ·çš„æ§åˆ¶å°è¾“å…¥ï¼Œç„¶åå°†å…¶ä½œä¸ºç´¢å¼•è®¿é—®æ•°ç»„å…ƒç´ çš„ä¾‹å­ï¼š

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();
    // è¯»å–æ§åˆ¶å°çš„è¾“å‡º
    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

ä½¿ç”¨ `cargo run` æ¥è¿è¡Œä»£ç ï¼Œå› ä¸ºæ•°ç»„åªæœ‰ 5 ä¸ªå…ƒç´ ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾è¾“å…¥ `5` å»è®¿é—®ç¬¬ 6 ä¸ªå…ƒç´ ï¼Œåˆ™ä¼šè®¿é—®åˆ°ä¸å­˜åœ¨çš„æ•°ç»„å…ƒç´ ï¼Œæœ€ç»ˆç¨‹åºä¼šå´©æºƒé€€å‡ºï¼š

```console
Please enter an array index.
5
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

è¿™å°±æ˜¯æ•°ç»„è®¿é—®è¶Šç•Œï¼Œè®¿é—®äº†æ•°ç»„ä¸­ä¸å­˜åœ¨çš„å…ƒç´ ï¼Œå¯¼è‡´ Rust è¿è¡Œæ—¶é”™è¯¯ã€‚ç¨‹åºå› æ­¤é€€å‡ºå¹¶æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼Œæœªæ‰§è¡Œæœ€åçš„ `println!` è¯­å¥ã€‚

å½“ä½ å°è¯•ä½¿ç”¨ç´¢å¼•è®¿é—®å…ƒç´ æ—¶ï¼ŒRust å°†æ£€æŸ¥ä½ æŒ‡å®šçš„ç´¢å¼•æ˜¯å¦å°äºæ•°ç»„é•¿åº¦ã€‚å¦‚æœç´¢å¼•å¤§äºæˆ–ç­‰äºæ•°ç»„é•¿åº¦ï¼ŒRust ä¼šå‡ºç° **_panic_**ã€‚è¿™ç§æ£€æŸ¥åªèƒ½åœ¨è¿è¡Œæ—¶è¿›è¡Œï¼Œæ¯”å¦‚åœ¨ä¸Šé¢è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸçŸ¥é“ç”¨æˆ·è¿è¡Œä»£ç æ—¶å°†è¾“å…¥ä»€ä¹ˆå€¼ã€‚

è¿™ç§å°±æ˜¯ Rust çš„å®‰å…¨ç‰¹æ€§ä¹‹ä¸€ã€‚åœ¨å¾ˆå¤šç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå¹¶ä¸ä¼šæ£€æŸ¥æ•°ç»„è¶Šç•Œé—®é¢˜ï¼Œä½ ä¼šè®¿é—®åˆ°æ— æ•ˆçš„å†…å­˜åœ°å€è·å–åˆ°ä¸€ä¸ªé£é©¬ç‰›ä¸ç›¸åŠçš„å€¼ï¼Œæœ€ç»ˆå¯¼è‡´åœ¨ç¨‹åºé€»è¾‘ä¸Šå‡ºç°å¤§é—®é¢˜ï¼Œè€Œä¸”è¿™ç§é—®é¢˜ä¼šéå¸¸éš¾ä»¥æ£€æŸ¥ã€‚

#### æ•°ç»„å…ƒç´ ä¸ºéåŸºç¡€ç±»å‹

å­¦ä¹ äº†ä¸Šé¢çš„çŸ¥è¯†ï¼Œå¾ˆå¤šæœ‹å‹è‚¯å®šè§‰å¾—å·²ç»å­¦ä¼šäº† Rust çš„æ•°ç»„ç±»å‹ï¼Œä½†ç°å®ä¼šç»™æˆ‘ä»¬ä¸€è®°é‡é”¤ï¼Œå®é™…å¼€å‘ä¸­è¿˜ä¼šç¢°åˆ°ä¸€ç§æƒ…å†µï¼Œå°±æ˜¯**æ•°ç»„å…ƒç´ æ˜¯éåŸºæœ¬ç±»å‹**çš„ï¼Œè¿™æ—¶å€™å¤§å®¶ä¸€å®šä¼šè¿™æ ·å†™ã€‚

```rust
let array = [String::from("rust is good!"); 8];

println!("{:#?}", array);
```

ç„¶åä½ ä¼šæƒŠå–œçš„å¾—åˆ°ç¼–è¯‘é”™è¯¯ã€‚

```console
error[E0277]: the trait bound `String: std::marker::Copy` is not satisfied
 --> src/main.rs:7:18
  |
7 |     let array = [String::from("rust is good!"); 8];
  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `String`
  |
  = note: the `Copy` trait is required because this value will be copied for each element of the array
```

æœ‰äº›è¿˜æ²¡æœ‰çœ‹è¿‡ç‰¹å¾çš„å°ä¼™ä¼´ï¼Œæœ‰å¯èƒ½ä¸å¤ªæ˜ç™½è¿™ä¸ªæŠ¥é”™ï¼Œä¸è¿‡è¿™ä¸ªç›®å‰å¯ä»¥ä¸æï¼Œæˆ‘ä»¬å°±æ‹¿ä¹‹å‰æ‰€å­¦çš„[æ‰€æœ‰æƒ](https://course.rs/basic/ownership/ownership.html)çŸ¥è¯†ï¼Œå°±å¯ä»¥æ€è€ƒæ˜ç™½ï¼Œå‰é¢å‡ ä¸ªä¾‹å­éƒ½æ˜¯ Rust çš„åŸºæœ¬ç±»å‹ï¼Œè€Œ**åŸºæœ¬ç±»å‹åœ¨ Rust ä¸­èµ‹å€¼æ˜¯ä»¥ Copy çš„å½¢å¼**ï¼Œè¿™æ—¶å€™ä½ å°±æ‡‚äº†å§ï¼Œ`let array=[3;5]`åº•å±‚å°±æ˜¯ä¸æ–­çš„Copyå‡ºæ¥çš„ï¼Œä½†å¾ˆå¯æƒœå¤æ‚ç±»å‹éƒ½æ²¡æœ‰æ·±æ‹·è´ï¼Œåªèƒ½ä¸€ä¸ªä¸ªåˆ›å»ºã€‚

æ¥ç€å°±æœ‰å°ä¼™ä¼´ä¼šè¿™æ ·å†™ã€‚

```rust
let array = [String::from("rust is good!"),String::from("rust is good!"),String::from("rust is good!")];

println!("{:#?}", array);
```

ä½œä¸ºä¸€ä¸ªè¿½æ±‚æè‡´å®Œç¾çš„Rustå¼€å‘è€…ï¼Œæ€ä¹ˆèƒ½å®¹å¿ä¸Šé¢è¿™ä¹ˆéš¾çœ‹çš„ä»£ç å­˜åœ¨ï¼

**æ­£ç¡®çš„å†™æ³•**ï¼Œåº”è¯¥è°ƒç”¨`std::array::from_fn`

```rust
let array: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));

println!("{:#?}", array);
```

## æ•°ç»„åˆ‡ç‰‡

åœ¨ä¹‹å‰çš„[ç« èŠ‚](https://course.rs/basic/compound-type/string-slice.html#åˆ‡ç‰‡slice)ï¼Œæˆ‘ä»¬æœ‰è®²åˆ° `åˆ‡ç‰‡` è¿™ä¸ªæ¦‚å¿µï¼Œå®ƒå…è®¸ä½ å¼•ç”¨é›†åˆä¸­çš„éƒ¨åˆ†è¿ç»­ç‰‡æ®µï¼Œè€Œä¸æ˜¯æ•´ä¸ªé›†åˆï¼Œå¯¹äºæ•°ç»„ä¹Ÿæ˜¯ï¼Œæ•°ç»„åˆ‡ç‰‡å…è®¸æˆ‘ä»¬å¼•ç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†ï¼š

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

ä¸Šé¢çš„æ•°ç»„åˆ‡ç‰‡ `slice` çš„ç±»å‹æ˜¯`&[i32]`ï¼Œä¸ä¹‹å¯¹æ¯”ï¼Œæ•°ç»„çš„ç±»å‹æ˜¯`[i32;5]`ï¼Œç®€å•æ€»ç»“ä¸‹åˆ‡ç‰‡çš„ç‰¹ç‚¹ï¼š

- åˆ‡ç‰‡çš„é•¿åº¦å¯ä»¥ä¸æ•°ç»„ä¸åŒï¼Œå¹¶ä¸æ˜¯å›ºå®šçš„ï¼Œè€Œæ˜¯å–å†³äºä½ ä½¿ç”¨æ—¶æŒ‡å®šçš„èµ·å§‹å’Œç»“æŸä½ç½®
- åˆ›å»ºåˆ‡ç‰‡çš„ä»£ä»·éå¸¸å°ï¼Œå› ä¸ºåˆ‡ç‰‡åªæ˜¯é’ˆå¯¹åº•å±‚æ•°ç»„çš„ä¸€ä¸ªå¼•ç”¨
- åˆ‡ç‰‡ç±»å‹ [T] æ‹¥æœ‰ä¸å›ºå®šçš„å¤§å°ï¼Œè€Œåˆ‡ç‰‡å¼•ç”¨ç±»å‹ &[T] åˆ™å…·æœ‰å›ºå®šçš„å¤§å°ï¼Œå› ä¸º Rust å¾ˆå¤šæ—¶å€™éƒ½éœ€è¦å›ºå®šå¤§å°æ•°æ®ç±»å‹ï¼Œå› æ­¤ &[T] æ›´æœ‰ç”¨ï¼Œ`&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ä¹ŸåŒç†

## æ€»ç»“

æœ€åï¼Œè®©æˆ‘ä»¬ä»¥ä¸€ä¸ªç»¼åˆæ€§ä½¿ç”¨æ•°ç»„çš„ä¾‹å­ï¼Œæ¥ç»“æŸæœ¬ç« èŠ‚çš„å­¦ä¹ ï¼š

```rust
fn main() {
  // ç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼å‡ºoneçš„ç±»å‹
  let one             = [1, 2, 3];
  // æ˜¾å¼ç±»å‹æ ‡æ³¨
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];

  // arraysæ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ ç±»å‹æ˜¯[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];

  // å€Ÿç”¨arraysçš„å…ƒç´ ç”¨ä½œå¾ªç¯ä¸­
  for a in &arrays {
    print!("{:?}: ", a);
    // å°†aå˜æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œç”¨äºå¾ªç¯
    // ä½ ä¹Ÿå¯ä»¥ç›´æ¥ç”¨for n in a {}æ¥è¿›è¡Œå¾ªç¯
    for n in a.iter() {
      print!("\t{} + 10 = {}", n, n+10);
    }

    let mut sum = 0;
    // 0..a.len,æ˜¯ä¸€ä¸ª Rust çš„è¯­æ³•ç³–ï¼Œå…¶å®å°±ç­‰äºä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ æ˜¯ä»0,1,2ä¸€ç›´å¢åŠ åˆ°åˆ°a.len-1
    for i in 0..a.len() {
      sum += a[i];
    }
    println!("\t({:?} = {})", a, sum);
  }
}
```

åšä¸ªæ€»ç»“ï¼Œæ•°ç»„è™½ç„¶å¾ˆç®€å•ï¼Œä½†æ˜¯å…¶å®è¿˜æ˜¯å­˜åœ¨å‡ ä¸ªè¦æ³¨æ„çš„ç‚¹ï¼š

- **æ•°ç»„ç±»å‹å®¹æ˜“è·Ÿæ•°ç»„åˆ‡ç‰‡æ··æ·†**ï¼Œ[T;n] æè¿°äº†ä¸€ä¸ªæ•°ç»„çš„ç±»å‹ï¼Œè€Œ [T] æè¿°äº†åˆ‡ç‰‡çš„ç±»å‹ï¼Œ å› ä¸ºåˆ‡ç‰‡æ˜¯è¿è¡ŒæœŸçš„æ•°æ®ç»“æ„ï¼Œå®ƒçš„é•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æœŸå¾—çŸ¥ï¼Œå› æ­¤ä¸èƒ½ç”¨ [T;n] çš„å½¢å¼å»æè¿°
- `[u8; 3]`å’Œ`[u8; 4]`æ˜¯ä¸åŒçš„ç±»å‹ï¼Œæ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†
- **åœ¨å®é™…å¼€å‘ä¸­ï¼Œä½¿ç”¨æœ€å¤šçš„æ˜¯æ•°ç»„åˆ‡ç‰‡[T]**ï¼Œæˆ‘ä»¬å¾€å¾€é€šè¿‡å¼•ç”¨çš„æ–¹å¼å»ä½¿ç”¨`&[T]`ï¼Œå› ä¸ºåè€…æœ‰å›ºå®šçš„ç±»å‹å¤§å°

è‡³æ­¤ï¼Œå…³äºæ•°æ®ç±»å‹éƒ¨åˆ†ï¼Œæˆ‘ä»¬å·²ç»å…¨éƒ¨å­¦å®Œäº†ï¼Œå¯¹äº Rust å­¦ä¹ è€Œè¨€ï¼Œæˆ‘ä»¬ä¹Ÿè¿ˆå‡ºäº†åšå®šçš„ç¬¬ä¸€æ­¥ï¼Œåé¢å°†å¼€å§‹æ›´é«˜çº§ç‰¹æ€§çš„å­¦ä¹ ã€‚æœªæ¥å¦‚æœå¤§å®¶æœ‰ç–‘æƒ‘éœ€è¦æ£€ç´¢çŸ¥è¯†ï¼Œä¸€æ ·å¯ä»¥ç»§ç»­å›é¡¾è¿‡å¾€çš„ç« èŠ‚ï¼Œå› ä¸ºæœ¬ä¹¦ä¸ä»…ä»…æ˜¯ä¸€é—¨ Rust çš„æ•™ç¨‹ï¼Œè¿˜æ˜¯ä¸€æœ¬åšé‡çš„ Rust å·¥å…·ä¹¦ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/compound-types/array.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/array.md)ã€‚



================================================
FILE: src/basic/compound-type/enum.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/intro.md
================================================
# å¤åˆç±»å‹

è¡Œç™¾é‡Œè€…åŠä¹åï¼Œæ¬¢è¿å¤§å®¶æ¥åˆ°è¿™é‡Œï¼Œè™½ç„¶è¿˜ä¸åˆ°ä¸­ç‚¹ï¼Œä½†æ˜¯å·²ç»ä¸è¿œäº†ã€‚å¦‚æœè¯´ä¹‹å‰å­¦çš„åŸºç¡€æ•°æ®ç±»å‹æ˜¯åŸå­ï¼Œé‚£ä¹ˆæœ¬ç« å°†è®²çš„æ•°æ®ç±»å‹å¯ä»¥è®¤ä¸ºæ˜¯åˆ†å­ã€‚

æœ¬ç« çš„é‡ç‚¹åœ¨å¤åˆç±»å‹ä¸Šï¼Œé¡¾åæ€ä¹‰ï¼Œå¤åˆç±»å‹æ˜¯ç”±å…¶å®ƒç±»å‹ç»„åˆè€Œæˆçš„ï¼Œæœ€å…¸å‹çš„å°±æ˜¯ç»“æ„ä½“ `struct` å’Œæšä¸¾ `enum`ã€‚ä¾‹å¦‚å¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹ `point(x, y)`ï¼Œå®ƒç”±ä¸¤ä¸ªæ•°å€¼ç±»å‹çš„å€¼ `x` å’Œ `y` ç»„åˆè€Œæ¥ã€‚æˆ‘ä»¬æ— æ³•å•ç‹¬å»ç»´æŠ¤è¿™ä¸¤ä¸ªæ•°å€¼ï¼Œå› ä¸ºå•ç‹¬ä¸€ä¸ª `x` æˆ–è€… `y` æ˜¯å«ä¹‰ä¸å®Œæ•´çš„ï¼Œæ— æ³•æ ‡è¯†å¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œåº”è¯¥æŠŠå®ƒä»¬çœ‹ä½œä¸€ä¸ªæ•´ä½“å»ç†è§£å’Œå¤„ç†ã€‚

æ¥çœ‹ä¸€æ®µä»£ç ï¼Œå®ƒä½¿ç”¨æˆ‘ä»¬ä¹‹å‰å­¦è¿‡çš„å†…å®¹æ¥æ„å»ºæ–‡ä»¶æ“ä½œï¼š

```rust
#![allow(unused_variables)]
type File = String;

fn open(f: &mut File) -> bool {
    true
}
fn close(f: &mut File) -> bool {
    true
}

#[allow(dead_code)]
fn read(f: &mut File, save_to: &mut Vec<u8>) -> ! {
    unimplemented!()
}

fn main() {
    let mut f1 = File::from("f1.txt");
    open(&mut f1);
    //read(&mut f1, &mut vec![]);
    close(&mut f1);
}
```

æ¥ä¸‹æ¥æˆ‘ä»¬çš„å­¦ä¹ éå¸¸ç±»ä¼¼åŸå‹è®¾è®¡ï¼šæœ‰çš„æ–¹æ³•åªæä¾› API æ¥å£ï¼Œä½†æ˜¯ä¸æä¾›å…·ä½“å®ç°ã€‚æ­¤å¤–ï¼Œæœ‰çš„å˜é‡åœ¨å£°æ˜ä¹‹åå¹¶æœªä½¿ç”¨ï¼Œå› æ­¤åœ¨è¿™ä¸ªé˜¶æ®µæˆ‘ä»¬éœ€è¦æ’é™¤ä¸€äº›ç¼–è¯‘å™¨å™ªéŸ³ï¼ˆRust åœ¨ç¼–è¯‘çš„æ—¶å€™ä¼šæ‰«æä»£ç ï¼Œå˜é‡å£°æ˜åæœªä½¿ç”¨ä¼šä»¥ `warning` è­¦å‘Šçš„å½¢å¼è¿›è¡Œæç¤ºï¼‰ï¼Œå¼•å…¥ `#![allow(unused_variables)]` å±æ€§æ ‡è®°ï¼Œè¯¥æ ‡è®°ä¼šå‘Šè¯‰ç¼–è¯‘å™¨å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡ï¼Œä¸è¦æŠ›å‡º `warning` è­¦å‘Šï¼Œå…·ä½“çš„å¸¸è§ç¼–è¯‘å™¨å±æ€§ä½ å¯ä»¥åœ¨è¿™é‡ŒæŸ¥é˜…ï¼š[ç¼–è¯‘å™¨å±æ€§æ ‡è®°](https://course.rs/profiling/compiler/attributes.html)ã€‚

`read` å‡½æ•°ä¹Ÿéå¸¸æœ‰è¶£ï¼Œå®ƒè¿”å›ä¸€ä¸ª `!` ç±»å‹ï¼Œè¿™ä¸ªè¡¨æ˜è¯¥å‡½æ•°æ˜¯ä¸€ä¸ªå‘æ•£å‡½æ•°ï¼Œä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼ŒåŒ…æ‹¬ `()`ã€‚`unimplemented!()` å‘Šè¯‰ç¼–è¯‘å™¨è¯¥å‡½æ•°å°šæœªå®ç°ï¼Œ`unimplemented!()` æ ‡è®°é€šå¸¸æ„å‘³ç€æˆ‘ä»¬æœŸæœ›å¿«é€Ÿå®Œæˆä¸»è¦ä»£ç ï¼Œå›å¤´å†é€šè¿‡æœç´¢è¿™äº›æ ‡è®°æ¥å®Œæˆæ¬¡è¦ä»£ç ï¼Œç±»ä¼¼çš„æ ‡è®°è¿˜æœ‰ `todo!()`ï¼Œå½“ä»£ç æ‰§è¡Œåˆ°è¿™ç§æœªå®ç°çš„åœ°æ–¹æ—¶ï¼Œç¨‹åºä¼šç›´æ¥æŠ¥é”™ã€‚ä½ å¯ä»¥åæ³¨é‡Š `read(&mut f1, &mut vec![]);` è¿™è¡Œï¼Œç„¶åå†è§‚å¯Ÿä¸‹ç»“æœã€‚

åŒæ—¶ï¼Œä»ä»£ç è®¾è®¡è§’åº¦æ¥çœ‹ï¼Œå…³äºæ–‡ä»¶æ“ä½œçš„ç±»å‹å’Œå‡½æ•°åº”è¯¥ç»„ç»‡åœ¨ä¸€èµ·ï¼Œæ•£è½å¾—åˆ°å¤„éƒ½æ˜¯ï¼Œæ˜¯éš¾ä»¥ç®¡ç†å’Œä½¿ç”¨çš„ã€‚è€Œä¸”é€šè¿‡ `open(&mut f1)` è¿›è¡Œè°ƒç”¨ï¼Œä¹Ÿè¿œæ²¡æœ‰ä½¿ç”¨ `f1.open()` æ¥è°ƒç”¨å¥½ï¼Œè¿™å°±ä½“ç°å‡ºäº†åªä½¿ç”¨åŸºæœ¬ç±»å‹çš„å±€é™æ€§ï¼š**æ— æ³•ä»æ›´é«˜çš„æŠ½è±¡å±‚æ¬¡å»ç®€åŒ–ä»£ç **ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å¼•å…¥ä¸€ä¸ªé«˜çº§æ•°æ®ç»“æ„ â€”â€” ç»“æ„ä½“ `struct`ï¼Œæ¥çœ‹çœ‹å¤åˆç±»å‹æ˜¯æ€æ ·æ›´å¥½çš„è§£å†³è¿™ç±»é—®é¢˜ã€‚ å¼€å§‹ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹ Rust çš„é‡ç‚¹ä¹Ÿæ˜¯éš¾ç‚¹ï¼šå­—ç¬¦ä¸² `String` å’Œ `&str`ã€‚



================================================
FILE: src/basic/compound-type/string-slice.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/struct.md
================================================
# ç»“æ„ä½“

ä¸Šä¸€èŠ‚ä¸­æåˆ°éœ€è¦ä¸€ä¸ªæ›´é«˜çº§çš„æ•°æ®ç»“æ„æ¥å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„æŠ½è±¡é—®é¢˜ï¼Œç»“æ„ä½“ `struct` æ°æ°å°±æ˜¯è¿™æ ·çš„å¤åˆæ•°æ®ç»“æ„ï¼Œå®ƒæ˜¯ç”±å…¶å®ƒæ•°æ®ç±»å‹ç»„åˆè€Œæ¥ã€‚ å…¶å®ƒè¯­è¨€ä¹Ÿæœ‰ç±»ä¼¼çš„æ•°æ®ç»“æ„ï¼Œä¸è¿‡å¯èƒ½æœ‰ä¸åŒçš„åç§°ï¼Œä¾‹å¦‚ `object`ã€ `record` ç­‰ã€‚

ç»“æ„ä½“è·Ÿä¹‹å‰è®²è¿‡çš„[å…ƒç»„](https://course.rs/basic/compound-type/tuple.html)æœ‰äº›ç›¸åƒï¼šéƒ½æ˜¯ç”±å¤šç§ç±»å‹ç»„åˆè€Œæˆã€‚ä½†æ˜¯ä¸å…ƒç»„ä¸åŒçš„æ˜¯ï¼Œç»“æ„ä½“å¯ä»¥ä¸ºå†…éƒ¨çš„æ¯ä¸ªå­—æ®µèµ·ä¸€ä¸ªå¯Œæœ‰å«ä¹‰çš„åç§°ã€‚å› æ­¤ç»“æ„ä½“æ›´åŠ çµæ´»æ›´åŠ å¼ºå¤§ï¼Œä½ æ— éœ€ä¾èµ–è¿™äº›å­—æ®µçš„é¡ºåºæ¥è®¿é—®å’Œè§£æå®ƒä»¬ã€‚

## ç»“æ„ä½“è¯­æ³•

å¤©ä¸‹æ— æ•Œçš„å‰‘å£«å¾€å¾€ä¹Ÿå› ä¸ºä»–æœ‰ä¸€æŸ„æ— åŒä¹‹å‰‘ï¼Œæ—¢ç„¶ç»“æ„ä½“è¿™ä¹ˆå¼ºå¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦ç»™å®ƒé…å¥—ä¸€å¥—å¼ºå¤§çš„è¯­æ³•ï¼Œè®©ç”¨æˆ·èƒ½æ›´å¥½çš„é©¾é©­ã€‚

#### å®šä¹‰ç»“æ„ä½“

ä¸€ä¸ªç»“æ„ä½“ç”±å‡ éƒ¨åˆ†ç»„æˆï¼š

- é€šè¿‡å…³é”®å­— `struct` å®šä¹‰
- ä¸€ä¸ªæ¸…æ™°æ˜ç¡®çš„ç»“æ„ä½“ `åç§°`
- å‡ ä¸ªæœ‰åå­—çš„ç»“æ„ä½“ `å­—æ®µ`

ä¾‹å¦‚, ä»¥ä¸‹ç»“æ„ä½“å®šä¹‰äº†æŸç½‘ç«™çš„ç”¨æˆ·ï¼š

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

è¯¥ç»“æ„ä½“åç§°æ˜¯ `User`ï¼Œæ‹¥æœ‰ 4 ä¸ªå­—æ®µï¼Œä¸”æ¯ä¸ªå­—æ®µéƒ½æœ‰å¯¹åº”çš„å­—æ®µååŠç±»å‹å£°æ˜ï¼Œä¾‹å¦‚ `username` ä»£è¡¨äº†ç”¨æˆ·åï¼Œæ˜¯ä¸€ä¸ªå¯å˜çš„ `String` ç±»å‹ã€‚

#### åˆ›å»ºç»“æ„ä½“å®ä¾‹

ä¸ºäº†ä½¿ç”¨ä¸Šè¿°ç»“æ„ä½“ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»º `User` ç»“æ„ä½“çš„**å®ä¾‹**ï¼š

```rust
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
```

æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„:

1. åˆå§‹åŒ–å®ä¾‹æ—¶ï¼Œ**æ¯ä¸ªå­—æ®µ**éƒ½éœ€è¦è¿›è¡Œåˆå§‹åŒ–
2. åˆå§‹åŒ–æ—¶çš„å­—æ®µé¡ºåº**ä¸éœ€è¦**å’Œç»“æ„ä½“å®šä¹‰æ—¶çš„é¡ºåºä¸€è‡´

#### è®¿é—®ç»“æ„ä½“å­—æ®µ

é€šè¿‡ `.` æ“ä½œç¬¦å³å¯è®¿é—®ç»“æ„ä½“å®ä¾‹å†…éƒ¨çš„å­—æ®µå€¼ï¼Œä¹Ÿå¯ä»¥ä¿®æ”¹å®ƒä»¬ï¼š

```rust
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¿…é¡»è¦å°†ç»“æ„ä½“å®ä¾‹å£°æ˜ä¸ºå¯å˜çš„ï¼Œæ‰èƒ½ä¿®æ”¹å…¶ä¸­çš„å­—æ®µï¼ŒRust ä¸æ”¯æŒå°†æŸä¸ªç»“æ„ä½“æŸä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜ã€‚

#### ç®€åŒ–ç»“æ„ä½“åˆ›å»º

ä¸‹é¢çš„å‡½æ•°ç±»ä¼¼ä¸€ä¸ªæ„å»ºå‡½æ•°ï¼Œè¿”å›äº† `User` ç»“æ„ä½“çš„å®ä¾‹ï¼š

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

å®ƒæ¥æ”¶ä¸¤ä¸ªå­—ç¬¦ä¸²å‚æ•°ï¼š `email` å’Œ `username`ï¼Œç„¶åä½¿ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ª `User` ç»“æ„ä½“ï¼Œå¹¶ä¸”è¿”å›ã€‚å¯ä»¥æ³¨æ„åˆ°è¿™ä¸¤è¡Œï¼š `email: email` å’Œ `username: username`ï¼Œéå¸¸çš„æ‰çœ¼ï¼Œå› ä¸ºå®åœ¨æœ‰äº›å•°å—¦ï¼Œå¦‚æœä½ ä» TypeScript è¿‡æ¥ï¼Œè‚¯å®šä¼šé„™è§† Rust ä¸€ç•ªï¼Œä¸è¿‡å¥½åœ¨ï¼Œå®ƒä¹Ÿä¸æ˜¯æ— å¯æ•‘è¯ï¼š

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå½“å‡½æ•°å‚æ•°å’Œç»“æ„ä½“å­—æ®µåŒåæ—¶ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ç¼©ç•¥çš„æ–¹å¼è¿›è¡Œåˆå§‹åŒ–ï¼Œè·Ÿ TypeScript ä¸­ä¸€æ¨¡ä¸€æ ·ã€‚

#### ç»“æ„ä½“æ›´æ–°è¯­æ³•

åœ¨å®é™…åœºæ™¯ä¸­ï¼Œæœ‰ä¸€ç§æƒ…å†µå¾ˆå¸¸è§ï¼šæ ¹æ®å·²æœ‰çš„ç»“æ„ä½“å®ä¾‹ï¼Œåˆ›å»ºæ–°çš„ç»“æ„ä½“å®ä¾‹ï¼Œä¾‹å¦‚æ ¹æ®å·²æœ‰çš„ `user1` å®ä¾‹æ¥æ„å»º `user2`ï¼š

```rust
  let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
```

è€è¯é‡æï¼Œå¦‚æœä½ ä» TypeScript è¿‡æ¥ï¼Œè‚¯å®šè§‰å¾—å•°å—¦çˆ†äº†ï¼šç«Ÿç„¶æ‰‹åŠ¨æŠŠ `user1` çš„ä¸‰ä¸ªå­—æ®µé€ä¸ªèµ‹å€¼ç»™ `user2`ï¼Œå¥½åœ¨ Rust ä¸ºæˆ‘ä»¬æä¾›äº† `ç»“æ„ä½“æ›´æ–°è¯­æ³•`ï¼š

```rust
  let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
```

å› ä¸º `user2` ä»…ä»…åœ¨ `email` ä¸Šä¸ `user1` ä¸åŒï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦å¯¹ `email` è¿›è¡Œèµ‹å€¼ï¼Œå‰©ä¸‹çš„é€šè¿‡ç»“æ„ä½“æ›´æ–°è¯­æ³• `..user1` å³å¯å®Œæˆã€‚

`..` è¯­æ³•è¡¨æ˜å‡¡æ˜¯æˆ‘ä»¬æ²¡æœ‰æ˜¾å¼å£°æ˜çš„å­—æ®µï¼Œå…¨éƒ¨ä» `user1` ä¸­è‡ªåŠ¨è·å–ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ `..user1` å¿…é¡»åœ¨ç»“æ„ä½“çš„å°¾éƒ¨ä½¿ç”¨ã€‚

> ç»“æ„ä½“æ›´æ–°è¯­æ³•è·Ÿèµ‹å€¼è¯­å¥ `=` éå¸¸ç›¸åƒï¼Œå› æ­¤åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œ`user1` çš„éƒ¨åˆ†å­—æ®µæ‰€æœ‰æƒè¢«è½¬ç§»åˆ° `user2` ä¸­ï¼š`username` å­—æ®µå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Œä½œä¸ºç»“æœï¼Œ`user1` æ— æ³•å†è¢«ä½¿ç”¨ã€‚
>
> èªæ˜çš„è¯»è€…è‚¯å®šè¦å‘é—®äº†ï¼šæ˜æ˜æœ‰ä¸‰ä¸ªå­—æ®µè¿›è¡Œäº†è‡ªåŠ¨èµ‹å€¼ï¼Œä¸ºä½•åªæœ‰ `username` å‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Ÿ
>
> ä»”ç»†å›æƒ³ä¸€ä¸‹[æ‰€æœ‰æƒ](https://course.rs/basic/ownership/ownership.html#æ‹·è´æµ…æ‹·è´)é‚£ä¸€èŠ‚çš„å†…å®¹ï¼Œæˆ‘ä»¬æåˆ°äº† `Copy` ç‰¹å¾ï¼šå®ç°äº† `Copy` ç‰¹å¾çš„ç±»å‹æ— éœ€æ‰€æœ‰æƒè½¬ç§»ï¼Œå¯ä»¥ç›´æ¥åœ¨èµ‹å€¼æ—¶è¿›è¡Œ
>æ•°æ®æ‹·è´ï¼Œå…¶ä¸­ `bool` å’Œ `u64` ç±»å‹å°±å®ç°äº† `Copy` ç‰¹å¾ï¼Œå› æ­¤ `active` å’Œ `sign_in_count` å­—æ®µåœ¨èµ‹å€¼ç»™ `user2` æ—¶ï¼Œä»…ä»…å‘ç”Ÿäº†æ‹·è´ï¼Œè€Œä¸æ˜¯æ‰€æœ‰æƒè½¬ç§»ã€‚
>
> å€¼å¾—æ³¨æ„çš„æ˜¯ï¼š`username` æ‰€æœ‰æƒè¢«è½¬ç§»ç»™äº† `user2`ï¼Œå¯¼è‡´äº† `user1` æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å¹¶ä¸ä»£è¡¨ `user1` å†…éƒ¨çš„å…¶å®ƒå­—æ®µä¸èƒ½è¢«ç»§ç»­ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

```rust
# #[derive(Debug)]
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# fn main() {
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
let user2 = User {
    active: user1.active,
    username: user1.username,
    email: String::from("another@example.com"),
    sign_in_count: user1.sign_in_count,
};
println!("{}", user1.active);
// ä¸‹é¢è¿™è¡Œä¼šæŠ¥é”™
println!("{:?}", user1);
# }
```

## ç»“æ„ä½“çš„å†…å­˜æ’åˆ—

å…ˆæ¥çœ‹ä»¥ä¸‹ä»£ç ï¼š

```rust
#[derive(Debug)]
 struct File {
   name: String,
   data: Vec<u8>,
 }

 fn main() {
   let f1 = File {
     name: String::from("f1.txt"),
     data: Vec::new(),
   };

   let f1_name = &f1.name;
   let f1_length = &f1.data.len();

   println!("{:?}", f1);
   println!("{} is {} bytes long", f1_name, f1_length);
 }
```

ä¸Šé¢å®šä¹‰çš„ `File` ç»“æ„ä½“åœ¨å†…å­˜ä¸­çš„æ’åˆ—å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
<img alt="" src="https://pic3.zhimg.com/80/v2-8cc4ed8cd06d60f974d06ca2199b8df5_1440w.png" class="center"  />

ä»å›¾ä¸­å¯ä»¥æ¸…æ™°åœ°çœ‹å‡º `File` ç»“æ„ä½“ä¸¤ä¸ªå­—æ®µ `name` å’Œ `data` åˆ†åˆ«æ‹¥æœ‰åº•å±‚ä¸¤ä¸ª `[u8]` æ•°ç»„çš„æ‰€æœ‰æƒï¼ˆ`String` ç±»å‹çš„åº•å±‚ä¹Ÿæ˜¯ `[u8]` æ•°ç»„ï¼‰ï¼Œé€šè¿‡ `ptr` æŒ‡é’ˆæŒ‡å‘åº•å±‚æ•°ç»„çš„å†…å­˜åœ°å€ï¼Œè¿™é‡Œä½ å¯ä»¥æŠŠ `ptr` æŒ‡é’ˆç†è§£ä¸º Rust ä¸­çš„å¼•ç”¨ç±»å‹ã€‚

è¯¥å›¾ç‰‡ä¹Ÿä¾§é¢å°è¯äº†ï¼š**æŠŠç»“æ„ä½“ä¸­å…·æœ‰æ‰€æœ‰æƒçš„å­—æ®µè½¬ç§»å‡ºå»åï¼Œå°†æ— æ³•å†è®¿é—®è¯¥å­—æ®µï¼Œä½†æ˜¯å¯ä»¥æ­£å¸¸è®¿é—®å…¶å®ƒçš„å­—æ®µ**ã€‚

## å…ƒç»„ç»“æ„ä½“(Tuple Struct)

ç»“æ„ä½“å¿…é¡»è¦æœ‰åç§°ï¼Œä½†æ˜¯ç»“æ„ä½“çš„å­—æ®µå¯ä»¥æ²¡æœ‰åç§°ï¼Œè¿™ç§ç»“æ„ä½“é•¿å¾—å¾ˆåƒå…ƒç»„ï¼Œå› æ­¤è¢«ç§°ä¸ºå…ƒç»„ç»“æ„ä½“ï¼Œä¾‹å¦‚ï¼š

```rust
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
```

å…ƒç»„ç»“æ„ä½“åœ¨ä½ å¸Œæœ›æœ‰ä¸€ä¸ªæ•´ä½“åç§°ï¼Œä½†æ˜¯åˆä¸å…³å¿ƒé‡Œé¢å­—æ®µçš„åç§°æ—¶å°†éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ä¸Šé¢çš„ `Point` å…ƒç»„ç»“æ„ä½“ï¼Œä¼—æ‰€å‘¨çŸ¥ 3D ç‚¹æ˜¯ `(x, y, z)` å½¢å¼çš„åæ ‡ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬æ— éœ€å†ä¸ºå†…éƒ¨çš„å­—æ®µé€ä¸€å‘½åä¸ºï¼š`x`, `y`, `z`ã€‚

## å•å…ƒç»“æ„ä½“(Unit-like Struct)

è¿˜è®°å¾—ä¹‹å‰è®²è¿‡çš„åŸºæœ¬æ²¡å•¥ç”¨çš„[å•å…ƒç±»å‹](https://course.rs/basic/base-type/char-bool.html#å•å…ƒç±»å‹)å§ï¼Ÿå•å…ƒç»“æ„ä½“å°±è·Ÿå®ƒå¾ˆåƒï¼Œæ²¡æœ‰ä»»ä½•å­—æ®µå’Œå±æ€§ï¼Œä½†æ˜¯å¥½åœ¨ï¼Œå®ƒè¿˜æŒºæœ‰ç”¨ã€‚

å¦‚æœä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `å•å…ƒç»“æ„ä½“`ï¼š

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;

// æˆ‘ä»¬ä¸å…³å¿ƒ AlwaysEqual çš„å­—æ®µæ•°æ®ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºï¼Œå› æ­¤å°†å®ƒå£°æ˜ä¸ºå•å…ƒç»“æ„ä½“ï¼Œç„¶åå†ä¸ºå®ƒå®ç°æŸä¸ªç‰¹å¾
impl SomeTrait for AlwaysEqual {

}
```

## ç»“æ„ä½“æ•°æ®çš„æ‰€æœ‰æƒ

åœ¨ä¹‹å‰çš„ `User` ç»“æ„ä½“çš„å®šä¹‰ä¸­ï¼Œæœ‰ä¸€å¤„ç»†èŠ‚ï¼šæˆ‘ä»¬ä½¿ç”¨äº†è‡ªèº«æ‹¥æœ‰æ‰€æœ‰æƒçš„ `String` ç±»å‹è€Œä¸æ˜¯åŸºäºå¼•ç”¨çš„ `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ã€‚è¿™æ˜¯ä¸€ä¸ªæœ‰æ„è€Œä¸ºä¹‹çš„é€‰æ‹©ï¼šå› ä¸ºæˆ‘ä»¬æƒ³è¦è¿™ä¸ªç»“æ„ä½“æ‹¥æœ‰å®ƒæ‰€æœ‰çš„æ•°æ®ï¼Œè€Œä¸æ˜¯ä»å…¶å®ƒåœ°æ–¹å€Ÿç”¨æ•°æ®ã€‚

ä½ ä¹Ÿå¯ä»¥è®© `User` ç»“æ„ä½“ä»å…¶å®ƒå¯¹è±¡å€Ÿç”¨æ•°æ®ï¼Œä¸è¿‡è¿™ä¹ˆåšï¼Œå°±éœ€è¦å¼•å…¥[ç”Ÿå‘½å‘¨æœŸ(lifetimes)](https://course.rs/basic/lifetime.html)è¿™ä¸ªæ–°æ¦‚å¿µï¼ˆä¹Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„æ¦‚å¿µï¼‰ï¼Œç®€è€Œè¨€ä¹‹ï¼Œç”Ÿå‘½å‘¨æœŸèƒ½ç¡®ä¿ç»“æ„ä½“çš„ä½œç”¨èŒƒå›´è¦æ¯”å®ƒæ‰€å€Ÿç”¨çš„æ•°æ®çš„ä½œç”¨èŒƒå›´è¦å°ã€‚

æ€»ä¹‹ï¼Œå¦‚æœä½ æƒ³åœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨ä¸€ä¸ªå¼•ç”¨ï¼Œå°±å¿…é¡»åŠ ä¸Šç”Ÿå‘½å‘¨æœŸï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™ï¼š

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

ç¼–è¯‘å™¨ä¼šæŠ±æ€¨å®ƒéœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡è¯†ç¬¦ï¼š

```console
error[E0106]: missing lifetime specifier
 --> src/main.rs:2:15
  |
2 |     username: &str,
  |               ^ expected named lifetime parameter // éœ€è¦ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ
  |
help: consider introducing a named lifetime parameter // è€ƒè™‘åƒä¸‹é¢çš„ä»£ç è¿™æ ·å¼•å…¥ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ
  |
1 ~ struct User<'a> {
2 ~     username: &'a str,
  |

error[E0106]: missing lifetime specifier
 --> src/main.rs:3:12
  |
3 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     username: &str,
3 ~     email: &'a str,
  |
```

æœªæ¥åœ¨[ç”Ÿå‘½å‘¨æœŸ](https://course.rs/basic/lifetime.html)ä¸­ä¼šè®²åˆ°å¦‚ä½•ä¿®å¤è¿™ä¸ªé—®é¢˜ä»¥ä¾¿åœ¨ç»“æ„ä½“ä¸­å­˜å‚¨å¼•ç”¨ï¼Œä¸è¿‡åœ¨é‚£ä¹‹å‰ï¼Œæˆ‘ä»¬ä¼šé¿å…åœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨å¼•ç”¨ç±»å‹ã€‚

## ä½¿ç”¨ `#[derive(Debug)]` æ¥æ‰“å°ç»“æ„ä½“çš„ä¿¡æ¯

åœ¨å‰é¢çš„ä»£ç ä¸­æˆ‘ä»¬ä½¿ç”¨ `#[derive(Debug)]` å¯¹ç»“æ„ä½“è¿›è¡Œäº†æ ‡è®°ï¼Œè¿™æ ·æ‰èƒ½ä½¿ç”¨ `println!("{:?}", s);` çš„æ–¹å¼å¯¹å…¶è¿›è¡Œæ‰“å°è¾“å‡ºï¼Œå¦‚æœä¸åŠ ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ:

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

é¦–å…ˆå¯ä»¥è§‚å¯Ÿåˆ°ï¼Œä¸Šé¢ä½¿ç”¨äº† `{}` è€Œä¸æ˜¯ä¹‹å‰çš„ `{:?}`ï¼Œè¿è¡ŒåæŠ¥é”™ï¼š

```shell
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

æç¤ºæˆ‘ä»¬ç»“æ„ä½“ `Rectangle` æ²¡æœ‰å®ç° `Display` ç‰¹å¾ï¼Œè¿™æ˜¯å› ä¸ºå¦‚æœæˆ‘ä»¬ä½¿ç”¨ `{}` æ¥æ ¼å¼åŒ–è¾“å‡ºï¼Œé‚£å¯¹åº”çš„ç±»å‹å°±å¿…é¡»å®ç° `Display` ç‰¹å¾ï¼Œä»¥å‰å­¦ä¹ çš„åŸºæœ¬ç±»å‹ï¼Œéƒ½é»˜è®¤å®ç°äº†è¯¥ç‰¹å¾:

```rust
fn main() {
    let v = 1;
    let b = true;

    println!("{}, {}", v, b);
}
```

ä¸Šé¢ä»£ç ä¸ä¼šæŠ¥é”™ï¼Œé‚£ä¹ˆç»“æ„ä½“ä¸ºä»€ä¹ˆä¸é»˜è®¤å®ç° `Display` ç‰¹å¾å‘¢ï¼ŸåŸå› åœ¨äºç»“æ„ä½“è¾ƒä¸ºå¤æ‚ï¼Œä¾‹å¦‚è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼šä½ æƒ³è¦é€—å·å¯¹å­—æ®µè¿›è¡Œåˆ†å‰²å—ï¼Ÿéœ€è¦æ‹¬å·å—ï¼ŸåŠ åœ¨ä»€ä¹ˆåœ°æ–¹ï¼Ÿæ‰€æœ‰çš„å­—æ®µéƒ½åº”è¯¥æ˜¾ç¤ºï¼Ÿç±»ä¼¼çš„è¿˜æœ‰å¾ˆå¤šï¼Œç”±äºè¿™ç§å¤æ‚æ€§ï¼ŒRust ä¸å¸Œæœ›çŒœæµ‹æˆ‘ä»¬æƒ³è¦çš„æ˜¯ä»€ä¹ˆï¼Œè€Œæ˜¯æŠŠé€‰æ‹©æƒäº¤ç»™æˆ‘ä»¬è‡ªå·±æ¥å®ç°ï¼šå¦‚æœè¦ç”¨ `{}` çš„æ–¹å¼æ‰“å°ç»“æ„ä½“ï¼Œé‚£å°±è‡ªå·±å®ç° `Display` ç‰¹å¾ã€‚

æ¥ä¸‹æ¥ç»§ç»­é˜…è¯»æŠ¥é”™ï¼š

```shell
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

ä¸Šé¢æç¤ºæˆ‘ä»¬ä½¿ç”¨ `{:?}` æ¥è¯•è¯•ï¼Œè¿™ä¸ªæ–¹å¼æˆ‘ä»¬åœ¨æœ¬æ–‡çš„å‰é¢ä¹Ÿè§è¿‡ï¼Œä¸‹é¢æ¥è¯•è¯•:

```rust
println!("rect1 is {:?}", rect1);
```

å¯æ˜¯ä¾ç„¶æ— æƒ…æŠ¥é”™äº†:

```shell
error[E0277]: `Rectangle` doesn't implement `Debug`
```

å¥½åœ¨ï¼Œèªæ˜çš„ç¼–è¯‘å™¨åˆä¸€æ¬¡ç»™å‡ºäº†æç¤º:

```shell
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

è®©æˆ‘ä»¬å®ç° `Debug` ç‰¹å¾ï¼ŒOh Noï¼Œå°±æ˜¯ä¸æƒ³å®ç° `Display` ç‰¹å¾ï¼Œæ‰ç”¨çš„ `{:?}`ï¼Œæ€ä¹ˆåˆè¦å®ç° `Debug`ï¼Œä½†æ˜¯ä»”ç»†çœ‹ï¼Œæç¤ºä¸­æœ‰ä¸€è¡Œï¼š `add #[derive(Debug)] to Rectangle`ï¼Œ å“¦ï¼Ÿè¿™ä¸å°±æ˜¯æˆ‘ä»¬å‰æ–‡ä¸€ç›´åœ¨ä½¿ç”¨çš„å—ï¼Ÿ

é¦–å…ˆï¼ŒRust é»˜è®¤ä¸ä¼šä¸ºæˆ‘ä»¬å®ç° `Debug`ï¼Œä¸ºäº†å®ç°ï¼Œæœ‰ä¸¤ç§æ–¹å¼å¯ä»¥é€‰æ‹©ï¼š

- æ‰‹åŠ¨å®ç°
- ä½¿ç”¨ `derive` æ´¾ç”Ÿå®ç°

åè€…ç®€å•çš„å¤šï¼Œä½†æ˜¯ä¹Ÿæœ‰é™åˆ¶ï¼Œå…·ä½“è§[é™„å½• D](https://course.rs/appendix/derive.html)ï¼Œè¿™é‡Œæˆ‘ä»¬å°±ä¸å†æ·±å…¥è®²è§£ï¼Œæ¥çœ‹çœ‹è¯¥å¦‚ä½•ä½¿ç”¨:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

æ­¤æ—¶è¿è¡Œç¨‹åºï¼Œå°±ä¸å†æœ‰é”™è¯¯ï¼Œè¾“å‡ºå¦‚ä¸‹:

```shell
$ cargo run
rect1 is Rectangle { width: 30, height: 50 }
```

è¿™ä¸ªè¾“å‡ºæ ¼å¼çœ‹ä¸Šå»ä¹Ÿä¸èµ–å˜›ï¼Œè™½ç„¶æœªå¿…æ˜¯æœ€å¥½çš„ã€‚è¿™ç§æ ¼å¼æ˜¯ Rust è‡ªåŠ¨ä¸ºæˆ‘ä»¬æä¾›çš„å®ç°ï¼Œçœ‹ä¸ŠåŸºæœ¬å°±è·Ÿç»“æ„ä½“çš„å®šä¹‰å½¢å¼ä¸€æ ·ã€‚

å½“ç»“æ„ä½“è¾ƒå¤§æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›èƒ½å¤Ÿæœ‰æ›´å¥½çš„è¾“å‡ºè¡¨ç°ï¼Œæ­¤æ—¶å¯ä»¥ä½¿ç”¨ `{:#?}` æ¥æ›¿ä»£ `{:?}`ï¼Œè¾“å‡ºå¦‚ä¸‹:

```shell
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```

æ­¤æ—¶ç»“æ„ä½“çš„è¾“å‡ºè·Ÿæˆ‘ä»¬åˆ›å»ºæ—¶å€™çš„ä»£ç å‡ ä¹ä¸€æ¨¡ä¸€æ ·äº†ï¼å½“ç„¶ï¼Œå¦‚æœå¤§å®¶è¿˜æ˜¯ä¸æ»¡è¶³ï¼Œé‚£æœ€å¥½è¿˜æ˜¯è‡ªå·±å®ç° `Display` ç‰¹å¾ï¼Œä»¥å‘ç”¨æˆ·æ›´ç¾çš„å±•ç¤ºä½ çš„ç§è—ç»“æ„ä½“ã€‚å…³äºæ ¼å¼åŒ–è¾“å‡ºçš„æ›´å¤šå†…å®¹ï¼Œæˆ‘ä»¬å¼ºçƒˆæ¨èçœ‹çœ‹è¿™ä¸ª[ç« èŠ‚](https://course.rs/basic/formatted-output.html#debug-ç‰¹å¾)ã€‚

è¿˜æœ‰ä¸€ä¸ªç®€å•çš„è¾“å‡º debug ä¿¡æ¯çš„æ–¹æ³•ï¼Œé‚£å°±æ˜¯ä½¿ç”¨ [`dbg!` å®](https://doc.rust-lang.org/std/macro.dbg.html)ï¼Œå®ƒä¼šæ‹¿èµ°è¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼Œç„¶åæ‰“å°å‡ºç›¸åº”çš„æ–‡ä»¶åã€è¡Œå·ç­‰ debug ä¿¡æ¯ï¼Œå½“ç„¶è¿˜æœ‰æˆ‘ä»¬éœ€è¦çš„è¡¨è¾¾å¼çš„æ±‚å€¼ç»“æœã€‚**é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒæœ€ç»ˆè¿˜ä¼šæŠŠè¡¨è¾¾å¼å€¼çš„æ‰€æœ‰æƒè¿”å›ï¼**

> `dbg!` è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡º `stderr`ï¼Œè€Œ `println!` è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º `stdout`ã€‚

ä¸‹é¢çš„ä¾‹å­ä¸­æ¸…æ™°çš„å±•ç¤ºäº† `dbg!` å¦‚ä½•åœ¨æ‰“å°å‡ºä¿¡æ¯çš„åŒæ—¶ï¼Œè¿˜æŠŠè¡¨è¾¾å¼çš„å€¼èµ‹ç»™äº† `width`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

æœ€ç»ˆçš„ debug è¾“å‡ºå¦‚ä¸‹:

```shell
$ cargo run
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æƒ³è¦çš„ debug ä¿¡æ¯å‡ ä¹éƒ½æœ‰äº†ï¼šä»£ç æ‰€åœ¨çš„æ–‡ä»¶åã€è¡Œå·ã€è¡¨è¾¾å¼ä»¥åŠè¡¨è¾¾å¼çš„å€¼ï¼Œç®€ç›´å®Œç¾ï¼

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/compound-types/struct.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/struct.md)ã€‚




================================================
FILE: src/basic/compound-type/tuple.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/crate.md
================================================
# åŒ…å’Œ Package

å½“è¯»è€…æŒ‰ç…§ç« èŠ‚é¡ºåºè¯»åˆ°æœ¬ç« æ—¶ï¼Œæ„å‘³ç€ä½ å·²ç»å‡ ä¹å…·å¤‡äº†å‚ä¸çœŸå®é¡¹ç›®å¼€å‘çš„èƒ½åŠ›ã€‚ä½†æ˜¯çœŸå®é¡¹ç›®è¿œæ¯”æˆ‘ä»¬ä¹‹å‰çš„ `cargo new` çš„é»˜è®¤ç›®å½•ç»“æ„è¦å¤æ‚ï¼Œå¥½åœ¨ï¼ŒRust ä¸ºæˆ‘ä»¬æä¾›äº†å¼ºå¤§çš„åŒ…ç®¡ç†å·¥å…·ï¼š

- **é¡¹ç›®(Package)**ï¼šå¯ä»¥ç”¨æ¥æ„å»ºã€æµ‹è¯•å’Œåˆ†äº«åŒ…
- **å·¥ä½œç©ºé—´(WorkSpace)**ï¼šå¯¹äºå¤§å‹é¡¹ç›®ï¼Œå¯ä»¥è¿›ä¸€æ­¥å°†å¤šä¸ªåŒ…è”åˆåœ¨ä¸€èµ·ï¼Œç»„ç»‡æˆå·¥ä½œç©ºé—´
- **åŒ…(Crate)**ï¼šä¸€ä¸ªç”±å¤šä¸ªæ¨¡å—ç»„æˆçš„æ ‘å½¢ç»“æ„ï¼Œå¯ä»¥ä½œä¸ºä¸‰æ–¹åº“è¿›è¡Œåˆ†å‘ï¼Œä¹Ÿå¯ä»¥ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶è¿›è¡Œè¿è¡Œ
- **æ¨¡å—(Module)**ï¼šå¯ä»¥ä¸€ä¸ªæ–‡ä»¶å¤šä¸ªæ¨¡å—ï¼Œä¹Ÿå¯ä»¥ä¸€ä¸ªæ–‡ä»¶ä¸€ä¸ªæ¨¡å—ï¼Œæ¨¡å—å¯ä»¥è¢«è®¤ä¸ºæ˜¯çœŸå®é¡¹ç›®ä¸­çš„ä»£ç ç»„ç»‡å•å…ƒ

## å®šä¹‰

å…¶å®é¡¹ç›® `Package` å’ŒåŒ… `Crate` å¾ˆå®¹æ˜“è¢«ææ··ï¼Œç”šè‡³åœ¨å¾ˆå¤šä¹¦ä¸­ï¼Œè¿™ä¸¤è€…éƒ½æ˜¯ä¸åˆ†çš„ï¼Œä½†æ˜¯ç”±äºå®˜æ–¹å¯¹æ­¤åšäº†æ˜ç¡®çš„åŒºåˆ†ï¼Œå› æ­¤æˆ‘ä»¬ä¼šåœ¨æœ¬ç« èŠ‚ä¸­è¯•å›¾ï¼ˆæŒ£æ‰ç€ï¼‰ç†æ¸…è¿™ä¸ªæ¦‚å¿µã€‚

#### åŒ… Crate

å¯¹äº Rust è€Œè¨€ï¼ŒåŒ…æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¯ç¼–è¯‘å•å…ƒï¼Œå®ƒç¼–è¯‘åä¼šç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–è€…ä¸€ä¸ªåº“ã€‚

ä¸€ä¸ªåŒ…ä¼šå°†ç›¸å…³è”çš„åŠŸèƒ½æ‰“åŒ…åœ¨ä¸€èµ·ï¼Œä½¿å¾—è¯¥åŠŸèƒ½å¯ä»¥å¾ˆæ–¹ä¾¿çš„åœ¨å¤šä¸ªé¡¹ç›®ä¸­åˆ†äº«ã€‚ä¾‹å¦‚æ ‡å‡†åº“ä¸­æ²¡æœ‰æä¾›ä½†æ˜¯åœ¨ä¸‰æ–¹åº“ä¸­æä¾›çš„ `rand` åŒ…ï¼Œå®ƒæä¾›äº†éšæœºæ•°ç”Ÿæˆçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¯¥åŒ…é€šè¿‡ `use rand;` å¼•å…¥åˆ°å½“å‰é¡¹ç›®çš„ä½œç”¨åŸŸä¸­ï¼Œå°±å¯ä»¥åœ¨é¡¹ç›®ä¸­ä½¿ç”¨ `rand` çš„åŠŸèƒ½ï¼š`rand::XXX`ã€‚

åŒä¸€ä¸ªåŒ…ä¸­ä¸èƒ½æœ‰åŒåçš„ç±»å‹ï¼Œä½†æ˜¯åœ¨ä¸åŒåŒ…ä¸­å°±å¯ä»¥ã€‚ä¾‹å¦‚ï¼Œè™½ç„¶ `rand` åŒ…ä¸­ï¼Œæœ‰ä¸€ä¸ª `Rng` ç‰¹å¾ï¼Œå¯æ˜¯æˆ‘ä»¬ä¾ç„¶å¯ä»¥åœ¨è‡ªå·±çš„é¡¹ç›®ä¸­å®šä¹‰ä¸€ä¸ª `Rng`ï¼Œå‰è€…é€šè¿‡ `rand::Rng` è®¿é—®ï¼Œåè€…é€šè¿‡ `Rng` è®¿é—®ï¼Œå¯¹äºç¼–è¯‘å™¨è€Œè¨€ï¼Œè¿™ä¸¤è€…çš„è¾¹ç•Œéå¸¸æ¸…æ™°ï¼Œä¸ä¼šå­˜åœ¨å¼•ç”¨æ­§ä¹‰ã€‚

## é¡¹ç›® Package

é‰´äº Rust å›¢é˜Ÿæ ‡æ–°ç«‹å¼‚çš„èµ·åä¼ ç»Ÿï¼Œä»¥åŠåŒ…çš„åç§°è¢« `crate` å ç”¨ï¼Œåº“çš„åç§°è¢« `library` å ç”¨ï¼Œç»è¿‡æ–Ÿé…Œï¼Œ æˆ‘ä»¬å†³å®šå°† `Package` ç¿»è¯‘æˆé¡¹ç›®ï¼Œä½ ä¹Ÿå¯ä»¥ç†è§£ä¸ºå·¥ç¨‹ã€è½¯ä»¶åŒ…ã€‚

ç”±äº `Package` å°±æ˜¯ä¸€ä¸ªé¡¹ç›®ï¼Œå› æ­¤å®ƒåŒ…å«æœ‰ç‹¬ç«‹çš„ `Cargo.toml` æ–‡ä»¶ï¼Œä»¥åŠå› ä¸ºåŠŸèƒ½æ€§è¢«ç»„ç»‡åœ¨ä¸€èµ·çš„ä¸€ä¸ªæˆ–å¤šä¸ªåŒ…ã€‚ä¸€ä¸ª `Package` åªèƒ½åŒ…å«**ä¸€ä¸ª**åº“(library)ç±»å‹çš„åŒ…ï¼Œä½†æ˜¯å¯ä»¥åŒ…å«**å¤šä¸ª**äºŒè¿›åˆ¶å¯æ‰§è¡Œç±»å‹çš„åŒ…ã€‚

#### äºŒè¿›åˆ¶ Package

è®©æˆ‘ä»¬æ¥åˆ›å»ºä¸€ä¸ªäºŒè¿›åˆ¶ `Package`ï¼š

```console
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

è¿™é‡Œï¼ŒCargo ä¸ºæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåç§°æ˜¯ `my-project` çš„ `Package`ï¼ŒåŒæ—¶åœ¨å…¶ä¸­åˆ›å»ºäº† `Cargo.toml` æ–‡ä»¶ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹è¯¥æ–‡ä»¶ï¼Œé‡Œé¢å¹¶æ²¡æœ‰æåˆ° `src/main.rs` ä½œä¸ºç¨‹åºçš„å…¥å£ï¼ŒåŸå› æ˜¯ Cargo æœ‰ä¸€ä¸ªæƒ¯ä¾‹ï¼š**`src/main.rs` æ˜¯äºŒè¿›åˆ¶åŒ…çš„æ ¹æ–‡ä»¶ï¼Œè¯¥äºŒè¿›åˆ¶åŒ…çš„åŒ…åè·Ÿæ‰€å± `Package` ç›¸åŒï¼Œåœ¨è¿™é‡Œéƒ½æ˜¯ `my-project`**ï¼Œæ‰€æœ‰çš„ä»£ç æ‰§è¡Œéƒ½ä»è¯¥æ–‡ä»¶ä¸­çš„ `fn main()` å‡½æ•°å¼€å§‹ã€‚

ä½¿ç”¨ `cargo run` å¯ä»¥è¿è¡Œè¯¥é¡¹ç›®ï¼Œè¾“å‡ºï¼š`Hello, world!`ã€‚

#### åº“ Package

å†æ¥åˆ›å»ºä¸€ä¸ªåº“ç±»å‹çš„ `Package`ï¼š

```console
$ cargo new my-lib --lib
     Created library `my-lib` package
$ ls my-lib
Cargo.toml
src
$ ls my-lib/src
lib.rs
```

é¦–å…ˆï¼Œå¦‚æœä½ è¯•å›¾è¿è¡Œ `my-lib`ï¼Œä¼šæŠ¥é”™ï¼š

```console
$ cargo run
error: a bin target must be available for `cargo run`
```

åŸå› æ˜¯åº“ç±»å‹çš„ `Package` åªèƒ½ä½œä¸ºä¸‰æ–¹åº“è¢«å…¶å®ƒé¡¹ç›®å¼•ç”¨ï¼Œè€Œä¸èƒ½ç‹¬ç«‹è¿è¡Œï¼Œåªæœ‰ä¹‹å‰çš„äºŒè¿›åˆ¶ `Package` æ‰å¯ä»¥è¿è¡Œã€‚

ä¸ `src/main.rs` ä¸€æ ·ï¼ŒCargo çŸ¥é“ï¼Œå¦‚æœä¸€ä¸ª `Package` åŒ…å«æœ‰ `src/lib.rs`ï¼Œæ„å‘³å®ƒåŒ…å«æœ‰ä¸€ä¸ªåº“ç±»å‹çš„åŒååŒ… `my-lib`ï¼Œè¯¥åŒ…çš„æ ¹æ–‡ä»¶æ˜¯ `src/lib.rs`ã€‚

#### æ˜“æ··æ·†çš„ Package å’ŒåŒ…

çœ‹å®Œä¸Šé¢ï¼Œç›¸ä¿¡å¤§å®¶çœ‹å‡ºæ¥ä¸ºä½• `Package` å’ŒåŒ…å®¹æ˜“è¢«æ··æ·†äº†å§ï¼Ÿå› ä¸ºä½ ç”¨ `cargo new` åˆ›å»ºçš„ `Package` å’Œå®ƒå…¶ä¸­åŒ…å«çš„åŒ…æ˜¯åŒåçš„ï¼

ä¸è¿‡ï¼Œåªè¦ä½ ç‰¢è®° `Package` æ˜¯ä¸€ä¸ªé¡¹ç›®å·¥ç¨‹ï¼Œè€ŒåŒ…åªæ˜¯ä¸€ä¸ªç¼–è¯‘å•å…ƒï¼Œä¹Ÿå°±ä¸ä¼šå†æ··æ·†è¿™ä¸¤ä¸ªæ¦‚å¿µï¼š`src/main.rs` å’Œ `src/lib.rs` éƒ½æ˜¯ç¼–è¯‘å•å…ƒï¼Œå› æ­¤å®ƒä»¬éƒ½æ˜¯åŒ…ã€‚

#### å…¸å‹çš„ `Package` ç»“æ„

ä¸Šé¢åˆ›å»ºçš„ `Package` ä¸­ä»…åŒ…å« `src/main.rs` æ–‡ä»¶ï¼Œæ„å‘³ç€å®ƒä»…åŒ…å«ä¸€ä¸ªäºŒè¿›åˆ¶åŒååŒ… `my-project`ã€‚å¦‚æœä¸€ä¸ª `Package` åŒæ—¶æ‹¥æœ‰ `src/main.rs` å’Œ `src/lib.rs`ï¼Œé‚£å°±æ„å‘³ç€å®ƒåŒ…å«ä¸¤ä¸ªåŒ…ï¼šåº“åŒ…å’ŒäºŒè¿›åˆ¶åŒ…ï¼Œè¿™ä¸¤ä¸ªåŒ…åä¹Ÿéƒ½æ˜¯ `my-project` â€”â€” éƒ½ä¸ `Package` åŒåã€‚

ä¸€ä¸ªçœŸå®é¡¹ç›®ä¸­å…¸å‹çš„ `Package`ï¼Œä¼šåŒ…å«å¤šä¸ªäºŒè¿›åˆ¶åŒ…ï¼Œè¿™äº›åŒ…æ–‡ä»¶è¢«æ”¾åœ¨ `src/bin` ç›®å½•ä¸‹ï¼Œæ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æ˜¯ç‹¬ç«‹çš„äºŒè¿›åˆ¶åŒ…ï¼ŒåŒæ—¶ä¹Ÿä¼šåŒ…å«ä¸€ä¸ªåº“åŒ…ï¼Œè¯¥åŒ…åªèƒ½å­˜åœ¨ä¸€ä¸ª `src/lib.rs`ï¼š

```css
.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ bin
â”‚       â””â”€â”€ main1.rs
â”‚       â””â”€â”€ main2.rs
â”œâ”€â”€ tests
â”‚   â””â”€â”€ some_integration_tests.rs
â”œâ”€â”€ benches
â”‚   â””â”€â”€ simple_bench.rs
â””â”€â”€ examples
    â””â”€â”€ simple_example.rs
```

- å”¯ä¸€åº“åŒ…ï¼š`src/lib.rs`
- é»˜è®¤äºŒè¿›åˆ¶åŒ…ï¼š`src/main.rs`ï¼Œç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸ `Package` åŒå
- å…¶ä½™äºŒè¿›åˆ¶åŒ…ï¼š`src/bin/main1.rs` å’Œ `src/bin/main2.rs`ï¼Œå®ƒä»¬ä¼šåˆ†åˆ«ç”Ÿæˆä¸€ä¸ªæ–‡ä»¶åŒåçš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶
- é›†æˆæµ‹è¯•æ–‡ä»¶ï¼š`tests` ç›®å½•ä¸‹
- åŸºå‡†æ€§èƒ½æµ‹è¯• `benchmark` æ–‡ä»¶ï¼š`benches` ç›®å½•ä¸‹
- é¡¹ç›®ç¤ºä¾‹ï¼š`examples` ç›®å½•ä¸‹

è¿™ç§ç›®å½•ç»“æ„åŸºæœ¬ä¸Šæ˜¯ Rust çš„æ ‡å‡†ç›®å½•ç»“æ„ï¼Œåœ¨ `GitHub` çš„å¤§å¤šæ•°é¡¹ç›®ä¸Šï¼Œä½ éƒ½å°†çœ‹åˆ°å®ƒçš„èº«å½±ã€‚

ç†è§£äº†åŒ…çš„æ¦‚å¿µï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹æ„æˆåŒ…çš„åŸºæœ¬å•å…ƒï¼šæ¨¡å—ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/crate-module/crate.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/crate.md)ã€‚


================================================
FILE: src/basic/crate-module/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/module.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/use.md
================================================
# ä½¿ç”¨ use åŠå—é™å¯è§æ€§

å¦‚æœä»£ç ä¸­ï¼Œé€šç¯‡éƒ½æ˜¯ `crate::front_of_house::hosting::add_to_waitlist` è¿™æ ·çš„å‡½æ•°è°ƒç”¨å½¢å¼ï¼Œæˆ‘ä¸çŸ¥é“æœ‰è°ä¼šå–œæ¬¢ï¼Œä¹Ÿè®¸é ä»£ç è¡Œæ•°èµšå·¥èµ„çš„äººä¼šå¾ˆå–œæ¬¢ï¼Œä½†æ˜¯å¼ºè¿«ç—‡è‚¯å®šå—ä¸äº†ï¼Œæ‚²ä¼¤çš„æ˜¯ç¨‹åºå‘˜å¤§å¤šéƒ½æœ‰å¼ºè¿«ç—‡ã€‚ã€‚ã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŠæ³•æ¥ç®€åŒ–è¿™ç§ä½¿ç”¨æ–¹å¼ï¼Œåœ¨ Rust ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `use` å…³é”®å­—æŠŠè·¯å¾„æå‰å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œéšåçš„è°ƒç”¨å°±å¯ä»¥çœç•¥è¯¥è·¯å¾„ï¼Œæå¤§åœ°ç®€åŒ–äº†ä»£ç ã€‚

## åŸºæœ¬å¼•å…¥æ–¹å¼

åœ¨ Rust ä¸­ï¼Œå¼•å…¥æ¨¡å—ä¸­çš„é¡¹æœ‰ä¸¤ç§æ–¹å¼ï¼š[ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„](https://course.rs/basic/crate-module/module.html#ç”¨è·¯å¾„å¼•ç”¨æ¨¡å—)ï¼Œè¿™ä¸¤è€…åœ¨å‰é¢ç« èŠ‚éƒ½æœ‰è®²è¿‡ï¼Œå°±ä¸å†èµ˜è¿°ï¼Œå…ˆæ¥çœ‹çœ‹ä½¿ç”¨ç»å¯¹è·¯å¾„çš„å¼•å…¥æ–¹å¼ã€‚

#### ç»å¯¹è·¯å¾„å¼•å…¥æ¨¡å—

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ `use` å’Œç»å¯¹è·¯å¾„çš„æ–¹å¼ï¼Œå°† `hosting` æ¨¡å—å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œç„¶ååªéœ€é€šè¿‡ `hosting::add_to_waitlist` çš„æ–¹å¼ï¼Œå³å¯è°ƒç”¨ç›®æ ‡æ¨¡å—ä¸­çš„å‡½æ•°ï¼Œç›¸æ¯” `crate::front_of_house::hosting::add_to_waitlist()` çš„æ–¹å¼è¦ç®€å•çš„å¤šï¼Œé‚£ä¹ˆè¿˜èƒ½æ›´ç®€å•å—ï¼Ÿ

#### ç›¸å¯¹è·¯å¾„å¼•å…¥æ¨¡å—ä¸­çš„å‡½æ•°

åœ¨ä¸‹é¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸ä»…è¦ä½¿ç”¨ç›¸å¯¹è·¯å¾„è¿›è¡Œå¼•å…¥ï¼Œè€Œä¸”ä¸ä¸Šé¢å¼•å…¥ `hosting` æ¨¡å—ä¸åŒï¼Œç›´æ¥å¼•å…¥è¯¥æ¨¡å—ä¸­çš„ `add_to_waitlist` å‡½æ•°ï¼š

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```

å¾ˆæ˜æ˜¾ï¼Œä¸‰å…„å¼Ÿåˆå˜å¾—æ›´çŸ­äº†ï¼Œä¸è¿‡ï¼Œæ€ä¹ˆè§‰å¾—è¿™å¥è¯æ€ªæ€ªçš„ã€‚ã€‚

#### å¼•å…¥æ¨¡å—è¿˜æ˜¯å‡½æ•°

ä»ä½¿ç”¨ç®€æ´æ€§æ¥è¯´ï¼Œå¼•å…¥å‡½æ•°è‡ªç„¶æ˜¯æ›´ç”šä¸€ç­¹ï¼Œä½†æ˜¯åœ¨æŸäº›æ—¶å€™ï¼Œå¼•å…¥æ¨¡å—ä¼šæ›´å¥½ï¼š

- éœ€è¦å¼•å…¥åŒä¸€ä¸ªæ¨¡å—çš„å¤šä¸ªå‡½æ•°
- ä½œç”¨åŸŸä¸­å­˜åœ¨åŒåå‡½æ•°

åœ¨ä»¥ä¸Šä¸¤ç§æƒ…å†µä¸­ï¼Œä½¿ç”¨ `use front_of_house::hosting;` å¼•å…¥æ¨¡å—è¦æ¯” `use front_of_house::hosting::add_to_waitlist;` å¼•å…¥å‡½æ•°æ›´å¥½ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæƒ³ä½¿ç”¨ `HashMap`ï¼Œé‚£ä¹ˆç›´æ¥å¼•å…¥è¯¥ç»“æ„ä½“æ˜¯æ¯”å¼•å…¥æ¨¡å—æ›´å¥½çš„é€‰æ‹©ï¼Œå› ä¸ºåœ¨ `collections` æ¨¡å—ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ä¸€ä¸ª `HashMap` ç»“æ„ä½“ï¼š

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

å…¶å®ä¸¥æ ¼æ¥è¯´ï¼Œå¯¹äºå¼•ç”¨æ–¹å¼å¹¶æ²¡æœ‰éœ€è¦éµå®ˆçš„æƒ¯ä¾‹ï¼Œä¸»è¦è¿˜æ˜¯å–å†³äºä½ çš„å–œå¥½ï¼Œä¸è¿‡æˆ‘ä»¬å»ºè®®ï¼š**ä¼˜å…ˆä½¿ç”¨æœ€ç»†ç²’åº¦ï¼ˆå¼•å…¥å‡½æ•°ã€ç»“æ„ä½“ç­‰ï¼‰çš„å¼•ç”¨æ–¹å¼ï¼Œå¦‚æœå¼•èµ·äº†æŸç§éº»çƒ¦ï¼ˆä¾‹å¦‚å‰é¢ä¸¤ç§æƒ…å†µï¼‰ï¼Œå†ä½¿ç”¨å¼•å…¥æ¨¡å—çš„æ–¹å¼**ã€‚

## é¿å…åŒåå¼•ç”¨

æ ¹æ®ä¸Šä¸€ç« èŠ‚çš„å†…å®¹ï¼Œæˆ‘ä»¬åªè¦ä¿è¯åŒä¸€ä¸ªæ¨¡å—ä¸­ä¸å­˜åœ¨åŒåé¡¹å°±è¡Œï¼Œæ¨¡å—ä¹‹é—´ã€åŒ…ä¹‹é—´çš„åŒåï¼Œè°ç®¡å¾—ç€è°å•Šï¼Œè¯è™½å¦‚æ­¤ï¼Œä¸€èµ·çœ‹çœ‹ï¼Œå¦‚æœé‡åˆ°åŒåçš„æƒ…å†µè¯¥å¦‚ä½•å¤„ç†ã€‚

#### æ¨¡å—::å‡½æ•°

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

ä¸Šé¢çš„ä¾‹å­ç»™å‡ºäº†å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œä½¿ç”¨æ¨¡å—å¼•å…¥çš„æ–¹å¼ï¼Œå…·ä½“çš„ `Result` é€šè¿‡ `æ¨¡å—::Result` çš„æ–¹å¼è¿›è¡Œè°ƒç”¨ã€‚

å¯ä»¥çœ‹å‡ºï¼Œé¿å…åŒåå†²çªçš„å…³é”®ï¼Œå°±æ˜¯ä½¿ç”¨**çˆ¶æ¨¡å—çš„æ–¹å¼æ¥è°ƒç”¨**ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯ä»¥ç»™äºˆå¼•å…¥çš„é¡¹èµ·ä¸€ä¸ªåˆ«åã€‚

#### `as` åˆ«åå¼•ç”¨

å¯¹äºåŒåå†²çªé—®é¢˜ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `as` å…³é”®å­—æ¥è§£å†³ï¼Œå®ƒå¯ä»¥èµ‹äºˆå¼•å…¥é¡¹ä¸€ä¸ªå…¨æ–°çš„åç§°ï¼š

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œé¦–å…ˆé€šè¿‡ `use std::io::Result` å°† `Result` å¼•å…¥åˆ°ä½œç”¨åŸŸï¼Œç„¶åä½¿ç”¨ `as` ç»™äºˆå®ƒä¸€ä¸ªå…¨æ–°çš„åç§° `IoResult`ï¼Œè¿™æ ·å°±ä¸ä¼šå†äº§ç”Ÿå†²çªï¼š

- `Result` ä»£è¡¨ `std::fmt::Result`
- `IoResult` ä»£è¡¨ `std:io::Result`

## å¼•å…¥é¡¹å†å¯¼å‡º

å½“å¤–éƒ¨çš„æ¨¡å—é¡¹ `A` è¢«å¼•å…¥åˆ°å½“å‰æ¨¡å—ä¸­æ—¶ï¼Œå®ƒçš„å¯è§æ€§è‡ªåŠ¨è¢«è®¾ç½®ä¸ºç§æœ‰çš„ï¼Œå¦‚æœä½ å¸Œæœ›å…è®¸å…¶å®ƒå¤–éƒ¨ä»£ç å¼•ç”¨æˆ‘ä»¬çš„æ¨¡å—é¡¹ `A`ï¼Œé‚£ä¹ˆå¯ä»¥å¯¹å®ƒè¿›è¡Œå†å¯¼å‡ºï¼š

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

å¦‚ä¸Šï¼Œä½¿ç”¨ `pub use` å³å¯å®ç°ã€‚è¿™é‡Œ `use` ä»£è¡¨å¼•å…¥ `hosting` æ¨¡å—åˆ°å½“å‰ä½œç”¨åŸŸï¼Œ`pub` è¡¨ç¤ºå°†è¯¥å¼•å…¥çš„å†…å®¹å†åº¦è®¾ç½®ä¸ºå¯è§ã€‚

å½“ä½ å¸Œæœ›å°†å†…éƒ¨çš„å®ç°ç»†èŠ‚éšè—èµ·æ¥æˆ–è€…æŒ‰ç…§æŸä¸ªç›®çš„ç»„ç»‡ä»£ç æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `pub use` å†å¯¼å‡ºï¼Œä¾‹å¦‚ç»Ÿä¸€ä½¿ç”¨ä¸€ä¸ªæ¨¡å—æ¥æä¾›å¯¹å¤–çš„ APIï¼Œé‚£è¯¥æ¨¡å—å°±å¯ä»¥å¼•å…¥å…¶å®ƒæ¨¡å—ä¸­çš„ APIï¼Œç„¶åè¿›è¡Œå†å¯¼å‡ºï¼Œæœ€ç»ˆå¯¹äºç”¨æˆ·æ¥è¯´ï¼Œæ‰€æœ‰çš„ API éƒ½æ˜¯ç”±ä¸€ä¸ªæ¨¡å—ç»Ÿä¸€æä¾›çš„ã€‚

## ä½¿ç”¨ç¬¬ä¸‰æ–¹åŒ…

ä¹‹å‰æˆ‘ä»¬ä¸€ç›´åœ¨å¼•å…¥æ ‡å‡†åº“æ¨¡å—æˆ–è€…è‡ªå®šä¹‰æ¨¡å—ï¼Œç°åœ¨æ¥å¼•å…¥ä¸‹ç¬¬ä¸‰æ–¹åŒ…ä¸­çš„æ¨¡å—ï¼Œå…³äºå¦‚ä½•å¼•å…¥å¤–éƒ¨ä¾èµ–ï¼Œæˆ‘ä»¬åœ¨ [Cargo å…¥é—¨](https://course.rs/first-try/cargo.html#package-é…ç½®æ®µè½)ä¸­å°±æœ‰è®²ï¼Œè¿™é‡Œç›´æ¥ç»™å‡ºæ“ä½œæ­¥éª¤ï¼š

1. ä¿®æ”¹ `Cargo.toml` æ–‡ä»¶ï¼Œåœ¨ `[dependencies]` åŒºåŸŸæ·»åŠ ä¸€è¡Œï¼š`rand = "0.8.3"`
2. æ­¤æ—¶ï¼Œå¦‚æœä½ ç”¨çš„æ˜¯ `VSCode` å’Œ `rust-analyzer` æ’ä»¶ï¼Œè¯¥æ’ä»¶ä¼šè‡ªåŠ¨æ‹‰å–è¯¥åº“ï¼Œä½ å¯èƒ½éœ€è¦ç­‰å®ƒå®Œæˆåï¼Œå†è¿›è¡Œä¸‹ä¸€æ­¥ï¼ˆVSCode å·¦ä¸‹è§’æœ‰æç¤ºï¼‰

å¥½äº†ï¼Œæ­¤æ—¶ï¼Œ`rand` åŒ…å·²ç»è¢«æˆ‘ä»¬æ·»åŠ åˆ°ä¾èµ–ä¸­ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯åœ¨ä»£ç ä¸­ä½¿ç”¨ï¼š

```rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
```

è¿™é‡Œä½¿ç”¨ `use` å¼•å…¥äº†ç¬¬ä¸‰æ–¹åŒ… `rand` ä¸­çš„ `Rng` ç‰¹å¾ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è°ƒç”¨çš„ `gen_range` æ–¹æ³•å®šä¹‰åœ¨è¯¥ç‰¹å¾ä¸­ã€‚

#### crates.ioï¼Œlib.rs

Rust ç¤¾åŒºå·²ç»ä¸ºæˆ‘ä»¬è´¡çŒ®äº†å¤§é‡é«˜è´¨é‡çš„ç¬¬ä¸‰æ–¹åŒ…ï¼Œä½ å¯ä»¥åœ¨ `crates.io` æˆ–è€… `lib.rs` ä¸­æ£€ç´¢å’Œä½¿ç”¨ï¼Œä»ç›®å‰æ¥è¯´æŸ¥æ‰¾åŒ…æ›´æ¨è `lib.rs`ï¼Œæœç´¢åŠŸèƒ½æ›´å¼ºå¤§ï¼Œå†…å®¹å±•ç¤ºä¹Ÿæ›´åŠ åˆç†ï¼Œä½†æ˜¯ä¸‹è½½ä¾èµ–åŒ…è¿˜æ˜¯å¾—ç”¨`crates.io`ã€‚

ä½ å¯ä»¥åœ¨ç½‘ç«™ä¸Šæœç´¢ `rand` åŒ…ï¼Œçœ‹çœ‹å®ƒçš„æ–‡æ¡£ä½¿ç”¨æ–¹å¼æ˜¯å¦å’Œæˆ‘ä»¬ä¹‹å‰å¼•å…¥æ–¹å¼ç›¸ä¸€è‡´ï¼šåœ¨ç½‘ä¸Šæ‰¾åˆ°æƒ³è¦çš„åŒ…ï¼Œç„¶åå°†ä½ æƒ³è¦çš„åŒ…å’Œç‰ˆæœ¬ä¿¡æ¯å†™å…¥åˆ° `Cargo.toml` ä¸­ã€‚

## ä½¿ç”¨ `{}` ç®€åŒ–å¼•å…¥æ–¹å¼

å¯¹äºä»¥ä¸‹ä¸€è¡Œä¸€è¡Œçš„å¼•å…¥æ–¹å¼ï¼š

```rust
use std::collections::HashMap;
use std::collections::BTreeMap;
use std::collections::HashSet;

use std::cmp::Ordering;
use std::io;
```

å¯ä»¥ä½¿ç”¨ `{}` æ¥ä¸€èµ·å¼•å…¥è¿›æ¥ï¼Œåœ¨å¤§å‹é¡¹ç›®ä¸­ï¼Œä½¿ç”¨è¿™ç§æ–¹å¼æ¥å¼•å…¥ï¼Œå¯ä»¥å‡å°‘å¤§é‡ `use` çš„ä½¿ç”¨ï¼š

```rust
use std::collections::{HashMap,BTreeMap,HashSet};
use std::{cmp::Ordering, io};
```

å¯¹äºä¸‹é¢çš„åŒæ—¶å¼•å…¥æ¨¡å—å’Œæ¨¡å—ä¸­çš„é¡¹ï¼š

```rust
use std::io;
use std::io::Write;
```

å¯ä»¥ä½¿ç”¨ `{}` çš„æ–¹å¼è¿›è¡Œç®€åŒ–:

```rust
use std::io::{self, Write};
```

#### self

ä¸Šé¢ä½¿ç”¨åˆ°äº†æ¨¡å—ç« èŠ‚æåˆ°çš„ `self` å…³é”®å­—ï¼Œç”¨æ¥æ›¿ä»£æ¨¡å—è‡ªèº«ï¼Œç»“åˆä¸Šä¸€èŠ‚ä¸­çš„ `self`ï¼Œå¯ä»¥å¾—å‡ºå®ƒåœ¨æ¨¡å—ä¸­çš„ä¸¤ä¸ªç”¨é€”ï¼š

- `use self::xxx`ï¼Œè¡¨ç¤ºåŠ è½½å½“å‰æ¨¡å—ä¸­çš„ `xxx`ã€‚æ­¤æ—¶ `self` å¯çœç•¥
- `use xxx::{self, yyy}`ï¼Œè¡¨ç¤ºï¼ŒåŠ è½½å½“å‰è·¯å¾„ä¸‹æ¨¡å— `xxx` æœ¬èº«ï¼Œä»¥åŠæ¨¡å— `xxx` ä¸‹çš„ `yyy`

## ä½¿ç”¨ `*` å¼•å…¥æ¨¡å—ä¸‹çš„æ‰€æœ‰é¡¹

å¯¹äºä¹‹å‰ä¸€è¡Œä¸€è¡Œå¼•å…¥ `std::collections` çš„æ–¹å¼ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨

```rust
use std::collections::*;
```

ä»¥ä¸Šè¿™ç§æ–¹å¼æ¥å¼•å…¥ `std::collections` æ¨¡å—ä¸‹çš„æ‰€æœ‰å…¬å…±é¡¹ï¼Œè¿™äº›å…¬å…±é¡¹è‡ªç„¶åŒ…å«äº† `HashMap`ï¼Œ`HashSet` ç­‰æƒ³æ‰‹åŠ¨å¼•å…¥çš„é›†åˆç±»å‹ã€‚

å½“ä½¿ç”¨ `*` æ¥å¼•å…¥çš„æ—¶å€™è¦æ ¼å¤–å°å¿ƒï¼Œå› ä¸ºä½ å¾ˆéš¾çŸ¥é“åˆ°åº•å“ªäº›è¢«å¼•å…¥åˆ°äº†å½“å‰ä½œç”¨åŸŸä¸­ï¼Œæœ‰å“ªäº›ä¼šå’Œä½ è‡ªå·±ç¨‹åºä¸­çš„åç§°ç›¸å†²çªï¼š

```rust
use std::collections::*;

struct HashMap;
fn main() {
   let mut v =  HashMap::new();
   v.insert("a", 1);
}
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œ`std::collections::HashMap` è¢« `*` å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸï¼Œä½†æ˜¯ç”±äºå­˜åœ¨å¦ä¸€ä¸ªåŒåçš„ç»“æ„ä½“ï¼Œå› æ­¤ `HashMap::new` æ ¹æœ¬ä¸å­˜åœ¨ï¼Œå› ä¸ºå¯¹äºç¼–è¯‘å™¨æ¥è¯´ï¼Œæœ¬åœ°åŒåç±»å‹çš„ä¼˜å…ˆçº§æ›´é«˜ã€‚

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™ç§å¼•ç”¨æ–¹å¼å¾€å¾€ç”¨äºå¿«é€Ÿå†™æµ‹è¯•ä»£ç ï¼Œå®ƒå¯ä»¥æŠŠæ‰€æœ‰ä¸œè¥¿ä¸€æ¬¡æ€§å¼•å…¥åˆ° `tests` æ¨¡å—ä¸­ã€‚

## å—é™çš„å¯è§æ€§

åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†[å¯è§æ€§](https://course.rs/basic/crate-module/module.html#ä»£ç å¯è§æ€§)è¿™ä¸ªæ¦‚å¿µï¼Œè¿™ä¹Ÿæ˜¯æ¨¡å—ä½“ç³»ä¸­æœ€ä¸ºæ ¸å¿ƒçš„æ¦‚å¿µï¼Œæ§åˆ¶äº†æ¨¡å—ä¸­å“ªäº›å†…å®¹å¯ä»¥è¢«å¤–éƒ¨çœ‹è§ï¼Œä½†æ˜¯åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œå…‰è¢«å¤–é¢çœ‹åˆ°è¿˜ä¸è¡Œï¼Œæˆ‘ä»¬è¿˜æƒ³æ§åˆ¶å“ªäº›äººèƒ½çœ‹ï¼Œè¿™å°±æ˜¯ Rust æä¾›çš„å—é™å¯è§æ€§ã€‚

ä¾‹å¦‚ï¼Œåœ¨ Rust ä¸­ï¼ŒåŒ…æ˜¯ä¸€ä¸ªæ¨¡å—æ ‘ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `pub(crate) item;` è¿™ç§æ–¹å¼æ¥å®ç°ï¼š`item` è™½ç„¶æ˜¯å¯¹å¤–å¯è§çš„ï¼Œä½†æ˜¯åªåœ¨å½“å‰åŒ…å†…å¯è§ï¼Œå¤–éƒ¨åŒ…æ— æ³•å¼•ç”¨åˆ°è¯¥ `item`ã€‚

æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è®©æŸä¸€é¡¹å¯ä»¥åœ¨æ•´ä¸ªåŒ…ä¸­éƒ½å¯ä»¥è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆæœ‰ä¸¤ç§åŠæ³•ï¼š

- åœ¨åŒ…æ ¹ä¸­å®šä¹‰ä¸€ä¸ªé `pub` ç±»å‹çš„ `X`(çˆ¶æ¨¡å—çš„é¡¹å¯¹å­æ¨¡å—éƒ½æ˜¯å¯è§çš„ï¼Œå› æ­¤åŒ…æ ¹ä¸­çš„é¡¹å¯¹æ¨¡å—æ ‘ä¸Šçš„æ‰€æœ‰æ¨¡å—éƒ½å¯è§)
- åœ¨å­æ¨¡å—ä¸­å®šä¹‰ä¸€ä¸ª `pub` ç±»å‹çš„ `Y`ï¼ŒåŒæ—¶é€šè¿‡ `use` å°†å…¶å¼•å…¥åˆ°åŒ…æ ¹

```rust
mod a {
    pub mod b {
        pub fn c() {
            println!("{:?}",crate::X);
        }

        #[derive(Debug)]
        pub struct Y;
    }
}

#[derive(Debug)]
struct X;
use a::b::Y;
fn d() {
    println!("{:?}",Y);
}
```

ä»¥ä¸Šä»£ç å……åˆ†è¯´æ˜äº†ä¹‹å‰ä¸¤ç§åŠæ³•çš„ä½¿ç”¨æ–¹å¼ï¼Œä½†æ˜¯æœ‰æ—¶æˆ‘ä»¬ä¼šé‡åˆ°è¿™ä¸¤ç§æ–¹æ³•éƒ½ä¸å¤ªå¥½ç”¨çš„æ—¶å€™ã€‚ä¾‹å¦‚å¸Œæœ›å¯¹äºæŸäº›ç‰¹å®šçš„æ¨¡å—å¯è§ï¼Œä½†æ˜¯å¯¹äºå…¶ä»–æ¨¡å—åˆä¸å¯è§ï¼š

```rust
// ç›®æ ‡ï¼š`a` å¯¼å‡º `I`ã€`bar` and `foo`ï¼Œå…¶ä»–çš„ä¸å¯¼å‡º
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -> i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        mod c {
            const J: i32 = 4;
        }
    }
}
```

è¿™æ®µä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸ºä¸çˆ¶æ¨¡å—ä¸­çš„é¡¹å¯¹å­æ¨¡å—å¯è§ç›¸åï¼Œå­æ¨¡å—ä¸­çš„é¡¹å¯¹çˆ¶æ¨¡å—æ˜¯ä¸å¯è§çš„ã€‚è¿™é‡Œ `semisecret` æ–¹æ³•ä¸­ï¼Œ`a` -> `b` -> `c` å½¢æˆäº†çˆ¶å­æ¨¡å—é“¾ï¼Œé‚£ `c` ä¸­çš„ `J` è‡ªç„¶å¯¹ `a` æ¨¡å—ä¸å¯è§ã€‚

å¦‚æœä½¿ç”¨ä¹‹å‰çš„å¯è§æ€§æ–¹å¼ï¼Œé‚£ä¹ˆæƒ³ä¿æŒ `J` ç§æœ‰ï¼ŒåŒæ—¶è®© `a` ç»§ç»­ä½¿ç”¨ `semisecret` å‡½æ•°çš„åŠæ³•æ˜¯å°†è¯¥å‡½æ•°ç§»åŠ¨åˆ° `c` æ¨¡å—ä¸­ï¼Œç„¶åç”¨ `pub use` å°† `semisecret` å‡½æ•°è¿›è¡Œå†å¯¼å‡ºï¼š

```rust
pub mod a {
    pub const I: i32 = 3;

    use self::b::semisecret;

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        pub use self::c::semisecret;
        mod c {
            const J: i32 = 4;
            pub fn semisecret(x: i32) -> i32 {
                x + J
            }
        }
    }
}
```

è¿™æ®µä»£ç è¯´å®è¯é—®é¢˜ä¸å¤§ï¼Œä½†æ˜¯æœ‰äº›ç ´åäº†æˆ‘ä»¬ä¹‹å‰çš„é€»è¾‘ï¼Œå¦‚æœæƒ³ä¿æŒä»£ç é€»è¾‘ï¼ŒåŒæ—¶åˆåªè®© `J` åœ¨ `a` å†…å¯è§è¯¥æ€ä¹ˆåŠï¼Ÿ

```rust
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -> i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}
```

é€šè¿‡ `pub(in crate::a)` çš„æ–¹å¼ï¼Œæˆ‘ä»¬æŒ‡å®šäº†æ¨¡å— `c` å’Œå¸¸é‡ `J` çš„å¯è§èŒƒå›´éƒ½åªæ˜¯ `a` æ¨¡å—ä¸­ï¼Œ`a` ä¹‹å¤–çš„æ¨¡å—æ˜¯å®Œå…¨è®¿é—®ä¸åˆ°å®ƒä»¬çš„ã€‚

#### é™åˆ¶å¯è§æ€§è¯­æ³•

`pub(crate)` æˆ– `pub(in crate::a)` å°±æ˜¯é™åˆ¶å¯è§æ€§è¯­æ³•ï¼Œå‰è€…æ˜¯é™åˆ¶åœ¨æ•´ä¸ªåŒ…å†…å¯è§ï¼Œåè€…æ˜¯é€šè¿‡ç»å¯¹è·¯å¾„ï¼Œé™åˆ¶åœ¨åŒ…å†…çš„æŸä¸ªæ¨¡å—å†…å¯è§ï¼Œæ€»ç»“ä¸€ä¸‹ï¼š

- `pub` æ„å‘³ç€å¯è§æ€§æ— ä»»ä½•é™åˆ¶
- `pub(crate)` è¡¨ç¤ºåœ¨å½“å‰åŒ…å¯è§
- `pub(self)` åœ¨å½“å‰æ¨¡å—å¯è§
- `pub(super)` åœ¨çˆ¶æ¨¡å—å¯è§
- `pub(in <path>)` è¡¨ç¤ºåœ¨æŸä¸ªè·¯å¾„ä»£è¡¨çš„æ¨¡å—ä¸­å¯è§ï¼Œå…¶ä¸­ `path` å¿…é¡»æ˜¯çˆ¶æ¨¡å—æˆ–è€…ç¥–å…ˆæ¨¡å—

#### ä¸€ä¸ªç»¼åˆä¾‹å­

```rust
// ä¸€ä¸ªåä¸º `my_mod` çš„æ¨¡å—
mod my_mod {
    // æ¨¡å—ä¸­çš„é¡¹é»˜è®¤å…·æœ‰ç§æœ‰çš„å¯è§æ€§
    fn private_function() {
        println!("called `my_mod::private_function()`");
    }

    // ä½¿ç”¨ `pub` ä¿®é¥°è¯­æ¥æ”¹å˜é»˜è®¤å¯è§æ€§ã€‚
    pub fn function() {
        println!("called `my_mod::function()`");
    }

    // åœ¨åŒä¸€æ¨¡å—ä¸­ï¼Œé¡¹å¯ä»¥è®¿é—®å…¶å®ƒé¡¹ï¼Œå³ä½¿å®ƒæ˜¯ç§æœ‰çš„ã€‚
    pub fn indirect_access() {
        print!("called `my_mod::indirect_access()`, that\n> ");
        private_function();
    }

    // æ¨¡å—ä¹Ÿå¯ä»¥åµŒå¥—
    pub mod nested {
        pub fn function() {
            println!("called `my_mod::nested::function()`");
        }

        #[allow(dead_code)]
        fn private_function() {
            println!("called `my_mod::nested::private_function()`");
        }

        // ä½¿ç”¨ `pub(in path)` è¯­æ³•å®šä¹‰çš„å‡½æ•°åªåœ¨ç»™å®šçš„è·¯å¾„ä¸­å¯è§ã€‚
        // `path` å¿…é¡»æ˜¯çˆ¶æ¨¡å—ï¼ˆparent moduleï¼‰æˆ–ç¥–å…ˆæ¨¡å—ï¼ˆancestor moduleï¼‰
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!("called `my_mod::nested::public_function_in_my_mod()`, that\n > ");
            public_function_in_nested()
        }

        // ä½¿ç”¨ `pub(self)` è¯­æ³•å®šä¹‰çš„å‡½æ•°åˆ™åªåœ¨å½“å‰æ¨¡å—ä¸­å¯è§ã€‚
        pub(self) fn public_function_in_nested() {
            println!("called `my_mod::nested::public_function_in_nested");
        }

        // ä½¿ç”¨ `pub(super)` è¯­æ³•å®šä¹‰çš„å‡½æ•°åªåœ¨çˆ¶æ¨¡å—ä¸­å¯è§ã€‚
        pub(super) fn public_function_in_super_mod() {
            println!("called my_mod::nested::public_function_in_super_mod");
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!("called `my_mod::call_public_funcion_in_my_mod()`, that\n> ");
        nested::public_function_in_my_mod();
        print!("> ");
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` ä½¿å¾—å‡½æ•°åªåœ¨å½“å‰åŒ…ä¸­å¯è§
    pub(crate) fn public_function_in_crate() {
        println!("called `my_mod::public_function_in_crate()");
    }

    // åµŒå¥—æ¨¡å—çš„å¯è§æ€§éµå¾ªç›¸åŒçš„è§„åˆ™
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!("called `my_mod::private_nested::function()`");
        }
    }
}

fn function() {
    println!("called `function()`");
}

fn main() {
    // æ¨¡å—æœºåˆ¶æ¶ˆé™¤äº†ç›¸åŒåå­—çš„é¡¹ä¹‹é—´çš„æ­§ä¹‰ã€‚
    function();
    my_mod::function();

    // å…¬æœ‰é¡¹ï¼ŒåŒ…æ‹¬åµŒå¥—æ¨¡å—å†…çš„ï¼Œéƒ½å¯ä»¥åœ¨çˆ¶æ¨¡å—å¤–éƒ¨è®¿é—®ã€‚
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) é¡¹å¯ä»¥åœ¨åŒä¸€ä¸ª crate ä¸­çš„ä»»ä½•åœ°æ–¹è®¿é—®
    my_mod::public_function_in_crate();

    // pub(in path) é¡¹åªèƒ½åœ¨æŒ‡å®šçš„æ¨¡å—ä¸­è®¿é—®
    // æŠ¥é”™ï¼å‡½æ•° `public_function_in_my_mod` æ˜¯ç§æœ‰çš„
    //my_mod::nested::public_function_in_my_mod();
    // è¯•ä¸€è¯• ^ å–æ¶ˆè¯¥è¡Œçš„æ³¨é‡Š

    // æ¨¡å—çš„ç§æœ‰é¡¹ä¸èƒ½ç›´æ¥è®¿é—®ï¼Œå³ä¾¿å®ƒæ˜¯åµŒå¥—åœ¨å…¬æœ‰æ¨¡å—å†…éƒ¨çš„

    // æŠ¥é”™ï¼`private_function` æ˜¯ç§æœ‰çš„
    //my_mod::private_function();
    // è¯•ä¸€è¯• ^ å–æ¶ˆæ­¤è¡Œæ³¨é‡Š

    // æŠ¥é”™ï¼`private_function` æ˜¯ç§æœ‰çš„
    //my_mod::nested::private_function();
    // è¯•ä¸€è¯• ^ å–æ¶ˆæ­¤è¡Œçš„æ³¨é‡Š

    // æŠ¥é”™ï¼ `private_nested` æ˜¯ç§æœ‰çš„
    //my_mod::private_nested::function();
    // è¯•ä¸€è¯• ^ å–æ¶ˆæ­¤è¡Œçš„æ³¨é‡Š
}
```

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/crate-module/use-pub.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/use-pub.md)ã€‚


================================================
FILE: src/basic/match-pattern/all-patterns.md
================================================
# å…¨æ¨¡å¼åˆ—è¡¨

åœ¨æœ¬ä¹¦ä¸­æˆ‘ä»¬å·²é¢†ç•¥è¿‡è®¸å¤šä¸åŒç±»å‹æ¨¡å¼çš„ä¾‹å­ï¼Œæœ¬èŠ‚çš„ç›®æ ‡å°±æ˜¯æŠŠè¿™äº›æ¨¡å¼è¯­æ³•éƒ½ç½—åˆ—å‡ºæ¥ï¼Œæ–¹ä¾¿å¤§å®¶æ£€ç´¢æŸ¥é˜…ï¼ˆæ¨¡å¼åŒ¹é…åœ¨æˆ‘ä»¬çš„å¼€å‘ä¸­ä¼šç»å¸¸ç”¨åˆ°ï¼‰ã€‚

### åŒ¹é…å­—é¢å€¼

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

è¿™æ®µä»£ç ä¼šæ‰“å° `one` å› ä¸º `x` çš„å€¼æ˜¯ 1ï¼Œå¦‚æœå¸Œæœ›ä»£ç è·å¾—ç‰¹å®šçš„å…·ä½“å€¼ï¼Œé‚£ä¹ˆè¿™ç§è¯­æ³•å¾ˆæœ‰ç”¨ã€‚

### åŒ¹é…å‘½åå˜é‡

åœ¨ [match](https://course.rs/basic/match-pattern/match-if-let.html#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD) ä¸­ï¼Œæˆ‘ä»¬æœ‰è®²è¿‡å˜é‡é®è”½çš„é—®é¢˜ï¼Œè¿™ä¸ªåœ¨**åŒ¹é…å‘½åå˜é‡**æ—¶ä¼šé‡åˆ°ï¼š

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

è®©æˆ‘ä»¬çœ‹çœ‹å½“ `match` è¯­å¥è¿è¡Œçš„æ—¶å€™å‘ç”Ÿäº†ä»€ä¹ˆã€‚ç¬¬ä¸€ä¸ªåŒ¹é…åˆ†æ”¯çš„æ¨¡å¼å¹¶ä¸åŒ¹é… `x` ä¸­å®šä¹‰çš„å€¼ï¼Œæ‰€ä»¥ä»£ç ç»§ç»­æ‰§è¡Œã€‚

ç¬¬äºŒä¸ªåŒ¹é…åˆ†æ”¯ä¸­çš„æ¨¡å¼å¼•å…¥äº†ä¸€ä¸ªæ–°å˜é‡ `y`ï¼Œå®ƒä¼šåŒ¹é…ä»»ä½• `Some` ä¸­çš„å€¼ã€‚å› ä¸ºè¿™é‡Œçš„ `y` åœ¨ `match` è¡¨è¾¾å¼çš„ä½œç”¨åŸŸä¸­ï¼Œè€Œä¸æ˜¯ä¹‹å‰ `main` ä½œç”¨åŸŸä¸­ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªæ–°å˜é‡ï¼Œä¸æ˜¯å¼€å¤´å£°æ˜ä¸ºå€¼ 10 çš„é‚£ä¸ª `y`ã€‚è¿™ä¸ªæ–°çš„ `y` ç»‘å®šä¼šåŒ¹é…ä»»ä½• `Some` ä¸­çš„å€¼ï¼Œåœ¨è¿™é‡Œæ˜¯ `x` ä¸­çš„å€¼ã€‚å› æ­¤è¿™ä¸ª `y` ç»‘å®šäº† `x` ä¸­ `Some` å†…éƒ¨çš„å€¼ã€‚è¿™ä¸ªå€¼æ˜¯ 5ï¼Œæ‰€ä»¥è¿™ä¸ªåˆ†æ”¯çš„è¡¨è¾¾å¼å°†ä¼šæ‰§è¡Œå¹¶æ‰“å°å‡º `Matchedï¼Œy = 5`ã€‚

å¦‚æœ `x` çš„å€¼æ˜¯ `None` è€Œä¸æ˜¯ `Some(5)`ï¼Œå¤´ä¸¤ä¸ªåˆ†æ”¯çš„æ¨¡å¼ä¸ä¼šåŒ¹é…ï¼Œæ‰€ä»¥ä¼šåŒ¹é…æ¨¡å¼ `_`ã€‚è¿™ä¸ªåˆ†æ”¯çš„æ¨¡å¼ä¸­æ²¡æœ‰å¼•å…¥å˜é‡ `x`ï¼Œæ‰€ä»¥æ­¤æ—¶è¡¨è¾¾å¼ä¸­çš„ `x` ä¼šæ˜¯å¤–éƒ¨æ²¡æœ‰è¢«é®è”½çš„ `x`ï¼Œä¹Ÿå°±æ˜¯ `None`ã€‚

ä¸€æ—¦ `match` è¡¨è¾¾å¼æ‰§è¡Œå®Œæ¯•ï¼Œå…¶ä½œç”¨åŸŸä¹Ÿå°±ç»“æŸäº†ï¼ŒåŒç†å†…éƒ¨ `y` çš„ä½œç”¨åŸŸä¹Ÿç»“æŸäº†ã€‚æœ€åçš„ `println!` ä¼šæ‰“å° `at the end: x = Some(5), y = 10`ã€‚

å¦‚æœä½ ä¸æƒ³å¼•å…¥å˜é‡é®è”½ï¼Œå¯ä»¥ä½¿ç”¨å¦ä¸€ä¸ªå˜é‡åè€Œé `y`ï¼Œæˆ–è€…ä½¿ç”¨åŒ¹é…å®ˆå«(match guard)çš„æ–¹å¼ï¼Œç¨ååœ¨[åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶](#åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶)ä¸­ä¼šè®²è§£ã€‚

### å•åˆ†æ”¯å¤šæ¨¡å¼

åœ¨ `match` è¡¨è¾¾å¼ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `|` è¯­æ³•åŒ¹é…å¤šä¸ªæ¨¡å¼ï¼Œå®ƒä»£è¡¨ **æˆ–**çš„æ„æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚ä¸‹ä»£ç å°† `x` çš„å€¼ä¸åŒ¹é…åˆ†æ”¯ç›¸æ¯”è¾ƒï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯æœ‰ **æˆ–** é€‰é¡¹ï¼Œæ„å‘³ç€å¦‚æœ `x` çš„å€¼åŒ¹é…æ­¤åˆ†æ”¯çš„ä»»ä½•ä¸€ä¸ªæ¨¡å¼ï¼Œå®ƒå°±ä¼šè¿è¡Œï¼š

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

ä¸Šé¢çš„ä»£ç ä¼šæ‰“å° `one or two`ã€‚

### é€šè¿‡åºåˆ— `..=` åŒ¹é…å€¼çš„èŒƒå›´

åœ¨[æ•°å€¼ç±»å‹](https://course.rs/basic/base-type/numbers.html#åºåˆ—range)ä¸­æˆ‘ä»¬æœ‰è®²åˆ°ä¸€ä¸ªåºåˆ—è¯­æ³•ï¼Œè¯¥è¯­æ³•ä¸ä»…å¯ä»¥ç”¨äºå¾ªç¯ä¸­ï¼Œè¿˜èƒ½ç”¨äºåŒ¹é…æ¨¡å¼ã€‚

`..=` è¯­æ³•å…è®¸ä½ åŒ¹é…ä¸€ä¸ªé—­åŒºé—´åºåˆ—å†…çš„å€¼ã€‚åœ¨å¦‚ä¸‹ä»£ç ä¸­ï¼Œå½“æ¨¡å¼åŒ¹é…ä»»ä½•åœ¨æ­¤åºåˆ—å†…çš„å€¼æ—¶ï¼Œè¯¥åˆ†æ”¯ä¼šæ‰§è¡Œï¼š

```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

å¦‚æœ `x` æ˜¯ 1ã€2ã€3ã€4 æˆ– 5ï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯å°±ä¼šåŒ¹é…ã€‚è¿™ç›¸æ¯”ä½¿ç”¨ `|` è¿ç®—ç¬¦è¡¨è¾¾ç›¸åŒçš„æ„æ€æ›´ä¸ºæ–¹ä¾¿ï¼›ç›¸æ¯” `1..=5`ï¼Œä½¿ç”¨ `|` åˆ™ä¸å¾—ä¸æŒ‡å®š `1 | 2 | 3 | 4 | 5` è¿™äº”ä¸ªå€¼ï¼Œè€Œä½¿ç”¨ `..=` æŒ‡å®šåºåˆ—å°±ç®€çŸ­çš„å¤šï¼Œæ¯”å¦‚å¸Œæœ›åŒ¹é…ä» 1 åˆ° 1000 çš„æ•°å­—çš„æ—¶å€™ï¼

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­ï¼ŒåŒæ—¶ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå­—ç¬¦å’Œæ•°å­—å€¼æ˜¯ Rust ä¸­ä»…æœ‰çš„å¯ä»¥ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹ã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å­—ç¬¦ç±»å‹åºåˆ—çš„ä¾‹å­ï¼š

```rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```

Rust çŸ¥é“ `'c'` ä½äºç¬¬ä¸€ä¸ªæ¨¡å¼çš„åºåˆ—å†…ï¼Œæ‰€ä»¥ä¼šæ‰“å°å‡º `early ASCII letter`ã€‚

### è§£æ„å¹¶åˆ†è§£å€¼

ä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„ã€æ•°ç»„å’Œå¼•ç”¨ã€‚

#### è§£æ„ç»“æ„ä½“

ä¸‹é¢ä»£ç å±•ç¤ºäº†å¦‚ä½•ç”¨ `let` è§£æ„ä¸€ä¸ªå¸¦æœ‰ä¸¤ä¸ªå­—æ®µ `x` å’Œ `y` çš„ç»“æ„ä½“ `Point`ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

è¿™æ®µä»£ç åˆ›å»ºäº†å˜é‡ `a` å’Œ `b` æ¥åŒ¹é…ç»“æ„ä½“ `p` ä¸­çš„ `x` å’Œ `y` å­—æ®µï¼Œè¿™ä¸ªä¾‹å­å±•ç¤ºäº†**æ¨¡å¼ä¸­çš„å˜é‡åä¸å¿…ä¸ç»“æ„ä½“ä¸­çš„å­—æ®µåä¸€è‡´**ã€‚ä¸è¿‡é€šå¸¸å¸Œæœ›å˜é‡åä¸å­—æ®µåä¸€è‡´ä»¥ä¾¿äºç†è§£å˜é‡æ¥è‡ªäºå“ªäº›å­—æ®µã€‚

å› ä¸ºå˜é‡ååŒ¹é…å­—æ®µåæ˜¯å¸¸è§çš„ï¼ŒåŒæ—¶å› ä¸º `let Point { x: x, y: y } = p;` ä¸­ `x` å’Œ `y` é‡å¤äº†ï¼Œæ‰€ä»¥å¯¹äºåŒ¹é…ç»“æ„ä½“å­—æ®µçš„æ¨¡å¼å­˜åœ¨ç®€å†™ï¼šåªéœ€åˆ—å‡ºç»“æ„ä½“å­—æ®µçš„åç§°ï¼Œåˆ™æ¨¡å¼åˆ›å»ºçš„å˜é‡ä¼šæœ‰ç›¸åŒçš„åç§°ã€‚ä¸‹ä¾‹ä¸ä¸Šä¾‹æœ‰ç€ç›¸åŒè¡Œä¸ºçš„ä»£ç ï¼Œä¸è¿‡ `let` æ¨¡å¼åˆ›å»ºçš„å˜é‡ä¸º `x` å’Œ `y` è€Œä¸æ˜¯ `a` å’Œ `b`ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

è¿™æ®µä»£ç åˆ›å»ºäº†å˜é‡ `x` å’Œ `y`ï¼Œä¸ç»“æ„ä½“ `p` ä¸­çš„ `x` å’Œ `y` å­—æ®µç›¸åŒ¹é…ã€‚å…¶ç»“æœæ˜¯å˜é‡ `x` å’Œ `y` åŒ…å«ç»“æ„ä½“ `p` ä¸­çš„å€¼ã€‚

ä¹Ÿå¯ä»¥ä½¿ç”¨å­—é¢å€¼ä½œä¸ºç»“æ„ä½“æ¨¡å¼çš„ä¸€éƒ¨åˆ†è¿›è¡Œè§£æ„ï¼Œè€Œä¸æ˜¯ä¸ºæ‰€æœ‰çš„å­—æ®µåˆ›å»ºå˜é‡ã€‚è¿™å…è®¸æˆ‘ä»¬æµ‹è¯•ä¸€äº›å­—æ®µä¸ºç‰¹å®šå€¼çš„åŒæ—¶åˆ›å»ºå…¶ä»–å­—æ®µçš„å˜é‡ã€‚

ä¸‹æ–‡å±•ç¤ºäº†å›ºå®šæŸä¸ªå­—æ®µçš„åŒ¹é…æ–¹å¼ï¼š

```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

é¦–å…ˆæ˜¯ `match` ç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼ŒæŒ‡å®šåŒ¹é… `y` ä¸º `0` çš„ `Point`ï¼›
ç„¶åç¬¬äºŒä¸ªåˆ†æ”¯åœ¨ç¬¬ä¸€ä¸ªåˆ†æ”¯ä¹‹åï¼ŒåŒ¹é… `y` ä¸ä¸º `0`ï¼Œ`x` ä¸º `0` çš„ `Point`;
æœ€åä¸€ä¸ªåˆ†æ”¯åŒ¹é… `x` ä¸ä¸º `0`ï¼Œ`y` ä¹Ÿä¸ä¸º `0` çš„ `Point`ã€‚

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå€¼ `p` å› ä¸ºå…¶ `x` åŒ…å« 0 è€ŒåŒ¹é…ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œå› æ­¤ä¼šæ‰“å°å‡º `On the y axis at 7`ã€‚

#### è§£æ„æšä¸¾

ä¸‹é¢ä»£ç ä»¥ `Message` æšä¸¾ä¸ºä¾‹ï¼Œç¼–å†™ä¸€ä¸ª `match` ä½¿ç”¨æ¨¡å¼è§£æ„æ¯ä¸€ä¸ªå†…éƒ¨å€¼ï¼š

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}
```

è¿™é‡Œè€ç”Ÿå¸¸è°ˆä¸€å¥è¯ï¼Œæ¨¡å¼åŒ¹é…ä¸€æ ·è¦ç±»å‹ç›¸åŒï¼Œå› æ­¤åŒ¹é… `Message::Move{1,2}` è¿™æ ·çš„æšä¸¾å€¼ï¼Œå°±å¿…é¡»è¦ç”¨ `Message::Move{x,y}` è¿™æ ·çš„åŒç±»å‹æ¨¡å¼æ‰è¡Œã€‚

è¿™æ®µä»£ç ä¼šæ‰“å°å‡º `Change the color to red 0, green 160, and blue 255`ã€‚å°è¯•æ”¹å˜ `msg` çš„å€¼æ¥è§‚å¯Ÿå…¶ä»–åˆ†æ”¯ä»£ç çš„è¿è¡Œã€‚

å¯¹äºåƒ `Message::Quit` è¿™æ ·æ²¡æœ‰ä»»ä½•æ•°æ®çš„æšä¸¾æˆå‘˜ï¼Œä¸èƒ½è¿›ä¸€æ­¥è§£æ„å…¶å€¼ã€‚åªèƒ½åŒ¹é…å…¶å­—é¢å€¼ `Message::Quit`ï¼Œå› æ­¤æ¨¡å¼ä¸­æ²¡æœ‰ä»»ä½•å˜é‡ã€‚

å¯¹äºå¦å¤–ä¸¤ä¸ªæšä¸¾æˆå‘˜ï¼Œå°±ç”¨ç›¸åŒç±»å‹çš„æ¨¡å¼å»åŒ¹é…å‡ºå¯¹åº”çš„å€¼å³å¯ã€‚

#### è§£æ„åµŒå¥—çš„ç»“æ„ä½“å’Œæšä¸¾

ç›®å‰ä¸ºæ­¢ï¼Œæ‰€æœ‰çš„ä¾‹å­éƒ½åªåŒ¹é…äº†æ·±åº¦ä¸ºä¸€çº§çš„ç»“æ„ä½“æˆ–æšä¸¾ã€‚ `match` ä¹Ÿå¯ä»¥åŒ¹é…åµŒå¥—çš„é¡¹ï¼

ä¾‹å¦‚ä½¿ç”¨ä¸‹é¢çš„ä»£ç æ¥åŒæ—¶æ”¯æŒ RGB å’Œ HSV è‰²å½©æ¨¡å¼ï¼š

```rust
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}
```

`match` ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼åŒ¹é…ä¸€ä¸ª `Message::ChangeColor` æšä¸¾æˆå‘˜ï¼Œè¯¥æšä¸¾æˆå‘˜åˆåŒ…å«äº†ä¸€ä¸ª `Color::Rgb` çš„æšä¸¾æˆå‘˜ï¼Œæœ€ç»ˆç»‘å®šäº† 3 ä¸ªå†…éƒ¨çš„ `i32` å€¼ã€‚ç¬¬äºŒä¸ªï¼Œå°±äº¤ç»™äº²çˆ±çš„è¯»è€…æ¥æ€è€ƒå®Œæˆã€‚

#### è§£æ„ç»“æ„ä½“å’Œå…ƒç»„

æˆ‘ä»¬ç”šè‡³å¯ä»¥ç”¨å¤æ‚çš„æ–¹å¼æ¥æ··åˆã€åŒ¹é…å’ŒåµŒå¥—è§£æ„æ¨¡å¼ã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªå¤æ‚ç»“æ„ä½“çš„ä¾‹å­ï¼Œå…¶ä¸­ç»“æ„ä½“å’Œå…ƒç»„åµŒå¥—åœ¨å…ƒç»„ä¸­ï¼Œå¹¶å°†æ‰€æœ‰çš„åŸå§‹ç±»å‹è§£æ„å‡ºæ¥ï¼š

```rust
struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
```

è¿™ç§å°†å¤æ‚ç±»å‹åˆ†è§£åŒ¹é…çš„æ–¹å¼ï¼Œå¯ä»¥è®©æˆ‘ä»¬å•ç‹¬å¾—åˆ°æ„Ÿå…´è¶£çš„æŸä¸ªå€¼ã€‚

#### è§£æ„æ•°ç»„

å¯¹äºæ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼å…ƒç»„çš„æ–¹å¼è§£æ„ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š

å®šé•¿æ•°ç»„
```rust
let arr: [u16; 2] = [114, 514];
let [x, y] = arr;

assert_eq!(x, 114);
assert_eq!(y, 514);
```

ä¸å®šé•¿æ•°ç»„
```rust
let arr: &[u16] = &[114, 514];

if let [x, ..] = arr {
    assert_eq!(x, &114);
}

if let &[.., y] = arr {
    assert_eq!(y, 514);
}

let arr: &[u16] = &[];

assert!(matches!(arr, [..]));
assert!(!matches!(arr, [x, ..]));
```

### å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼

æœ‰æ—¶å¿½ç•¥æ¨¡å¼ä¸­çš„ä¸€äº›å€¼æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œæ¯”å¦‚åœ¨ `match` ä¸­çš„æœ€åä¸€ä¸ªåˆ†æ”¯ä½¿ç”¨ `_` æ¨¡å¼åŒ¹é…æ‰€æœ‰å‰©ä½™çš„å€¼ã€‚ ä½ ä¹Ÿå¯ä»¥åœ¨å¦ä¸€ä¸ªæ¨¡å¼ä¸­ä½¿ç”¨ `_` æ¨¡å¼ï¼Œä½¿ç”¨ä¸€ä¸ªä»¥ä¸‹åˆ’çº¿å¼€å§‹çš„åç§°ï¼Œæˆ–è€…ä½¿ç”¨ `..` å¿½ç•¥æ‰€å‰©éƒ¨åˆ†çš„å€¼ã€‚

#### ä½¿ç”¨ `_` å¿½ç•¥æ•´ä¸ªå€¼

è™½ç„¶ `_` æ¨¡å¼ä½œä¸º `match` è¡¨è¾¾å¼æœ€åçš„åˆ†æ”¯ç‰¹åˆ«æœ‰ç”¨ï¼Œä½†æ˜¯å®ƒçš„ä½œç”¨è¿˜ä¸é™äºæ­¤ã€‚ä¾‹å¦‚å¯ä»¥å°†å…¶ç”¨äºå‡½æ•°å‚æ•°ä¸­ï¼š

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```

è¿™æ®µä»£ç ä¼šå®Œå…¨å¿½ç•¥ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’çš„å€¼ `3`ï¼Œå¹¶ä¼šæ‰“å°å‡º `This code only uses the y parameter: 4`ã€‚

å¤§éƒ¨åˆ†æƒ…å†µå½“ä½ ä¸å†éœ€è¦ç‰¹å®šå‡½æ•°å‚æ•°æ—¶ï¼Œæœ€å¥½ä¿®æ”¹ç­¾åä¸å†åŒ…å«æ— ç”¨çš„å‚æ•°ã€‚åœ¨ä¸€äº›æƒ…å†µä¸‹å¿½ç•¥å‡½æ•°å‚æ•°ä¼šå˜å¾—ç‰¹åˆ«æœ‰ç”¨ï¼Œæ¯”å¦‚å®ç°ç‰¹å¾æ—¶ï¼Œå½“ä½ éœ€è¦ç‰¹å®šç±»å‹ç­¾åä½†æ˜¯å‡½æ•°å®ç°å¹¶ä¸éœ€è¦æŸä¸ªå‚æ•°æ—¶ã€‚æ­¤æ—¶ç¼–è¯‘å™¨å°±**ä¸ä¼šè­¦å‘Šè¯´å­˜åœ¨æœªä½¿ç”¨çš„å‡½æ•°å‚æ•°**ï¼Œå°±è·Ÿä½¿ç”¨å‘½åå‚æ•°ä¸€æ ·ã€‚

#### ä½¿ç”¨åµŒå¥—çš„ `_` å¿½ç•¥éƒ¨åˆ†å€¼

å¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼å†…éƒ¨ä½¿ç”¨ `_` å¿½ç•¥éƒ¨åˆ†å€¼ï¼š

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);
```

è¿™æ®µä»£ç ä¼šæ‰“å°å‡º `Can't overwrite an existing customized value` æ¥ç€æ˜¯ `setting is Some(5)`ã€‚

ç¬¬ä¸€ä¸ªåŒ¹é…åˆ†æ”¯ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒé‡Œé¢çš„å€¼ï¼Œåªå…³å¿ƒå…ƒç»„ä¸­ä¸¤ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œå› æ­¤å¯¹äº `Some` ä¸­çš„å€¼ï¼Œç›´æ¥è¿›è¡Œå¿½ç•¥ã€‚
å‰©ä¸‹çš„å½¢å¦‚ `(Some(_),None)`ï¼Œ`(None, Some(_))`, `(None,None)` å½¢å¼ï¼Œéƒ½ç”±ç¬¬äºŒä¸ªåˆ†æ”¯ `_` è¿›è¡Œåˆ†é…ã€‚

è¿˜å¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼ä¸­çš„å¤šå¤„ä½¿ç”¨ä¸‹åˆ’çº¿æ¥å¿½ç•¥ç‰¹å®šå€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œè¿™é‡Œå¿½ç•¥äº†ä¸€ä¸ªäº”å…ƒå…ƒç»„ä¸­çš„ç¬¬äºŒå’Œç¬¬å››ä¸ªå€¼ï¼š

```rust
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("Some numbers: {}, {}, {}", first, third, fifth)
    },
}
```

è€ç”Ÿå¸¸è°ˆï¼šæ¨¡å¼åŒ¹é…ä¸€å®šè¦ç±»å‹ç›¸åŒï¼Œå› æ­¤åŒ¹é… `numbers` å…ƒç»„çš„æ¨¡å¼ï¼Œä¹Ÿå¿…é¡»æœ‰äº”ä¸ªå€¼ï¼ˆå…ƒç»„ä¸­å…ƒç´ çš„æ•°é‡ä¹Ÿå±äºå…ƒç»„ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚

è¿™ä¼šæ‰“å°å‡º `Some numbers: 2, 8, 32`, å€¼ 4 å’Œ 16 ä¼šè¢«å¿½ç•¥ã€‚

#### ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡

å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªå˜é‡å´ä¸åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨å®ƒï¼ŒRust é€šå¸¸ä¼šç»™ä½ ä¸€ä¸ªè­¦å‘Šï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ˜¯ä¸ª BUGã€‚ä½†æ˜¯æœ‰æ—¶åˆ›å»ºä¸€ä¸ªä¸ä¼šè¢«ä½¿ç”¨çš„å˜é‡æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚ä½ æ­£åœ¨è®¾è®¡åŸå‹æˆ–åˆšåˆšå¼€å§‹ä¸€ä¸ªé¡¹ç›®ã€‚è¿™æ—¶ä½ å¸Œæœ›å‘Šè¯‰ Rust ä¸è¦è­¦å‘Šæœªä½¿ç”¨çš„å˜é‡ï¼Œä¸ºæ­¤å¯ä»¥ç”¨ä¸‹åˆ’çº¿ä½œä¸ºå˜é‡åçš„å¼€å¤´ï¼š

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

è¿™é‡Œå¾—åˆ°äº†è­¦å‘Šè¯´æœªä½¿ç”¨å˜é‡ `y`ï¼Œè‡³äº `x` åˆ™æ²¡æœ‰è­¦å‘Šã€‚

æ³¨æ„, åªä½¿ç”¨ `_` å’Œä½¿ç”¨ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„åç§°æœ‰äº›å¾®å¦™çš„ä¸åŒï¼šæ¯”å¦‚ **`_x` ä»ä¼šå°†å€¼ç»‘å®šåˆ°å˜é‡ï¼Œè€Œ `_` åˆ™å®Œå…¨ä¸ä¼šç»‘å®š**ã€‚

```rust
let s = Some(String::from("Hello!"));

if let Some(_s) = s {
    println!("found a string");
}

println!("{:?}", s);
```

`s` æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„åŠ¨æ€å­—ç¬¦ä¸²ï¼Œåœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸º `s` çš„å€¼ä¼šè¢«è½¬ç§»ç»™ `_s`ï¼Œåœ¨ `println!` ä¸­å†æ¬¡ä½¿ç”¨ `s` ä¼šæŠ¥é”™ï¼š

```console
error[E0382]: borrow of partially moved value: `s`
 --> src/main.rs:8:22
  |
4 |     if let Some(_s) = s {
  |                 -- value partially moved here
...
8 |     println!("{:?}", s);
  |                      ^ value borrowed here after partial move
```

åªä½¿ç”¨ä¸‹åˆ’çº¿æœ¬èº«ï¼Œåˆ™å¹¶ä¸ä¼šç»‘å®šå€¼ï¼Œå› ä¸º `s` æ²¡æœ‰è¢«ç§»åŠ¨è¿› `_`ï¼š

```rust
let s = Some(String::from("Hello!"));

if let Some(_) = s {
    println!("found a string");
}

println!("{:?}", s);
```

#### ç”¨ `..` å¿½ç•¥å‰©ä½™å€¼

å¯¹äºæœ‰å¤šä¸ªéƒ¨åˆ†çš„å€¼ï¼Œå¯ä»¥ä½¿ç”¨ `..` è¯­æ³•æ¥åªä½¿ç”¨éƒ¨åˆ†å€¼è€Œå¿½ç•¥å…¶å®ƒå€¼ï¼Œè¿™æ ·ä¹Ÿä¸ç”¨å†ä¸ºæ¯ä¸€ä¸ªè¢«å¿½ç•¥çš„å€¼éƒ½å•ç‹¬åˆ—å‡ºä¸‹åˆ’çº¿ã€‚`..` æ¨¡å¼ä¼šå¿½ç•¥æ¨¡å¼ä¸­å‰©ä½™çš„ä»»ä½•æ²¡æœ‰æ˜¾å¼åŒ¹é…çš„å€¼éƒ¨åˆ†ã€‚

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

è¿™é‡Œåˆ—å‡ºäº† `x` å€¼ï¼Œæ¥ç€ä½¿ç”¨äº† `..` æ¨¡å¼æ¥å¿½ç•¥å…¶å®ƒå­—æ®µï¼Œè¿™æ ·çš„å†™æ³•è¦æ¯”ä¸€ä¸€åˆ—å‡ºå…¶å®ƒå­—æ®µï¼Œç„¶åç”¨ `_` å¿½ç•¥ç®€æ´çš„å¤šã€‚

è¿˜å¯ä»¥ç”¨ `..` æ¥å¿½ç•¥å…ƒç»„ä¸­é—´çš„æŸäº›å€¼ï¼š

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }
}
```

è¿™é‡Œç”¨ `first` å’Œ `last` æ¥åŒ¹é…ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå€¼ã€‚`..` å°†åŒ¹é…å¹¶å¿½ç•¥ä¸­é—´çš„æ‰€æœ‰å€¼ã€‚

ç„¶è€Œä½¿ç”¨ `..` å¿…é¡»æ˜¯æ— æ­§ä¹‰çš„ã€‚å¦‚æœæœŸæœ›åŒ¹é…å’Œå¿½ç•¥çš„å€¼æ˜¯ä¸æ˜ç¡®çš„ï¼ŒRust ä¼šæŠ¥é”™ã€‚ä¸‹é¢ä»£ç å±•ç¤ºäº†ä¸€ä¸ªå¸¦æœ‰æ­§ä¹‰çš„ `..` ä¾‹å­ï¼Œå› æ­¤ä¸èƒ½ç¼–è¯‘ï¼š

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```

å¦‚æœç¼–è¯‘ä¸Šé¢çš„ä¾‹å­ï¼Œä¼šå¾—åˆ°ä¸‹é¢çš„é”™è¯¯ï¼š

```text
error: `..` can only be used once per tuple pattern // æ¯ä¸ªå…ƒç»„æ¨¡å¼åªèƒ½ä½¿ç”¨ä¸€ä¸ª `..`
 --> src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here // ä¸Šä¸€æ¬¡ä½¿ç”¨åœ¨è¿™é‡Œ

error: could not compile `world_hello` due to previous error              ^^
```

Rust æ— æ³•åˆ¤æ–­ï¼Œ`second` åº”è¯¥åŒ¹é… `numbers` ä¸­çš„ç¬¬å‡ ä¸ªå…ƒç´ ï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨ä¸¤ä¸ª `..` æ¨¡å¼ï¼Œæ˜¯æœ‰å¾ˆå¤§æ­§ä¹‰çš„ï¼

### åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶

**åŒ¹é…å®ˆå«**ï¼ˆ_match guard_ï¼‰æ˜¯ä¸€ä¸ªä½äº `match` åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– `if` æ¡ä»¶ï¼Œå®ƒèƒ½ä¸ºåˆ†æ”¯æ¨¡å¼æä¾›æ›´è¿›ä¸€æ­¥çš„åŒ¹é…æ¡ä»¶ã€‚

è¿™ä¸ªæ¡ä»¶å¯ä»¥ä½¿ç”¨æ¨¡å¼ä¸­åˆ›å»ºçš„å˜é‡ï¼š

```rust
let num = Some(4);

match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
```

è¿™ä¸ªä¾‹å­ä¼šæ‰“å°å‡º `less than five: 4`ã€‚å½“ `num` ä¸æ¨¡å¼ä¸­ç¬¬ä¸€ä¸ªåˆ†æ”¯åŒ¹é…æ—¶ï¼Œ`Some(4)` å¯ä»¥ä¸ `Some(x)` åŒ¹é…ï¼Œæ¥ç€åŒ¹é…å®ˆå«æ£€æŸ¥ `x` å€¼æ˜¯å¦å°äº 5ï¼Œå› ä¸º 4 å°äº 5ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªåˆ†æ”¯è¢«é€‰æ‹©ã€‚

ç›¸åå¦‚æœ `num` ä¸º `Some(10)`ï¼Œå› ä¸º 10 ä¸å°äº 5 ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„åŒ¹é…å®ˆå«ä¸ºå‡ã€‚æ¥ç€ Rust ä¼šå‰å¾€ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œå› ä¸ºè¿™é‡Œæ²¡æœ‰åŒ¹é…å®ˆå«æ‰€ä»¥ä¼šåŒ¹é…ä»»ä½• `Some` æˆå‘˜ã€‚

æ¨¡å¼ä¸­æ— æ³•æä¾›ç±»å¦‚ `if x < 5` çš„è¡¨è¾¾èƒ½åŠ›ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åŒ¹é…å®ˆå«çš„æ–¹å¼æ¥å®ç°ã€‚

åœ¨[ä¹‹å‰](#åŒ¹é…å‘½åå˜é‡)ï¼Œæˆ‘ä»¬æåˆ°å¯ä»¥ä½¿ç”¨åŒ¹é…å®ˆå«æ¥è§£å†³æ¨¡å¼ä¸­å˜é‡è¦†ç›–çš„é—®é¢˜ï¼Œé‚£é‡Œ `match` è¡¨è¾¾å¼çš„æ¨¡å¼ä¸­æ–°å»ºäº†ä¸€ä¸ªå˜é‡è€Œä¸æ˜¯ä½¿ç”¨ `match` ä¹‹å¤–çš„åŒåå˜é‡ã€‚å†…éƒ¨å˜é‡è¦†ç›–äº†å¤–éƒ¨å˜é‡ï¼Œæ„å‘³ç€æ­¤æ—¶ä¸èƒ½å¤Ÿä½¿ç”¨å¤–éƒ¨å˜é‡çš„å€¼ï¼Œä¸‹é¢ä»£ç å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨åŒ¹é…å®ˆå«ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```

ä¸Šé¢ä»£ç ä¼šæ‰“å° `Default case, x = Some(5)`ã€‚å…¶ä¸­ï¼Œç¬¬äºŒä¸ªåŒ¹é…åˆ†æ”¯ç”±äºæ²¡æœ‰æ–°å»ºå±€éƒ¨å˜é‡ `y`ï¼Œå› æ­¤åœ¨åŒ¹é…å®ˆå«ä¸­ä½¿ç”¨çš„æ˜¯å¤–éƒ¨çš„ `y`ã€‚

åŒ¹é…å®ˆå« `if n == y` å¹¶ä¸æ˜¯ä¸€ä¸ªæ¨¡å¼æ‰€ä»¥æ²¡æœ‰å¼•å…¥æ–°å˜é‡ã€‚è¿™ä¸ª `y` **æ­£æ˜¯** å¤–éƒ¨çš„ `y` è€Œä¸æ˜¯æ–°çš„è¦†ç›–å˜é‡ `y`ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡æ¯”è¾ƒ `n` å’Œ `y` æ¥è¡¨è¾¾å¯»æ‰¾ä¸€ä¸ªä¸å¤–éƒ¨ `y` ç›¸åŒçš„å€¼çš„æ¦‚å¿µäº†ã€‚

ä¹Ÿå¯ä»¥åœ¨åŒ¹é…å®ˆå«ä¸­ä½¿ç”¨ **æˆ–** è¿ç®—ç¬¦ `|` æ¥æŒ‡å®šå¤šä¸ªæ¨¡å¼ï¼Œ**åŒæ—¶åŒ¹é…å®ˆå«çš„æ¡ä»¶ä¼šä½œç”¨äºæ‰€æœ‰çš„æ¨¡å¼**ã€‚ä¸‹é¢ä»£ç å±•ç¤ºäº†åŒ¹é…å®ˆå«ä¸ `|` çš„ä¼˜å…ˆçº§ã€‚è¿™ä¸ªä¾‹å­ä¸­çœ‹èµ·æ¥å¥½åƒ `if y` åªä½œç”¨äº `6`ï¼Œä½†å®é™…ä¸ŠåŒ¹é…å®ˆå« `if y` ä½œç”¨äº `4`ã€`5` **å’Œ** `6` ï¼Œåœ¨æ»¡è¶³ `x` å±äº `4 | 5 | 6` åæ‰ä¼šåˆ¤æ–­ `y` æ˜¯å¦ä¸º `true`ï¼š

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

è¿™ä¸ªåŒ¹é…æ¡ä»¶è¡¨æ˜æ­¤åˆ†æ”¯åªåŒ¹é… `x` å€¼ä¸º `4`ã€`5` æˆ– `6` **åŒæ—¶** `y` ä¸º `true` çš„æƒ…å†µã€‚

è™½ç„¶åœ¨ç¬¬ä¸€ä¸ªåˆ†æ”¯ä¸­ï¼Œ`x` åŒ¹é…äº†æ¨¡å¼ `4` ï¼Œä½†æ˜¯å¯¹äºåŒ¹é…å®ˆå« `if y` æ¥è¯´ï¼Œå› ä¸º `y` æ˜¯ `false`ï¼Œå› æ­¤è¯¥å®ˆå«æ¡ä»¶çš„å€¼æ°¸è¿œæ˜¯ `false`ï¼Œä¹Ÿæ„å‘³ç€ç¬¬ä¸€ä¸ªåˆ†æ”¯æ°¸è¿œæ— æ³•è¢«åŒ¹é…ã€‚

ä¸‹é¢çš„æ–‡å­—å›¾è§£é‡Šäº†åŒ¹é…å®ˆå«ä½œç”¨äºå¤šä¸ªæ¨¡å¼æ—¶çš„ä¼˜å…ˆçº§è§„åˆ™ï¼Œç¬¬ä¸€å¼ æ˜¯æ­£ç¡®çš„ï¼š

```text
(4 | 5 | 6) if y => ...
```

è€Œç¬¬äºŒå¼ å›¾æ˜¯é”™è¯¯çš„

```text
4 | 5 | (6 if y) => ...
```

å¯ä»¥é€šè¿‡è¿è¡Œä»£ç æ—¶çš„æƒ…å†µçœ‹å‡ºè¿™ä¸€ç‚¹ï¼šå¦‚æœåŒ¹é…å®ˆå«åªä½œç”¨äºç”± `|` è¿ç®—ç¬¦æŒ‡å®šçš„å€¼åˆ—è¡¨çš„æœ€åä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªåˆ†æ”¯å°±ä¼šåŒ¹é…ä¸”ç¨‹åºä¼šæ‰“å°å‡º `yes`ã€‚

## @ç»‘å®š

`@`ï¼ˆè¯»ä½œ atï¼‰è¿ç®—ç¬¦å…è®¸ä¸ºä¸€ä¸ªå­—æ®µç»‘å®šå¦å¤–ä¸€ä¸ªå˜é‡ã€‚ä¸‹é¢ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›æµ‹è¯• `Message::Hello` çš„ `id` å­—æ®µæ˜¯å¦ä½äº `3..=7` èŒƒå›´å†…ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›èƒ½å°†å…¶å€¼ç»‘å®šåˆ° `id_variable` å˜é‡ä¸­ä»¥ä¾¿æ­¤åˆ†æ”¯ä¸­ç›¸å…³çš„ä»£ç å¯ä»¥ä½¿ç”¨å®ƒã€‚æˆ‘ä»¬å¯ä»¥å°† `id_variable` å‘½åä¸º `id`ï¼Œä¸å­—æ®µåŒåï¼Œä¸è¿‡å‡ºäºç¤ºä¾‹çš„ç›®çš„è¿™é‡Œé€‰æ‹©äº†ä¸åŒçš„åç§°ã€‚

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
```

ä¸Šä¾‹ä¼šæ‰“å°å‡º `Found an id in range: 5`ã€‚é€šè¿‡åœ¨ `3..=7` ä¹‹å‰æŒ‡å®š `id_variable @`ï¼Œæˆ‘ä»¬æ•è·äº†ä»»ä½•åŒ¹é…æ­¤èŒƒå›´çš„å€¼å¹¶åŒæ—¶å°†è¯¥å€¼ç»‘å®šåˆ°å˜é‡ `id_variable` ä¸Šã€‚

ç¬¬äºŒä¸ªåˆ†æ”¯åªåœ¨æ¨¡å¼ä¸­æŒ‡å®šäº†ä¸€ä¸ªèŒƒå›´ï¼Œ`id` å­—æ®µçš„å€¼å¯ä»¥æ˜¯ `10ã€11 æˆ– 12`ï¼Œä¸è¿‡è¿™ä¸ªæ¨¡å¼çš„ä»£ç å¹¶ä¸çŸ¥æƒ…ä¹Ÿä¸èƒ½ä½¿ç”¨ `id` å­—æ®µä¸­çš„å€¼ï¼Œå› ä¸ºæ²¡æœ‰å°† `id` å€¼ä¿å­˜è¿›ä¸€ä¸ªå˜é‡ã€‚

æœ€åä¸€ä¸ªåˆ†æ”¯æŒ‡å®šäº†ä¸€ä¸ªæ²¡æœ‰èŒƒå›´çš„å˜é‡ï¼Œæ­¤æ—¶ç¡®å®æ‹¥æœ‰å¯ä»¥ç”¨äºåˆ†æ”¯ä»£ç çš„å˜é‡ `id`ï¼Œå› ä¸ºè¿™é‡Œä½¿ç”¨äº†ç»“æ„ä½“å­—æ®µç®€å†™è¯­æ³•ã€‚ä¸è¿‡æ­¤åˆ†æ”¯ä¸­æ²¡æœ‰åƒå¤´ä¸¤ä¸ªåˆ†æ”¯é‚£æ ·å¯¹ `id` å­—æ®µçš„å€¼è¿›è¡Œæµ‹è¯•ï¼šä»»ä½•å€¼éƒ½ä¼šåŒ¹é…æ­¤åˆ†æ”¯ã€‚

å½“ä½ æ—¢æƒ³è¦é™å®šåˆ†æ”¯èŒƒå›´ï¼Œåˆæƒ³è¦ä½¿ç”¨åˆ†æ”¯çš„å˜é‡æ—¶ï¼Œå°±å¯ä»¥ç”¨ `@` æ¥ç»‘å®šåˆ°ä¸€ä¸ªæ–°çš„å˜é‡ä¸Šï¼Œå®ç°æƒ³è¦çš„åŠŸèƒ½ã€‚

#### @å‰ç»‘å®šåè§£æ„(Rust 1.56 æ–°å¢)

ä½¿ç”¨ `@` è¿˜å¯ä»¥åœ¨ç»‘å®šæ–°å˜é‡çš„åŒæ—¶ï¼Œå¯¹ç›®æ ‡è¿›è¡Œè§£æ„ï¼š

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // ç»‘å®šæ–°å˜é‡ `p`ï¼ŒåŒæ—¶å¯¹ `Point` è¿›è¡Œè§£æ„
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```

#### @æ–°ç‰¹æ€§(Rust 1.53 æ–°å¢)

è€ƒè™‘ä¸‹é¢ä¸€æ®µä»£ç :

```rust
fn main() {
    match 1 {
        num @ 1 | 2 => {
            println!("{}", num);
        }
        _ => {}
    }
}
```

ç¼–è¯‘ä¸é€šè¿‡ï¼Œæ˜¯å› ä¸º `num` æ²¡æœ‰ç»‘å®šåˆ°æ‰€æœ‰çš„æ¨¡å¼ä¸Šï¼Œåªç»‘å®šäº†æ¨¡å¼ `1`ï¼Œä½ å¯èƒ½ä¼šè¯•å›¾é€šè¿‡è¿™ä¸ªæ–¹å¼æ¥è§£å†³ï¼š

```rust
num @ (1 | 2)
```

ä½†æ˜¯ï¼Œå¦‚æœä½ ç”¨çš„æ˜¯ Rust 1.53 ä¹‹å‰çš„ç‰ˆæœ¬ï¼Œé‚£è¿™ç§å†™æ³•ä¼šæŠ¥é”™ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸æ”¯æŒã€‚

è‡³æ­¤ï¼Œæ¨¡å¼åŒ¹é…çš„å†…å®¹å·²ç»å…¨éƒ¨å®Œç»“ï¼Œå¤æ‚ä½†æ˜¯è¯¦å°½ï¼Œæƒ³è¦ä¸€æ¬¡æ€§å…¨éƒ¨è®°ä½å±å®ä¸æ˜“ï¼Œå› æ­¤è¯»è€…å¯ä»¥å…ˆç•™ä¸€ä¸ªå°è±¡ï¼Œç­‰æœªæ¥éœ€è¦æ—¶ï¼Œå†æ¥ç¿»é˜…å¯»æ‰¾å…·ä½“çš„æ¨¡å¼å®ç°æ–¹å¼ã€‚


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/pattern-match/patterns.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/patterns.md)ã€‚



================================================
FILE: src/basic/match-pattern/intro.md
================================================
# æ¨¡å¼åŒ¹é…

æ¨¡å¼åŒ¹é…ï¼Œè¿™ä¸ªè¯ï¼Œå¯¹äºéå‡½æ•°è¯­è¨€ç¼–ç¨‹æ¥è¯´ï¼ŒçœŸçš„è¿˜è›®å°‘å¬åˆ°ï¼Œå› ä¸ºå®ƒç»å¸¸å‡ºç°åœ¨å‡½æ•°å¼ç¼–ç¨‹é‡Œï¼Œç”¨äºä¸ºå¤æ‚çš„ç±»å‹ç³»ç»Ÿæä¾›ä¸€ä¸ªè½»æ¾çš„è§£æ„èƒ½åŠ›ã€‚

æ›¾è®°å¦ï¼Ÿåœ¨æšä¸¾å’Œæµç¨‹æ§åˆ¶é‚£ç« ï¼Œæˆ‘ä»¬é—ç•™äº†ä¸¤ä¸ªé—®é¢˜ï¼Œéƒ½æ˜¯å…³äº `match` çš„ï¼Œç¬¬ä¸€ä¸ªæ˜¯å¦‚ä½•å¯¹ `Option` æšä¸¾è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯å¦‚ä½•ç”¨ `match` æ¥æ›¿ä»£ `else if` è¿™ç§ä¸‘é™‹çš„å¤šé‡åˆ†æ”¯ä½¿ç”¨æ–¹å¼ã€‚é‚£ä¹ˆè®©æˆ‘ä»¬å…ˆä¸€èµ·æ¥æ­å¼€ `match` çš„ç¥ç§˜é¢çº±ã€‚



================================================
FILE: src/basic/match-pattern/match-if-let.md
================================================
# match å’Œ if let

åœ¨ Rust ä¸­ï¼Œæ¨¡å¼åŒ¹é…æœ€å¸¸ç”¨çš„å°±æ˜¯ `match` å’Œ `if let`ï¼Œæœ¬ç« èŠ‚å°†å¯¹ä¸¤è€…åŠç›¸å…³çš„æ¦‚å¿µè¿›è¡Œè¯¦å°½ä»‹ç»ã€‚

å…ˆæ¥çœ‹ä¸€ä¸ªå…³äº `match` çš„ç®€å•ä¾‹å­ï¼š

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
        _ => println!("West"),
    };
}
```

è¿™é‡Œæˆ‘ä»¬æƒ³å»åŒ¹é… `dire` å¯¹åº”çš„æšä¸¾ç±»å‹ï¼Œå› æ­¤åœ¨ `match` ä¸­ç”¨ä¸‰ä¸ªåŒ¹é…åˆ†æ”¯æ¥å®Œå…¨è¦†ç›–æšä¸¾å˜é‡ `Direction` çš„æ‰€æœ‰æˆå‘˜ç±»å‹ï¼Œæœ‰ä»¥ä¸‹å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- `match` çš„åŒ¹é…å¿…é¡»è¦ç©·ä¸¾å‡ºæ‰€æœ‰å¯èƒ½ï¼Œå› æ­¤è¿™é‡Œç”¨ `_` æ¥ä»£è¡¨æœªåˆ—å‡ºçš„æ‰€æœ‰å¯èƒ½æ€§
- `match` çš„æ¯ä¸€ä¸ªåˆ†æ”¯éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸”æ‰€æœ‰åˆ†æ”¯çš„è¡¨è¾¾å¼æœ€ç»ˆè¿”å›å€¼çš„ç±»å‹å¿…é¡»ç›¸åŒ
- **X | Y**ï¼Œç±»ä¼¼é€»è¾‘è¿ç®—ç¬¦ `æˆ–`ï¼Œä»£è¡¨è¯¥åˆ†æ”¯å¯ä»¥åŒ¹é… `X` ä¹Ÿå¯ä»¥åŒ¹é… `Y`ï¼Œåªè¦æ»¡è¶³ä¸€ä¸ªå³å¯

å…¶å® `match` è·Ÿå…¶ä»–è¯­è¨€ä¸­çš„ `switch` éå¸¸åƒï¼Œ`_` ç±»ä¼¼äº `switch` ä¸­çš„ `default`ã€‚

## `match` åŒ¹é…

é¦–å…ˆæ¥çœ‹çœ‹ `match` çš„é€šç”¨å½¢å¼ï¼š

```rust
match target {
    æ¨¡å¼1 => è¡¨è¾¾å¼1,
    æ¨¡å¼2 => {
        è¯­å¥1;
        è¯­å¥2;
        è¡¨è¾¾å¼2
    },
    _ => è¡¨è¾¾å¼3
}
```

è¯¥å½¢å¼æ¸…æ™°çš„è¯´æ˜äº†ä½•ä¸ºæ¨¡å¼ï¼Œä½•ä¸ºæ¨¡å¼åŒ¹é…ï¼šå°†æ¨¡å¼ä¸ `target` è¿›è¡ŒåŒ¹é…ï¼Œå³ä¸ºæ¨¡å¼åŒ¹é…ï¼Œè€Œæ¨¡å¼åŒ¹é…ä¸ä»…ä»…å±€é™äº `match`ï¼Œåé¢æˆ‘ä»¬ä¼šè¯¦ç»†é˜è¿°ã€‚

`match` å…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®ç›¸åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œå¯¹åº”çš„ä»£ç ï¼Œä¸‹é¢è®©æˆ‘ä»¬æ¥ä¸€ä¸€è¯¦è§£ï¼Œå…ˆçœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny =>  {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

`value_in_cents` å‡½æ•°æ ¹æ®åŒ¹é…åˆ°çš„ç¡¬å¸ï¼Œè¿”å›å¯¹åº”çš„ç¾åˆ†æ•°å€¼ã€‚`match` åç´§è·Ÿç€çš„æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè·Ÿ `if` å¾ˆåƒï¼Œä½†æ˜¯ `if` åçš„è¡¨è¾¾å¼å¿…é¡»æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè€Œ `match` åçš„è¡¨è¾¾å¼è¿”å›å€¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œåªè¦èƒ½è·Ÿåé¢çš„åˆ†æ”¯ä¸­çš„æ¨¡å¼åŒ¹é…èµ·æ¥å³å¯ï¼Œè¿™é‡Œçš„ `coin` æ˜¯æšä¸¾ `Coin` ç±»å‹ã€‚

æ¥ä¸‹æ¥æ˜¯ `match` çš„åˆ†æ”¯ã€‚ä¸€ä¸ªåˆ†æ”¯æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š**ä¸€ä¸ªæ¨¡å¼å’Œé’ˆå¯¹è¯¥æ¨¡å¼çš„å¤„ç†ä»£ç **ã€‚ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼æ˜¯ `Coin::Penny`ï¼Œå…¶åçš„ `=>` è¿ç®—ç¬¦å°†æ¨¡å¼å’Œå°†è¦è¿è¡Œçš„ä»£ç åˆ†å¼€ã€‚è¿™é‡Œçš„ä»£ç å°±ä»…ä»…æ˜¯è¡¨è¾¾å¼ `1`ï¼Œä¸åŒåˆ†æ”¯ä¹‹é—´ä½¿ç”¨é€—å·åˆ†éš”ã€‚

å½“ `match` è¡¨è¾¾å¼æ‰§è¡Œæ—¶ï¼Œå®ƒå°†ç›®æ ‡å€¼ `coin` æŒ‰é¡ºåºä¾æ¬¡ä¸æ¯ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¦‚æœæ¨¡å¼åŒ¹é…äº†è¿™ä¸ªå€¼ï¼Œé‚£ä¹ˆæ¨¡å¼ä¹‹åçš„ä»£ç å°†è¢«æ‰§è¡Œã€‚å¦‚æœæ¨¡å¼å¹¶ä¸åŒ¹é…è¿™ä¸ªå€¼ï¼Œå°†ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªåˆ†æ”¯ã€‚

æ¯ä¸ªåˆ†æ”¯ç›¸å…³è”çš„ä»£ç æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè€Œè¡¨è¾¾å¼çš„ç»“æœå€¼å°†ä½œä¸ºæ•´ä¸ª `match` è¡¨è¾¾å¼çš„è¿”å›å€¼ã€‚å¦‚æœåˆ†æ”¯æœ‰å¤šè¡Œä»£ç ï¼Œé‚£ä¹ˆéœ€è¦ç”¨ `{}` åŒ…è£¹ï¼ŒåŒæ—¶æœ€åä¸€è¡Œä»£ç éœ€è¦æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚

#### ä½¿ç”¨ `match` è¡¨è¾¾å¼èµ‹å€¼

è¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼Œ`match` æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨å®ƒæ¥èµ‹å€¼ï¼š

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```

å› ä¸ºè¿™é‡ŒåŒ¹é…åˆ° `_` åˆ†æ”¯ï¼Œæ‰€ä»¥å°† `"::1"` èµ‹å€¼ç»™äº† `ip_str`ã€‚

#### æ¨¡å¼ç»‘å®š

æ¨¡å¼åŒ¹é…çš„å¦å¤–ä¸€ä¸ªé‡è¦åŠŸèƒ½æ˜¯ä»æ¨¡å¼ä¸­å–å‡ºç»‘å®šçš„å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25ç¾åˆ†ç¡¬å¸
}
```

å…¶ä¸­ `Coin::Quarter` æˆå‘˜è¿˜å­˜æ”¾äº†ä¸€ä¸ªå€¼ï¼šç¾å›½çš„æŸä¸ªå·ï¼ˆå› ä¸ºåœ¨ 1999 å¹´åˆ° 2008 å¹´é—´ï¼Œç¾å›½åœ¨ 25 ç¾åˆ†(Quarter)ç¡¬å¸çš„èƒŒåä¸º 50 ä¸ªå·å°åˆ·äº†ä¸åŒçš„æ ‡è®°ï¼Œå…¶å®ƒç¡¬å¸éƒ½æ²¡æœ‰è¿™æ ·çš„è®¾è®¡ï¼‰ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨æ¨¡å¼åŒ¹é…ä¸­ï¼Œè·å–åˆ° 25 ç¾åˆ†ç¡¬å¸ä¸Šåˆ»å°çš„å·çš„åç§°ï¼š

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

ä¸Šé¢ä»£ç ä¸­ï¼Œåœ¨åŒ¹é… `Coin::Quarter(state)` æ¨¡å¼æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå†…éƒ¨å­˜å‚¨çš„å€¼ç»‘å®šåˆ°äº† `state` å˜é‡ä¸Šï¼Œå› æ­¤ `state` å˜é‡å°±æ˜¯å¯¹åº”çš„ `UsState` æšä¸¾ç±»å‹ã€‚

ä¾‹å¦‚æœ‰ä¸€ä¸ªå°äº†é˜¿æ‹‰æ–¯åŠ å·æ ‡è®°çš„ 25 åˆ†ç¡¬å¸ï¼š`Coin::Quarter(UsState::Alaska)`ï¼Œå®ƒåœ¨åŒ¹é…æ—¶ï¼Œ`state` å˜é‡å°†è¢«ç»‘å®š `UsState::Alaska` çš„æšä¸¾å€¼ã€‚

å†æ¥çœ‹ä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼š

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
```

è¿è¡Œåè¾“å‡ºï¼š

```console
$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `target/debug/world_hello`
Hello Rust
point from (0, 0) move to (1, 2)
change color into '(r:255, g:255, b:0)', 'b' has been ignored
```

#### ç©·å°½åŒ¹é…

åœ¨æ–‡ç« çš„å¼€å¤´ï¼Œæˆ‘ä»¬ç®€å•æ€»ç»“è¿‡ `match` çš„åŒ¹é…å¿…é¡»ç©·å°½æ‰€æœ‰æƒ…å†µï¼Œä¸‹é¢æ¥ä¸¾ä¾‹è¯´æ˜ï¼Œä¾‹å¦‚ï¼š

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
    };
}
```

æˆ‘ä»¬æ²¡æœ‰å¤„ç† `Direction::West` çš„æƒ…å†µï¼Œå› æ­¤ä¼šæŠ¥é”™ï¼š

```console
error[E0004]: non-exhaustive patterns: `West` not covered // éç©·å°½åŒ¹é…ï¼Œ`West` æ²¡æœ‰è¢«è¦†ç›–
  --> src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // æ¨¡å¼ `West` æ²¡æœ‰è¢«è¦†ç›–
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
```

ä¸ç¦æƒ³æ„Ÿå¹ï¼ŒRust çš„ç¼–è¯‘å™¨**çœŸå¼ºå¤§**ï¼Œå¿ä¸ä½æƒ³çˆ†ç²—å£äº†ï¼Œsorryï¼Œå¦‚æœä½ ä»¥åè¿›ä¸€æ­¥æ·±å…¥ä½¿ç”¨ Rust ä¹Ÿä¼šåƒæˆ‘è¿™æ ·æ„Ÿå¹çš„ã€‚Rust ç¼–è¯‘å™¨æ¸…æ™°åœ°çŸ¥é“ `match` ä¸­æœ‰å“ªäº›åˆ†æ”¯æ²¡æœ‰è¢«è¦†ç›–ï¼Œè¿™ç§è¡Œä¸ºèƒ½å¼ºåˆ¶æˆ‘ä»¬å¤„ç†æ‰€æœ‰çš„å¯èƒ½æ€§ï¼Œæœ‰æ•ˆé¿å…ä¼ è¯´ä¸­ä»·å€¼**åäº¿ç¾é‡‘**çš„ `null` é™·é˜±ã€‚

#### `_` é€šé…ç¬¦

å½“æˆ‘ä»¬ä¸æƒ³åœ¨åŒ¹é…æ—¶åˆ—å‡ºæ‰€æœ‰å€¼çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ Rust æä¾›çš„ä¸€ä¸ªç‰¹æ®Š**æ¨¡å¼**ï¼Œä¾‹å¦‚ï¼Œ`u8` å¯ä»¥æ‹¥æœ‰ 0 åˆ° 255 çš„æœ‰æ•ˆçš„å€¼ï¼Œä½†æ˜¯æˆ‘ä»¬åªå…³å¿ƒ `1ã€3ã€5 å’Œ 7` è¿™å‡ ä¸ªå€¼ï¼Œä¸æƒ³åˆ—å‡ºå…¶å®ƒçš„ `0ã€2ã€4ã€6ã€8ã€9 ä¸€ç›´åˆ° 255` çš„å€¼ã€‚é‚£ä¹ˆ, æˆ‘ä»¬ä¸å¿…ä¸€ä¸ªä¸€ä¸ªåˆ—å‡ºæ‰€æœ‰å€¼, å› ä¸ºå¯ä»¥ä½¿ç”¨ç‰¹æ®Šçš„æ¨¡å¼ `_` æ›¿ä»£ï¼š

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

é€šè¿‡å°† `_` å…¶æ”¾ç½®äºå…¶ä»–åˆ†æ”¯åï¼Œ`_` å°†ä¼šåŒ¹é…æ‰€æœ‰é—æ¼çš„å€¼ã€‚`()` è¡¨ç¤ºè¿”å›**å•å…ƒç±»å‹**ä¸æ‰€æœ‰åˆ†æ”¯è¿”å›å€¼çš„ç±»å‹ç›¸åŒï¼Œæ‰€ä»¥å½“åŒ¹é…åˆ° `_` åï¼Œä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚

é™¤äº†`_`é€šé…ç¬¦ï¼Œç”¨ä¸€ä¸ªå˜é‡æ¥æ‰¿è½½å…¶ä»–æƒ…å†µä¹Ÿæ˜¯å¯ä»¥çš„ã€‚

```rust
#[derive(Debug)]
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        other => println!("other direction: {:?}", other),
    };
}
```

ç„¶è€Œï¼Œåœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å…¶å®åªå…³å¿ƒ**æŸä¸€ä¸ªå€¼æ˜¯å¦å­˜åœ¨**ï¼Œæ­¤æ—¶ `match` å°±æ˜¾å¾—è¿‡äºå•°å—¦ã€‚

## `if let` åŒ¹é…

æœ‰æ—¶ä¼šé‡åˆ°åªæœ‰ä¸€ä¸ªæ¨¡å¼çš„å€¼éœ€è¦è¢«å¤„ç†ï¼Œå…¶å®ƒå€¼ç›´æ¥å¿½ç•¥çš„åœºæ™¯ï¼Œå¦‚æœç”¨ `match` æ¥å¤„ç†å°±è¦å†™æˆä¸‹é¢è¿™æ ·ï¼š

```rust
    let v = Some(3u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }
```

æˆ‘ä»¬åªæƒ³è¦å¯¹ `Some(3)` æ¨¡å¼è¿›è¡ŒåŒ¹é…, ä¸æƒ³å¤„ç†ä»»ä½•å…¶ä»– `Some<u8>` å€¼æˆ– `None` å€¼ã€‚ä½†æ˜¯ä¸ºäº†æ»¡è¶³ `match` è¡¨è¾¾å¼ï¼ˆç©·å°½æ€§ï¼‰çš„è¦æ±‚ï¼Œå†™ä»£ç æ—¶å¿…é¡»åœ¨å¤„ç†å®Œè¿™å”¯ä¸€çš„æˆå‘˜ååŠ ä¸Š `_ => ()`ï¼Œè¿™æ ·ä¼šå¢åŠ ä¸å°‘æ— ç”¨çš„ä»£ç ã€‚

ä¿—è¯è¯´â€œæ€é¸¡ç„‰ç”¨ç‰›åˆ€â€ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥ç”¨ `if let` çš„æ–¹å¼æ¥å®ç°ï¼š

```rust
if let Some(3) = v {
    println!("three");
}
```

è¿™ä¸¤ç§åŒ¹é…å¯¹äºæ–°æ‰‹æ¥è¯´ï¼Œå¯èƒ½æœ‰äº›éš¾ä»¥æŠ‰æ‹©ï¼Œä½†æ˜¯åªè¦è®°ä½ä¸€ç‚¹å°±å¥½ï¼š**å½“ä½ åªè¦åŒ¹é…ä¸€ä¸ªæ¡ä»¶ï¼Œä¸”å¿½ç•¥å…¶ä»–æ¡ä»¶æ—¶å°±ç”¨ `if let` ï¼Œå¦åˆ™éƒ½ç”¨ `match`**ã€‚

## matches!å®

Rust æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªéå¸¸å®ç”¨çš„å®ï¼š`matches!`ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªè¡¨è¾¾å¼è·Ÿæ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œç„¶åè¿”å›åŒ¹é…çš„ç»“æœ `true` or `false`ã€‚

ä¾‹å¦‚ï¼Œæœ‰ä¸€ä¸ªåŠ¨æ€æ•°ç»„ï¼Œé‡Œé¢å­˜æœ‰ä»¥ä¸‹æšä¸¾ï¼š

```rust
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
}
```

ç°åœ¨å¦‚æœæƒ³å¯¹ `v` è¿›è¡Œè¿‡æ»¤ï¼Œåªä¿ç•™ç±»å‹æ˜¯ `MyEnum::Foo` çš„å…ƒç´ ï¼Œä½ å¯èƒ½æƒ³è¿™ä¹ˆå†™ï¼š

```rust
v.iter().filter(|x| x == MyEnum::Foo);
```

ä½†æ˜¯ï¼Œå®é™…ä¸Šè¿™è¡Œä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸ºä½ æ— æ³•å°† `x` ç›´æ¥è·Ÿä¸€ä¸ªæšä¸¾æˆå‘˜è¿›è¡Œæ¯”è¾ƒã€‚å¥½åœ¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ `match` æ¥å®Œæˆï¼Œä½†æ˜¯ä¼šå¯¼è‡´ä»£ç æ›´ä¸ºå•°å—¦ï¼Œæ˜¯å¦æœ‰æ›´ç®€æ´çš„æ–¹å¼ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨ `matches!`ï¼š

```rust
v.iter().filter(|x| matches!(x, MyEnum::Foo));
```

å¾ˆç®€å•ä¹Ÿå¾ˆç®€æ´ï¼Œå†æ¥çœ‹çœ‹æ›´å¤šçš„ä¾‹å­ï¼š

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```

## å˜é‡é®è”½

æ— è®ºæ˜¯ `match` è¿˜æ˜¯ `if let`ï¼Œè¿™é‡Œéƒ½æ˜¯ä¸€ä¸ªæ–°çš„ä»£ç å—ï¼Œè€Œä¸”è¿™é‡Œçš„ç»‘å®šç›¸å½“äºæ–°å˜é‡ï¼Œå¦‚æœä½ ä½¿ç”¨åŒåå˜é‡ï¼Œä¼šå‘ç”Ÿå˜é‡é®è”½ï¼š

```rust
fn main() {
   let age = Some(30);
   println!("åœ¨åŒ¹é…å‰ï¼Œageæ˜¯{:?}",age);
   if let Some(age) = age {
       println!("åŒ¹é…å‡ºæ¥çš„ageæ˜¯{}",age);
   }

   println!("åœ¨åŒ¹é…åï¼Œageæ˜¯{:?}",age);
}
```

`cargo run `è¿è¡Œåè¾“å‡ºå¦‚ä¸‹ï¼š

```console
åœ¨åŒ¹é…å‰ï¼Œageæ˜¯Some(30)
åŒ¹é…å‡ºæ¥çš„ageæ˜¯30
åœ¨åŒ¹é…åï¼Œageæ˜¯Some(30)
```

å¯ä»¥çœ‹å‡ºåœ¨ `if let` ä¸­ï¼Œ`=` å³è¾¹ `Some(i32)` ç±»å‹çš„ `age` è¢«å·¦è¾¹ `i32` ç±»å‹çš„æ–° `age` é®è”½äº†ï¼Œè¯¥é®è”½ä¸€ç›´æŒç»­åˆ° `if let` è¯­å¥å—çš„ç»“æŸã€‚å› æ­¤ç¬¬ä¸‰ä¸ª `println!` è¾“å‡ºçš„ `age` ä¾ç„¶æ˜¯ `Some(i32)` ç±»å‹ã€‚

å¯¹äº `match` ç±»å‹ä¹Ÿæ˜¯å¦‚æ­¤:

```rust
fn main() {
   let age = Some(30);
   println!("åœ¨åŒ¹é…å‰ï¼Œageæ˜¯{:?}",age);
   match age {
       Some(age) =>  println!("åŒ¹é…å‡ºæ¥çš„ageæ˜¯{}",age),
       _ => ()
   }
   println!("åœ¨åŒ¹é…åï¼Œageæ˜¯{:?}",age);
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**`match` ä¸­çš„å˜é‡é®è”½å…¶å®ä¸æ˜¯é‚£ä¹ˆçš„å®¹æ˜“çœ‹å‡º**ï¼Œå› æ­¤è¦å°å¿ƒï¼å…¶å®è¿™é‡Œæœ€å¥½ä¸è¦ä½¿ç”¨åŒåï¼Œé¿å…éš¾ä»¥ç†è§£ï¼Œå¦‚ä¸‹ã€‚

```rust
fn main() {
   let age = Some(30);
   println!("åœ¨åŒ¹é…å‰ï¼Œageæ˜¯{:?}", age);
   match age {
       Some(x) =>  println!("åŒ¹é…å‡ºæ¥çš„ageæ˜¯{}", x),
       _ => ()
   }
   println!("åœ¨åŒ¹é…åï¼Œageæ˜¯{:?}", age);
}
```


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/pattern-match/match-iflet.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/match.md)ã€‚



================================================
FILE: src/basic/match-pattern/option.md
================================================
# è§£æ„ Option

åœ¨æšä¸¾é‚£ç« ï¼Œæåˆ°è¿‡ `Option` æšä¸¾ï¼Œå®ƒç”¨æ¥è§£å†³ Rust ä¸­å˜é‡æ˜¯å¦æœ‰å€¼çš„é—®é¢˜ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

```rust
enum Option<T> {
    None,
    Some(T),
}
```

ç®€å•è§£é‡Šå°±æ˜¯ï¼š**ä¸€ä¸ªå˜é‡è¦ä¹ˆæœ‰å€¼ï¼š`Some(T)`, è¦ä¹ˆä¸ºç©ºï¼š`None`**ã€‚

é‚£ä¹ˆç°åœ¨çš„é—®é¢˜å°±æ˜¯è¯¥å¦‚ä½•å»ä½¿ç”¨è¿™ä¸ª `Option` æšä¸¾ç±»å‹ï¼Œæ ¹æ®æˆ‘ä»¬ä¸Šä¸€èŠ‚çš„ç»éªŒï¼Œå¯ä»¥é€šè¿‡ `match` æ¥å®ç°ã€‚

> å› ä¸º `Option`ï¼Œ`Some`ï¼Œ`None` éƒ½åŒ…å«åœ¨ `prelude` ä¸­ï¼Œå› æ­¤ä½ å¯ä»¥ç›´æ¥é€šè¿‡åç§°æ¥ä½¿ç”¨å®ƒä»¬ï¼Œè€Œæ— éœ€ä»¥ `Option::Some` è¿™ç§å½¢å¼å»ä½¿ç”¨ï¼Œæ€»ä¹‹ï¼Œåƒä¸‡ä¸è¦å› ä¸ºè°ƒç”¨è·¯å¾„å˜çŸ­äº†ï¼Œå°±å¿˜è®° `Some` å’Œ `None` ä¹Ÿæ˜¯ `Option` åº•ä¸‹çš„æšä¸¾æˆå‘˜ï¼

## åŒ¹é… `Option<T>`

ä½¿ç”¨ `Option<T>`ï¼Œæ˜¯ä¸ºäº†ä» `Some` ä¸­å–å‡ºå…¶å†…éƒ¨çš„ `T` å€¼ä»¥åŠå¤„ç†æ²¡æœ‰å€¼çš„æƒ…å†µï¼Œä¸ºäº†æ¼”ç¤ºè¿™ä¸€ç‚¹ï¼Œä¸‹é¢ä¸€èµ·æ¥ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè·å–ä¸€ä¸ª `Option<i32>`ï¼Œå¦‚æœå…¶ä¸­å«æœ‰ä¸€ä¸ªå€¼ï¼Œå°†å…¶åŠ ä¸€ï¼›å¦‚æœå…¶ä¸­æ²¡æœ‰å€¼ï¼Œåˆ™å‡½æ•°è¿”å› `None` å€¼ï¼š

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

`plus_one` æ¥å—ä¸€ä¸ª `Option<i32>` ç±»å‹çš„å‚æ•°ï¼ŒåŒæ—¶è¿”å›ä¸€ä¸ª `Option<i32>` ç±»å‹çš„å€¼ï¼ˆè¿™ç§å½¢å¼çš„å‡½æ•°åœ¨æ ‡å‡†åº“å†…éšå¤„æ‰€è§ï¼‰ï¼Œåœ¨è¯¥å‡½æ•°çš„å†…éƒ¨å¤„ç†ä¸­ï¼Œå¦‚æœä¼ å…¥çš„æ˜¯ä¸€ä¸ª `None` ï¼Œåˆ™è¿”å›ä¸€ä¸ª `None` ä¸”ä¸åšä»»ä½•å¤„ç†ï¼›å¦‚æœä¼ å…¥çš„æ˜¯ä¸€ä¸ª `Some(i32)`ï¼Œåˆ™é€šè¿‡æ¨¡å¼ç»‘å®šï¼ŒæŠŠå…¶ä¸­çš„å€¼ç»‘å®šåˆ°å˜é‡ `i` ä¸Šï¼Œç„¶åè¿”å› `i+1` çš„å€¼ï¼ŒåŒæ—¶ç”¨ `Some` è¿›è¡ŒåŒ…è£¹ã€‚

ä¸ºäº†è¿›ä¸€æ­¥è¯´æ˜ï¼Œå‡è®¾ `plus_one` å‡½æ•°æ¥å—çš„å‚æ•°å€¼ x æ˜¯ `Some(5)`ï¼Œæ¥çœ‹çœ‹å…·ä½“çš„åˆ†æ”¯åŒ¹é…æƒ…å†µï¼š

#### ä¼ å…¥å‚æ•° `Some(5)`

```rust,ignore
None => None,
```

é¦–å…ˆæ˜¯åŒ¹é… `None` åˆ†æ”¯ï¼Œå› ä¸ºå€¼ `Some(5)` å¹¶ä¸åŒ¹é…æ¨¡å¼ `None`ï¼Œæ‰€ä»¥ç»§ç»­åŒ¹é…ä¸‹ä¸€ä¸ªåˆ†æ”¯ã€‚

```rust,ignore
Some(i) => Some(i + 1),
```

`Some(5)` ä¸ `Some(i)` åŒ¹é…å—ï¼Ÿå½“ç„¶åŒ¹é…ï¼å®ƒä»¬æ˜¯ç›¸åŒçš„æˆå‘˜ã€‚`i` ç»‘å®šäº† `Some` ä¸­åŒ…å«çš„å€¼ï¼Œå› æ­¤ `i` çš„å€¼æ˜¯ `5`ã€‚æ¥ç€åŒ¹é…åˆ†æ”¯çš„ä»£ç è¢«æ‰§è¡Œï¼Œæœ€åå°† `i` çš„å€¼åŠ ä¸€å¹¶è¿”å›ä¸€ä¸ªå«æœ‰å€¼ `6` çš„æ–° `Some`ã€‚

#### ä¼ å…¥å‚æ•° None

æ¥ç€è€ƒè™‘ä¸‹ `plus_one` çš„ç¬¬äºŒä¸ªè°ƒç”¨ï¼Œè¿™æ¬¡ä¼ å…¥çš„ `x` æ˜¯ `None`ï¼Œ æˆ‘ä»¬è¿›å…¥ `match` å¹¶ä¸ç¬¬ä¸€ä¸ªåˆ†æ”¯ç›¸æ¯”è¾ƒã€‚

```rust,ignore
None => None,
```

åŒ¹é…ä¸Šäº†ï¼æ¥ç€ç¨‹åºç»§ç»­æ‰§è¡Œè¯¥åˆ†æ”¯åçš„ä»£ç ï¼šè¿”å›è¡¨è¾¾å¼ `None` çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¿”å›ä¸€ä¸ª `None`ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªåˆ†æ”¯å°±åŒ¹é…åˆ°äº†ï¼Œå…¶ä»–çš„åˆ†æ”¯å°†ä¸å†æ¯”è¾ƒã€‚



================================================
FILE: src/basic/match-pattern/pattern-match.md
================================================
# æ¨¡å¼é€‚ç”¨åœºæ™¯

## æ¨¡å¼

æ¨¡å¼æ˜¯ Rust ä¸­çš„ç‰¹æ®Šè¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„å’Œæ•°æ®ï¼Œå®ƒå¾€å¾€å’Œ `match` è¡¨è¾¾å¼è”ç”¨ï¼Œä»¥å®ç°å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½åŠ›ã€‚æ¨¡å¼ä¸€èˆ¬ç”±ä»¥ä¸‹å†…å®¹ç»„åˆè€Œæˆï¼š

- å­—é¢å€¼
- è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„
- å˜é‡
- é€šé…ç¬¦
- å ä½ç¬¦

### æ‰€æœ‰å¯èƒ½ç”¨åˆ°æ¨¡å¼çš„åœ°æ–¹

#### match åˆ†æ”¯

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œ`match` çš„æ¯ä¸ªåˆ†æ”¯å°±æ˜¯ä¸€ä¸ª**æ¨¡å¼**ï¼Œå› ä¸º `match` åŒ¹é…æ˜¯ç©·å°½å¼çš„ï¼Œå› æ­¤æˆ‘ä»¬å¾€å¾€éœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„æ¨¡å¼ `_`ï¼Œæ¥åŒ¹é…å‰©ä½™çš„æ‰€æœ‰æƒ…å†µï¼š

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    _ => EXPRESSION,
}
```

#### if let åˆ†æ”¯

`if let` å¾€å¾€ç”¨äºåŒ¹é…ä¸€ä¸ªæ¨¡å¼ï¼Œè€Œå¿½ç•¥å‰©ä¸‹çš„æ‰€æœ‰æ¨¡å¼çš„åœºæ™¯ï¼š

```rust
if let PATTERN = SOME_VALUE {

}
```

#### while let æ¡ä»¶å¾ªç¯

ä¸€ä¸ªä¸ `if let` ç±»ä¼¼çš„ç»“æ„æ˜¯ `while let` æ¡ä»¶å¾ªç¯ï¼Œå®ƒå…è®¸åªè¦æ¨¡å¼åŒ¹é…å°±ä¸€ç›´è¿›è¡Œ `while` å¾ªç¯ã€‚ä¸‹é¢å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ `while let` çš„ä¾‹å­ï¼š

```rust
// Vecæ˜¯åŠ¨æ€æ•°ç»„
let mut stack = Vec::new();

// å‘æ•°ç»„å°¾éƒ¨æ’å…¥å…ƒç´ 
stack.push(1);
stack.push(2);
stack.push(3);

// stack.popä»æ•°ç»„å°¾éƒ¨å¼¹å‡ºå…ƒç´ 
while let Some(top) = stack.pop() {
    println!("{}", top);
}
```

è¿™ä¸ªä¾‹å­ä¼šæ‰“å°å‡º `3`ã€`2` æ¥ç€æ˜¯ `1`ã€‚`pop` æ–¹æ³•å–å‡ºåŠ¨æ€æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ å¹¶è¿”å› `Some(value)`ï¼Œå¦‚æœåŠ¨æ€æ•°ç»„æ˜¯ç©ºçš„ï¼Œå°†è¿”å› `None`ï¼Œå¯¹äº `while` æ¥è¯´ï¼Œåªè¦ `pop` è¿”å› `Some` å°±ä¼šä¸€ç›´ä¸åœçš„å¾ªç¯ã€‚ä¸€æ—¦å…¶è¿”å› `None`ï¼Œ`while` å¾ªç¯åœæ­¢ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `while let` æ¥å¼¹å‡ºæ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚

ä½ ä¹Ÿå¯ä»¥ç”¨ `loop` + `if let` æˆ–è€… `match` æ¥å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œä½†æ˜¯ä¼šæ›´åŠ å•°å—¦ã€‚

#### for å¾ªç¯

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

è¿™é‡Œä½¿ç”¨ `enumerate` æ–¹æ³•äº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥è¿­ä»£å™¨æ¯æ¬¡è¿­ä»£ä¼šè¿”å›ä¸€ä¸ª `(ç´¢å¼•ï¼Œå€¼)` å½¢å¼çš„å…ƒç»„ï¼Œç„¶åç”¨ `(index,value)` æ¥åŒ¹é…ã€‚

#### let è¯­å¥

```rust
let PATTERN = EXPRESSION;
```

æ˜¯çš„ï¼Œ è¯¥è¯­å¥æˆ‘ä»¬å·²ç»ç”¨äº†æ— æ•°æ¬¡äº†ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…ï¼š

```rust
let x = 5;
```

è¿™å…¶ä¸­ï¼Œ`x` ä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼ç»‘å®šï¼Œä»£è¡¨å°†**åŒ¹é…çš„å€¼ç»‘å®šåˆ°å˜é‡ x ä¸Š**ã€‚å› æ­¤ï¼Œåœ¨ Rust ä¸­ï¼Œ**å˜é‡åä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼**ï¼Œåªä¸è¿‡å®ƒæ¯”è¾ƒæœ´ç´ å¾ˆä¸èµ·çœ¼ç½¢äº†ã€‚

```rust
let (x, y, z) = (1, 2, 3);
```

ä¸Šé¢å°†ä¸€ä¸ªå…ƒç»„ä¸æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼ˆ**æ¨¡å¼å’Œå€¼çš„ç±»å‹å¿…éœ€ç›¸åŒï¼**ï¼‰ï¼Œç„¶åæŠŠ `1, 2, 3` åˆ†åˆ«ç»‘å®šåˆ° `x, y, z` ä¸Šã€‚

æ¨¡å¼åŒ¹é…è¦æ±‚ä¸¤è¾¹çš„ç±»å‹å¿…é¡»ç›¸åŒï¼Œå¦åˆ™å°±ä¼šå¯¼è‡´ä¸‹é¢çš„æŠ¥é”™ï¼š

```rust
let (x, y) = (1, 2, 3);
```

```rust
error[E0308]: mismatched types
 --> src/main.rs:4:5
  |
4 | let (x, y) = (1, 2, 3);
  |     ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |     |
  |     expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error
```

å¯¹äºå…ƒç»„æ¥è¯´ï¼Œå…ƒç´ ä¸ªæ•°ä¹Ÿæ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼

#### å‡½æ•°å‚æ•°

å‡½æ•°å‚æ•°ä¹Ÿæ˜¯æ¨¡å¼ï¼š

```rust
fn foo(x: i32) {
    // ä»£ç 
}
```

å…¶ä¸­ `x` å°±æ˜¯ä¸€ä¸ªæ¨¡å¼ï¼Œä½ è¿˜å¯ä»¥åœ¨å‚æ•°ä¸­åŒ¹é…å…ƒç»„ï¼š

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

`&(3, 5)` ä¼šåŒ¹é…æ¨¡å¼ `&(x, y)`ï¼Œå› æ­¤ `x` å¾—åˆ°äº† `3`ï¼Œ`y` å¾—åˆ°äº† `5`ã€‚

#### let å’Œ if let

å¯¹äºä»¥ä¸‹ä»£ç ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š

```rust
let Some(x) = some_option_value;
```

å› ä¸ºå³è¾¹çš„å€¼å¯èƒ½ä¸ä¸º `Some`ï¼Œè€Œæ˜¯ `None`ï¼Œè¿™ç§æ—¶å€™å°±ä¸èƒ½è¿›è¡ŒåŒ¹é…ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„ä»£ç é—æ¼äº† `None` çš„åŒ¹é…ã€‚

ç±»ä¼¼ `let` , `for`å’Œ`match` éƒ½å¿…é¡»è¦æ±‚å®Œå…¨è¦†ç›–åŒ¹é…ï¼Œæ‰èƒ½é€šè¿‡ç¼–è¯‘( ä¸å¯é©³æ¨¡å¼åŒ¹é… )ã€‚

ä½†æ˜¯å¯¹äº `if let`ï¼Œå°±å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š

```rust
if let Some(x) = some_option_value {
    println!("{}", x);
}
```

å› ä¸º `if let` å…è®¸åŒ¹é…ä¸€ç§æ¨¡å¼ï¼Œè€Œå¿½ç•¥å…¶ä½™çš„æ¨¡å¼( å¯é©³æ¨¡å¼åŒ¹é… )ã€‚

#### let-else(Rust 1.65 æ–°å¢)

ä½¿ç”¨ `let-else` åŒ¹é…ï¼Œå³å¯ä½¿ `let` å˜ä¸ºå¯é©³æ¨¡å¼ã€‚å®ƒå¯ä»¥ä½¿ç”¨ `else` åˆ†æ”¯æ¥å¤„ç†æ¨¡å¼ä¸åŒ¹é…çš„æƒ…å†µï¼Œä½†æ˜¯ `else` åˆ†æ”¯ä¸­å¿…é¡»ç”¨å‘æ•£çš„ä»£ç å—å¤„ç†ï¼ˆä¾‹å¦‚ï¼š`break`ã€`return`ã€`panic`ï¼‰ã€‚è¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š

```rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    // error: `else` clause of `let...else` does not diverge
    // let Ok(count) = u64::from_str(count_str) else { 0 };
    (count, item)
}

fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
}
```

ä¸ `match` å’Œ `if let` ç›¸æ¯”ï¼Œ`let-else` çš„ä¸€ä¸ªæ˜¾è‘—ç‰¹ç‚¹åœ¨äºå…¶è§£åŒ…æˆåŠŸæ—¶æ‰€åˆ›å»ºçš„å˜é‡å…·æœ‰æ›´å¹¿çš„ä½œç”¨åŸŸã€‚åœ¨ `let-else` è¯­å¥ä¸­ï¼ŒæˆåŠŸåŒ¹é…åçš„å˜é‡ä¸å†ä»…é™äºç‰¹å®šåˆ†æ”¯å†…ä½¿ç”¨ï¼š

```rust
// if let
if let Some(x) = some_option_value {
    println!("{}", x);
}

// let-else
let Some(x) = some_option_value else { return; }
println!("{}", x);
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ`if let` å†™æ³•é‡Œçš„ `x` åªèƒ½åœ¨ `if` åˆ†æ”¯å†…ä½¿ç”¨ï¼Œè€Œ `let-else` å†™æ³•é‡Œçš„ `x` åˆ™å¯ä»¥åœ¨ `let` ä¹‹å¤–ä½¿ç”¨ã€‚




================================================
FILE: src/basic/ownership/borrowing.md
================================================
[Binary file]


================================================
FILE: src/basic/ownership/index.md
================================================
# æ‰€æœ‰æƒå’Œå€Ÿç”¨

Rust ä¹‹æ‰€ä»¥èƒ½æˆä¸ºä¸‡ä¼—ç©ç›®çš„è¯­è¨€ï¼Œå°±æ˜¯å› ä¸ºå…¶å†…å­˜å®‰å…¨æ€§ã€‚åœ¨ä»¥å¾€ï¼Œå†…å­˜å®‰å…¨å‡ ä¹éƒ½æ˜¯é€šè¿‡ GC çš„æ–¹å¼å®ç°ï¼Œä½†æ˜¯ GC ä¼šå¼•æ¥æ€§èƒ½ã€å†…å­˜å ç”¨ä»¥åŠ Stop the world ç­‰é—®é¢˜ï¼Œåœ¨é«˜æ€§èƒ½åœºæ™¯å’Œç³»ç»Ÿç¼–ç¨‹ä¸Šæ˜¯ä¸å¯æ¥å—çš„ï¼Œå› æ­¤ Rust é‡‡ç”¨äº†ä¸ ( ä¸ ) ä¼— ( å’‹ ) ä¸ ( å¥½ ) åŒ ( å­¦ )çš„æ–¹å¼ï¼š**æ‰€æœ‰æƒç³»ç»Ÿ**ã€‚

ç†è§£**æ‰€æœ‰æƒ**å’Œ**å€Ÿç”¨**ï¼Œå¯¹äº Rust å­¦ä¹ æ˜¯è‡³å…³é‡è¦çš„ï¼Œå› æ­¤æˆ‘ä»¬æŠŠæœ¬ç« æåˆ°äº†éå¸¸é å‰çš„ä½ç½®ï¼ŒSoï¼Œåœ¨åº§çš„å„ä½ï¼Œæœ‰ä¸€ä¸ªç®—ä¸€ä¸ªï¼Œå‡†å¤‡å¥½äº†å˜›ï¼Ÿ

ä»ç°åœ¨å¼€å§‹ï¼Œé‰´äºå¤§å®¶å·²ç»æŒæ¡äº†éå¸¸åŸºæœ¬çš„è¯­æ³•ï¼Œæœ‰äº›æ—¶å€™ï¼Œåœ¨ç¤ºä¾‹ä»£ç ä¸­ï¼Œå°†çœç•¥ `fn main() {}` çš„æ¨¡ç‰ˆä»£ç ï¼Œåªè¦å°†ç›¸åº”çš„ç¤ºä¾‹æ”¾åœ¨ `fn main() {}` ä¸­ï¼Œå³å¯è¿è¡Œã€‚



================================================
FILE: src/basic/ownership/ownership.md
================================================
[Binary file]


================================================
FILE: src/basic/result-error/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/result-error/panic.md
================================================
# panic æ·±å…¥å‰–æ

åœ¨æ­£å¼å¼€å§‹ä¹‹å‰ï¼Œå…ˆæ¥æ€è€ƒä¸€ä¸ªé—®é¢˜ï¼šå‡è®¾æˆ‘ä»¬æƒ³è¦ä»æ–‡ä»¶è¯»å–æ•°æ®ï¼Œå¦‚æœå¤±è´¥ï¼Œä½ æœ‰æ²¡æœ‰å¥½çš„åŠæ³•é€šçŸ¥è°ƒç”¨è€…ä¸ºä½•å¤±è´¥ï¼Ÿå¦‚æœæˆåŠŸï¼Œä½ æœ‰æ²¡æœ‰å¥½çš„åŠæ³•æŠŠè¯»å–çš„ç»“æœè¿”è¿˜ç»™è°ƒç”¨è€…ï¼Ÿ

## panic! ä¸ä¸å¯æ¢å¤é”™è¯¯

ä¸Šé¢çš„é—®é¢˜åœ¨çœŸå®åœºæ™¯ä¼šç»å¸¸é‡åˆ°ï¼Œå…¶å®å¤„ç†èµ·æ¥æŒºå¤æ‚çš„ï¼Œè®©æˆ‘ä»¬å…ˆåšä¸€ä¸ªå‡è®¾ï¼šæ–‡ä»¶è¯»å–æ“ä½œå‘ç”Ÿåœ¨ç³»ç»Ÿå¯åŠ¨é˜¶æ®µã€‚é‚£ä¹ˆå¯ä»¥è½»æ˜“å¾—å‡ºä¸€ä¸ªç»“è®ºï¼Œä¸€æ—¦æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œé‚£ä¹ˆç³»ç»Ÿå¯åŠ¨ä¹Ÿå°†å¤±è´¥ï¼Œè¿™æ„å‘³ç€è¯¥å¤±è´¥æ˜¯ä¸å¯æ¢å¤çš„é”™è¯¯ï¼Œæ— è®ºæ˜¯å› ä¸ºæ–‡ä»¶ä¸å­˜åœ¨è¿˜æ˜¯æ“ä½œç³»ç»Ÿç¡¬ç›˜çš„é—®é¢˜ï¼Œè¿™äº›åªæ˜¯é”™è¯¯çš„åŸå› ä¸åŒï¼Œä½†æ˜¯å½’æ ¹åˆ°åº•éƒ½æ˜¯ä¸å¯æ¢å¤çš„é”™è¯¯ï¼ˆæ¢³ç†æ¸…æ¥šå½“å‰åœºæ™¯çš„é”™è¯¯ç±»å‹éå¸¸é‡è¦ï¼‰ã€‚

å¯¹äºè¿™äº›ä¸¥é‡åˆ°å½±å“ç¨‹åºè¿è¡Œçš„é”™è¯¯ï¼Œè§¦å‘ `panic` æ˜¯å¾ˆå¥½çš„è§£å†³æ–¹å¼ã€‚åœ¨ Rust ä¸­è§¦å‘ `panic` æœ‰ä¸¤ç§æ–¹å¼ï¼šè¢«åŠ¨è§¦å‘å’Œä¸»åŠ¨è°ƒç”¨ï¼Œä¸‹é¢ä¾æ¬¡æ¥çœ‹çœ‹ã€‚


### è¢«åŠ¨è§¦å‘
å…ˆæ¥çœ‹ä¸€æ®µç®€å•åˆç†Ÿæ‚‰çš„ä»£ç :
```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

å¿ƒæ˜çœ¼äº®çš„åŒå­¦ç«‹é©¬å°±èƒ½çœ‹å‡ºè¿™é‡Œå‘ç”Ÿäº†ä¸¥é‡çš„é”™è¯¯ â€”â€” æ•°ç»„è®¿é—®è¶Šç•Œï¼Œåœ¨å…¶å®ƒç¼–ç¨‹è¯­è¨€ä¸­æ— ä¸€ä¾‹å¤–ï¼Œéƒ½ä¼šæŠ¥å‡ºä¸¥é‡çš„å¼‚å¸¸ï¼Œç”šè‡³å¯¼è‡´ç¨‹åºç›´æ¥å´©æºƒå…³é—­ã€‚

è€Œ Rust ä¹Ÿä¸ä¾‹å¤–ï¼Œè¿è¡Œåå°†çœ‹åˆ°å¦‚ä¸‹æŠ¥é”™ï¼š
```shell
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

ä¸Šé¢ç»™å‡ºäº†éå¸¸è¯¦ç»†çš„æŠ¥é”™ä¿¡æ¯ï¼ŒåŒ…å«äº†å…·ä½“çš„å¼‚å¸¸æè¿°ä»¥åŠå‘ç”Ÿçš„ä½ç½®ï¼Œç”šè‡³ä½ è¿˜å¯ä»¥åŠ å…¥é¢å¤–çš„å‘½ä»¤æ¥çœ‹åˆ°å¼‚å¸¸å‘ç”Ÿæ—¶çš„å †æ ˆä¿¡æ¯ï¼Œè¿™ä¸ªä¼šåœ¨åé¢è¯¦ç»†å±•å¼€ã€‚

æ€»ä¹‹ï¼Œç±»ä¼¼çš„ `panic` è¿˜æœ‰å¾ˆå¤šï¼Œè€Œè¢«åŠ¨è§¦å‘çš„ `panic` æ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­æœ€å¸¸é‡åˆ°çš„ï¼Œè¿™ä¹Ÿæ˜¯ Rust ç»™æˆ‘ä»¬çš„ä¸€ç§ä¿æŠ¤ï¼Œæ¯•ç«Ÿé”™è¯¯åªæœ‰æŠ›å‡ºæ¥ï¼Œæ‰æœ‰å¯èƒ½è¢«å¤„ç†ï¼Œå¦åˆ™åªä¼šå·å·éšè—èµ·æ¥ï¼Œå¯»è§…æ—¶æœºç»™ä½ è‡´å‘½ä¸€å‡»ã€‚


### ä¸»åŠ¨è°ƒç”¨

åœ¨æŸäº›ç‰¹æ®Šåœºæ™¯ä¸­ï¼Œå¼€å‘è€…æƒ³è¦ä¸»åŠ¨æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼Œä¾‹å¦‚å¼€å¤´æåˆ°çš„åœ¨ç³»ç»Ÿå¯åŠ¨é˜¶æ®µè¯»å–æ–‡ä»¶å¤±è´¥ã€‚

å¯¹æ­¤ï¼ŒRust ä¸ºæˆ‘ä»¬æä¾›äº† `panic!` å®ï¼Œå½“è°ƒç”¨æ‰§è¡Œè¯¥å®æ—¶ï¼Œ**ç¨‹åºä¼šæ‰“å°å‡ºä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œå±•å¼€æŠ¥é”™ç‚¹å¾€å‰çš„å‡½æ•°è°ƒç”¨å †æ ˆï¼Œæœ€åé€€å‡ºç¨‹åº**ã€‚

> åˆ‡è®°ï¼Œä¸€å®šæ˜¯ä¸å¯æ¢å¤çš„é”™è¯¯ï¼Œæ‰è°ƒç”¨ `panic!` å¤„ç†ï¼Œä½ æ€»ä¸æƒ³ç³»ç»Ÿä»…ä»…å› ä¸ºç”¨æˆ·éšä¾¿ä¼ å…¥ä¸€ä¸ªéæ³•å‚æ•°å°±å´©æºƒå§ï¼Ÿæ‰€ä»¥ï¼Œ**åªæœ‰å½“ä½ ä¸çŸ¥é“è¯¥å¦‚ä½•å¤„ç†æ—¶ï¼Œå†å»è°ƒç”¨ panic!**.

é¦–å…ˆï¼Œæ¥è°ƒç”¨ä¸€ä¸‹ `panic!`ï¼Œè¿™é‡Œä½¿ç”¨äº†æœ€ç®€å•çš„ä»£ç å®ç°ï¼Œå®é™…ä¸Šä½ åœ¨ç¨‹åºçš„ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è¿™æ ·è°ƒç”¨ï¼š

```rust
fn main() {
    panic!("crash and burn");
}
```

è¿è¡Œåè¾“å‡º:

```console
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

ä»¥ä¸Šä¿¡æ¯åŒ…å«äº†ä¸¤æ¡é‡è¦ä¿¡æ¯ï¼š

- `main` å‡½æ•°æ‰€åœ¨çš„çº¿ç¨‹å´©æºƒäº†ï¼Œå‘ç”Ÿçš„ä»£ç ä½ç½®æ˜¯ `src/main.rs` ä¸­çš„ç¬¬ 2 è¡Œç¬¬ 5 ä¸ªå­—ç¬¦ï¼ˆåŒ…å«è¯¥è¡Œå‰é¢çš„ç©ºå­—ç¬¦ï¼‰
- åœ¨ä½¿ç”¨æ—¶åŠ ä¸Šä¸€ä¸ªç¯å¢ƒå˜é‡å¯ä»¥è·å–æ›´è¯¦ç»†çš„æ ˆå±•å¼€ä¿¡æ¯ï¼š
  - Linux/macOS ç­‰ UNIX ç³»ç»Ÿï¼š `RUST_BACKTRACE=1 cargo run`
  - Windows ç³»ç»Ÿï¼ˆPowerShellï¼‰ï¼š `$env:RUST_BACKTRACE=1 ; cargo run`

ä¸‹é¢è®©æˆ‘ä»¬é’ˆå¯¹ç¬¬äºŒç‚¹è¿›è¡Œè¯¦ç»†å±•å¼€è®²è§£ã€‚

## backtrace æ ˆå±•å¼€

åœ¨çœŸå®åœºæ™¯ä¸­ï¼Œé”™è¯¯å¾€å¾€æ¶‰åŠåˆ°å¾ˆé•¿çš„è°ƒç”¨é“¾ç”šè‡³ä¼šæ·±å…¥ç¬¬ä¸‰æ–¹åº“ï¼Œå¦‚æœæ²¡æœ‰æ ˆå±•å¼€æŠ€æœ¯ï¼Œé”™è¯¯å°†éš¾ä»¥è·Ÿè¸ªå¤„ç†ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªçœŸå®çš„å´©æºƒä¾‹å­ï¼š

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

ä¸Šé¢çš„ä»£ç å¾ˆç®€å•ï¼Œæ•°ç»„åªæœ‰ `3` ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å´å°è¯•å»è®¿é—®å®ƒçš„ç¬¬ `100` å·å…ƒç´ ï¼ˆæ•°ç»„ç´¢å¼•ä» `0` å¼€å§‹ï¼‰ï¼Œé‚£è‡ªç„¶ä¼šå´©æºƒã€‚

æˆ‘ä»¬çš„è¯»è€…é‡Œä¸ä¹æ­£ä¹‰ä¹‹å£«ï¼Œæ­¤æ—¶è‚¯å®šè¦è´¨ç–‘ï¼Œä¸€ä¸ªç®€å•çš„æ•°ç»„è¶Šç•Œè®¿é—®ï¼Œä¸ºä½•è¦ç›´æ¥è®©ç¨‹åºå´©æºƒï¼Ÿæ˜¯ä¸æ˜¯æœ‰äº›å°é¢˜å¤§ä½œäº†ï¼Ÿ

å¦‚æœæœ‰è¿‡ C è¯­è¨€çš„ç»éªŒï¼Œå³ä½¿ä½ è¶Šç•Œäº†ï¼Œé—®é¢˜ä¸å¤§ï¼Œæˆ‘ä¾ç„¶å°è¯•å»è®¿é—®ï¼Œè‡³äºè¿™ä¸ªå€¼æ˜¯ä¸æ˜¯ä½ æƒ³è¦çš„ï¼ˆ`100` å·å†…å­˜åœ°å€ä¹Ÿæœ‰å¯èƒ½æœ‰å€¼ï¼Œåªä¸è¿‡æ˜¯å…¶å®ƒå˜é‡æˆ–è€…ç¨‹åºçš„ï¼ï¼‰ï¼ŒæŠ±æ­‰ï¼Œä¸å½’æˆ‘ç®¡ï¼Œæˆ‘åªè´Ÿè´£å–ï¼Œä½ è¦è´Ÿè´£ç®¡ç†å¥½è‡ªå·±çš„ç´¢å¼•è®¿é—®èŒƒå›´ã€‚ä¸Šé¢è¿™ç§æƒ…å†µè¢«ç§°ä¸º**ç¼“å†²åŒºæº¢å‡º**ï¼Œå¹¶å¯èƒ½ä¼šå¯¼è‡´å®‰å…¨æ¼æ´ï¼Œä¾‹å¦‚æ”»å‡»è€…å¯ä»¥é€šè¿‡ç´¢å¼•æ¥è®¿é—®åˆ°æ•°ç»„åé¢ä¸è¢«å…è®¸çš„æ•°æ®ã€‚

è¯´å®è¯ï¼Œæˆ‘å®æ„¿ç¨‹åºå´©æºƒï¼Œä¸ºä»€ä¹ˆï¼Ÿå½“ä½ å–åˆ°äº†ä¸€ä¸ªä¸å±äºä½ çš„å€¼ï¼Œè¿™åœ¨å¾ˆå¤šæ—¶å€™ä¼šå¯¼è‡´ç¨‹åºä¸Šçš„é€»è¾‘ BUGï¼ æœ‰ç¼–ç¨‹ç»éªŒçš„äººéƒ½çŸ¥é“è¿™ç§é€»è¾‘ä¸Šçš„ BUG æ˜¯å¤šä¹ˆéš¾è¢«å‘ç°å’Œä¿®å¤ï¼å› æ­¤ç¨‹åºç›´æ¥å´©æºƒï¼Œç„¶åå‘Šè¯‰æˆ‘ä»¬é—®é¢˜å‘ç”Ÿçš„ä½ç½®ï¼Œæœ€åæˆ‘ä»¬å¯¹æ­¤è¿›è¡Œä¿®å¤ï¼Œè¿™æ‰æ˜¯æœ€åˆç†çš„è½¯ä»¶å¼€å‘æµç¨‹ï¼Œè€Œä¸æ˜¯æŠŠé—®é¢˜è—ç€æ–ç€ï¼š

```console
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

å¥½çš„ï¼Œç°åœ¨æˆåŠŸçŸ¥é“é—®é¢˜å‘ç”Ÿçš„ä½ç½®ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³çŸ¥é“è¯¥é—®é¢˜ä¹‹å‰ç»è¿‡äº†å“ªäº›è°ƒç”¨ç¯èŠ‚ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿé‚£å°±æŒ‰ç…§æç¤ºä½¿ç”¨ `RUST_BACKTRACE=1 cargo run` æˆ– `$env:RUST_BACKTRACE=1 ; cargo run` æ¥å†ä¸€æ¬¡è¿è¡Œç¨‹åºï¼š

```console
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

ä¸Šé¢çš„ä»£ç å°±æ˜¯ä¸€æ¬¡æ ˆå±•å¼€ï¼ˆä¹Ÿç§°æ ˆå›æº¯ï¼‰ï¼Œå®ƒåŒ…å«äº†å‡½æ•°è°ƒç”¨çš„é¡ºåºï¼Œå½“ç„¶æŒ‰ç…§é€†åºæ’åˆ—ï¼šæœ€è¿‘è°ƒç”¨çš„å‡½æ•°æ’åœ¨åˆ—è¡¨çš„æœ€ä¸Šæ–¹ã€‚å› ä¸ºå’±ä»¬çš„ `main` å‡½æ•°åŸºæœ¬æ˜¯æœ€å…ˆè°ƒç”¨çš„å‡½æ•°äº†ï¼Œæ‰€ä»¥æ’åœ¨äº†å€’æ•°ç¬¬äºŒä½ï¼Œè¿˜æœ‰ä¸€ä¸ªå…³æ³¨ç‚¹ï¼Œæ’åœ¨æœ€é¡¶éƒ¨æœ€åä¸€ä¸ªè°ƒç”¨çš„å‡½æ•°æ˜¯ `rust_begin_unwind`ï¼Œè¯¥å‡½æ•°çš„ç›®çš„å°±æ˜¯è¿›è¡Œæ ˆå±•å¼€ï¼Œå‘ˆç°è¿™äº›åˆ—è¡¨ä¿¡æ¯ç»™æˆ‘ä»¬ã€‚

è¦è·å–åˆ°æ ˆå›æº¯ä¿¡æ¯ï¼Œä½ è¿˜éœ€è¦å¼€å¯ `debug` æ ‡å¿—ï¼Œè¯¥æ ‡å¿—åœ¨ä½¿ç”¨ `cargo run` æˆ–è€… `cargo build` æ—¶è‡ªåŠ¨å¼€å¯ï¼ˆè¿™ä¸¤ä¸ªæ“ä½œé»˜è®¤æ˜¯ `Debug` è¿è¡Œæ–¹å¼ï¼‰ã€‚åŒæ—¶ï¼Œæ ˆå±•å¼€ä¿¡æ¯åœ¨ä¸åŒæ“ä½œç³»ç»Ÿæˆ–è€… Rust ç‰ˆæœ¬ä¸Šä¹Ÿæœ‰æ‰€ä¸åŒã€‚

## panic æ—¶çš„ä¸¤ç§ç»ˆæ­¢æ–¹å¼

å½“å‡ºç° `panic!` æ—¶ï¼Œç¨‹åºæä¾›äº†ä¸¤ç§æ–¹å¼æ¥å¤„ç†ç»ˆæ­¢æµç¨‹ï¼š**æ ˆå±•å¼€**å’Œ**ç›´æ¥ç»ˆæ­¢**ã€‚

å…¶ä¸­ï¼Œé»˜è®¤çš„æ–¹å¼å°±æ˜¯ `æ ˆå±•å¼€`ï¼Œè¿™æ„å‘³ç€ Rust ä¼šå›æº¯æ ˆä¸Šæ•°æ®å’Œå‡½æ•°è°ƒç”¨ï¼Œå› æ­¤ä¹Ÿæ„å‘³ç€æ›´å¤šçš„å–„åå·¥ä½œï¼Œå¥½å¤„æ˜¯å¯ä»¥ç»™å‡ºå……åˆ†çš„æŠ¥é”™ä¿¡æ¯å’Œæ ˆè°ƒç”¨ä¿¡æ¯ï¼Œä¾¿äºäº‹åçš„é—®é¢˜å¤ç›˜ã€‚`ç›´æ¥ç»ˆæ­¢`ï¼Œé¡¾åæ€ä¹‰ï¼Œä¸æ¸…ç†æ•°æ®å°±ç›´æ¥é€€å‡ºç¨‹åºï¼Œå–„åå·¥ä½œäº¤ä¸æ“ä½œç³»ç»Ÿæ¥è´Ÿè´£ã€‚

å¯¹äºç»å¤§å¤šæ•°ç”¨æˆ·ï¼Œä½¿ç”¨é»˜è®¤é€‰æ‹©æ˜¯æœ€å¥½çš„ï¼Œä½†æ˜¯å½“ä½ å…³å¿ƒæœ€ç»ˆç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å¤§å°æ—¶ï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•å»ä½¿ç”¨ç›´æ¥ç»ˆæ­¢çš„æ–¹å¼ï¼Œä¾‹å¦‚ä¸‹é¢çš„é…ç½®ä¿®æ”¹ `Cargo.toml` æ–‡ä»¶ï¼Œå®ç°åœ¨ [`release`](https://course.rs/first-try/cargo.html#æ‰‹åŠ¨ç¼–è¯‘å’Œè¿è¡Œé¡¹ç›®) æ¨¡å¼ä¸‹é‡åˆ° `panic` ç›´æ¥ç»ˆæ­¢ï¼š

```rust
[profile.release]
panic = 'abort'
```

## çº¿ç¨‹ `panic` åï¼Œç¨‹åºæ˜¯å¦ä¼šç»ˆæ­¢ï¼Ÿ

é•¿è¯çŸ­è¯´ï¼Œå¦‚æœæ˜¯ `main` çº¿ç¨‹ï¼Œåˆ™ç¨‹åºä¼šç»ˆæ­¢ï¼Œå¦‚æœæ˜¯å…¶å®ƒå­çº¿ç¨‹ï¼Œè¯¥çº¿ç¨‹ä¼šç»ˆæ­¢ï¼Œä½†æ˜¯ä¸ä¼šå½±å“ `main` çº¿ç¨‹ã€‚å› æ­¤ï¼Œå°½é‡ä¸è¦åœ¨ `main` çº¿ç¨‹ä¸­åšå¤ªå¤šä»»åŠ¡ï¼Œå°†è¿™äº›ä»»åŠ¡äº¤ç”±å­çº¿ç¨‹å»åšï¼Œå°±ç®—å­çº¿ç¨‹ `panic` ä¹Ÿä¸ä¼šå¯¼è‡´æ•´ä¸ªç¨‹åºçš„ç»“æŸã€‚

å…·ä½“è§£æè§ [panic åŸç†å‰–æ](#panic-åŸç†å‰–æ)ã€‚

## ä½•æ—¶è¯¥ä½¿ç”¨ panic!

ä¸‹é¢è®©æˆ‘ä»¬å¤§æ¦‚ç½—åˆ—ä¸‹ä½•æ—¶é€‚åˆä½¿ç”¨ `panic`ï¼Œä¹Ÿè®¸ç»è¿‡ä¹‹å‰çš„å­¦ä¹ ï¼Œä½ å·²ç»èƒ½å¤Ÿå¯¹ `panic` çš„ä½¿ç”¨æœ‰äº†è‡ªå·±çš„çœ‹æ³•ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯ä¼šç½—åˆ—ä¸€äº›å¸¸è§çš„ç”¨æ³•æ¥åŠ æ·±ä½ çš„ç†è§£ã€‚

å…ˆæ¥ä¸€ç‚¹èƒŒæ™¯çŸ¥è¯†ï¼Œåœ¨å‰é¢ç« èŠ‚æˆ‘ä»¬ç²—ç•¥è®²è¿‡ `Result<T, E>` è¿™ä¸ªæšä¸¾ç±»å‹ï¼Œå®ƒæ˜¯ç”¨æ¥è¡¨ç¤ºå‡½æ•°çš„è¿”å›ç»“æœï¼š

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

å½“æ²¡æœ‰é”™è¯¯å‘ç”Ÿæ—¶ï¼Œå‡½æ•°è¿”å›ä¸€ä¸ªç”¨ `Result` ç±»å‹åŒ…è£¹çš„å€¼ `Ok(T)`ï¼Œå½“é”™è¯¯æ—¶ï¼Œè¿”å›ä¸€ä¸ª `Err(E)`ã€‚å¯¹äº `Result` è¿”å›æˆ‘ä»¬æœ‰å¾ˆå¤šå¤„ç†æ–¹æ³•ï¼Œæœ€ç®€å•ç²—æš´çš„å°±æ˜¯ `unwrap` å’Œ `expect`ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°éå¸¸ç±»ä¼¼ï¼Œæˆ‘ä»¬ä»¥ `unwrap` ä¸¾ä¾‹ï¼š

```rust
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```

ä¸Šé¢çš„ `parse` æ–¹æ³•è¯•å›¾å°†å­—ç¬¦ä¸² `"127.0.0.1" `è§£æä¸ºä¸€ä¸ª IP åœ°å€ç±»å‹ `IpAddr`ï¼Œå®ƒè¿”å›ä¸€ä¸ª `Result<IpAddr, E>` ç±»å‹ï¼Œå¦‚æœè§£ææˆåŠŸï¼Œåˆ™æŠŠ `Ok(IpAddr)` ä¸­çš„å€¼èµ‹ç»™ `home`ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™ä¸å¤„ç† `Err(E)`ï¼Œè€Œæ˜¯ç›´æ¥ `panic`ã€‚

å› æ­¤ `unwrap` ç®€è€Œè¨€ä¹‹ï¼šæˆåŠŸåˆ™è¿”å›å€¼ï¼Œå¤±è´¥åˆ™ `panic`ï¼Œæ€»ä¹‹ä¸è¿›è¡Œä»»ä½•é”™è¯¯å¤„ç†ã€‚

#### ç¤ºä¾‹ã€åŸå‹ã€æµ‹è¯•

è¿™å‡ ä¸ªåœºæ™¯ä¸‹ï¼Œéœ€è¦å¿«é€Ÿåœ°æ­å»ºä»£ç ï¼Œé”™è¯¯å¤„ç†ä¼šæ‹–æ…¢ç¼–ç çš„é€Ÿåº¦ï¼Œä¹Ÿä¸æ˜¯ç‰¹åˆ«æœ‰å¿…è¦ï¼Œå› æ­¤é€šè¿‡ `unwrap`ã€`expect` ç­‰æ–¹æ³•æ¥å¤„ç†æ˜¯æœ€å¿«çš„ã€‚

åŒæ—¶ï¼Œå½“æˆ‘ä»¬å›å¤´å‡†å¤‡åšé”™è¯¯å¤„ç†æ—¶ï¼Œå¯ä»¥å…¨å±€æœç´¢è¿™äº›æ–¹æ³•ï¼Œä¸é—æ¼åœ°è¿›è¡Œæ›¿æ¢ã€‚

#### ä½ ç¡®åˆ‡çš„çŸ¥é“ä½ çš„ç¨‹åºæ˜¯æ­£ç¡®æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ panic

å› ä¸º `panic` çš„è§¦å‘æ–¹å¼æ¯”é”™è¯¯å¤„ç†è¦ç®€å•ï¼Œå› æ­¤å¯ä»¥è®©ä»£ç æ›´æ¸…æ™°ï¼Œå¯è¯»æ€§ä¹Ÿæ›´åŠ å¥½ï¼Œå½“æˆ‘ä»¬çš„ä»£ç æ³¨å®šæ˜¯æ­£ç¡®æ—¶ï¼Œä½ å¯ä»¥ç”¨ `unwrap` ç­‰æ–¹æ³•ç›´æ¥è¿›è¡Œå¤„ç†ï¼Œåæ­£ä¹Ÿä¸å¯èƒ½ `panic` ï¼š

```rust
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```

ä¾‹å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œ`"127.0.0.1"` å°±æ˜¯ `ip` åœ°å€ï¼Œå› æ­¤æˆ‘ä»¬çŸ¥é“ `parse` æ–¹æ³•ä¸€å®šä¼šæˆåŠŸï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥ç”¨ `unwrap` æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚

å½“ç„¶ï¼Œå¦‚æœè¯¥å­—ç¬¦ä¸²æ˜¯æ¥è‡ªäºç”¨æˆ·è¾“å…¥ï¼Œé‚£åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå°±å¿…é¡»ç”¨é”™è¯¯å¤„ç†çš„æ–¹å¼ï¼Œè€Œä¸æ˜¯ `unwrap`ï¼Œå¦åˆ™ä½ çš„ç¨‹åºä¸€å¤©è¦å´©æºƒå‡ åä¸‡æ¬¡å§ï¼

#### å¯èƒ½å¯¼è‡´å…¨å±€æœ‰å®³çŠ¶æ€æ—¶

æœ‰å®³çŠ¶æ€å¤§æ¦‚åˆ†ä¸ºå‡ ç±»ï¼š

- éé¢„æœŸçš„é”™è¯¯
- åç»­ä»£ç çš„è¿è¡Œä¼šå—åˆ°æ˜¾è‘—å½±å“
- å†…å­˜å®‰å…¨çš„é—®é¢˜

å½“é”™è¯¯é¢„æœŸä¼šå‡ºç°æ—¶ï¼Œè¿”å›ä¸€ä¸ªé”™è¯¯è¾ƒä¸ºåˆé€‚ï¼Œä¾‹å¦‚è§£æå™¨æ¥æ”¶åˆ°æ ¼å¼é”™è¯¯çš„æ•°æ®ï¼ŒHTTP è¯·æ±‚æ¥æ”¶åˆ°é”™è¯¯çš„å‚æ•°ç”šè‡³è¯¥è¯·æ±‚å†…çš„ä»»ä½•é”™è¯¯ï¼ˆä¸ä¼šå¯¼è‡´æ•´ä¸ªç¨‹åºæœ‰é—®é¢˜ï¼Œåªå½±å“è¯¥æ¬¡è¯·æ±‚ï¼‰ã€‚**å› ä¸ºé”™è¯¯æ˜¯å¯é¢„æœŸçš„ï¼Œå› æ­¤ä¹Ÿæ˜¯å¯ä»¥å¤„ç†çš„**ã€‚

å½“å¯åŠ¨æ—¶æŸä¸ªæµç¨‹å‘ç”Ÿäº†é”™è¯¯ï¼Œå¯¹åç»­ä»£ç çš„è¿è¡Œé€ æˆäº†å½±å“ï¼Œé‚£ä¹ˆå°±åº”è¯¥ä½¿ç”¨ `panic`ï¼Œè€Œä¸æ˜¯å¤„ç†é”™è¯¯åç»§ç»­è¿è¡Œï¼Œå½“ç„¶ä½ å¯ä»¥é€šè¿‡é‡è¯•çš„æ–¹å¼æ¥ç»§ç»­ã€‚

ä¸Šé¢æåˆ°è¿‡ï¼Œæ•°ç»„è®¿é—®è¶Šç•Œï¼Œå°±è¦ `panic` çš„åŸå› ï¼Œè¿™ä¸ªå°±æ˜¯å±äºå†…å­˜å®‰å…¨çš„èŒƒç•´ï¼Œä¸€æ—¦å†…å­˜è®¿é—®ä¸å®‰å…¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ— æ³•ä¿è¯è‡ªå·±çš„ç¨‹åºä¼šæ€ä¹ˆè¿è¡Œä¸‹å»ï¼Œä¹Ÿæ— æ³•ä¿è¯é€»è¾‘å’Œæ•°æ®çš„æ­£ç¡®æ€§ã€‚

## panic åŸç†å‰–æ

æœ¬æ¥ä¸æƒ³å†™è¿™å—å„¿å†…å®¹ï¼Œå› ä¸ºçœŸçš„éš¾å†™ï¼Œä½†æ˜¯è½¬å¿µä¸€æƒ³ï¼Œæ—¢ç„¶å·ç§°åœ£ç»ï¼Œé‚£ä¹ˆæœ¬ä¹¦å°±å¾—ä¸ä¼—ä¸åŒï¼Œé¿é‡å°±è½»æ˜¾ç„¶ä¸æ˜¯è¯¥æœ‰çš„æ€åº¦ã€‚

å½“è°ƒç”¨ `panic!` å®æ—¶ï¼Œå®ƒä¼š

1. æ ¼å¼åŒ– `panic` ä¿¡æ¯ï¼Œç„¶åä½¿ç”¨è¯¥ä¿¡æ¯ä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨ `std::panic::panic_any()` å‡½æ•°
2. `panic_any` ä¼šæ£€æŸ¥åº”ç”¨æ˜¯å¦ä½¿ç”¨äº† [`panic hook`](https://doc.rust-lang.org/std/panic/fn.set_hook.html)ï¼Œå¦‚æœä½¿ç”¨äº†ï¼Œè¯¥ `hook` å‡½æ•°å°±ä¼šè¢«è°ƒç”¨ï¼ˆ`hook` æ˜¯ä¸€ä¸ªé’©å­å‡½æ•°ï¼Œæ˜¯å¤–éƒ¨ä»£ç è®¾ç½®çš„ï¼Œç”¨äºåœ¨ `panic` è§¦å‘æ—¶ï¼Œæ‰§è¡Œå¤–éƒ¨ä»£ç æ‰€éœ€çš„åŠŸèƒ½ï¼‰
3. å½“ `hook` å‡½æ•°è¿”å›åï¼Œå½“å‰çš„çº¿ç¨‹å°±å¼€å§‹è¿›è¡Œæ ˆå±•å¼€ï¼šä» `panic_any` å¼€å§‹ï¼Œå¦‚æœå¯„å­˜å™¨æˆ–è€…æ ˆå› ä¸ºæŸäº›åŸå› ä¿¡æ¯é”™ä¹±äº†ï¼Œé‚£å¾ˆå¯èƒ½è¯¥å±•å¼€ä¼šå‘ç”Ÿå¼‚å¸¸ï¼Œæœ€ç»ˆçº¿ç¨‹ä¼šç›´æ¥åœæ­¢ï¼Œå±•å¼€ä¹Ÿæ— æ³•ç»§ç»­è¿›è¡Œ
4. å±•å¼€çš„è¿‡ç¨‹æ˜¯ä¸€å¸§ä¸€å¸§çš„å»å›æº¯æ•´ä¸ªæ ˆï¼Œæ¯ä¸ªå¸§çš„æ•°æ®éƒ½ä¼šéšä¹‹è¢«ä¸¢å¼ƒï¼Œä½†æ˜¯åœ¨å±•å¼€è¿‡ç¨‹ä¸­ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°è¢«ç”¨æˆ·æ ‡è®°ä¸º `catching` çš„å¸§ï¼ˆé€šè¿‡ `std::panic::catch_unwind()` å‡½æ•°æ ‡è®°ï¼‰ï¼Œæ­¤æ—¶ç”¨æˆ·æä¾›çš„ `catch` å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå±•å¼€ä¹Ÿéšä¹‹åœæ­¢ï¼šå½“ç„¶ï¼Œå¦‚æœ `catch` é€‰æ‹©åœ¨å†…éƒ¨è°ƒç”¨ `std::panic::resume_unwind()` å‡½æ•°ï¼Œåˆ™å±•å¼€è¿˜ä¼šç»§ç»­ã€‚

è¿˜æœ‰ä¸€ç§æƒ…å†µï¼Œåœ¨å±•å¼€è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå±•å¼€æœ¬èº« `panic` äº†ï¼Œé‚£å±•å¼€çº¿ç¨‹ä¼šç»ˆæ­¢ï¼Œå±•å¼€ä¹Ÿéšä¹‹åœæ­¢ã€‚

ä¸€æ—¦çº¿ç¨‹å±•å¼€è¢«ç»ˆæ­¢æˆ–è€…å®Œæˆï¼Œæœ€ç»ˆçš„è¾“å‡ºç»“æœæ˜¯å–å†³äºå“ªä¸ªçº¿ç¨‹ `panic`ï¼šå¯¹äº `main` çº¿ç¨‹ï¼Œæ“ä½œç³»ç»Ÿæä¾›çš„ç»ˆæ­¢åŠŸèƒ½ `core::intrinsics::abort()` ä¼šè¢«è°ƒç”¨ï¼Œæœ€ç»ˆç»“æŸå½“å‰çš„ `panic` è¿›ç¨‹ï¼›å¦‚æœæ˜¯å…¶å®ƒå­çº¿ç¨‹ï¼Œé‚£ä¹ˆå­çº¿ç¨‹å°±ä¼šç®€å•çš„ç»ˆæ­¢ï¼ŒåŒæ—¶ä¿¡æ¯ä¼šåœ¨ç¨åé€šè¿‡ `std::thread::join()` è¿›è¡Œæ”¶é›†ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/result-panic/panic.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/panic.md)ã€‚



================================================
FILE: src/basic/result-error/result.md
================================================
# å¯æ¢å¤çš„é”™è¯¯ Result

è¿˜è®°å¾—ä¸Šä¸€èŠ‚ä¸­ï¼Œæåˆ°çš„å…³äºæ–‡ä»¶è¯»å–çš„æ€è€ƒé¢˜å§ï¼Ÿå½“æ—¶æˆ‘ä»¬è§£å†³äº†è¯»å–æ–‡ä»¶æ—¶é‡åˆ°ä¸å¯æ¢å¤é”™è¯¯è¯¥æ€ä¹ˆå¤„ç†çš„é—®é¢˜ï¼Œç°åœ¨æ¥çœ‹çœ‹ï¼Œè¯»å–è¿‡ç¨‹ä¸­ï¼Œæ­£å¸¸è¿”å›å’Œé‡åˆ°å¯ä»¥æ¢å¤çš„é”™è¯¯æ—¶è¯¥å¦‚ä½•å¤„ç†ã€‚

å‡è®¾ï¼Œæˆ‘ä»¬æœ‰ä¸€å°æ¶ˆæ¯æœåŠ¡å™¨ï¼Œæ¯ä¸ªç”¨æˆ·éƒ½é€šè¿‡ websocket è¿æ¥åˆ°è¯¥æœåŠ¡å™¨æ¥æ¥æ”¶å’Œå‘é€æ¶ˆæ¯ï¼Œè¯¥è¿‡ç¨‹å°±æ¶‰åŠåˆ° socket æ–‡ä»¶çš„è¯»å†™ï¼Œé‚£ä¹ˆæ­¤æ—¶ï¼Œå¦‚æœä¸€ä¸ªç”¨æˆ·çš„è¯»å†™å‘ç”Ÿäº†é”™è¯¯ï¼Œæ˜¾ç„¶ä¸èƒ½ç›´æ¥ `panic`ï¼Œå¦åˆ™æœåŠ¡å™¨ä¼šç›´æ¥å´©æºƒï¼Œæ‰€æœ‰ç”¨æˆ·éƒ½ä¼šæ–­å¼€è¿æ¥ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ç§æ›´æ¸©å’Œçš„é”™è¯¯å¤„ç†æ–¹å¼ï¼š`Result<T, E>`ã€‚

ä¹‹å‰ç« èŠ‚æœ‰æåˆ°è¿‡ï¼Œ`Result<T, E>` æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

æ³›å‹å‚æ•° `T` ä»£è¡¨æˆåŠŸæ—¶å­˜å…¥çš„æ­£ç¡®å€¼çš„ç±»å‹ï¼Œå­˜æ”¾æ–¹å¼æ˜¯ `Ok(T)`ï¼Œ`E` ä»£è¡¨é”™è¯¯æ—¶å­˜å…¥çš„é”™è¯¯å€¼ï¼Œå­˜æ”¾æ–¹å¼æ˜¯ `Err(E)`ï¼Œæ¯ç‡¥çš„è®²è§£æ°¸è¿œä¸åŠä»£ç ç”ŸåŠ¨å‡†ç¡®ï¼Œå› æ­¤å…ˆæ¥çœ‹ä¸‹æ‰“å¼€æ–‡ä»¶çš„ä¾‹å­ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```

ä»¥ä¸Š `File::open` è¿”å›ä¸€ä¸ª `Result` ç±»å‹ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼š

> #### å¦‚ä½•è·çŸ¥å˜é‡ç±»å‹æˆ–è€…å‡½æ•°çš„è¿”å›ç±»å‹
>
> æœ‰å‡ ç§å¸¸ç”¨çš„æ–¹å¼ï¼Œæ­¤å¤„æ›´æ¨èç¬¬äºŒç§æ–¹æ³•ï¼š
>
> - ç¬¬ä¸€ç§æ˜¯æŸ¥è¯¢æ ‡å‡†åº“æˆ–è€…ä¸‰æ–¹åº“æ–‡æ¡£ï¼Œæœç´¢ `File`ï¼Œç„¶åæ‰¾åˆ°å®ƒçš„ `open` æ–¹æ³•
> - åœ¨ [Rust IDE](https://course.rs/first-try/editor.html) ç« èŠ‚ï¼Œæˆ‘ä»¬æ¨èäº† `VSCode` IDE å’Œ `rust-analyzer` æ’ä»¶ï¼Œå¦‚æœä½ æˆåŠŸå®‰è£…çš„è¯ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨ `VSCode` ä¸­å¾ˆæ–¹ä¾¿çš„é€šè¿‡ä»£ç è·³è½¬çš„æ–¹å¼æŸ¥çœ‹ä»£ç ï¼ŒåŒæ—¶ `rust-analyzer` æ’ä»¶è¿˜ä¼šå¯¹ä»£ç ä¸­çš„ç±»å‹è¿›è¡Œæ ‡æ³¨ï¼Œéå¸¸æ–¹ä¾¿å¥½ç”¨ï¼
> - ä½ è¿˜å¯ä»¥å°è¯•æ•…æ„æ ‡è®°ä¸€ä¸ªé”™è¯¯çš„ç±»å‹ï¼Œç„¶åè®©ç¼–è¯‘å™¨å‘Šè¯‰ä½ ï¼š

```rust
let f: u32 = File::open("hello.txt");
```

é”™è¯¯æç¤ºå¦‚ä¸‹ï¼š

```console
error[E0308]: mismatched types
 --> src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result<std::fs::File, std::io::Error>`
```

ä¸Šé¢ä»£ç ï¼Œæ•…æ„å°† `f` ç±»å‹æ ‡è®°æˆæ•´å½¢ï¼Œç¼–è¯‘å™¨ç«‹åˆ»ä¸ä¹æ„äº†ï¼Œä½ æ˜¯åœ¨å¿½æ‚ æˆ‘å—ï¼Ÿæ‰“å¼€æ–‡ä»¶æ“ä½œè¿”å›ä¸€ä¸ªæ•´å½¢ï¼Ÿæ¥ï¼Œå¤§å“¥æ¥å‘Šè¯‰ä½ è¿”å›ä»€ä¹ˆï¼š`std::result::Result<std::fs::File, std::io::Error>`ï¼Œæˆ‘çš„å¤©å‘ï¼Œæ€ä¹ˆè¿™ä¹ˆé•¿çš„ç±»å‹ï¼

åˆ«æ…Œï¼Œå…¶å®å¾ˆç®€å•ï¼Œé¦–å…ˆ `Result` æœ¬èº«æ˜¯å®šä¹‰åœ¨ `std::result` ä¸­çš„ï¼Œä½†æ˜¯å› ä¸º `Result` å¾ˆå¸¸ç”¨ï¼Œæ‰€ä»¥å°±è¢«åŒ…å«åœ¨äº† [`prelude`](https://course.rs/appendix/prelude.html) ä¸­ï¼ˆå°†å¸¸ç”¨çš„ä¸œä¸œæå‰å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸå†…ï¼‰ï¼Œå› æ­¤æ— éœ€æ‰‹åŠ¨å¼•å…¥ `std::result::Result`ï¼Œé‚£ä¹ˆè¿”å›ç±»å‹å¯ä»¥ç®€åŒ–ä¸º `Result<std::fs::File,std::io::Error>`ï¼Œä½ çœ‹çœ‹æ˜¯ä¸æ˜¯å¾ˆåƒæ ‡å‡†çš„ `Result<T, E>` æšä¸¾å®šä¹‰ï¼Ÿåªä¸è¿‡ `T` è¢«æ›¿æ¢æˆäº†å…·ä½“çš„ç±»å‹ `std::fs::File`ï¼Œæ˜¯ä¸€ä¸ªæ–‡ä»¶å¥æŸ„ç±»å‹ï¼Œ`E` è¢«æ›¿æ¢æˆ `std::io::Error`ï¼Œæ˜¯ä¸€ä¸ª IO é”™è¯¯ç±»å‹ã€‚

è¿™ä¸ªè¿”å›å€¼ç±»å‹è¯´æ˜ `File::open` è°ƒç”¨å¦‚æœæˆåŠŸåˆ™è¿”å›ä¸€ä¸ªå¯ä»¥è¿›è¡Œè¯»å†™çš„æ–‡ä»¶å¥æŸ„ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™è¿”å›ä¸€ä¸ª IO é”™è¯¯ï¼šæ–‡ä»¶ä¸å­˜åœ¨æˆ–è€…æ²¡æœ‰è®¿é—®æ–‡ä»¶çš„æƒé™ç­‰ã€‚æ€»ä¹‹ `File::open` éœ€è¦ä¸€ä¸ªæ–¹å¼å‘ŠçŸ¥è°ƒç”¨è€…æ˜¯æˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œå¹¶åŒæ—¶è¿”å›å…·ä½“çš„æ–‡ä»¶å¥æŸ„ï¼ˆæˆåŠŸï¼‰æˆ–é”™è¯¯ä¿¡æ¯ï¼ˆå¤±è´¥ï¼‰ï¼Œä¸‡å¹¸çš„æ˜¯ï¼Œè¿™äº›ä¿¡æ¯å¯ä»¥é€šè¿‡ `Result` æšä¸¾æä¾›ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}
```

ä»£ç å¾ˆæ¸…æ™°ï¼Œå¯¹æ‰“å¼€æ–‡ä»¶åçš„ `Result<T, E>` ç±»å‹è¿›è¡ŒåŒ¹é…å–å€¼ï¼Œå¦‚æœæ˜¯æˆåŠŸï¼Œåˆ™å°† `Ok(file)` ä¸­å­˜æ”¾çš„çš„æ–‡ä»¶å¥æŸ„ `file` èµ‹å€¼ç»™ `f`ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™å°† `Err(error)` ä¸­å­˜æ”¾çš„é”™è¯¯ä¿¡æ¯ `error` ä½¿ç”¨ `panic` æŠ›å‡ºæ¥ï¼Œè¿›è€Œç»“æŸç¨‹åºï¼Œè¿™éå¸¸ç¬¦åˆä¸Šæ–‡æåˆ°è¿‡çš„ `panic` ä½¿ç”¨åœºæ™¯ã€‚

å¥½å§ï¼Œä¹Ÿæ²¡æœ‰é‚£ä¹ˆåˆç† :)

## å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†

ç›´æ¥ `panic` è¿˜æ˜¯è¿‡äºç²—æš´ï¼Œå› ä¸ºå®é™…ä¸Š IO çš„é”™è¯¯æœ‰å¾ˆå¤šç§ï¼Œæˆ‘ä»¬éœ€è¦å¯¹éƒ¨åˆ†é”™è¯¯è¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œè€Œä¸æ˜¯æ‰€æœ‰é”™è¯¯éƒ½ç›´æ¥å´©æºƒï¼š

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}
```

ä¸Šé¢ä»£ç åœ¨åŒ¹é…å‡º `error` åï¼Œåˆå¯¹ `error` è¿›è¡Œäº†è¯¦ç»†çš„åŒ¹é…è§£æï¼Œæœ€ç»ˆç»“æœï¼š

- å¦‚æœæ˜¯æ–‡ä»¶ä¸å­˜åœ¨é”™è¯¯ `ErrorKind::NotFound`ï¼Œå°±åˆ›å»ºæ–‡ä»¶ï¼Œè¿™é‡Œåˆ›å»ºæ–‡ä»¶`File::create` ä¹Ÿæ˜¯è¿”å› `Result`ï¼Œå› æ­¤ç»§ç»­ç”¨ `match` å¯¹å…¶ç»“æœè¿›è¡Œå¤„ç†ï¼šåˆ›å»ºæˆåŠŸï¼Œå°†æ–°çš„æ–‡ä»¶å¥æŸ„èµ‹å€¼ç»™ `f`ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™ `panic`
- å‰©ä¸‹çš„é”™è¯¯ï¼Œä¸€å¾‹ `panic`

è™½ç„¶å¾ˆæ¸…æ™°ï¼Œä½†æ˜¯ä»£ç è¿˜æ˜¯æœ‰äº›å•°å—¦ï¼Œæˆ‘ä»¬ä¼šåœ¨[ç®€åŒ–é”™è¯¯å¤„ç†](https://course.rs/advance/errors.html)ä¸€ç« é‡ç‚¹è®²è¿°å¦‚ä½•å†™å‡ºæ›´ä¼˜é›…çš„é”™è¯¯ã€‚

## å¤±è´¥å°± panic: unwrap å’Œ expect

ä¸Šä¸€èŠ‚ä¸­ï¼Œå·²ç»çœ‹åˆ°è¿‡è¿™ä¸¤å…„å¼Ÿçš„ç®€å•ä»‹ç»ï¼Œè¿™é‡Œå†æ¥å›é¡¾ä¸‹ã€‚

åœ¨ä¸éœ€è¦å¤„ç†é”™è¯¯çš„åœºæ™¯ï¼Œä¾‹å¦‚å†™åŸå‹ã€ç¤ºä¾‹æ—¶ï¼Œæˆ‘ä»¬ä¸æƒ³ä½¿ç”¨ `match` å»åŒ¹é… `Result<T, E> ` ä»¥è·å–å…¶ä¸­çš„ `T` å€¼ï¼Œå› ä¸º `match` çš„ç©·å°½åŒ¹é…ç‰¹æ€§ï¼Œä½ æ€»è¦å»å¤„ç†ä¸‹ `Err` åˆ†æ”¯ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•ç®€åŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Ÿæœ‰ï¼Œç­”æ¡ˆå°±æ˜¯ `unwrap` å’Œ `expect`ã€‚

å®ƒä»¬çš„ä½œç”¨å°±æ˜¯ï¼Œå¦‚æœè¿”å›æˆåŠŸï¼Œå°±å°† `Ok(T)` ä¸­çš„å€¼å–å‡ºæ¥ï¼Œå¦‚æœå¤±è´¥ï¼Œå°±ç›´æ¥ `panic`ï¼ŒçœŸçš„å‹‡å£«ç»ä¸å¤š BBï¼Œç›´æ¥å´©æºƒã€‚

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```

å¦‚æœè°ƒç”¨è¿™æ®µä»£ç æ—¶ _hello.txt_ æ–‡ä»¶ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆ `unwrap` å°±å°†ç›´æ¥ `panic`ï¼š

```console
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

`expect` è·Ÿ `unwrap` å¾ˆåƒï¼Œä¹Ÿæ˜¯é‡åˆ°é”™è¯¯ç›´æ¥ `panic`, ä½†æ˜¯ä¼šå¸¦ä¸Šè‡ªå®šä¹‰çš„é”™è¯¯æç¤ºä¿¡æ¯ï¼Œç›¸å½“äºé‡è½½äº†é”™è¯¯æ‰“å°çš„å‡½æ•°ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```console
thread 'main' panicked at 'Failed to open hello.txt: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

å¯ä»¥çœ‹å‡ºï¼Œ`expect` ç›¸æ¯” `unwrap` èƒ½æä¾›æ›´ç²¾ç¡®çš„é”™è¯¯ä¿¡æ¯ï¼Œåœ¨æœ‰äº›åœºæ™¯ä¹Ÿä¼šæ›´åŠ å®ç”¨ã€‚

## ä¼ æ’­é”™è¯¯

å’±ä»¬çš„ç¨‹åºå‡ ä¹ä¸å¤ªå¯èƒ½åªæœ‰ `A->B` å½¢å¼çš„å‡½æ•°è°ƒç”¨ï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„ç¨‹åºï¼Œä¸€ä¸ªåŠŸèƒ½æ¶‰åŠåå‡ å±‚çš„å‡½æ•°è°ƒç”¨éƒ½æœ‰å¯èƒ½ã€‚è€Œé”™è¯¯å¤„ç†ä¹Ÿå¾€å¾€ä¸æ˜¯å“ªé‡Œè°ƒç”¨å‡ºé”™ï¼Œå°±åœ¨å“ªé‡Œå¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­ï¼Œå¤§æ¦‚ç‡ä¼šæŠŠé”™è¯¯å±‚å±‚ä¸Šä¼ ç„¶åäº¤ç»™è°ƒç”¨é“¾çš„ä¸Šæ¸¸å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œé”™è¯¯ä¼ æ’­å°†æä¸ºå¸¸è§ã€‚

ä¾‹å¦‚ä»¥ä¸‹å‡½æ•°ä»æ–‡ä»¶ä¸­è¯»å–ç”¨æˆ·åï¼Œç„¶åå°†ç»“æœè¿›è¡Œè¿”å›ï¼š

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    // æ‰“å¼€æ–‡ä»¶ï¼Œfæ˜¯`Result<æ–‡ä»¶å¥æŸ„,io::Error>`
    let f = File::open("hello.txt");

    let mut f = match f {
        // æ‰“å¼€æ–‡ä»¶æˆåŠŸï¼Œå°†fileå¥æŸ„èµ‹å€¼ç»™f
        Ok(file) => file,
        // æ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œå°†é”™è¯¯è¿”å›(å‘ä¸Šä¼ æ’­)
        Err(e) => return Err(e),
    };
    // åˆ›å»ºåŠ¨æ€å­—ç¬¦ä¸²s
    let mut s = String::new();
    // ä»fæ–‡ä»¶å¥æŸ„è¯»å–æ•°æ®å¹¶å†™å…¥sä¸­
    match f.read_to_string(&mut s) {
        // è¯»å–æˆåŠŸï¼Œè¿”å›Okå°è£…çš„å­—ç¬¦ä¸²
        Ok(_) => Ok(s),
        // å°†é”™è¯¯å‘ä¸Šä¼ æ’­
        Err(e) => Err(e),
    }
}
```

æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª `Result<String, io::Error>` ç±»å‹ï¼Œå½“è¯»å–ç”¨æˆ·åæˆåŠŸæ—¶ï¼Œè¿”å› `Ok(String)`ï¼Œå¤±è´¥æ—¶ï¼Œè¿”å› `Err(io:Error)`
- `File::open` å’Œ `f.read_to_string` è¿”å›çš„ `Result<T, E>` ä¸­çš„ `E` å°±æ˜¯ `io::Error`

ç”±æ­¤å¯è§ï¼Œè¯¥å‡½æ•°å°† `io::Error` çš„é”™è¯¯å¾€ä¸Šè¿›è¡Œä¼ æ’­ï¼Œè¯¥å‡½æ•°çš„è°ƒç”¨è€…æœ€ç»ˆä¼šå¯¹ `Result<String,io::Error>` è¿›è¡Œå†å¤„ç†ï¼Œè‡³äºæ€ä¹ˆå¤„ç†å°±æ˜¯è°ƒç”¨è€…çš„äº‹ï¼Œå¦‚æœæ˜¯é”™è¯¯ï¼Œå®ƒå¯ä»¥é€‰æ‹©ç»§ç»­å‘ä¸Šä¼ æ’­é”™è¯¯ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ `panic`ï¼Œäº¦æˆ–å°†å…·ä½“çš„é”™è¯¯åŸå› åŒ…è£…åå†™å…¥ socket ä¸­å‘ˆç°ç»™ç»ˆç«¯ç”¨æˆ·ã€‚

ä½†æ˜¯ä¸Šé¢çš„ä»£ç ä¹Ÿæœ‰è‡ªå·±çš„é—®é¢˜ï¼Œé‚£å°±æ˜¯å¤ªé•¿äº†ï¼ˆä¼˜ç§€çš„ç¨‹åºå‘˜èº«ä¸Šçš„ä¼˜ç‚¹æå¤šï¼Œå…¶ä¸­æœ€å¤§çš„ä¼˜ç‚¹å°±æ˜¯*æ‡’*ï¼‰ï¼Œæˆ‘è‡ªè®¤ä¸ºä¹Ÿæœ‰é‚£ä¹ˆä¸€ç‚¹ç‚¹ä¼˜ç§€ï¼Œå› æ­¤è§ä¸å¾—è¿™ä¹ˆå•°å—¦çš„ä»£ç ï¼Œä¸‹é¢å’±ä»¬æ¥è®²è®²å¦‚ä½•ç®€åŒ–å®ƒã€‚

### ä¼ æ’­ç•Œçš„å¤§æ˜æ˜Ÿ: ?

å¤§æ˜æ˜Ÿå‡ºåœºï¼Œå¿…é¡»å¾—æœ‰æ’é¢ï¼Œæ¥çœ‹çœ‹ `?` çš„æ’é¢ï¼š

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

çœ‹åˆ°æ²¡ï¼Œè¿™å°±æ˜¯æ’é¢ï¼Œç›¸æ¯”å‰é¢çš„ `match` å¤„ç†é”™è¯¯çš„å‡½æ•°ï¼Œä»£ç ç›´æ¥å‡å°‘äº†ä¸€åŠä¸æ­¢ï¼Œä½†æ˜¯ï¼Œä¸€å±±æ›´æ¯”ä¸€å±±éš¾ï¼Œçœ‹ä¸æ‡‚å•Šï¼

å…¶å® `?` å°±æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒçš„ä½œç”¨è·Ÿä¸Šé¢çš„ `match` å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼š

```rust
let mut f = match f {
    // æ‰“å¼€æ–‡ä»¶æˆåŠŸï¼Œå°†fileå¥æŸ„èµ‹å€¼ç»™f
    Ok(file) => file,
    // æ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œå°†é”™è¯¯è¿”å›(å‘ä¸Šä¼ æ’­)
    Err(e) => return Err(e),
};
```

å¦‚æœç»“æœæ˜¯ `Ok(T)`ï¼Œåˆ™æŠŠ `T` èµ‹å€¼ç»™ `f`ï¼Œå¦‚æœç»“æœæ˜¯ `Err(E)`ï¼Œåˆ™è¿”å›è¯¥é”™è¯¯ï¼Œæ‰€ä»¥ `?` ç‰¹åˆ«é€‚åˆç”¨æ¥ä¼ æ’­é”™è¯¯ã€‚

è™½ç„¶ `?` å’Œ `match` åŠŸèƒ½ä¸€è‡´ï¼Œä½†æ˜¯äº‹å®ä¸Š `?` ä¼šæ›´èƒœä¸€ç­¹ã€‚ä½•è§£ï¼Ÿ

æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„ç³»ç»Ÿä¸­ï¼Œè‚¯å®šæœ‰è‡ªå®šä¹‰çš„é”™è¯¯ç‰¹å¾ï¼Œé”™è¯¯ä¹‹é—´å¾ˆå¯èƒ½ä¼šå­˜åœ¨ä¸Šä¸‹çº§å…³ç³»ï¼Œä¾‹å¦‚æ ‡å‡†åº“ä¸­çš„ `std::io::Error `å’Œ `std::error::Error`ï¼Œå‰è€…æ˜¯ IO ç›¸å…³çš„é”™è¯¯ç»“æ„ä½“ï¼Œåè€…æ˜¯ä¸€ä¸ªæœ€æœ€é€šç”¨çš„æ ‡å‡†é”™è¯¯ç‰¹å¾ï¼ŒåŒæ—¶å‰è€…å®ç°äº†åè€…ï¼Œå› æ­¤ `std::io::Error` å¯ä»¥è½¬æ¢ä¸º `std:error::Error`ã€‚

æ˜ç™½äº†ä»¥ä¸Šçš„é”™è¯¯è½¬æ¢ï¼Œ`?` çš„æ›´èƒœä¸€ç­¹å°±å¾ˆå¥½ç†è§£äº†ï¼Œå®ƒå¯ä»¥è‡ªåŠ¨è¿›è¡Œç±»å‹æå‡ï¼ˆè½¬æ¢ï¼‰ï¼š

```rust
fn open_file() -> Result<File, Box<dyn std::error::Error>> {
    let mut f = File::open("hello.txt")?;
    Ok(f)
}
```

ä¸Šé¢ä»£ç ä¸­ `File::open` æŠ¥é”™æ—¶è¿”å›çš„é”™è¯¯æ˜¯ `std::io::Error` ç±»å‹ï¼Œä½†æ˜¯ `open_file` å‡½æ•°è¿”å›çš„é”™è¯¯ç±»å‹æ˜¯ `std::error::Error` çš„ç‰¹å¾å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°ä¸€ä¸ªé”™è¯¯ç±»å‹é€šè¿‡ `?` è¿”å›åï¼Œå˜æˆäº†å¦ä¸€ä¸ªé”™è¯¯ç±»å‹ï¼Œè¿™å°±æ˜¯ `?` çš„ç¥å¥‡ä¹‹å¤„ã€‚

æ ¹æœ¬åŸå› æ˜¯åœ¨äºæ ‡å‡†åº“ä¸­å®šä¹‰çš„ `From` ç‰¹å¾ï¼Œè¯¥ç‰¹å¾æœ‰ä¸€ä¸ªæ–¹æ³• `from`ï¼Œç”¨äºæŠŠä¸€ä¸ªç±»å‹è½¬æˆå¦å¤–ä¸€ä¸ªç±»å‹ï¼Œ`?` å¯ä»¥è‡ªåŠ¨è°ƒç”¨è¯¥æ–¹æ³•ï¼Œç„¶åè¿›è¡Œéšå¼ç±»å‹è½¬æ¢ã€‚å› æ­¤åªè¦å‡½æ•°è¿”å›çš„é”™è¯¯ `ReturnError` å®ç°äº† `From<OtherError>` ç‰¹å¾ï¼Œé‚£ä¹ˆ `?` å°±ä¼šè‡ªåŠ¨æŠŠ `OtherError` è½¬æ¢ä¸º `ReturnError`ã€‚

è¿™ç§è½¬æ¢éå¸¸å¥½ç”¨ï¼Œæ„å‘³ç€ä½ å¯ä»¥ç”¨ä¸€ä¸ªå¤§è€Œå…¨çš„ `ReturnError` æ¥è¦†ç›–æ‰€æœ‰é”™è¯¯ç±»å‹ï¼Œåªéœ€è¦ä¸ºå„ç§å­é”™è¯¯ç±»å‹å®ç°è¿™ç§è½¬æ¢å³å¯ã€‚

å¼ºä¸­è‡ªæœ‰å¼ºä¸­æ‰‹ï¼Œä¸€ç æ›´æ¯”ä¸€ç çŸ­ï¼š

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```

ç§è§æ²¡ï¼Ÿ `?` è¿˜èƒ½å®ç°é“¾å¼è°ƒç”¨ï¼Œ`File::open` é‡åˆ°é”™è¯¯å°±è¿”å›ï¼Œæ²¡æœ‰é”™è¯¯å°±å°† `Ok` ä¸­çš„å€¼å–å‡ºæ¥ç”¨äºä¸‹ä¸€ä¸ªæ–¹æ³•è°ƒç”¨ï¼Œç®€ç›´å¤ªç²¾å¦™äº†ï¼Œä» Go è¯­è¨€è¿‡æ¥çš„æˆ‘ï¼Œå†…å¿ƒç‹‚å–œï¼ˆå…¶å®å­¦ Rust çš„è‹¦å’Œç—›æˆ‘æ‰ä¸ä¼šå‘Šè¯‰ä½ ä»¬ï¼‰ã€‚

ä¸ä»…æœ‰æ›´å¼ºï¼Œè¿˜è¦æœ‰æœ€å¼ºï¼Œæˆ‘ä¸ä¿¡è¿˜æœ‰äººæ¯”æˆ‘æ›´çŸ­(ä¸è¦è¯¯è§£)ï¼š

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    // read_to_stringæ˜¯å®šä¹‰åœ¨std::ioä¸­çš„æ–¹æ³•ï¼Œå› æ­¤éœ€è¦åœ¨ä¸Šé¢è¿›è¡Œå¼•ç”¨
    fs::read_to_string("hello.txt")
}
```

ä»æ–‡ä»¶è¯»å–æ•°æ®åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œæ˜¯æ¯”è¾ƒå¸¸è§çš„æ“ä½œï¼Œå› æ­¤ Rust æ ‡å‡†åº“ä¸ºæˆ‘ä»¬æä¾›äº† `fs::read_to_string` å‡½æ•°ï¼Œè¯¥å‡½æ•°å†…éƒ¨ä¼šæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ã€åˆ›å»º `String`ã€è¯»å–æ–‡ä»¶å†…å®¹æœ€åå†™å…¥å­—ç¬¦ä¸²å¹¶è¿”å›ï¼Œå› ä¸ºè¯¥å‡½æ•°å…¶å®ä¸æœ¬ç« è®²çš„å†…å®¹å…³ç³»ä¸å¤§ï¼Œå› æ­¤æ”¾åœ¨æœ€åæ¥è®²ï¼Œå…¶å®åªæ˜¯æˆ‘æƒ³éœ‡ä½ ä»¬ä¸€ä¸‹ :)

#### ? ç”¨äº Option çš„è¿”å›

`?` ä¸ä»…ä»…å¯ä»¥ç”¨äº `Result` çš„ä¼ æ’­ï¼Œè¿˜èƒ½ç”¨äº `Option` çš„ä¼ æ’­ï¼Œå†æ¥å›å¿†ä¸‹ `Option` çš„å®šä¹‰ï¼š

```rust
pub enum Option<T> {
    Some(T),
    None
}
```

`Result` é€šè¿‡ `?` è¿”å›é”™è¯¯ï¼Œé‚£ä¹ˆ `Option` å°±é€šè¿‡ `?` è¿”å› `None`ï¼š

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   let v = arr.get(0)?;
   Some(v)
}
```

ä¸Šé¢çš„å‡½æ•°ä¸­ï¼Œ`arr.get` è¿”å›ä¸€ä¸ª `Option<&i32>` ç±»å‹ï¼Œå› ä¸º `?` çš„ä½¿ç”¨ï¼Œå¦‚æœ `get` çš„ç»“æœæ˜¯ `None`ï¼Œåˆ™ç›´æ¥è¿”å› `None`ï¼Œå¦‚æœæ˜¯ `Some(&i32)`ï¼Œåˆ™æŠŠé‡Œé¢çš„å€¼èµ‹ç»™ `v`ã€‚

å…¶å®è¿™ä¸ªå‡½æ•°æœ‰äº›ç”»è›‡æ·»è¶³ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥å†™å‡ºæ›´ç®€å•çš„ç‰ˆæœ¬ï¼š

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   arr.get(0)
}
```

æœ‰ä¸€å¥è¯æ€ä¹ˆè¯´ï¼Ÿæ²¡æœ‰éœ€æ±‚ï¼Œåˆ¶é€ éœ€æ±‚ä¹Ÿè¦ä¸Šâ€¦â€¦å¤§å®¶åˆ«è·Ÿæˆ‘å­¦ä¹ ï¼Œè¿™æ˜¯è½¯ä»¶å¼€å‘å¤§å¿Œã€‚åªèƒ½ç”¨ä»£ç æ´—æ´—çœ¼äº†ï¼š

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

ä¸Šé¢ä»£ç å±•ç¤ºäº†åœ¨é“¾å¼è°ƒç”¨ä¸­ä½¿ç”¨ `?` æå‰è¿”å› `None` çš„ç”¨æ³•ï¼Œ `.next` æ–¹æ³•è¿”å›çš„æ˜¯ `Option` ç±»å‹ï¼šå¦‚æœè¿”å› `Some(&str)`ï¼Œé‚£ä¹ˆç»§ç»­è°ƒç”¨ `chars` æ–¹æ³•ï¼Œå¦‚æœè¿”å› `None`ï¼Œåˆ™ç›´æ¥ä»æ•´ä¸ªå‡½æ•°ä¸­è¿”å› `None`ï¼Œä¸å†ç»§ç»­è¿›è¡Œé“¾å¼è°ƒç”¨ã€‚

#### æ–°æ‰‹ç”¨ ? å¸¸ä¼šçŠ¯çš„é”™è¯¯

åˆå­¦è€…åœ¨ç”¨ `?` æ—¶ï¼Œè€æ˜¯ä¼šçŠ¯é”™ï¼Œä¾‹å¦‚å†™å‡ºè¿™æ ·çš„ä»£ç ï¼š

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   arr.get(0)?
}
```

è¿™æ®µä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œåˆ‡è®°ï¼š`?` æ“ä½œç¬¦éœ€è¦ä¸€ä¸ªå˜é‡æ¥æ‰¿è½½æ­£ç¡®çš„å€¼ï¼Œè¿™ä¸ªå‡½æ•°åªä¼šè¿”å› `Some(&i32)` æˆ–è€… `None`ï¼Œåªæœ‰é”™è¯¯å€¼èƒ½ç›´æ¥è¿”å›ï¼Œæ­£ç¡®çš„å€¼ä¸è¡Œï¼Œæ‰€ä»¥å¦‚æœæ•°ç»„ä¸­å­˜åœ¨ 0 å·å…ƒç´ ï¼Œé‚£ä¹ˆå‡½æ•°ç¬¬äºŒè¡Œä½¿ç”¨ `?` åçš„è¿”å›ç±»å‹ä¸º `&i32` è€Œä¸æ˜¯ `Some(&i32)`ã€‚å› æ­¤ `?` åªèƒ½ç”¨äºä»¥ä¸‹å½¢å¼ï¼š

- `let v = xxx()?;`
- `xxx()?.yyy()?;`

#### å¸¦è¿”å›å€¼çš„ main å‡½æ•°

åœ¨äº†è§£äº† `?` çš„ä½¿ç”¨é™åˆ¶åï¼Œè¿™æ®µä»£ç ä½ å¾ˆå®¹æ˜“çœ‹å‡ºå®ƒæ— æ³•ç¼–è¯‘ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```

è¿è¡Œåä¼šæŠ¥é”™:
```shell
$ cargo run
   ...
   the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
```

å› ä¸º `?` è¦æ±‚ `Result<T, E>` å½¢å¼çš„è¿”å›å€¼ï¼Œè€Œ `main` å‡½æ•°çš„è¿”å›æ˜¯ `()`ï¼Œå› æ­¤æ— æ³•æ»¡è¶³ï¼Œé‚£æ˜¯ä¸æ˜¯å°±æ— è§£äº†å‘¢ï¼Ÿ

å®é™…ä¸Š Rust è¿˜æ”¯æŒå¦å¤–ä¸€ç§å½¢å¼çš„ `main` å‡½æ•°ï¼š

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

è¿™æ ·å°±èƒ½ä½¿ç”¨ `?` æå‰è¿”å›äº†ï¼ŒåŒæ—¶æˆ‘ä»¬åˆä¸€æ¬¡çœ‹åˆ°äº†`Box<dyn Error>` ç‰¹å¾å¯¹è±¡ï¼Œå› ä¸º `std::error:Error` æ˜¯ Rust ä¸­æŠ½è±¡å±‚æ¬¡æœ€é«˜çš„é”™è¯¯ï¼Œå…¶å®ƒæ ‡å‡†åº“ä¸­çš„é”™è¯¯éƒ½å®ç°äº†è¯¥ç‰¹å¾ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨è¯¥ç‰¹å¾å¯¹è±¡ä»£è¡¨ä¸€åˆ‡é”™è¯¯ï¼Œå°±ç®— `main` å‡½æ•°ä¸­è°ƒç”¨ä»»ä½•æ ‡å‡†åº“å‡½æ•°å‘ç”Ÿé”™è¯¯ï¼Œéƒ½å¯ä»¥é€šè¿‡ `Box<dyn Error>` è¿™ä¸ªç‰¹å¾å¯¹è±¡è¿›è¡Œè¿”å›ã€‚

è‡³äº `main` å‡½æ•°å¯ä»¥æœ‰å¤šç§è¿”å›å€¼ï¼Œé‚£æ˜¯å› ä¸ºå®ç°äº† [std::process::Termination](https://doc.rust-lang.org/std/process/trait.Termination.html) ç‰¹å¾ï¼Œç›®å‰ä¸ºæ­¢è¯¥ç‰¹å¾è¿˜æ²¡è¿›å…¥ç¨³å®šç‰ˆ Rust ä¸­ï¼Œä¹Ÿè®¸æœªæ¥ä½ å¯ä»¥ä¸ºè‡ªå·±çš„ç±»å‹å®ç°è¯¥ç‰¹å¾ï¼

#### try!

åœ¨ `?` æ¨ªç©ºå‡ºä¸–ä¹‹å‰( Rust 1.13 )ï¼ŒRust å¼€å‘è€…è¿˜å¯ä»¥ä½¿ç”¨ `try!` æ¥å¤„ç†é”™è¯¯ï¼Œè¯¥å®çš„å¤§è‡´å®šä¹‰å¦‚ä¸‹ï¼š

```rust
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(::std::convert::From::from(err)),
    });
}
```

ç®€å•çœ‹ä¸€ä¸‹ä¸ `?` çš„å¯¹æ¯”:

```rust
//  `?`
let x = function_with_error()?; // è‹¥è¿”å› Err, åˆ™ç«‹åˆ»è¿”å›ï¼›è‹¥è¿”å› Ok(255)ï¼Œåˆ™å°† x çš„å€¼è®¾ç½®ä¸º 255

// `try!()`
let x = try!(function_with_error());
```

å¯ä»¥çœ‹å‡º `?` çš„ä¼˜åŠ¿éå¸¸æ˜æ˜¾ï¼Œä½•å†µ `?` è¿˜èƒ½åšé“¾å¼è°ƒç”¨ã€‚

æ€»ä¹‹ï¼Œ`try!` ä½œä¸ºå‰æµªå·²ç»æ­»åœ¨äº†æ²™æ»©ä¸Šï¼Œ**åœ¨å½“å‰ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬è¦å°½é‡é¿å…ä½¿ç”¨ try!**ã€‚

## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/result-panic/result.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/result.md)ã€‚



================================================
FILE: src/basic/trait/advance-trait.md
================================================
[Binary file]


================================================
FILE: src/basic/trait/generic.md
================================================
[Binary file]


================================================
FILE: src/basic/trait/intro.md
================================================
# æ³›å‹å’Œç‰¹å¾

æ³›å‹å’Œç‰¹å¾æ˜¯ Rust ä¸­æœ€æœ€é‡è¦çš„æŠ½è±¡ç±»å‹ï¼Œä¹Ÿæ˜¯ä½ åœ¨å­¦ä¹  Rust è·¯ä¸Šçš„æ‹¦è·¯è™ï¼Œä½†æ˜¯æŒ‘æˆ˜å¾€å¾€ä¸ä¹è¶£å¹¶å­˜ï¼Œä¸€æ—¦å­¦ä¼šï¼Œåœ¨åé¢å­¦ä¹  Rust çš„è·¯ä¸Šï¼Œä½ å°†ä¸€å¾€æ— å‰ã€‚



================================================
FILE: src/basic/trait/trait-object.md
================================================
# ç‰¹å¾å¯¹è±¡

åœ¨ä¸Šä¸€èŠ‚ä¸­æœ‰ä¸€æ®µä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼š

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
           // ...
        }
    } else {
        Weibo {
            // ...
        }
    }
}
```

å…¶ä¸­ `Post` å’Œ `Weibo` éƒ½å®ç°äº† `Summary` ç‰¹å¾ï¼Œå› æ­¤ä¸Šé¢çš„å‡½æ•°è¯•å›¾é€šè¿‡è¿”å› `impl Summary` æ¥è¿”å›è¿™ä¸¤ä¸ªç±»å‹ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å´æ— æƒ…åœ°æŠ¥é”™äº†ï¼ŒåŸå› æ˜¯ `impl Trait` çš„è¿”å›å€¼ç±»å‹å¹¶ä¸æ”¯æŒå¤šç§ä¸åŒçš„ç±»å‹è¿”å›ï¼Œé‚£å¦‚æœæˆ‘ä»¬æƒ³è¿”å›å¤šç§ç±»å‹ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿ

å†æ¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼šç°åœ¨åœ¨åšä¸€æ¬¾æ¸¸æˆï¼Œéœ€è¦å°†å¤šä¸ªå¯¹è±¡æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼Œè¿™äº›å¯¹è±¡å±äºä¸åŒçš„ç±»å‹ï¼Œå­˜å‚¨åœ¨åˆ—è¡¨ä¸­ï¼Œæ¸²æŸ“çš„æ—¶å€™ï¼Œéœ€è¦å¾ªç¯è¯¥åˆ—è¡¨å¹¶é¡ºåºæ¸²æŸ“æ¯ä¸ªå¯¹è±¡ï¼Œåœ¨ Rust ä¸­è¯¥æ€ä¹ˆå®ç°ï¼Ÿ

èªæ˜çš„åŒå­¦å¯èƒ½å·²ç»èƒ½æƒ³åˆ°ä¸€ä¸ªåŠæ³•ï¼Œåˆ©ç”¨æšä¸¾ï¼š

```rust
#[derive(Debug)]
enum UiObject {
    Button,
    SelectBox,
}

fn main() {
    let objects = [
        UiObject::Button,
        UiObject::SelectBox
    ];

    for o in objects {
        draw(o)
    }
}

fn draw(o: UiObject) {
    println!("{:?}",o);
}
```

Bingoï¼Œè¿™ä¸ªç¡®å®æ˜¯ä¸€ä¸ªåŠæ³•ï¼Œä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œå¦‚æœä½ çš„å¯¹è±¡é›†åˆå¹¶ä¸èƒ½äº‹å…ˆæ˜ç¡®åœ°çŸ¥é“å‘¢ï¼Ÿæˆ–è€…åˆ«äººæƒ³è¦å®ç°ä¸€ä¸ª UI ç»„ä»¶å‘¢ï¼Ÿæ­¤æ—¶æšä¸¾ä¸­çš„ç±»å‹æ˜¯æœ‰äº›ç¼ºå°‘çš„ï¼Œæ˜¯ä¸æ˜¯è¿˜è¦ä¿®æ”¹ä½ çš„ä»£ç å¢åŠ ä¸€ä¸ªæšä¸¾æˆå‘˜ï¼Ÿ

æ€»ä¹‹ï¼Œåœ¨ç¼–å†™è¿™ä¸ª UI åº“æ—¶ï¼Œæˆ‘ä»¬æ— æ³•çŸ¥é“æ‰€æœ‰çš„ UI å¯¹è±¡ç±»å‹ï¼ŒåªçŸ¥é“çš„æ˜¯ï¼š

- UI å¯¹è±¡çš„ç±»å‹ä¸åŒ
- éœ€è¦ä¸€ä¸ªç»Ÿä¸€çš„ç±»å‹æ¥å¤„ç†è¿™äº›å¯¹è±¡ï¼Œæ— è®ºæ˜¯ä½œä¸ºå‡½æ•°å‚æ•°è¿˜æ˜¯ä½œä¸ºåˆ—è¡¨ä¸­çš„ä¸€å‘˜
- éœ€è¦å¯¹æ¯ä¸€ä¸ªå¯¹è±¡è°ƒç”¨ `draw` æ–¹æ³•

åœ¨æ‹¥æœ‰ç»§æ‰¿çš„è¯­è¨€ä¸­ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªåä¸º `Component` çš„ç±»ï¼Œè¯¥ç±»ä¸Šæœ‰ä¸€ä¸ª `draw` æ–¹æ³•ã€‚å…¶ä»–çš„ç±»æ¯”å¦‚ `Button`ã€`Image` å’Œ `SelectBox` ä¼šä» `Component` æ´¾ç”Ÿå¹¶å› æ­¤ç»§æ‰¿ `draw` æ–¹æ³•ã€‚å®ƒä»¬å„è‡ªéƒ½å¯ä»¥è¦†ç›– `draw` æ–¹æ³•æ¥å®šä¹‰è‡ªå·±çš„è¡Œä¸ºï¼Œä½†æ˜¯æ¡†æ¶ä¼šæŠŠæ‰€æœ‰è¿™äº›ç±»å‹å½“ä½œæ˜¯ `Component` çš„å®ä¾‹ï¼Œå¹¶åœ¨å…¶ä¸Šè°ƒç”¨ `draw`ã€‚ä¸è¿‡ Rust å¹¶æ²¡æœ‰ç»§æ‰¿ï¼Œæˆ‘ä»¬å¾—å¦å¯»å‡ºè·¯ã€‚

## ç‰¹å¾å¯¹è±¡å®šä¹‰

ä¸ºäº†è§£å†³ä¸Šé¢çš„æ‰€æœ‰é—®é¢˜ï¼ŒRust å¼•å…¥äº†ä¸€ä¸ªæ¦‚å¿µ â€”â€” **ç‰¹å¾å¯¹è±¡**ã€‚

åœ¨ä»‹ç»ç‰¹å¾å¯¹è±¡ä¹‹å‰ï¼Œå…ˆæ¥ä¸ºä¹‹å‰çš„ UI ç»„ä»¶å®šä¹‰ä¸€ä¸ªç‰¹å¾ï¼š

```rust
pub trait Draw {
    fn draw(&self);
}
```

åªè¦ç»„ä»¶å®ç°äº† `Draw` ç‰¹å¾ï¼Œå°±å¯ä»¥è°ƒç”¨ `draw` æ–¹æ³•æ¥è¿›è¡Œæ¸²æŸ“ã€‚å‡è®¾æœ‰ä¸€ä¸ª `Button` å’Œ `SelectBox` ç»„ä»¶å®ç°äº† `Draw` ç‰¹å¾ï¼š

```rust
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // ç»˜åˆ¶æŒ‰é’®çš„ä»£ç 
    }
}

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // ç»˜åˆ¶SelectBoxçš„ä»£ç 
    }
}

```

æ­¤æ—¶ï¼Œè¿˜éœ€è¦ä¸€ä¸ªåŠ¨æ€æ•°ç»„æ¥å­˜å‚¨è¿™äº› UI å¯¹è±¡ï¼š

```rust
pub struct Screen {
    pub components: Vec<?>,
}
```

æ³¨æ„åˆ°ä¸Šé¢ä»£ç ä¸­çš„ `?` å—ï¼Ÿå®ƒçš„æ„æ€æ˜¯ï¼šæˆ‘ä»¬åº”è¯¥å¡«å…¥ä»€ä¹ˆç±»å‹ï¼Œå¯ä»¥è¯´å°±ä¹‹å‰å­¦è¿‡çš„å†…å®¹é‡Œï¼Œä½ æ‰¾ä¸åˆ°å“ªä¸ªç±»å‹å¯ä»¥å¡«å…¥è¿™é‡Œï¼Œä½†æ˜¯å› ä¸º `Button` å’Œ `SelectBox` éƒ½å®ç°äº† `Draw` ç‰¹å¾ï¼Œé‚£æˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥æŠŠ `Draw` ç‰¹å¾çš„å¯¹è±¡ä½œä¸ºç±»å‹ï¼Œå¡«å…¥åˆ°æ•°ç»„ä¸­å‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚

**ç‰¹å¾å¯¹è±¡**æŒ‡å‘å®ç°äº† `Draw` ç‰¹å¾çš„ç±»å‹çš„å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯æŒ‡å‘äº† `Button` æˆ–è€… `SelectBox` çš„å®ä¾‹ï¼Œè¿™ç§æ˜ å°„å…³ç³»æ˜¯å­˜å‚¨åœ¨ä¸€å¼ è¡¨ä¸­ï¼Œå¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡ç‰¹å¾å¯¹è±¡æ‰¾åˆ°å…·ä½“è°ƒç”¨çš„ç±»å‹æ–¹æ³•ã€‚

å¯ä»¥é€šè¿‡ `&` å¼•ç”¨æˆ–è€… `Box<T>` æ™ºèƒ½æŒ‡é’ˆçš„æ–¹å¼æ¥åˆ›å»ºç‰¹å¾å¯¹è±¡ã€‚

> `Box<T>` åœ¨åé¢ç« èŠ‚ä¼š[è¯¦ç»†è®²è§£](https://course.rs/advance/smart-pointer/box.html)ï¼Œå¤§å®¶ç°åœ¨æŠŠå®ƒå½“æˆä¸€ä¸ªå¼•ç”¨å³å¯ï¼Œåªä¸è¿‡å®ƒåŒ…è£¹çš„å€¼ä¼šè¢«å¼ºåˆ¶åˆ†é…åœ¨å †ä¸Šã€‚


```rust
trait Draw {
    fn draw(&self) -> String;
}

impl Draw for u8 {
    fn draw(&self) -> String {
        format!("u8: {}", *self)
    }
}

impl Draw for f64 {
    fn draw(&self) -> String {
        format!("f64: {}", *self)
    }
}

// è‹¥ T å®ç°äº† Draw ç‰¹å¾ï¼Œ åˆ™è°ƒç”¨è¯¥å‡½æ•°æ—¶ä¼ å…¥çš„ Box<T> å¯ä»¥è¢«éšå¼è½¬æ¢æˆå‡½æ•°å‚æ•°ç­¾åä¸­çš„ Box<dyn Draw>
fn draw1(x: Box<dyn Draw>) {
    // ç”±äºå®ç°äº† Deref ç‰¹å¾ï¼ŒBox æ™ºèƒ½æŒ‡é’ˆä¼šè‡ªåŠ¨è§£å¼•ç”¨ä¸ºå®ƒæ‰€åŒ…è£¹çš„å€¼ï¼Œç„¶åè°ƒç”¨è¯¥å€¼å¯¹åº”çš„ç±»å‹ä¸Šå®šä¹‰çš„ `draw` æ–¹æ³•
    x.draw();
}

fn draw2(x: &dyn Draw) {
    x.draw();
}

fn main() {
    let x = 1.1f64;
    // do_something(&x);
    let y = 8u8;

    // x å’Œ y çš„ç±»å‹ T éƒ½å®ç°äº† `Draw` ç‰¹å¾ï¼Œå› ä¸º Box<T> å¯ä»¥åœ¨å‡½æ•°è°ƒç”¨æ—¶éšå¼åœ°è¢«è½¬æ¢ä¸ºç‰¹å¾å¯¹è±¡ Box<dyn Draw> 
    // åŸºäº x çš„å€¼åˆ›å»ºä¸€ä¸ª Box<f64> ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆï¼ŒæŒ‡é’ˆæŒ‡å‘çš„æ•°æ®è¢«æ”¾ç½®åœ¨äº†å †ä¸Š
    draw1(Box::new(x));
    // åŸºäº y çš„å€¼åˆ›å»ºä¸€ä¸ª Box<u8> ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆ
    draw1(Box::new(y));
    draw2(&x);
    draw2(&y);
}
```

ä¸Šé¢ä»£ç ï¼Œæœ‰å‡ ä¸ªéå¸¸é‡è¦çš„ç‚¹ï¼š

- `draw1` å‡½æ•°çš„å‚æ•°æ˜¯ `Box<dyn Draw>` å½¢å¼çš„ç‰¹å¾å¯¹è±¡ï¼Œè¯¥ç‰¹å¾å¯¹è±¡æ˜¯é€šè¿‡ `Box::new(x)` çš„æ–¹å¼åˆ›å»ºçš„
- `draw2` å‡½æ•°çš„å‚æ•°æ˜¯ `&dyn Draw` å½¢å¼çš„ç‰¹å¾å¯¹è±¡ï¼Œè¯¥ç‰¹å¾å¯¹è±¡æ˜¯é€šè¿‡ `&x` çš„æ–¹å¼åˆ›å»ºçš„
- `dyn` å…³é”®å­—åªç”¨åœ¨ç‰¹å¾å¯¹è±¡çš„ç±»å‹å£°æ˜ä¸Šï¼Œåœ¨åˆ›å»ºæ—¶æ— éœ€ä½¿ç”¨ `dyn`

å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨ç‰¹å¾å¯¹è±¡æ¥ä»£è¡¨æ³›å‹æˆ–å…·ä½“çš„ç±»å‹ã€‚

ç»§ç»­æ¥å®Œå–„ä¹‹å‰çš„ UI ç»„ä»¶ä»£ç ï¼Œé¦–å…ˆæ¥å®ç° `Screen`ï¼š

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

å…¶ä¸­å­˜å‚¨äº†ä¸€ä¸ªåŠ¨æ€æ•°ç»„ï¼Œé‡Œé¢å…ƒç´ çš„ç±»å‹æ˜¯ `Draw` ç‰¹å¾å¯¹è±¡ï¼š`Box<dyn Draw>`ï¼Œä»»ä½•å®ç°äº† `Draw` ç‰¹å¾çš„ç±»å‹ï¼Œéƒ½å¯ä»¥å­˜æ”¾å…¶ä¸­ã€‚

å†æ¥ä¸º `Screen` å®šä¹‰ `run` æ–¹æ³•ï¼Œç”¨äºå°†åˆ—è¡¨ä¸­çš„ UI ç»„ä»¶æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼š

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ä¹‹å‰çš„ç›®æ ‡ï¼šåœ¨åˆ—è¡¨ä¸­å­˜å‚¨å¤šç§ä¸åŒç±»å‹çš„å®ä¾‹ï¼Œç„¶åå°†å®ƒä»¬ä½¿ç”¨åŒä¸€ä¸ªæ–¹æ³•é€ä¸€æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼

å†æ¥çœ‹çœ‹ï¼Œå¦‚æœé€šè¿‡æ³›å‹å®ç°ï¼Œä¼šå¦‚ä½•ï¼š

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

ä¸Šé¢çš„ `Screen` çš„åˆ—è¡¨ä¸­ï¼Œå­˜å‚¨äº†ç±»å‹ä¸º `T` çš„å…ƒç´ ï¼Œç„¶ååœ¨ `Screen` ä¸­ä½¿ç”¨ç‰¹å¾çº¦æŸè®© `T` å®ç°äº† `Draw` ç‰¹å¾ï¼Œè¿›è€Œå¯ä»¥è°ƒç”¨ `draw` æ–¹æ³•ã€‚

ä½†æ˜¯è¿™ç§å†™æ³•é™åˆ¶äº† `Screen` å®ä¾‹çš„ `Vec<T>` ä¸­çš„æ¯ä¸ªå…ƒç´ å¿…é¡»æ˜¯ `Button` ç±»å‹æˆ–è€…å…¨æ˜¯ `SelectBox` ç±»å‹ã€‚å¦‚æœåªéœ€è¦åŒè´¨ï¼ˆç›¸åŒç±»å‹ï¼‰é›†åˆï¼Œæ›´å€¾å‘äºé‡‡ç”¨æ³›å‹+ç‰¹å¾çº¦æŸè¿™ç§å†™æ³•ï¼Œå› å…¶å®ç°æ›´æ¸…æ™°ï¼Œä¸”æ€§èƒ½æ›´å¥½(ç‰¹å¾å¯¹è±¡ï¼Œéœ€è¦åœ¨è¿è¡Œæ—¶ä» `vtable` åŠ¨æ€æŸ¥æ‰¾éœ€è¦è°ƒç”¨çš„æ–¹æ³•)ã€‚

ç°åœ¨æ¥è¿è¡Œæ¸²æŸ“ä¸‹å’±ä»¬ç²¾å¿ƒè®¾è®¡çš„ UI ç»„ä»¶åˆ—è¡¨ï¼š

```rust
fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No")
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```

ä¸Šé¢ä½¿ç”¨ `Box::new(T)` çš„æ–¹å¼æ¥åˆ›å»ºäº†ä¸¤ä¸ª `Box<dyn Draw>` ç‰¹å¾å¯¹è±¡ï¼Œå¦‚æœä»¥åè¿˜éœ€è¦å¢åŠ ä¸€ä¸ª UI ç»„ä»¶ï¼Œé‚£ä¹ˆè®©è¯¥ç»„ä»¶å®ç° `Draw` ç‰¹å¾ï¼Œåˆ™å¯ä»¥å¾ˆè½»æ¾çš„å°†å…¶æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼Œç”šè‡³ç”¨æˆ·å¯ä»¥å¼•å…¥æˆ‘ä»¬çš„åº“ä½œä¸ºä¸‰æ–¹åº“ï¼Œç„¶ååœ¨è‡ªå·±çš„åº“ä¸­ä¸ºè‡ªå·±çš„ç±»å‹å®ç° `Draw` ç‰¹å¾ï¼Œç„¶åè¿›è¡Œæ¸²æŸ“ã€‚

åœ¨åŠ¨æ€ç±»å‹è¯­è¨€ä¸­ï¼Œæœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µï¼š**é¸­å­ç±»å‹**(_duck typing_)ï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯åªå…³å¿ƒå€¼é•¿å•¥æ ·ï¼Œè€Œä¸å…³å¿ƒå®ƒå®é™…æ˜¯ä»€ä¹ˆã€‚å½“ä¸€ä¸ªä¸œè¥¿èµ°èµ·æ¥åƒé¸­å­ï¼Œå«èµ·æ¥åƒé¸­å­ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€åªé¸­å­ï¼Œå°±ç®—å®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªå¥¥ç‰¹æ›¼ï¼Œä¹Ÿä¸é‡è¦ï¼Œæˆ‘ä»¬å°±å½“å®ƒæ˜¯é¸­å­ã€‚

åœ¨ä¸Šä¾‹ä¸­ï¼Œ`Screen` åœ¨ `run` çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦çŸ¥é“å„ä¸ªç»„ä»¶çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆã€‚å®ƒä¹Ÿä¸æ£€æŸ¥ç»„ä»¶åˆ°åº•æ˜¯ `Button` è¿˜æ˜¯ `SelectBox` çš„å®ä¾‹ï¼Œåªè¦å®ƒå®ç°äº† `Draw` ç‰¹å¾ï¼Œå°±èƒ½é€šè¿‡ `Box::new` åŒ…è£…æˆ `Box<dyn Draw>` ç‰¹å¾å¯¹è±¡ï¼Œç„¶åè¢«æ¸²æŸ“åœ¨å±å¹•ä¸Šã€‚

ä½¿ç”¨ç‰¹å¾å¯¹è±¡å’Œ Rust ç±»å‹ç³»ç»Ÿæ¥è¿›è¡Œç±»ä¼¼é¸­å­ç±»å‹æ“ä½œçš„ä¼˜åŠ¿æ˜¯ï¼Œæ— éœ€åœ¨è¿è¡Œæ—¶æ£€æŸ¥ä¸€ä¸ªå€¼æ˜¯å¦å®ç°äº†ç‰¹å®šæ–¹æ³•æˆ–è€…æ‹…å¿ƒåœ¨è°ƒç”¨æ—¶å› ä¸ºå€¼æ²¡æœ‰å®ç°æ–¹æ³•è€Œäº§ç”Ÿé”™è¯¯ã€‚å¦‚æœå€¼æ²¡æœ‰å®ç°ç‰¹å¾å¯¹è±¡æ‰€éœ€çš„ç‰¹å¾ï¼Œ é‚£ä¹ˆ Rust æ ¹æœ¬å°±ä¸ä¼šç¼–è¯‘è¿™äº›ä»£ç ï¼š

```rust
fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from("Hi")),
        ],
    };

    screen.run();
}
```

å› ä¸º `String` ç±»å‹æ²¡æœ‰å®ç° `Draw` ç‰¹å¾ï¼Œç¼–è¯‘å™¨ç›´æ¥å°±ä¼šæŠ¥é”™ï¼Œä¸ä¼šè®©ä¸Šè¿°ä»£ç è¿è¡Œã€‚å¦‚æœæƒ³è¦ `String` ç±»å‹è¢«æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼Œé‚£ä¹ˆåªéœ€è¦ä¸ºå…¶å®ç° `Draw` ç‰¹å¾å³å¯ï¼Œéå¸¸å®¹æ˜“ã€‚

<!-- #### &dyn å’Œ Box\<dyn\>çš„åŒºåˆ«

å‰æ–‡æåˆ°ï¼Œ `&dyn` å’Œ `Box<dyn>` éƒ½å¯ä»¥ç”¨äºç‰¹å¾å¯¹è±¡ï¼Œå› æ­¤åœ¨åŠŸèƒ½ä¸Š `&dyn` å’Œ `Box<dyn>` å‡ ä¹æ²¡æœ‰åŒºåˆ«ï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯ï¼š`&dyn` å‡å°‘äº†ä¸€æ¬¡æŒ‡é’ˆè°ƒç”¨ã€‚

å› ä¸º `Box<dyn>` æ˜¯ä¸€ä¸ªå®½æŒ‡é’ˆï¼ˆ`fat pointer`ï¼‰ï¼Œå®ƒéœ€è¦ä¸€æ¬¡é¢å¤–çš„è§£å¼•ç”¨åï¼Œæ‰èƒ½è·å–åˆ°æŒ‡å‘ `vtable` çš„æŒ‡é’ˆï¼Œç„¶åå†é€šè¿‡è¯¥æŒ‡é’ˆè®¿é—® `vtable` æŸ¥è¯¢åˆ°å…·ä½“çš„å‡½æ•°æŒ‡é’ˆï¼Œæœ€åè¿›è¡Œè°ƒç”¨ã€‚

æ‰€ä»¥ï¼Œå¦‚æœä½ åœ¨ä¹æ€§èƒ½ï¼Œåˆæƒ³ä½¿ç”¨ç‰¹å¾å¯¹è±¡ç®€åŒ–ä»£ç ï¼Œå¯ä»¥ä¼˜å…ˆè€ƒè™‘ `&dyn`ã€‚ -->

æ³¨æ„ `dyn` ä¸èƒ½å•ç‹¬ä½œä¸ºç‰¹å¾å¯¹è±¡çš„å®šä¹‰ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼ŒåŸå› æ˜¯ç‰¹å¾å¯¹è±¡å¯ä»¥æ˜¯ä»»æ„å®ç°äº†æŸä¸ªç‰¹å¾çš„ç±»å‹ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸä¸çŸ¥é“è¯¥ç±»å‹çš„å¤§å°ï¼Œä¸åŒçš„ç±»å‹å¤§å°æ˜¯ä¸åŒçš„ã€‚

è€Œ `&dyn` å’Œ `Box<dyn>` åœ¨ç¼–è¯‘æœŸéƒ½æ˜¯å·²çŸ¥å¤§å°ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä½œç‰¹å¾å¯¹è±¡çš„å®šä¹‰ã€‚

```rust
fn draw2(x: dyn Draw) {
    x.draw();
}
```

```
10 | fn draw2(x: dyn Draw) {
   |          ^ doesn't have a size known at compile-time
   |
   = help: the trait `Sized` is not implemented for `(dyn Draw + 'static)`
help: function arguments must have a statically known size, borrowed types always have a known size
```

## ç‰¹å¾å¯¹è±¡çš„åŠ¨æ€åˆ†å‘

å›å¿†ä¸€ä¸‹æ³›å‹ç« èŠ‚æˆ‘ä»¬æåˆ°è¿‡çš„ï¼Œæ³›å‹æ˜¯åœ¨ç¼–è¯‘æœŸå®Œæˆå¤„ç†çš„ï¼šç¼–è¯‘å™¨ä¼šä¸ºæ¯ä¸€ä¸ªæ³›å‹å‚æ•°å¯¹åº”çš„å…·ä½“ç±»å‹ç”Ÿæˆä¸€ä»½ä»£ç ï¼Œè¿™ç§æ–¹å¼æ˜¯**é™æ€åˆ†å‘(static dispatch)**ï¼Œå› ä¸ºæ˜¯åœ¨ç¼–è¯‘æœŸå®Œæˆçš„ï¼Œå¯¹äºè¿è¡ŒæœŸæ€§èƒ½å®Œå…¨æ²¡æœ‰ä»»ä½•å½±å“ã€‚

ä¸é™æ€åˆ†å‘ç›¸å¯¹åº”çš„æ˜¯**åŠ¨æ€åˆ†å‘(dynamic dispatch)**ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç›´åˆ°è¿è¡Œæ—¶ï¼Œæ‰èƒ½ç¡®å®šéœ€è¦è°ƒç”¨ä»€ä¹ˆæ–¹æ³•ã€‚ä¹‹å‰ä»£ç ä¸­çš„å…³é”®å­— `dyn` æ­£æ˜¯åœ¨å¼ºè°ƒè¿™ä¸€â€œåŠ¨æ€â€çš„ç‰¹ç‚¹ã€‚

å½“ä½¿ç”¨ç‰¹å¾å¯¹è±¡æ—¶ï¼ŒRust å¿…é¡»ä½¿ç”¨åŠ¨æ€åˆ†å‘ã€‚ç¼–è¯‘å™¨æ— æ³•çŸ¥æ™“æ‰€æœ‰å¯èƒ½ç”¨äºç‰¹å¾å¯¹è±¡ä»£ç çš„ç±»å‹ï¼Œæ‰€ä»¥å®ƒä¹Ÿä¸çŸ¥é“åº”è¯¥è°ƒç”¨å“ªä¸ªç±»å‹çš„å“ªä¸ªæ–¹æ³•å®ç°ã€‚ä¸ºæ­¤ï¼ŒRust åœ¨è¿è¡Œæ—¶ä½¿ç”¨ç‰¹å¾å¯¹è±¡ä¸­çš„æŒ‡é’ˆæ¥çŸ¥æ™“éœ€è¦è°ƒç”¨å“ªä¸ªæ–¹æ³•ã€‚åŠ¨æ€åˆ†å‘ä¹Ÿé˜»æ­¢ç¼–è¯‘å™¨æœ‰é€‰æ‹©çš„å†…è”æ–¹æ³•ä»£ç ï¼Œè¿™ä¼šç›¸åº”çš„ç¦ç”¨ä¸€äº›ä¼˜åŒ–ã€‚

ä¸‹é¢è¿™å¼ å›¾å¾ˆå¥½çš„è§£é‡Šäº†é™æ€åˆ†å‘ `Box<T>` å’ŒåŠ¨æ€åˆ†å‘ `Box<dyn Trait>` çš„åŒºåˆ«ï¼š

<img alt="" src="https://pic1.zhimg.com/80/v2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg" class="center"  />

ç»“åˆä¸Šæ–‡çš„å†…å®¹å’Œè¿™å¼ å›¾å¯ä»¥äº†è§£ï¼š

- **ç‰¹å¾å¯¹è±¡å¤§å°ä¸å›ºå®š**ï¼šè¿™æ˜¯å› ä¸ºï¼Œå¯¹äºç‰¹å¾ `Draw`ï¼Œç±»å‹ `Button` å¯ä»¥å®ç°ç‰¹å¾ `Draw`ï¼Œç±»å‹ `SelectBox` ä¹Ÿå¯ä»¥å®ç°ç‰¹å¾ `Draw`ï¼Œå› æ­¤ç‰¹å¾æ²¡æœ‰å›ºå®šå¤§å°
- **å‡ ä¹æ€»æ˜¯ä½¿ç”¨ç‰¹å¾å¯¹è±¡çš„å¼•ç”¨æ–¹å¼**ï¼Œå¦‚ `&dyn Draw`ã€`Box<dyn Draw>`
  - è™½ç„¶ç‰¹å¾å¯¹è±¡æ²¡æœ‰å›ºå®šå¤§å°ï¼Œä½†å®ƒçš„å¼•ç”¨ç±»å‹çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå®ƒç”±ä¸¤ä¸ªæŒ‡é’ˆç»„æˆï¼ˆ`ptr` å’Œ `vptr`ï¼‰ï¼Œå› æ­¤å ç”¨ä¸¤ä¸ªæŒ‡é’ˆå¤§å°
  - ä¸€ä¸ªæŒ‡é’ˆ `ptr` æŒ‡å‘å®ç°äº†ç‰¹å¾ `Draw` çš„å…·ä½“ç±»å‹çš„å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯å½“ä½œç‰¹å¾ `Draw` æ¥ç”¨çš„ç±»å‹çš„å®ä¾‹ï¼Œæ¯”å¦‚ç±»å‹ `Button` çš„å®ä¾‹ã€ç±»å‹ `SelectBox` çš„å®ä¾‹
  - å¦ä¸€ä¸ªæŒ‡é’ˆ `vptr` æŒ‡å‘ä¸€ä¸ªè™šè¡¨ `vtable`ï¼Œ`vtable` ä¸­ä¿å­˜äº†ç±»å‹ `Button` æˆ–ç±»å‹ `SelectBox` çš„å®ä¾‹å¯¹äºå¯ä»¥è°ƒç”¨çš„å®ç°äºç‰¹å¾ `Draw` çš„æ–¹æ³•ã€‚å½“è°ƒç”¨æ–¹æ³•æ—¶ï¼Œç›´æ¥ä» `vtable` ä¸­æ‰¾åˆ°æ–¹æ³•å¹¶è°ƒç”¨ã€‚ä¹‹æ‰€ä»¥è¦ä½¿ç”¨ä¸€ä¸ª `vtable` æ¥ä¿å­˜å„å®ä¾‹çš„æ–¹æ³•ï¼Œæ˜¯å› ä¸ºå®ç°äº†ç‰¹å¾ `Draw` çš„ç±»å‹æœ‰å¤šç§ï¼Œè¿™äº›ç±»å‹æ‹¥æœ‰çš„æ–¹æ³•å„ä¸ç›¸åŒï¼Œå½“å°†è¿™äº›ç±»å‹çš„å®ä¾‹éƒ½å½“ä½œç‰¹å¾ `Draw` æ¥ä½¿ç”¨æ—¶(æ­¤æ—¶ï¼Œå®ƒä»¬å…¨éƒ½çœ‹ä½œæ˜¯ç‰¹å¾ `Draw` ç±»å‹çš„å®ä¾‹)ï¼Œæœ‰å¿…è¦åŒºåˆ†è¿™äº›å®ä¾‹å„è‡ªæœ‰å“ªäº›æ–¹æ³•å¯è°ƒç”¨

ç®€è€Œè¨€ä¹‹ï¼Œå½“ç±»å‹ `Button` å®ç°äº†ç‰¹å¾ `Draw` æ—¶ï¼Œç±»å‹ `Button` çš„å®ä¾‹å¯¹è±¡ `btn` å¯ä»¥å½“ä½œç‰¹å¾ `Draw` çš„ç‰¹å¾å¯¹è±¡ç±»å‹æ¥ä½¿ç”¨ï¼Œ`btn` ä¸­ä¿å­˜äº†ä½œä¸ºç‰¹å¾å¯¹è±¡çš„æ•°æ®æŒ‡é’ˆï¼ˆæŒ‡å‘ç±»å‹ `Button` çš„å®ä¾‹æ•°æ®ï¼‰å’Œè¡Œä¸ºæŒ‡é’ˆï¼ˆæŒ‡å‘ `vtable`ï¼‰ã€‚

ä¸€å®šè¦æ³¨æ„ï¼Œæ­¤æ—¶çš„ `btn` æ˜¯ `Draw` çš„ç‰¹å¾å¯¹è±¡çš„å®ä¾‹ï¼Œè€Œä¸å†æ˜¯å…·ä½“ç±»å‹ `Button` çš„å®ä¾‹ï¼Œè€Œä¸” `btn` çš„ `vtable` åªåŒ…å«äº†å®ç°è‡ªç‰¹å¾ `Draw` çš„é‚£äº›æ–¹æ³•ï¼ˆæ¯”å¦‚ `draw`ï¼‰ï¼Œå› æ­¤ `btn` åªèƒ½è°ƒç”¨å®ç°äºç‰¹å¾ `Draw` çš„ `draw` æ–¹æ³•ï¼Œè€Œä¸èƒ½è°ƒç”¨ç±»å‹ `Button` æœ¬èº«å®ç°çš„æ–¹æ³•å’Œç±»å‹ `Button` å®ç°äºå…¶ä»–ç‰¹å¾çš„æ–¹æ³•ã€‚**ä¹Ÿå°±æ˜¯è¯´ï¼Œ`btn` æ˜¯å“ªä¸ªç‰¹å¾å¯¹è±¡çš„å®ä¾‹ï¼Œå®ƒçš„ `vtable` ä¸­å°±åŒ…å«äº†è¯¥ç‰¹å¾çš„æ–¹æ³•ã€‚**

## Self ä¸ self

åœ¨ Rust ä¸­ï¼Œæœ‰ä¸¤ä¸ª`self`ï¼Œä¸€ä¸ªæŒ‡ä»£å½“å‰çš„å®ä¾‹å¯¹è±¡ï¼Œä¸€ä¸ªæŒ‡ä»£ç‰¹å¾æˆ–è€…æ–¹æ³•ç±»å‹çš„åˆ«åï¼š

```rust
trait Draw {
    fn draw(&self) -> Self;
}

#[derive(Clone)]
struct Button;
impl Draw for Button {
    fn draw(&self) -> Self {
        return self.clone()
    }
}

fn main() {
    let button = Button;
    let newb = button.draw();
}
```

ä¸Šè¿°ä»£ç ä¸­ï¼Œ`self`æŒ‡ä»£çš„å°±æ˜¯å½“å‰çš„å®ä¾‹å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯ `button.draw()` ä¸­çš„ `button` å®ä¾‹ï¼Œ`Self` åˆ™æŒ‡ä»£çš„æ˜¯ `Button` ç±»å‹ã€‚

å½“ç†è§£äº† `self` ä¸ `Self` çš„åŒºåˆ«åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ä½•ä¸ºå¯¹è±¡å®‰å…¨ã€‚

## ç‰¹å¾å¯¹è±¡çš„é™åˆ¶

ä¸æ˜¯æ‰€æœ‰ç‰¹å¾éƒ½èƒ½æ‹¥æœ‰ç‰¹å¾å¯¹è±¡ï¼Œåªæœ‰å¯¹è±¡å®‰å…¨çš„ç‰¹å¾æ‰è¡Œã€‚å½“ä¸€ä¸ªç‰¹å¾çš„æ‰€æœ‰æ–¹æ³•éƒ½æœ‰å¦‚ä¸‹å±æ€§æ—¶ï¼Œå®ƒçš„å¯¹è±¡æ‰æ˜¯å®‰å…¨çš„ï¼š

- æ–¹æ³•çš„è¿”å›ç±»å‹ä¸èƒ½æ˜¯ `Self`
- æ–¹æ³•æ²¡æœ‰ä»»ä½•æ³›å‹å‚æ•°

å¯¹è±¡å®‰å…¨å¯¹äºç‰¹å¾å¯¹è±¡æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºä¸€æ—¦æœ‰äº†ç‰¹å¾å¯¹è±¡ï¼Œå°±ä¸å†éœ€è¦çŸ¥é“å®ç°è¯¥ç‰¹å¾çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆäº†ã€‚å¦‚æœç‰¹å¾æ–¹æ³•è¿”å›äº†å…·ä½“çš„ `Self` ç±»å‹ï¼Œä½†æ˜¯ç‰¹å¾å¯¹è±¡å¿˜è®°äº†å…¶çœŸæ­£çš„ç±»å‹ï¼Œé‚£è¿™ä¸ª `Self` å°±éå¸¸å°´å°¬ï¼Œå› ä¸ºæ²¡äººçŸ¥é“å®ƒæ˜¯è°äº†ã€‚ä½†æ˜¯å¯¹äºæ³›å‹ç±»å‹å‚æ•°æ¥è¯´ï¼Œå½“ä½¿ç”¨ç‰¹å¾æ—¶å…¶ä¼šæ”¾å…¥å…·ä½“çš„ç±»å‹å‚æ•°ï¼šæ­¤å…·ä½“ç±»å‹å˜æˆäº†å®ç°è¯¥ç‰¹å¾çš„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚è€Œå½“ä½¿ç”¨ç‰¹å¾å¯¹è±¡æ—¶å…¶å…·ä½“ç±»å‹è¢«æŠ¹å»äº†ï¼Œæ•…è€Œæ— ä»å¾—çŸ¥æ”¾å…¥æ³›å‹å‚æ•°ç±»å‹åˆ°åº•æ˜¯ä»€ä¹ˆã€‚

æ ‡å‡†åº“ä¸­çš„ `Clone` ç‰¹å¾å°±ä¸ç¬¦åˆå¯¹è±¡å®‰å…¨çš„è¦æ±‚ï¼š

```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```

å› ä¸ºå®ƒçš„å…¶ä¸­ä¸€ä¸ªæ–¹æ³•ï¼Œè¿”å›äº† `Self` ç±»å‹ï¼Œå› æ­¤å®ƒæ˜¯å¯¹è±¡ä¸å®‰å…¨çš„ã€‚

`String` ç±»å‹å®ç°äº† `Clone` ç‰¹å¾ï¼Œ `String` å®ä¾‹ä¸Šè°ƒç”¨ `clone` æ–¹æ³•æ—¶ä¼šå¾—åˆ°ä¸€ä¸ª `String` å®ä¾‹ã€‚ç±»ä¼¼çš„ï¼Œå½“è°ƒç”¨ `Vec<T>` å®ä¾‹çš„ `clone` æ–¹æ³•ä¼šå¾—åˆ°ä¸€ä¸ª `Vec<T>` å®ä¾‹ã€‚`clone` çš„ç­¾åéœ€è¦çŸ¥é“ä»€ä¹ˆç±»å‹ä¼šä»£æ›¿ `Self`ï¼Œå› ä¸ºè¿™æ˜¯å®ƒçš„è¿”å›å€¼ã€‚

å¦‚æœè¿åäº†å¯¹è±¡å®‰å…¨çš„è§„åˆ™ï¼Œç¼–è¯‘å™¨ä¼šæç¤ºä½ ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°è¯•ä½¿ç”¨ä¹‹å‰çš„ `Screen` ç»“æ„ä½“æ¥å­˜æ”¾å®ç°äº† `Clone` ç‰¹å¾çš„ç±»å‹ï¼š

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}
```

å°†ä¼šå¾—åˆ°å¦‚ä¸‹é”™è¯¯ï¼š

```text
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --> src/lib.rs:2:5
  |
2 |     pub components: Vec<Box<dyn Clone>>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`
  cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`
```

è¿™æ„å‘³ç€ä¸èƒ½ä»¥è¿™ç§æ–¹å¼ä½¿ç”¨æ­¤ç‰¹å¾ä½œä¸ºç‰¹å¾å¯¹è±¡ã€‚


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/generics-traits/trait-object.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/trait-object.md)ã€‚



================================================
FILE: src/basic/trait/trait.md
================================================
# ç‰¹å¾ Trait

å¦‚æœæˆ‘ä»¬æƒ³å®šä¹‰ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œé‚£ä¹ˆæŠŠè¯¥ç³»ç»Ÿè·Ÿåº•å±‚å­˜å‚¨è§£è€¦æ˜¯å¾ˆé‡è¦çš„ã€‚æ–‡ä»¶æ“ä½œä¸»è¦åŒ…å«å››ä¸ªï¼š`open` ã€`write`ã€`read`ã€`close`ï¼Œè¿™äº›æ“ä½œå¯ä»¥å‘ç”Ÿåœ¨ç¡¬ç›˜ï¼Œå¯ä»¥å‘ç”Ÿåœ¨å†…å­˜ï¼Œè¿˜å¯ä»¥å‘ç”Ÿåœ¨ç½‘ç»œ IO ç”šè‡³ï¼ˆ...æˆ‘å®åœ¨ç¼–ä¸ä¸‹å»äº†ï¼Œå¤§å®¶æ¥å¸®å¸®æˆ‘ï¼‰ã€‚æ€»ä¹‹å¦‚æœä½ è¦ä¸ºæ¯ä¸€ç§æƒ…å†µéƒ½å•ç‹¬å®ç°ä¸€å¥—ä»£ç ï¼Œé‚£è¿™ç§å®ç°å°†è¿‡äºç¹æ‚ï¼Œè€Œä¸”ä¹Ÿæ²¡é‚£ä¸ªå¿…è¦ã€‚

è¦è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œéœ€è¦æŠŠè¿™äº›è¡Œä¸ºæŠ½è±¡å‡ºæ¥ï¼Œå°±è¦ä½¿ç”¨ Rust ä¸­çš„ç‰¹å¾ `trait` æ¦‚å¿µã€‚å¯èƒ½ä½ æ˜¯ç¬¬ä¸€æ¬¡å¬è¯´è¿™ä¸ªåè¯ï¼Œä½†æ˜¯ä¸è¦æ€•ï¼Œå¦‚æœå­¦è¿‡å…¶ä»–è¯­è¨€ï¼Œé‚£ä¹ˆå¤§æ¦‚ç‡ä½ å¬è¯´è¿‡æ¥å£ï¼Œæ²¡é”™ï¼Œç‰¹å¾è·Ÿæ¥å£å¾ˆç±»ä¼¼ã€‚

åœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¤šæ¬¡è§è¿‡ç‰¹å¾çš„ä½¿ç”¨ï¼Œä¾‹å¦‚ `#[derive(Debug)]`ï¼Œå®ƒåœ¨æˆ‘ä»¬å®šä¹‰çš„ç±»å‹(`struct`)ä¸Šè‡ªåŠ¨æ´¾ç”Ÿ `Debug` ç‰¹å¾ï¼Œæ¥ç€å¯ä»¥ä½¿ç”¨ `println!("{:?}", x)` æ‰“å°è¿™ä¸ªç±»å‹ï¼›å†ä¾‹å¦‚ï¼š

```rust
fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
    a + b
}
```

é€šè¿‡ `std::ops::Add` ç‰¹å¾æ¥é™åˆ¶ `T`ï¼Œåªæœ‰ `T` å®ç°äº† `std::ops::Add` æ‰èƒ½è¿›è¡Œåˆæ³•çš„åŠ æ³•æ“ä½œï¼Œæ¯•ç«Ÿä¸æ˜¯æ‰€æœ‰çš„ç±»å‹éƒ½èƒ½è¿›è¡Œç›¸åŠ ã€‚

è¿™äº›éƒ½è¯´æ˜ä¸€ä¸ªé“ç†ï¼Œç‰¹å¾å®šä¹‰äº†**ä¸€ç»„å¯ä»¥è¢«å…±äº«çš„è¡Œä¸ºï¼Œåªè¦å®ç°äº†ç‰¹å¾ï¼Œä½ å°±èƒ½ä½¿ç”¨è¿™ç»„è¡Œä¸º**ã€‚

## å®šä¹‰ç‰¹å¾

å¦‚æœä¸åŒçš„ç±»å‹å…·æœ‰ç›¸åŒçš„è¡Œä¸ºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰ä¸€ä¸ªç‰¹å¾ï¼Œç„¶åä¸ºè¿™äº›ç±»å‹å®ç°è¯¥ç‰¹å¾ã€‚**å®šä¹‰ç‰¹å¾**æ˜¯æŠŠä¸€äº›æ–¹æ³•ç»„åˆåœ¨ä¸€èµ·ï¼Œç›®çš„æ˜¯å®šä¹‰ä¸€ä¸ªå®ç°æŸäº›ç›®æ ‡æ‰€å¿…éœ€çš„è¡Œä¸ºçš„é›†åˆã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰æ–‡ç«  `Post` å’Œå¾®åš `Weibo` ä¸¤ç§å†…å®¹è½½ä½“ï¼Œè€Œæˆ‘ä»¬æƒ³å¯¹ç›¸åº”çš„å†…å®¹è¿›è¡Œæ€»ç»“ï¼Œä¹Ÿå°±æ˜¯æ— è®ºæ˜¯æ–‡ç« å†…å®¹ï¼Œè¿˜æ˜¯å¾®åšå†…å®¹ï¼Œéƒ½å¯ä»¥åœ¨æŸä¸ªæ—¶é—´ç‚¹è¿›è¡Œæ€»ç»“ï¼Œé‚£ä¹ˆæ€»ç»“è¿™ä¸ªè¡Œä¸ºå°±æ˜¯å…±äº«çš„ï¼Œå› æ­¤å¯ä»¥ç”¨ç‰¹å¾æ¥å®šä¹‰ï¼š

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

è¿™é‡Œä½¿ç”¨ `trait` å…³é”®å­—æ¥å£°æ˜ä¸€ä¸ªç‰¹å¾ï¼Œ`Summary` æ˜¯ç‰¹å¾åã€‚åœ¨å¤§æ‹¬å·ä¸­å®šä¹‰äº†è¯¥ç‰¹å¾çš„æ‰€æœ‰æ–¹æ³•ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ï¼š `fn summarize(&self) -> String`ã€‚

ç‰¹å¾åªå®šä¹‰è¡Œä¸ºçœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œè€Œä¸å®šä¹‰è¡Œä¸ºå…·ä½“æ˜¯æ€ä¹ˆæ ·çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªå®šä¹‰ç‰¹å¾æ–¹æ³•çš„ç­¾åï¼Œè€Œä¸è¿›è¡Œå®ç°ï¼Œæ­¤æ—¶æ–¹æ³•ç­¾åç»“å°¾æ˜¯ `;`ï¼Œè€Œä¸æ˜¯ä¸€ä¸ª `{}`ã€‚

æ¥ä¸‹æ¥ï¼Œæ¯ä¸€ä¸ªå®ç°è¿™ä¸ªç‰¹å¾çš„ç±»å‹éƒ½éœ€è¦å…·ä½“å®ç°è¯¥ç‰¹å¾çš„ç›¸åº”æ–¹æ³•ï¼Œç¼–è¯‘å™¨ä¹Ÿä¼šç¡®ä¿ä»»ä½•å®ç° `Summary` ç‰¹å¾çš„ç±»å‹éƒ½æ‹¥æœ‰ä¸è¿™ä¸ªç­¾åçš„å®šä¹‰å®Œå…¨ä¸€è‡´çš„ `summarize` æ–¹æ³•ã€‚

## ä¸ºç±»å‹å®ç°ç‰¹å¾

å› ä¸ºç‰¹å¾åªå®šä¹‰è¡Œä¸ºçœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸ºç±»å‹å®ç°å…·ä½“çš„ç‰¹å¾ï¼Œå®šä¹‰è¡Œä¸ºå…·ä½“æ˜¯æ€ä¹ˆæ ·çš„ã€‚

é¦–å…ˆæ¥ä¸º `Post` å’Œ `Weibo` å®ç° `Summary` ç‰¹å¾ï¼š

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String, // æ ‡é¢˜
    pub author: String, // ä½œè€…
    pub content: String, // å†…å®¹
}

impl Summary for Post {
    fn summarize(&self) -> String {
        format!("æ–‡ç« {}, ä½œè€…æ˜¯{}", self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}å‘è¡¨äº†å¾®åš{}", self.username, self.content)
    }
}
```

å®ç°ç‰¹å¾çš„è¯­æ³•ä¸ä¸ºç»“æ„ä½“ã€æšä¸¾å®ç°æ–¹æ³•å¾ˆåƒï¼š`impl Summary for Post`ï¼Œè¯»ä½œâ€œä¸º `Post` ç±»å‹å®ç° `Summary` ç‰¹å¾â€ï¼Œç„¶ååœ¨ `impl` çš„èŠ±æ‹¬å·ä¸­å®ç°è¯¥ç‰¹å¾çš„å…·ä½“æ–¹æ³•ã€‚

æ¥ä¸‹æ¥å°±å¯ä»¥åœ¨è¿™ä¸ªç±»å‹ä¸Šè°ƒç”¨ç‰¹å¾çš„æ–¹æ³•ï¼š

```rust
fn main() {
    let post = Post{title: "Rustè¯­è¨€ç®€ä»‹".to_string(),author: "Sunface".to_string(), content: "Rustæ£’æäº†!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "å¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨".to_string()};

    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
}
```

è¿è¡Œè¾“å‡ºï¼š

```console
æ–‡ç«  Rust è¯­è¨€ç®€ä»‹, ä½œè€…æ˜¯Sunface
sunfaceå‘è¡¨äº†å¾®åšå¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨
```

è¯´å®è¯ï¼Œå¦‚æœç‰¹å¾ä»…ä»…å¦‚æ­¤ï¼Œä½ å¯èƒ½ä¼šè§‰å¾—èŠ±é‡Œèƒ¡å“¨æ²¡å•¥ç”¨ï¼Œæ¥ä¸‹æ¥å°±è®©ä½ è§è¯†ä¸‹ `trait` çœŸæ­£çš„å¨åŠ›ã€‚

#### ç‰¹å¾å®šä¹‰ä¸å®ç°çš„ä½ç½®(å­¤å„¿è§„åˆ™)

ä¸Šé¢æˆ‘ä»¬å°† `Summary` å®šä¹‰æˆäº† `pub` å…¬å¼€çš„ã€‚è¿™æ ·ï¼Œå¦‚æœä»–äººæƒ³è¦ä½¿ç”¨æˆ‘ä»¬çš„ `Summary` ç‰¹å¾ï¼Œåˆ™å¯ä»¥å¼•å…¥åˆ°ä»–ä»¬çš„åŒ…ä¸­ï¼Œç„¶åå†è¿›è¡Œå®ç°ã€‚

å…³äºç‰¹å¾å®ç°ä¸å®šä¹‰çš„ä½ç½®ï¼Œæœ‰ä¸€æ¡éå¸¸é‡è¦çš„åŸåˆ™ï¼š**å¦‚æœä½ æƒ³è¦ä¸ºç±»å‹** `A` **å®ç°ç‰¹å¾** `T`**ï¼Œé‚£ä¹ˆ** `A` **æˆ–è€…** `T` **è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨å½“å‰ä½œç”¨åŸŸä¸­å®šä¹‰çš„ï¼** ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥ä¸ºä¸Šé¢çš„ `Post` ç±»å‹å®ç°æ ‡å‡†åº“ä¸­çš„ `Display` ç‰¹å¾ï¼Œè¿™æ˜¯å› ä¸º `Post` ç±»å‹å®šä¹‰åœ¨å½“å‰çš„ä½œç”¨åŸŸä¸­ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨å½“å‰åŒ…ä¸­ä¸º `String` ç±»å‹å®ç° `Summary` ç‰¹å¾ï¼Œå› ä¸º `Summary` å®šä¹‰åœ¨å½“å‰ä½œç”¨åŸŸä¸­ã€‚

ä½†æ˜¯ä½ æ— æ³•åœ¨å½“å‰ä½œç”¨åŸŸä¸­ï¼Œä¸º `String` ç±»å‹å®ç° `Display` ç‰¹å¾ï¼Œå› ä¸ºå®ƒä»¬ä¿©éƒ½å®šä¹‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œå…¶å®šä¹‰æ‰€åœ¨çš„ä½ç½®éƒ½ä¸åœ¨å½“å‰ä½œç”¨åŸŸï¼Œè·Ÿä½ åŠæ¯›é’±å…³ç³»éƒ½æ²¡æœ‰ï¼Œçœ‹çœ‹å°±è¡Œäº†ã€‚

è¯¥è§„åˆ™è¢«ç§°ä¸º**å­¤å„¿è§„åˆ™**ï¼Œå¯ä»¥ç¡®ä¿å…¶å®ƒäººç¼–å†™çš„ä»£ç ä¸ä¼šç ´åä½ çš„ä»£ç ï¼Œä¹Ÿç¡®ä¿äº†ä½ ä¸ä¼šè«åå…¶å¦™å°±ç ´åäº†é£é©¬ç‰›ä¸ç›¸åŠçš„ä»£ç ã€‚

#### é»˜è®¤å®ç°

ä½ å¯ä»¥åœ¨ç‰¹å¾ä¸­å®šä¹‰å…·æœ‰**é»˜è®¤å®ç°**çš„æ–¹æ³•ï¼Œè¿™æ ·å…¶å®ƒç±»å‹æ— éœ€å†å®ç°è¯¥æ–¹æ³•ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥é€‰æ‹©é‡å†™è¯¥æ–¹æ³•ï¼š

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

ä¸Šé¢ä¸º `Summary` å®šä¹‰äº†ä¸€ä¸ªé»˜è®¤å®ç°ï¼Œä¸‹é¢æˆ‘ä»¬ç¼–å†™æ®µä»£ç æ¥æµ‹è¯•ä¸‹ï¼š

```rust
impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}å‘è¡¨äº†å¾®åš{}", self.username, self.content)
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œ`Post` é€‰æ‹©äº†é»˜è®¤å®ç°ï¼Œè€Œ `Weibo` é‡å†™äº†è¯¥æ–¹æ³•ï¼Œè°ƒç”¨å’Œè¾“å‡ºå¦‚ä¸‹ï¼š

```rust
    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
```

```console
(Read more...)
sunfaceå‘è¡¨äº†å¾®åšå¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨
```

é»˜è®¤å®ç°å…è®¸è°ƒç”¨ç›¸åŒç‰¹å¾ä¸­çš„å…¶ä»–æ–¹æ³•ï¼Œå“ªæ€•è¿™äº›æ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°ã€‚å¦‚æ­¤ï¼Œç‰¹å¾å¯ä»¥æä¾›å¾ˆå¤šæœ‰ç”¨çš„åŠŸèƒ½è€Œåªéœ€è¦å®ç°æŒ‡å®šçš„ä¸€å°éƒ¨åˆ†å†…å®¹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ `Summary` ç‰¹å¾ï¼Œä½¿å…¶å…·æœ‰ä¸€ä¸ªéœ€è¦å®ç°çš„ `summarize_author` æ–¹æ³•ï¼Œç„¶åå®šä¹‰ä¸€ä¸ª `summarize` æ–¹æ³•ï¼Œæ­¤æ–¹æ³•çš„é»˜è®¤å®ç°è°ƒç”¨ `summarize_author` æ–¹æ³•ï¼š

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

ä¸ºäº†ä½¿ç”¨ `Summary`ï¼Œåªéœ€è¦å®ç° `summarize_author` æ–¹æ³•å³å¯ï¼š

```rust
impl Summary for Weibo {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
println!("1 new weibo: {}", weibo.summarize());

```

`weibo.summarize()` ä¼šå…ˆè°ƒç”¨ `Summary` ç‰¹å¾é»˜è®¤å®ç°çš„ `summarize` æ–¹æ³•ï¼Œé€šè¿‡è¯¥æ–¹æ³•è¿›è€Œè°ƒç”¨ `Weibo` ä¸º `Summary` å®ç°çš„ `summarize_author` æ–¹æ³•ï¼Œæœ€ç»ˆè¾“å‡ºï¼š`1 new weibo: (Read more from @horse_ebooks...)`ã€‚

## ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°

ä¹‹å‰æåˆ°è¿‡ï¼Œç‰¹å¾å¦‚æœä»…ä»…æ˜¯ç”¨æ¥å®ç°æ–¹æ³•ï¼Œé‚£çœŸçš„æœ‰äº›å¤§æå°ç”¨ï¼Œç°åœ¨æˆ‘ä»¬æ¥è®²ä¸‹ï¼ŒçœŸæ­£å¯ä»¥è®©ç‰¹å¾å¤§æ”¾å…‰å½©çš„åœ°æ–¹ã€‚

ç°åœ¨ï¼Œå…ˆå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°ï¼š

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

`impl Summary`ï¼Œåªèƒ½è¯´æƒ³å‡ºè¿™ä¸ªç±»å‹çš„äººçœŸçš„æ˜¯èµ·åé¬¼æ‰ï¼Œç®€ç›´å¤ªè´´åˆ‡äº†ï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒçš„æ„æ€æ˜¯ **å®ç°äº†`Summary`ç‰¹å¾** çš„ `item` å‚æ•°ã€‚

ä½ å¯ä»¥ä½¿ç”¨ä»»ä½•å®ç°äº† `Summary` ç‰¹å¾çš„ç±»å‹ä½œä¸ºè¯¥å‡½æ•°çš„å‚æ•°ï¼ŒåŒæ—¶åœ¨å‡½æ•°ä½“å†…ï¼Œè¿˜å¯ä»¥è°ƒç”¨è¯¥ç‰¹å¾çš„æ–¹æ³•ï¼Œä¾‹å¦‚ `summarize` æ–¹æ³•ã€‚å…·ä½“çš„è¯´ï¼Œå¯ä»¥ä¼ é€’ `Post` æˆ– `Weibo` çš„å®ä¾‹æ¥ä½œä¸ºå‚æ•°ï¼Œè€Œå…¶å®ƒç±»å¦‚ `String` æˆ–è€… `i32` çš„ç±»å‹åˆ™ä¸èƒ½ç”¨åšè¯¥å‡½æ•°çš„å‚æ•°ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å®ç° `Summary` ç‰¹å¾ã€‚

## ç‰¹å¾çº¦æŸ(trait bound)

è™½ç„¶ `impl Trait` è¿™ç§è¯­æ³•éå¸¸å¥½ç†è§£ï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼š

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

çœŸæ­£çš„å®Œæ•´ä¹¦å†™å½¢å¼å¦‚ä¸Šæ‰€è¿°ï¼Œå½¢å¦‚ `T: Summary` è¢«ç§°ä¸º**ç‰¹å¾çº¦æŸ**ã€‚

åœ¨ç®€å•çš„åœºæ™¯ä¸‹ `impl Trait` è¿™ç§è¯­æ³•ç³–å°±è¶³å¤Ÿä½¿ç”¨ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„åœºæ™¯ï¼Œç‰¹å¾çº¦æŸå¯ä»¥è®©æˆ‘ä»¬æ‹¥æœ‰æ›´å¤§çš„çµæ´»æ€§å’Œè¯­æ³•è¡¨ç°èƒ½åŠ›ï¼Œä¾‹å¦‚ä¸€ä¸ªå‡½æ•°æ¥å—ä¸¤ä¸ª `impl Summary` çš„å‚æ•°ï¼š

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
```

å¦‚æœå‡½æ•°ä¸¤ä¸ªå‚æ•°æ˜¯ä¸åŒçš„ç±»å‹ï¼Œé‚£ä¹ˆä¸Šé¢çš„æ–¹æ³•å¾ˆå¥½ï¼Œåªè¦è¿™ä¸¤ä¸ªç±»å‹éƒ½å®ç°äº† `Summary` ç‰¹å¾å³å¯ã€‚ä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³è¦å¼ºåˆ¶å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°æ˜¯åŒä¸€ç±»å‹å‘¢ï¼Ÿä¸Šé¢çš„è¯­æ³•å°±æ— æ³•åšåˆ°è¿™ç§é™åˆ¶ï¼Œæ­¤æ—¶æˆ‘ä»¬åªèƒ½ä½¿ç‰¹å¾çº¦æŸæ¥å®ç°ï¼š

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

æ³›å‹ç±»å‹ `T` è¯´æ˜äº† `item1` å’Œ `item2` å¿…é¡»æ‹¥æœ‰åŒæ ·çš„ç±»å‹ï¼ŒåŒæ—¶ `T: Summary` è¯´æ˜äº† `T` å¿…é¡»å®ç° `Summary` ç‰¹å¾ã€‚

#### å¤šé‡çº¦æŸ

é™¤äº†å•ä¸ªçº¦æŸæ¡ä»¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šå¤šä¸ªçº¦æŸæ¡ä»¶ï¼Œä¾‹å¦‚é™¤äº†è®©å‚æ•°å®ç° `Summary` ç‰¹å¾å¤–ï¼Œè¿˜å¯ä»¥è®©å‚æ•°å®ç° `Display` ç‰¹å¾ä»¥æ§åˆ¶å®ƒçš„æ ¼å¼åŒ–è¾“å‡ºï¼š

```rust
pub fn notify(item: &(impl Summary + Display)) {}
```

é™¤äº†ä¸Šè¿°çš„è¯­æ³•ç³–å½¢å¼ï¼Œè¿˜èƒ½ä½¿ç”¨ç‰¹å¾çº¦æŸçš„å½¢å¼ï¼š

```rust
pub fn notify<T: Summary + Display>(item: &T) {}
```

é€šè¿‡è¿™ä¸¤ä¸ªç‰¹å¾ï¼Œå°±å¯ä»¥ä½¿ç”¨ `item.summarize` æ–¹æ³•ï¼Œä»¥åŠé€šè¿‡ `println!("{}", item)` æ¥æ ¼å¼åŒ–è¾“å‡º `item`ã€‚

#### Where çº¦æŸ

å½“ç‰¹å¾çº¦æŸå˜å¾—å¾ˆå¤šæ—¶ï¼Œå‡½æ•°çš„ç­¾åå°†å˜å¾—å¾ˆå¤æ‚ï¼š

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
```

ä¸¥æ ¼æ¥è¯´ï¼Œä¸Šé¢çš„ä¾‹å­è¿˜æ˜¯ä¸å¤Ÿå¤æ‚ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯èƒ½å¯¹å…¶åšä¸€äº›å½¢å¼ä¸Šçš„æ”¹è¿›ï¼Œé€šè¿‡ `where`ï¼š

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```

#### ä½¿ç”¨ç‰¹å¾çº¦æŸæœ‰æ¡ä»¶åœ°å®ç°æ–¹æ³•æˆ–ç‰¹å¾

ç‰¹å¾çº¦æŸï¼Œå¯ä»¥è®©æˆ‘ä»¬åœ¨æŒ‡å®šç±»å‹ + æŒ‡å®šç‰¹å¾çš„æ¡ä»¶ä¸‹å»å®ç°æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

`cmp_display` æ–¹æ³•ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ `Pair<T>` ç»“æ„ä½“å¯¹è±¡éƒ½å¯ä»¥æ‹¥æœ‰ï¼Œåªæœ‰ `T` åŒæ—¶å®ç°äº† `Display + PartialOrd` çš„ `Pair<T>` æ‰å¯ä»¥æ‹¥æœ‰æ­¤æ–¹æ³•ã€‚
è¯¥å‡½æ•°å¯è¯»æ€§ä¼šæ›´å¥½ï¼Œå› ä¸ºæ³›å‹å‚æ•°ã€å‚æ•°ã€è¿”å›å€¼éƒ½åœ¨ä¸€èµ·ï¼Œå¯ä»¥å¿«é€Ÿçš„é˜…è¯»ï¼ŒåŒæ—¶æ¯ä¸ªæ³›å‹å‚æ•°çš„ç‰¹å¾ä¹Ÿåœ¨æ–°çš„ä»£ç è¡Œä¸­é€šè¿‡**ç‰¹å¾çº¦æŸ**è¿›è¡Œäº†çº¦æŸã€‚

**ä¹Ÿå¯ä»¥æœ‰æ¡ä»¶åœ°å®ç°ç‰¹å¾**ï¼Œä¾‹å¦‚ï¼Œæ ‡å‡†åº“ä¸ºä»»ä½•å®ç°äº† `Display` ç‰¹å¾çš„ç±»å‹å®ç°äº† `ToString` ç‰¹å¾ï¼š

```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

æˆ‘ä»¬å¯ä»¥å¯¹ä»»ä½•å®ç°äº† `Display` ç‰¹å¾çš„ç±»å‹è°ƒç”¨ç”± `ToString` å®šä¹‰çš„ `to_string` æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å°†æ•´å‹è½¬æ¢ä¸ºå¯¹åº”çš„ `String` å€¼ï¼Œå› ä¸ºæ•´å‹å®ç°äº† `Display`ï¼š

```rust
let s = 3.to_string();
```

## å‡½æ•°è¿”å›ä¸­çš„ `impl Trait`

å¯ä»¥é€šè¿‡ `impl Trait` æ¥è¯´æ˜ä¸€ä¸ªå‡½æ•°è¿”å›äº†ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å®ç°äº†æŸä¸ªç‰¹å¾ï¼š

```rust
fn returns_summarizable() -> impl Summary {
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 maxå¤ªå‰å®³äº†ï¼Œç”µè„‘å†ä¹Ÿä¸ä¼šå¡",
        )
    }
}
```

å› ä¸º `Weibo` å®ç°äº† `Summary`ï¼Œå› æ­¤è¿™é‡Œå¯ä»¥ç”¨å®ƒæ¥ä½œä¸ºè¿”å›å€¼ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶æˆ‘ä»¬çŸ¥é“è¿™é‡Œæ˜¯ä¸€ä¸ª `Weibo` ç±»å‹ï¼Œä½†æ˜¯å¯¹äº `returns_summarizable` çš„è°ƒç”¨è€…è€Œè¨€ï¼Œä»–åªçŸ¥é“è¿”å›äº†ä¸€ä¸ªå®ç°äº† `Summary` ç‰¹å¾çš„å¯¹è±¡ï¼Œä½†æ˜¯å¹¶ä¸çŸ¥é“è¿”å›äº†ä¸€ä¸ª `Weibo` ç±»å‹ã€‚

è¿™ç§ `impl Trait` å½¢å¼çš„è¿”å›å€¼ï¼Œåœ¨ä¸€ç§åœºæ™¯ä¸‹éå¸¸éå¸¸æœ‰ç”¨ï¼Œé‚£å°±æ˜¯è¿”å›çš„çœŸå®ç±»å‹éå¸¸å¤æ‚ï¼Œä½ ä¸çŸ¥é“è¯¥æ€ä¹ˆå£°æ˜æ—¶ï¼ˆæ¯•ç«Ÿ Rust è¦æ±‚ä½ å¿…é¡»æ ‡å‡ºæ‰€æœ‰çš„ç±»å‹ï¼‰ï¼Œæ­¤æ—¶å°±å¯ä»¥ç”¨ `impl Trait` çš„æ–¹å¼ç®€å•è¿”å›ã€‚ä¾‹å¦‚ï¼Œé—­åŒ…å’Œè¿­ä»£å™¨å°±æ˜¯å¾ˆå¤æ‚ï¼Œåªæœ‰ç¼–è¯‘å™¨æ‰çŸ¥é“é‚£ç©æ„çš„çœŸå®ç±»å‹ï¼Œå¦‚æœè®©ä½ å†™å‡ºæ¥å®ƒä»¬çš„å…·ä½“ç±»å‹ï¼Œä¼°è®¡å†…å¿ƒæœ‰ä¸€ä¸‡åªè‰æ³¥é©¬å¥”è…¾ï¼Œå¥½åœ¨ä½ å¯ä»¥ç”¨ `impl Iterator` æ¥å‘Šè¯‰è°ƒç”¨è€…ï¼Œè¿”å›äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå› ä¸ºæ‰€æœ‰è¿­ä»£å™¨éƒ½ä¼šå®ç° `Iterator` ç‰¹å¾ã€‚

ä½†æ˜¯è¿™ç§è¿”å›å€¼æ–¹å¼æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šåªèƒ½æœ‰ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œä¾‹å¦‚ï¼š

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
            title: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Weibo {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
        }
    }
}
```

ä»¥ä¸Šçš„ä»£ç å°±æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºå®ƒè¿”å›äº†ä¸¤ä¸ªä¸åŒçš„ç±»å‹ `Post` å’Œ `Weibo`ã€‚

```console
`if` and `else` have incompatible types
expected struct `Post`, found struct `Weibo`
```

æŠ¥é”™æç¤ºæˆ‘ä»¬ `if` å’Œ `else` è¿”å›äº†ä¸åŒçš„ç±»å‹ã€‚å¦‚æœæƒ³è¦å®ç°è¿”å›ä¸åŒçš„ç±»å‹ï¼Œéœ€è¦ä½¿ç”¨ä¸‹ä¸€ç« èŠ‚ä¸­çš„[ç‰¹å¾å¯¹è±¡](https://course.rs/basic/trait/trait-object.html)ã€‚

## ä¿®å¤ä¸Šä¸€èŠ‚ä¸­çš„ `largest` å‡½æ•°

è¿˜è®°å¾—ä¸Šä¸€èŠ‚ä¸­çš„[ä¾‹å­](https://course.rs/basic/trait/generic.html#æ³›å‹è¯¦è§£)å§ï¼Œå½“æ—¶ç•™ä¸‹ä¸€ä¸ªç–‘é—®ï¼Œè¯¥å¦‚ä½•è§£å†³ç¼–è¯‘æŠ¥é”™ï¼š

```rust
error[E0369]: binary operation `>` cannot be applied to type `T` // æ— æ³•åœ¨ `T` ç±»å‹ä¸Šåº”ç”¨`>`è¿ç®—ç¬¦
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T` // è€ƒè™‘ä½¿ç”¨ä»¥ä¸‹çš„ç‰¹å¾æ¥çº¦æŸ `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^
```

åœ¨ `largest` å‡½æ•°ä½“ä¸­æˆ‘ä»¬æƒ³è¦ä½¿ç”¨å¤§äºè¿ç®—ç¬¦ï¼ˆ`>`ï¼‰æ¯”è¾ƒä¸¤ä¸ª `T` ç±»å‹çš„å€¼ã€‚è¿™ä¸ªè¿ç®—ç¬¦æ˜¯æ ‡å‡†åº“ä¸­ç‰¹å¾ `std::cmp::PartialOrd` çš„ä¸€ä¸ªé»˜è®¤æ–¹æ³•ã€‚æ‰€ä»¥éœ€è¦åœ¨ `T` çš„ç‰¹å¾çº¦æŸä¸­æŒ‡å®š `PartialOrd`ï¼Œè¿™æ · `largest` å‡½æ•°å¯ä»¥ç”¨äºå†…éƒ¨å…ƒç´ ç±»å‹å¯æ¯”è¾ƒå¤§å°çš„æ•°ç»„åˆ‡ç‰‡ã€‚

ç”±äº `PartialOrd` ä½äº `prelude` ä¸­æ‰€ä»¥å¹¶ä¸éœ€è¦é€šè¿‡ `std::cmp` æ‰‹åŠ¨å°†å…¶å¼•å…¥ä½œç”¨åŸŸã€‚æ‰€ä»¥å¯ä»¥å°† `largest` çš„ç­¾åä¿®æ”¹ä¸ºå¦‚ä¸‹ï¼š

```rust
fn largest<T: PartialOrd>(list: &[T]) -> T {}
```

ä½†æ˜¯æ­¤æ—¶ç¼–è¯‘ï¼Œåˆä¼šå‡ºç°æ–°çš„é”™è¯¯ï¼š

```rust
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&list[0]`

error[E0507]: cannot move out of borrowed content
 --> src/main.rs:4:9
  |
4 |     for &item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
```

é”™è¯¯çš„æ ¸å¿ƒæ˜¯ `cannot move out of type [T], a non-copy slice`ï¼ŒåŸå› æ˜¯ `T` æ²¡æœ‰[å®ç° `Copy` ç‰¹æ€§](https://course.rs/basic/ownership/ownership.html#æ‹·è´æµ…æ‹·è´)ï¼Œå› æ­¤æˆ‘ä»¬åªèƒ½æŠŠæ‰€æœ‰æƒè¿›è¡Œè½¬ç§»ï¼Œæ¯•ç«Ÿåªæœ‰ `i32` ç­‰åŸºç¡€ç±»å‹æ‰å®ç°äº† `Copy` ç‰¹æ€§ï¼Œå¯ä»¥å­˜å‚¨åœ¨æ ˆä¸Šï¼Œè€Œ `T` å¯ä»¥æŒ‡ä»£ä»»ä½•ç±»å‹ï¼ˆä¸¥æ ¼æ¥è¯´æ˜¯å®ç°äº† `PartialOrd` ç‰¹å¾çš„æ‰€æœ‰ç±»å‹ï¼‰ã€‚

å› æ­¤ï¼Œä¸ºäº†è®© `T` æ‹¥æœ‰ `Copy` ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å¢åŠ ç‰¹å¾çº¦æŸï¼š

```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

å¦‚æœå¹¶ä¸å¸Œæœ›é™åˆ¶ `largest` å‡½æ•°åªèƒ½ç”¨äºå®ç°äº† `Copy` ç‰¹å¾çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ `T` çš„ç‰¹å¾çº¦æŸä¸­æŒ‡å®š [`Clone` ç‰¹å¾](https://course.rs/basic/ownership/ownership.html#å…‹éš†æ·±æ‹·è´) è€Œä¸æ˜¯ `Copy` ç‰¹å¾ã€‚å¹¶å…‹éš† `list` ä¸­çš„æ¯ä¸€ä¸ªå€¼ä½¿å¾— `largest` å‡½æ•°æ‹¥æœ‰å…¶æ‰€æœ‰æƒã€‚ä½¿ç”¨ `clone` å‡½æ•°æ„å‘³ç€å¯¹äºç±»ä¼¼ `String` è¿™æ ·æ‹¥æœ‰å †ä¸Šæ•°æ®çš„ç±»å‹ï¼Œä¼šæ½œåœ¨åœ°åˆ†é…æ›´å¤šå †ä¸Šç©ºé—´ï¼Œè€Œå †åˆ†é…åœ¨æ¶‰åŠå¤§é‡æ•°æ®æ—¶å¯èƒ½ä¼šç›¸å½“ç¼“æ…¢ã€‚

å¦ä¸€ç§ `largest` çš„å®ç°æ–¹å¼æ˜¯è¿”å›åœ¨ `list` ä¸­ `T` å€¼çš„å¼•ç”¨ã€‚å¦‚æœæˆ‘ä»¬å°†å‡½æ•°è¿”å›å€¼ä» `T` æ”¹ä¸º `&T` å¹¶æ”¹å˜å‡½æ•°ä½“ä½¿å…¶èƒ½å¤Ÿè¿”å›ä¸€ä¸ªå¼•ç”¨ï¼Œæˆ‘ä»¬å°†ä¸éœ€è¦ä»»ä½• `Clone` æˆ– `Copy` çš„ç‰¹å¾çº¦æŸè€Œä¸”ä¹Ÿä¸ä¼šæœ‰ä»»ä½•çš„å †åˆ†é…ã€‚å°è¯•è‡ªå·±å®ç°è¿™ç§æ›¿ä»£è§£å†³æ–¹å¼å§ï¼

## é€šè¿‡ `derive` æ´¾ç”Ÿç‰¹å¾

åœ¨æœ¬ä¹¦ä¸­ï¼Œå½¢å¦‚ `#[derive(Debug)]` çš„ä»£ç å·²ç»å‡ºç°äº†å¾ˆå¤šæ¬¡ï¼Œè¿™ç§æ˜¯ä¸€ç§ç‰¹å¾æ´¾ç”Ÿè¯­æ³•ï¼Œè¢« `derive` æ ‡è®°çš„å¯¹è±¡ä¼šè‡ªåŠ¨å®ç°å¯¹åº”çš„é»˜è®¤ç‰¹å¾ä»£ç ï¼Œç»§æ‰¿ç›¸åº”çš„åŠŸèƒ½ã€‚

ä¾‹å¦‚ `Debug` ç‰¹å¾ï¼Œå®ƒæœ‰ä¸€å¥—è‡ªåŠ¨å®ç°çš„é»˜è®¤ä»£ç ï¼Œå½“ä½ ç»™ä¸€ä¸ªç»“æ„ä½“æ ‡è®°åï¼Œå°±å¯ä»¥ä½¿ç”¨ `println!("{:?}", s)` çš„å½¢å¼æ‰“å°è¯¥ç»“æ„ä½“çš„å¯¹è±¡ã€‚

å†å¦‚ `Copy` ç‰¹å¾ï¼Œå®ƒä¹Ÿæœ‰ä¸€å¥—è‡ªåŠ¨å®ç°çš„é»˜è®¤ä»£ç ï¼Œå½“æ ‡è®°åˆ°ä¸€ä¸ªç±»å‹ä¸Šæ—¶ï¼Œå¯ä»¥è®©è¿™ä¸ªç±»å‹è‡ªåŠ¨å®ç° `Copy` ç‰¹å¾ï¼Œè¿›è€Œå¯ä»¥è°ƒç”¨ `copy` æ–¹æ³•ï¼Œè¿›è¡Œè‡ªæˆ‘å¤åˆ¶ã€‚

æ€»ä¹‹ï¼Œ`derive` æ´¾ç”Ÿå‡ºæ¥çš„æ˜¯ Rust é»˜è®¤ç»™æˆ‘ä»¬æä¾›çš„ç‰¹å¾ï¼Œåœ¨å¼€å‘è¿‡ç¨‹ä¸­æå¤§çš„ç®€åŒ–äº†è‡ªå·±æ‰‹åŠ¨å®ç°ç›¸åº”ç‰¹å¾çš„éœ€æ±‚ï¼Œå½“ç„¶ï¼Œå¦‚æœä½ æœ‰ç‰¹æ®Šçš„éœ€æ±‚ï¼Œè¿˜å¯ä»¥è‡ªå·±æ‰‹åŠ¨é‡å†™è¯¥å®ç°ã€‚

è¯¦ç»†çš„ `derive` åˆ—è¡¨å‚è§[é™„å½•-æ´¾ç”Ÿç‰¹å¾](https://course.rs/appendix/derive.html)ã€‚

## è°ƒç”¨æ–¹æ³•éœ€è¦å¼•å…¥ç‰¹å¾

åœ¨ä¸€äº›åœºæ™¯ä¸­ï¼Œä½¿ç”¨ `as` å…³é”®å­—åšç±»å‹è½¬æ¢ä¼šæœ‰æ¯”è¾ƒå¤§çš„é™åˆ¶ï¼Œå› ä¸ºä½ æƒ³è¦åœ¨ç±»å‹è½¬æ¢ä¸Šæ‹¥æœ‰å®Œå…¨çš„æ§åˆ¶ï¼Œä¾‹å¦‚å¤„ç†è½¬æ¢é”™è¯¯ï¼Œé‚£ä¹ˆä½ å°†éœ€è¦ `TryInto`ï¼š

```rust
use std::convert::TryInto;

fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into()
            .unwrap();

  if a < b_ {
    println!("Ten is less than one hundred.");
  }
}
```

ä¸Šé¢ä»£ç ä¸­å¼•å…¥äº† `std::convert::TryInto` ç‰¹å¾ï¼Œä½†æ˜¯å´æ²¡æœ‰ä½¿ç”¨å®ƒï¼Œå¯èƒ½æœ‰äº›åŒå­¦ä¼šä¸ºæ­¤å›°æƒ‘ï¼Œä¸»è¦åŸå› åœ¨äº**å¦‚æœä½ è¦ä½¿ç”¨ä¸€ä¸ªç‰¹å¾çš„æ–¹æ³•ï¼Œé‚£ä¹ˆä½ éœ€è¦å°†è¯¥ç‰¹å¾å¼•å…¥å½“å‰çš„ä½œç”¨åŸŸä¸­**ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢ç”¨åˆ°äº† `try_into` æ–¹æ³•ï¼Œå› æ­¤éœ€è¦å¼•å…¥å¯¹åº”çš„ç‰¹å¾ã€‚

ä½†æ˜¯ Rust åˆæä¾›äº†ä¸€ä¸ªéå¸¸ä¾¿åˆ©çš„åŠæ³•ï¼Œå³æŠŠæœ€å¸¸ç”¨çš„æ ‡å‡†åº“ä¸­çš„ç‰¹å¾é€šè¿‡ [`std::prelude`](https://course.rs/appendix/prelude.html) æ¨¡å—æå‰å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œå…¶ä¸­åŒ…æ‹¬äº† `std::convert::TryInto`ï¼Œä½ å¯ä»¥å°è¯•åˆ é™¤ç¬¬ä¸€è¡Œçš„ä»£ç  `use ...`ï¼Œçœ‹çœ‹æ˜¯å¦ä¼šæŠ¥é”™ã€‚

## å‡ ä¸ªç»¼åˆä¾‹å­

#### ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `+` æ“ä½œ

åœ¨ Rust ä¸­é™¤äº†æ•°å€¼ç±»å‹çš„åŠ æ³•ï¼Œ`String` ä¹Ÿå¯ä»¥åš[åŠ æ³•](https://course.rs/basic/compound-type/string-slice.html#æ“ä½œå­—ç¬¦ä¸²)ï¼Œå› ä¸º Rust ä¸ºè¯¥ç±»å‹å®ç°äº† `std::ops::Add` ç‰¹å¾ï¼ŒåŒç†ï¼Œå¦‚æœæˆ‘ä»¬ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°äº†è¯¥ç‰¹å¾ï¼Œé‚£å°±å¯ä»¥è‡ªå·±å®ç° `Point1 + Point2` çš„æ“ä½œ:

```rust
use std::ops::Add;

// ä¸ºPointç»“æ„ä½“æ´¾ç”ŸDebugç‰¹å¾ï¼Œç”¨äºæ ¼å¼åŒ–è¾“å‡º
#[derive(Debug)]
struct Point<T: Add<T, Output = T>> { //é™åˆ¶ç±»å‹Tå¿…é¡»å®ç°äº†Addç‰¹å¾ï¼Œå¦åˆ™æ— æ³•è¿›è¡Œ+æ“ä½œã€‚
    x: T,
    y: T,
}

impl<T: Add<T, Output = T>> Add for Point<T> {
    type Output = Point<T>;

    fn add(self, p: Point<T>) -> Point<T> {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add<T: Add<T, Output=T>>(a:T, b:T) -> T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!("{:?}", add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!("{:?}", add(p3, p4));
}
```

#### è‡ªå®šä¹‰ç±»å‹çš„æ‰“å°è¾“å‡º

åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå¾€å¾€åªè¦ä½¿ç”¨ `#[derive(Debug)]` å¯¹æˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹è¿›è¡Œæ ‡æ³¨ï¼Œå³å¯å®ç°æ‰“å°è¾“å‡ºçš„åŠŸèƒ½ï¼š

```rust
#[derive(Debug)]
struct Point{
    x: i32,
    y: i32
}
fn main() {
    let p = Point{x:3,y:3};
    println!("{:?}",p);
}
```

ä½†æ˜¯åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå¾€å¾€éœ€è¦å¯¹æˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹è¿›è¡Œè‡ªå®šä¹‰çš„æ ¼å¼åŒ–è¾“å‡ºï¼Œä»¥è®©ç”¨æˆ·æ›´å¥½çš„é˜…è¯»ç†è§£æˆ‘ä»¬çš„ç±»å‹ï¼Œæ­¤æ—¶å°±è¦ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `std::fmt::Display` ç‰¹å¾ï¼š

```rust
#![allow(dead_code)]

use std::fmt;
use std::fmt::{Display};

#[derive(Debug,PartialEq)]
enum FileState {
  Open,
  Closed,
}

#[derive(Debug)]
struct File {
  name: String,
  data: Vec<u8>,
  state: FileState,
}

impl Display for FileState {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
     match *self {
         FileState::Open => write!(f, "OPEN"),
         FileState::Closed => write!(f, "CLOSED"),
     }
   }
}

impl Display for File {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
      write!(f, "<{} ({})>",
             self.name, self.state)
   }
}

impl File {
  fn new(name: &str) -> File {
    File {
        name: String::from(name),
        data: Vec::new(),
        state: FileState::Closed,
    }
  }
}

fn main() {
  let f6 = File::new("f6.txt");
  //...
  println!("{:?}", f6);
  println!("{}", f6);
}
```

ä»¥ä¸Šä¸¤ä¸ªä¾‹å­è¾ƒä¸ºå¤æ‚ï¼Œç›®çš„æ˜¯ä¸ºè¯»è€…å±•ç¤ºä¸‹çœŸå®çš„ä½¿ç”¨åœºæ™¯é•¿ä»€ä¹ˆæ ·ï¼Œå› æ­¤éœ€è¦è¯»è€…ç»†ç»†é˜…è¯»ï¼Œæœ€ç»ˆæ¶ˆåŒ–è¿™äº›çŸ¥è¯†å¯¹äºä½ çš„ Rust ä¹‹è·¯ä¼šæœ‰è«å¤§çš„å¸®åŠ©ã€‚

æœ€åï¼Œç‰¹å¾å’Œç‰¹å¾çº¦æŸï¼Œæ˜¯ Rust ä¸­æå…¶é‡è¦çš„æ¦‚å¿µï¼Œå¦‚æœä½ è¿˜æ˜¯æ²¡ææ‡‚ï¼Œå¼ºçƒˆå»ºè®®å›å¤´å†çœ‹ä¸€éï¼Œæˆ–è€…å¯»æ‰¾ç›¸å…³çš„èµ„æ–™è¿›è¡Œè¡¥å……å­¦ä¹ ã€‚å¦‚æœå·²ç»è§‰å¾—æŒæ¡äº†ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›å…¥ä¸‹ä¸€èŠ‚çš„å­¦ä¹ ã€‚


## è¯¾åç»ƒä¹ 

> [Rust By Practice](https://practice-zh.course.rs/generics-traits/traits.html)ï¼Œæ”¯æŒä»£ç åœ¨çº¿ç¼–è¾‘å’Œè¿è¡Œï¼Œå¹¶æä¾›è¯¦ç»†çš„[ä¹ é¢˜è§£ç­”](https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/traits.md)ã€‚



================================================
FILE: src/basic-practice/base-features.md
================================================
# å®ç°åŸºæœ¬åŠŸèƒ½

æ— è®ºåŠŸèƒ½è®¾è®¡çš„å†æ€ä¹ˆèŠ±é‡Œèƒ¡å“¨ï¼Œå¯¹äºä¸€ä¸ªæ–‡ä»¶æŸ¥æ‰¾å‘½ä»¤è€Œè¨€ï¼Œé¦–å…ˆå¾—æŒ‡å®šæ–‡ä»¶å’Œå¾…æŸ¥æ‰¾çš„å­—ç¬¦ä¸²ï¼Œå®ƒä»¬éœ€è¦ç”¨æˆ·ä»å‘½ä»¤è¡Œç»™äºˆè¾“å…¥ï¼Œç„¶åæˆ‘ä»¬åœ¨ç¨‹åºå†…è¿›è¡Œè¯»å–ã€‚

## æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°

å›½é™…æƒ¯ä¾‹ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›® `minigrep` ï¼Œè¯¥åå­—å……åˆ†ä½“ç°äº†æˆ‘ä»¬çš„è‡ªä¿¡ï¼šå°±æ˜¯ä¸å¦‚ `grep`ã€‚

```shell
cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

é¦–å…ˆæ¥æ€è€ƒä¸‹ï¼Œå¦‚æœè¦ä¼ å…¥æ–‡ä»¶è·¯å¾„å’Œå¾…æœç´¢çš„å­—ç¬¦ä¸²ï¼Œé‚£è¿™ä¸ªå‘½ä»¤è¯¥é•¿å•¥æ ·ï¼Œæˆ‘è§‰å¾—å¤§æ¦‚ç‡æ˜¯è¿™æ ·:

```shell
cargo run -- searchstring example-filename.txt
```

`--` å‘Šè¯‰ `cargo` åé¢çš„å‚æ•°æ˜¯ç»™æˆ‘ä»¬çš„ç¨‹åºä½¿ç”¨çš„ï¼Œè€Œä¸æ˜¯ç»™ `cargo` è‡ªå·±ä½¿ç”¨ï¼Œä¾‹å¦‚ `--` å‰çš„ `run` å°±æ˜¯ç»™å®ƒç”¨çš„ã€‚

æ¥ä¸‹æ¥å°±æ˜¯åœ¨ç¨‹åºä¸­è¯»å–ä¼ å…¥çš„å‚æ•°ï¼Œè¿™ä¸ªå¾ˆç®€å•ï¼Œä¸‹é¢ä»£ç å°±å¯ä»¥:
```rust
// in main.rs
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
}
```
é¦–å…ˆé€šè¿‡ `use` å¼•å…¥æ ‡å‡†åº“ä¸­çš„ `env` æ¨¡å—ï¼Œç„¶å `env::args` æ–¹æ³•ä¼šè¯»å–å¹¶åˆ†æä¼ å…¥çš„å‘½ä»¤è¡Œå‚æ•°ï¼Œæœ€ç»ˆé€šè¿‡ `collect` æ–¹æ³•è¾“å‡ºä¸€ä¸ªé›†åˆç±»å‹ `Vector`ã€‚

å¯èƒ½æœ‰åŒå­¦ç–‘æƒ‘ï¼Œä¸ºå•¥ä¸ç›´æ¥å¼•å…¥ `args` ï¼Œä¾‹å¦‚ `use std::env::args` ï¼Œè¿™æ ·å°±æ— éœ€ `env::args` æ¥ç¹çè°ƒç”¨ï¼Œç›´æ¥`args().collect()` å³å¯ã€‚åŸå› å¾ˆç®€å•ï¼Œ`args` æ–¹æ³•åªä¼šä½¿ç”¨ä¸€æ¬¡ï¼Œå•°å—¦å°±å•°å—¦ç‚¹å§ï¼ŒæŠŠç›¸åŒçš„å¥½åå­—è®©ç»™ `let args..` è¿™ä½å¤§å“¥ä¸å¥½å—ï¼Ÿæ¯•ç«Ÿäººå®¶è¦å‡ºåœºå¤šæ¬¡çš„ã€‚

> ### ä¸å¯ä¿¡çš„è¾“å…¥
> æ‰€æœ‰çš„ç”¨æˆ·è¾“å…¥éƒ½ä¸å¯ä¿¡ï¼ä¸å¯ä¿¡ï¼ä¸å¯ä¿¡ï¼
>
> é‡è¦çš„è¯è¯´ä¸‰éï¼Œæˆ‘ä»¬çš„å‘½ä»¤è¡Œç¨‹åºä¹Ÿæ˜¯ï¼Œç”¨æˆ·ä¼šè¾“å…¥ä»€ä¹ˆä½ æ ¹æœ¬å°±ä¸çŸ¥é“ï¼Œä¾‹å¦‚ä»–è¾“å…¥äº†ä¸€ä¸ªé Unicode å­—ç¬¦ï¼Œä½ èƒ½é˜»æ­¢å—ï¼Ÿæ˜¾ç„¶ä¸èƒ½ï¼Œä½†æ˜¯è¿™ç§è¾“å…¥ä¼šç›´æ¥è®©æˆ‘ä»¬çš„ç¨‹åºå´©æºƒï¼
>
> åŸå› æ˜¯å½“ä¼ å…¥çš„å‘½ä»¤è¡Œå‚æ•°åŒ…å«é Unicode å­—ç¬¦æ—¶ï¼Œ `std::env::args` ä¼šç›´æ¥å´©æºƒï¼Œå¦‚æœæœ‰è¿™ç§ç‰¹æ®Šéœ€æ±‚ï¼Œå»ºè®®å¤§å®¶ä½¿ç”¨ `std::env::args_os`ï¼Œè¯¥æ–¹æ³•äº§ç”Ÿçš„æ•°ç»„å°†åŒ…å« `OsString` ç±»å‹ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„ `String` ç±»å‹ï¼Œå‰è€…å¯¹äºé Unicode å­—ç¬¦ä¼šæœ‰æ›´å¥½çš„å¤„ç†ã€‚
>
> è‡³äºä¸ºå•¥æˆ‘ä»¬ä¸ç”¨ï¼Œä¸¤ä¸ªç†ç”±ï¼Œä½ ä¿¡å“ªä¸ªï¼š1. ç”¨æˆ·çˆ±è¾“å…¥å•¥è¾“å…¥å•¥ï¼Œåæ­£å´©æºƒäº†ï¼Œä»–å°±çŸ¥é“è‡ªå·±é”™äº† 2. `args_os` ä¼šå¼•å…¥é¢å¤–çš„è·¨å¹³å°å¤æ‚æ€§ 



`collect` æ–¹æ³•å…¶å®å¹¶ä¸æ˜¯`std::env`æ¨¡å—æä¾›çš„ï¼Œè€Œæ˜¯è¿­ä»£å™¨è‡ªå¸¦çš„æ–¹æ³•(`env::args()` ä¼šè¿”å›ä¸€ä¸ªè¿­ä»£å™¨)ï¼Œå®ƒä¼šå°†è¿­ä»£å™¨æ¶ˆè´¹åè½¬æ¢æˆæˆ‘ä»¬æƒ³è¦çš„é›†åˆç±»å‹ï¼Œå…³äºè¿­ä»£å™¨å’Œ `collect` çš„å…·ä½“ä»‹ç»ï¼Œè¯·å‚è€ƒ[è¿™é‡Œ](https://course.rs/advance/functional-programing/iterator.html)ã€‚

æœ€åï¼Œä»£ç ä¸­ä½¿ç”¨ `dbg!` å®æ¥è¾“å‡ºè¯»å–åˆ°çš„æ•°ç»„å†…å®¹ï¼Œæ¥çœ‹çœ‹é•¿å•¥æ ·ï¼š
```shell
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    "target/debug/minigrep",
]
```

```shell
$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
```

ä¸Šé¢ä¸¤ä¸ªç‰ˆæœ¬åˆ†åˆ«æ˜¯æ— å‚æ•°å’Œä¸¤ä¸ªå‚æ•°ï¼Œå…¶ä¸­æ— å‚æ•°ç‰ˆæœ¬å®é™…ä¸Šä¹Ÿä¼šè¯»å–åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»”ç»†çœ‹ï¼Œæ˜¯ä¸æ˜¯é•¿å¾—å¾ˆåƒæˆ‘ä»¬çš„ç¨‹åºåï¼ŒBingo! `env::args` è¯»å–åˆ°çš„å‚æ•°ä¸­ç¬¬ä¸€ä¸ªå°±æ˜¯ç¨‹åºçš„å¯æ‰§è¡Œè·¯å¾„åã€‚

## å­˜å‚¨è¯»å–åˆ°çš„å‚æ•°

åœ¨ç¼–ç¨‹ä¸­ï¼Œç»™äºˆæ¸…æ™°åˆç†çš„å˜é‡åæ˜¯ä¸€é¡¹åŸºæœ¬åŠŸï¼Œå’±æ€»ä¸èƒ½åˆ°å¤„éƒ½æ˜¯ `args[1]` ã€`args[2]` è¿™æ ·çš„ç³Ÿç³•ä»£ç å§ã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªå˜é‡æ¥å­˜å‚¨æ–‡ä»¶è·¯å¾„å’Œå¾…æœç´¢çš„å­—ç¬¦ä¸²:
```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", file_path);
}
```

å¾ˆç®€å•çš„ä»£ç ï¼Œæ¥è¿è¡Œä¸‹:
```shell
$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```

è¾“å‡ºç»“æœå¾ˆæ¸…æ™°çš„è¯´æ˜äº†æˆ‘ä»¬çš„ç›®æ ‡ï¼šåœ¨æ–‡ä»¶ `sample.txt` ä¸­æœç´¢åŒ…å« `test` å­—ç¬¦ä¸²çš„å†…å®¹ã€‚

äº‹å®ä¸Šï¼Œå°±ç®—ä½œä¸ºä¸€ä¸ªç®€å•çš„ç¨‹åºï¼Œå®ƒä¹Ÿå¤ªè¿‡äºç®€å•äº†ï¼Œä¾‹å¦‚ç”¨æˆ·ä¸æä¾›ä»»ä½•å‚æ•°æ€ä¹ˆåŠï¼Ÿå› æ­¤ï¼Œé”™è¯¯å¤„ç†æ˜¾ç„¶æ˜¯ä¸å¯å°‘çš„ï¼Œä½†æ˜¯åœ¨æ·»åŠ ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹å¦‚ä½•è¯»å–æ–‡ä»¶å†…å®¹ã€‚

## æ–‡ä»¶è¯»å–

æ—¢ç„¶è¯»å–æ–‡ä»¶ï¼Œé‚£ä¹ˆé¦–å…ˆæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¹¶ç»™äºˆä¸€äº›å†…å®¹ï¼Œæ¥é¦–è¯—æ­Œå¦‚ä½•ï¼Ÿ"æˆ‘å•¥ä¹Ÿä¸æ˜¯ï¼Œä½ å‘¢?"

```text
I'm nobody! Who are you?
æˆ‘å•¥ä¹Ÿä¸æ˜¯ï¼Œä½ å‘¢ï¼Ÿ
Are you nobody, too?
ç‰›é€¼å¦‚ä½ ä¹Ÿæ˜¯æ— åä¹‹è¾ˆå—ï¼Ÿ
Then there's a pair of us - don't tell!
é‚£æˆ‘ä»¬å°±æ˜¯å¤©ç”Ÿä¸€å¯¹ï¼Œå˜˜ï¼åˆ«è¯´è¯ï¼
They'd banish us, you know.
ä½ çŸ¥é“ï¼Œæˆ‘ä»¬ä¸å±äºè¿™é‡Œã€‚
How dreary to be somebody!
å› ä¸ºè¿™é‡Œå±äºæ²¡åŠ²çš„å¤§äººç‰©ï¼
How public, like a frog
ä»–ä»¬å°±åƒé’è›™ä¸€æ ·å‘±å™ªï¼Œ
To tell your name the livelong day
æˆå¤©å°†è‡ªå·±çš„å¤§å
To an admiring bog!
ä¼ éæ•´ä¸ªæ— èŠçš„æ²¼æ³½ï¼
```

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `poem.txt` æ–‡ä»¶ï¼Œå¹¶å†™å…¥å¦‚ä¸Šçš„ä¼˜ç¾è¯—æ­Œ(å¯èƒ½ç¿»è¯‘çš„å¾ˆçƒ‚ï¼Œåˆ«æ‰“æˆ‘ï¼Œå“ˆå“ˆï¼Œäº‹å®ä¸Šå¤§å®¶å†™å…¥è‹±æ–‡å†…å®¹å°±å¤Ÿäº†)ã€‚

æ¥ä¸‹æ¥ä¿®æ”¹ `main.rs` æ¥è¯»å–æ–‡ä»¶å†…å®¹ï¼š
```rust
use std::env;
use std::fs;

fn main() {
    // --çœç•¥ä¹‹å‰çš„å†…å®¹--
    println!("In file {}", file_path);

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}
```

é¦–å…ˆï¼Œé€šè¿‡ `use std::fs` å¼•å…¥æ–‡ä»¶æ“ä½œæ¨¡å—ï¼Œç„¶åé€šè¿‡ `fs::read_to_string` è¯»å–æŒ‡å®šçš„æ–‡ä»¶å†…å®¹ï¼Œæœ€åè¿”å›çš„ `contents` æ˜¯ `std::io::Result<String>` ç±»å‹ã€‚

è¿è¡Œä¸‹è¯•è¯•ï¼Œè¿™é‡Œæ— éœ€è¾“å…¥ç¬¬äºŒä¸ªå‚æ•°ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰å®ç°æŸ¥è¯¢åŠŸèƒ½:
```shell
$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```

å®Œç¾ï¼Œè™½ç„¶ä»£ç è¿˜æœ‰å¾ˆå¤šç‘•ç–µï¼Œä¾‹å¦‚æ‰€æœ‰å†…å®¹éƒ½åœ¨ `main` å‡½æ•°ï¼Œè¿™ä¸ªä¸ç¬¦åˆè½¯ä»¶å·¥ç¨‹ï¼Œæ²¡æœ‰é”™è¯¯å¤„ç†ï¼ŒåŠŸèƒ½ä¸å®Œå–„ç­‰ã€‚ä¸è¿‡æ²¡å…³ç³»ï¼Œä¸‡äº‹å¼€å¤´éš¾ï¼Œå¥½æ­¹æˆ‘ä»¬æˆåŠŸè¿ˆå¼€äº†ç¬¬ä¸€æ­¥ã€‚

å¥½äº†ï¼Œæ˜¯æ—¶å€™é‡æ„èµšæ³¢ KPI äº†ï¼Œè¯»è€…ï¼šare you serious? è¿™å°±å¼€å§‹é‡æ„äº†ï¼Ÿ



================================================
FILE: src/basic-practice/envs.md
================================================
# ä½¿ç”¨ç¯å¢ƒå˜é‡æ¥å¢å¼ºç¨‹åº

åœ¨ä¸Šä¸€ç« èŠ‚ä¸­ï¼Œç•™ä¸‹äº†ä¸€ä¸ªæ‚¬å¿µï¼Œè¯¥å¦‚ä½•å®ç°ç”¨æˆ·æ§åˆ¶çš„å¤§å°å†™æ•æ„Ÿï¼Œå…¶å®ç­”æ¡ˆå¾ˆç®€å•ï¼Œä½ åœ¨å…¶å®ƒç¨‹åºä¸­è‚¯å®šä¹Ÿé‡åˆ°è¿‡ä¸å°‘ï¼Œä¾‹å¦‚å¦‚ä½•æ§åˆ¶ `panic` åçš„æ ˆå±•å¼€ï¼Ÿ Rust æä¾›çš„è§£å†³æ–¹æ¡ˆæ˜¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æ¥æ§åˆ¶: 

```shell
RUST_BACKTRACE=1 cargo run
```

ä¸ä¹‹ç±»ä¼¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ç¯å¢ƒå˜é‡æ¥æ§åˆ¶å¤§å°å†™æ•æ„Ÿï¼Œä¾‹å¦‚: 

```shell
IGNORE_CASE=1 cargo run -- to poem.txt
```

æ—¢ç„¶æœ‰äº†ç›®æ ‡ï¼Œé‚£ä¹ˆä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•å®ç°å§ã€‚


## ç¼–å†™å¤§å°å†™ä¸æ•æ„Ÿçš„æµ‹è¯•ç”¨ä¾‹

è¿˜æ˜¯éµå¾ªä¹‹å‰çš„è§„åˆ™ï¼šæµ‹è¯•é©±åŠ¨ï¼Œè¿™æ¬¡æ˜¯å¯¹ä¸€ä¸ªæ–°çš„å¤§å°å†™ä¸æ•æ„Ÿå‡½æ•°è¿›è¡Œæµ‹è¯• `search_case_insensitive`ã€‚

è¿˜è®°å¾— TDD çš„æµ‹è¯•æ­¥éª¤å˜›ï¼Ÿé¦–å…ˆç¼–å†™ä¸€ä¸ªæ³¨å®šå¤±è´¥çš„ç”¨ä¾‹:

```rust
// in src/lib.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œæ–°å¢äº†ä¸€ä¸ª `case_insensitive` æµ‹è¯•ç”¨ä¾‹ï¼Œå¹¶å¯¹ `search_case_insensitive` è¿›è¡Œäº†æµ‹è¯•ï¼Œç»“æœæ˜¾è€Œæ˜“è§ï¼Œå‡½æ•°éƒ½æ²¡æœ‰å®ç°ï¼Œè‡ªç„¶ä¼šå¤±è´¥ã€‚

æ¥ç€æ¥å®ç°è¿™ä¸ªå¤§å°å†™ä¸æ•æ„Ÿçš„æœç´¢å‡½æ•°:

```rust
pub fn search_case_insensitive<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
```

è·Ÿä¹‹å‰ä¸€æ ·ï¼Œä½†æ˜¯å¼•å…¥äº†ä¸€ä¸ªæ–°çš„æ–¹æ³• `to_lowercase`ï¼Œå®ƒä¼šå°† `line` è½¬æ¢æˆå…¨å°å†™çš„å­—ç¬¦ä¸²ï¼Œç±»ä¼¼çš„æ–¹æ³•åœ¨å…¶å®ƒè¯­è¨€ä¸­ä¹Ÿå·®ä¸å¤šï¼Œå°±ä¸å†èµ˜è¿°ã€‚

è¿˜è¦æ³¨æ„çš„æ˜¯ `query` ç°åœ¨æ˜¯ `String` ç±»å‹ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„ `&str`ï¼Œå› ä¸º `to_lowercase` è¿”å›çš„æ˜¯ `String`ã€‚

ä¿®æ”¹åï¼Œå†æ¥è·‘ä¸€æ¬¡æµ‹è¯•ï¼Œçœ‹èƒ½å¦é€šè¿‡ã€‚

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

Okï¼ŒTDDçš„ç¬¬äºŒæ­¥ä¹Ÿå®Œæˆäº†ï¼Œæµ‹è¯•é€šè¿‡ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æœ€åä¸€æ­¥ï¼Œåœ¨ `run` ä¸­è°ƒç”¨æ–°çš„æœç´¢å‡½æ•°ã€‚ä½†æ˜¯åœ¨æ­¤ä¹‹å‰ï¼Œè¦æ–°å¢ä¸€ä¸ªé…ç½®é¡¹ï¼Œç”¨äºæ§åˆ¶æ˜¯å¦å¼€å¯å¤§å°å†™æ•æ„Ÿã€‚

```rust
// in lib.rs
pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
```

æ¥ä¸‹æ¥å°±æ˜¯æ£€æŸ¥è¯¥å­—æ®µï¼Œæ¥åˆ¤æ–­æ˜¯å¦å¯åŠ¨å¤§å°å†™æ•æ„Ÿï¼š

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&config.query, &contents)
    } else {
        search(&config.query, &contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
```

ç°åœ¨çš„é—®é¢˜æ¥äº†ï¼Œè¯¥å¦‚ä½•æ§åˆ¶è¿™ä¸ªé…ç½®é¡¹å‘¢ã€‚è¿™ä¸ªå°±è¦å€ŸåŠ©äºç« èŠ‚å¼€å¤´æåˆ°çš„ç¯å¢ƒå˜é‡ï¼Œå¥½åœ¨ Rust çš„ `env` åŒ…æä¾›äº†ç›¸åº”çš„æ–¹æ³•ã€‚

```rust
use std::env;
// --snip--

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

`env::var` æ²¡å•¥å¥½è¯´çš„ï¼Œå€’æ˜¯ `is_ok` å€¼å¾—è¯´é“ä¸‹ã€‚è¯¥æ–¹æ³•æ˜¯ `Result` æä¾›çš„ï¼Œç”¨äºæ£€æŸ¥æ˜¯å¦æœ‰å€¼ï¼Œæœ‰å°±è¿”å› `true`ï¼Œæ²¡æœ‰åˆ™è¿”å› `false`ï¼Œåˆšå¥½å®Œç¾ç¬¦åˆæˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯ï¼Œå› ä¸ºæˆ‘ä»¬å¹¶ä¸å…³å¿ƒ `Ok<T>` ä¸­å…·ä½“çš„å€¼ã€‚

è¿è¡Œä¸‹è¯•è¯•ï¼š
```shell
$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
```

çœ‹èµ·æ¥æ²¡æœ‰é—®é¢˜ï¼Œæ¥ä¸‹æ¥æµ‹è¯•ä¸‹å¤§å°å†™ä¸æ•æ„Ÿ: 

```shell
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

```shell
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

å¤§å°å†™ä¸æ•æ„Ÿåï¼ŒæŸ¥è¯¢åˆ°çš„å†…å®¹æ˜æ˜¾å¤šäº†å¾ˆå¤šï¼Œä¹Ÿå¾ˆç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸã€‚

æœ€åï¼Œç»™å¤§å®¶ç•™ä¸€ä¸ªå°ä½œä¸šï¼šåŒæ—¶ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°å’Œç¯å¢ƒå˜é‡çš„æ–¹å¼æ¥æ§åˆ¶å¤§å°å†™ä¸æ•æ„Ÿï¼Œå…¶ä¸­ç¯å¢ƒå˜é‡çš„ä¼˜å…ˆçº§æ›´é«˜ï¼Œä¹Ÿå°±æ˜¯ä¸¤ä¸ªéƒ½è®¾ç½®çš„æƒ…å†µä¸‹ï¼Œä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡çš„è®¾ç½®ã€‚






================================================
FILE: src/basic-practice/intro.md
================================================
# æ„å»ºä¸€ä¸ªç®€å•å‘½ä»¤è¡Œç¨‹åº

åœ¨å‰å¾€æ›´é«˜çš„å±±å³°å‰ï¼Œæˆ‘ä»¬åº”è¯¥é©»è¶³æ¬£èµä¸‹èº«åçš„é£æ™¯ï¼Œè™½ç„¶æ˜¯åŠè§ˆä¼—å±±ä¸å’‹å°ï¼Œä½†æ€»æ¯”èº«åœ¨æ­¤å±±ä¸­æ— æ³•çª¥å…¨è²Œè¦å¼ºä¸€ä¸¢ä¸¢ã€‚

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¸€èµ·æ„å»ºä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åºï¼Œç›®æ ‡æ˜¯å°½å¯èƒ½å¸®å¤§å®¶èä¼šè´¯é€šä¹‹å‰çš„å­¦åˆ°çš„çŸ¥è¯†ã€‚

linux ç³»ç»Ÿä¸­çš„ `grep` å‘½ä»¤å¾ˆå¼ºå¤§ï¼Œå¯ä»¥å®Œæˆå„ç§æ–‡ä»¶æœç´¢ä»»åŠ¡ï¼Œæˆ‘ä»¬è‚¯å®šåšä¸äº†é‚£ä¹ˆå¼ºå¤§ï¼Œä½†æ˜¯å‡å†’ä¸€ä¸ªä¼ªåŠ£çš„ç‰ˆæœ¬è¿˜æ˜¯å¯ä»¥çš„ï¼Œå®ƒå°†ä»å‘½ä»¤è¡Œå‚æ•°ä¸­è¯»å–æŒ‡å®šçš„æ–‡ä»¶åå’Œå­—ç¬¦ä¸²ï¼Œç„¶ååœ¨ç›¸åº”çš„æ–‡ä»¶ä¸­æ‰¾åˆ°åŒ…å«è¯¥å­—ç¬¦ä¸²çš„å†…å®¹ï¼Œæœ€ç»ˆæ‰“å°å‡ºæ¥ã€‚

> è¿™é‡Œæ¨èä¸€ä½å¤§ç¥å†™çš„çŸ¥å Rust é¡¹ç›® [ripgrep](https://github.com/BurntSushi/ripgrep) ï¼Œç»å¯¹æ˜¯ `grep` çœŸæ­£çš„é«˜æ›¿å“ï¼Œå€¼å¾—å­¦ä¹ å’Œä½¿ç”¨


================================================
FILE: src/basic-practice/iterators.md
================================================
[Binary file]


================================================
FILE: src/basic-practice/refactoring.md
================================================
[Binary file]


================================================
FILE: src/basic-practice/stderr.md
================================================
# é‡å®šå‘é”™è¯¯ä¿¡æ¯çš„è¾“å‡º

è¿„ä»Šä¸ºæ­¢ï¼Œæ‰€æœ‰çš„è¾“å‡ºä¿¡æ¯ï¼Œæ— è®º debug è¿˜æ˜¯ error ç±»å‹ï¼Œéƒ½æ˜¯é€šè¿‡ `println!` å®è¾“å‡ºåˆ°ç»ˆç«¯çš„æ ‡å‡†è¾“å‡º( `stdout` )ï¼Œä½†æ˜¯å¯¹äºç¨‹åºæ¥è¯´ï¼Œé”™è¯¯ä¿¡æ¯æ›´é€‚åˆè¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡º(stderr)ã€‚

è¿™æ ·ä¿®æ”¹åï¼Œç”¨æˆ·å°±å¯ä»¥é€‰æ‹©å°†æ™®é€šçš„æ—¥å¿—ç±»ä¿¡æ¯è¾“å‡ºåˆ°æ—¥å¿—æ–‡ä»¶ 1ï¼Œç„¶åå°†é”™è¯¯ä¿¡æ¯è¾“å‡ºåˆ°æ—¥å¿—æ–‡ä»¶ 2ï¼Œç”šè‡³è¿˜å¯ä»¥è¾“å‡ºåˆ°ç»ˆç«¯å‘½ä»¤è¡Œã€‚

## ç›®å‰çš„é”™è¯¯è¾“å‡ºä½ç½®

æˆ‘ä»¬å…ˆæ¥è§‚å¯Ÿä¸‹ï¼Œç›®å‰çš„è¾“å‡ºä¿¡æ¯åŒ…æ‹¬é”™è¯¯ï¼Œæ˜¯å¦æ˜¯å¦‚ä¸Šé¢æ‰€è¯´ï¼Œéƒ½å†™åˆ°æ ‡å‡†é”™è¯¯è¾“å‡ºã€‚

æµ‹è¯•æ–¹å¼å¾ˆç®€å•ï¼Œå°†æ ‡å‡†é”™è¯¯è¾“å‡ºçš„å†…å®¹é‡å®šå‘åˆ°æ–‡ä»¶ä¸­ï¼Œçœ‹çœ‹æ˜¯å¦åŒ…å«æ•…æ„ç”Ÿæˆçš„é”™è¯¯ä¿¡æ¯å³å¯ã€‚

```shell
$ cargo run > output.txt
```

é¦–å…ˆï¼Œè¿™é‡Œçš„è¿è¡Œæ²¡æœ‰å¸¦ä»»ä½•å‚æ•°ï¼Œå› æ­¤ä¼šæŠ¥å‡ºç±»å¦‚æ–‡ä»¶ä¸å­˜åœ¨çš„é”™è¯¯ï¼Œå…¶æ¬¡ï¼Œé€šè¿‡ `>` æ“ä½œç¬¦ï¼Œæ ‡å‡†è¾“å‡ºä¸Šçš„å†…å®¹è¢«é‡å®šå‘åˆ°æ–‡ä»¶ `output.txt` ä¸­ï¼Œä¸å†æ‰“å°åˆ°æ§åˆ¶ä¸Šã€‚

å¤§å®¶å…ˆè§‚å¯Ÿä¸‹æ§åˆ¶å°ï¼Œç„¶åå†çœ‹çœ‹ `output.txt`ï¼Œæ˜¯å¦å‘ç°å¦‚ä¸‹çš„é”™è¯¯ä¿¡æ¯å·²ç»å¦‚æœŸè¢«å†™å…¥åˆ°æ–‡ä»¶ä¸­ï¼Ÿ

```shell
Problem parsing arguments: not enough arguments
```

æ‰€ä»¥ï¼Œå¯ä»¥å¾—å‡ºä¸€ä¸ªç»“è®ºï¼Œå¦‚æœé”™è¯¯ä¿¡æ¯è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼Œé‚£ä¹ˆå®ƒä»¬å°†è·Ÿæ™®é€šçš„æ—¥å¿—ä¿¡æ¯æ··åœ¨ä¸€èµ·ï¼Œéš¾ä»¥åˆ†è¾¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°†é”™è¯¯ä¿¡æ¯è¿›è¡Œå•ç‹¬è¾“å‡ºã€‚


## æ ‡å‡†é”™è¯¯è¾“å‡º stderr

å°†é”™è¯¯ä¿¡æ¯é‡å®šå‘åˆ° `stderr` å¾ˆç®€å•ï¼Œåªéœ€åœ¨æ‰“å°é”™è¯¯çš„åœ°æ–¹ï¼Œå°† `println!` å®æ›¿æ¢ä¸º `eprintln!`å³å¯ã€‚

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

æ¥ä¸‹æ¥ï¼Œè¿˜æ˜¯åŒæ ·çš„è¿è¡Œå‘½ä»¤ï¼š
```shell
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

å¯ä»¥çœ‹åˆ°ï¼Œæ—¥å¿—ä¿¡æ¯æˆåŠŸçš„é‡å®šå‘åˆ° `output.txt` æ–‡ä»¶ä¸­ï¼Œè€Œé”™è¯¯ä¿¡æ¯ç”±äº `eprintln!` çš„ä½¿ç”¨ï¼Œè¢«å†™å…¥åˆ°æ ‡å‡†é”™è¯¯è¾“å‡ºä¸­ï¼Œé»˜è®¤è¿˜æ˜¯è¾“å‡ºåœ¨æ§åˆ¶å°ä¸­ã€‚

å†æ¥è¯•è¯•æ²¡æœ‰é”™è¯¯çš„æƒ…å†µ:

```shell
$ cargo run -- to poem.txt > output.txt
```

è¿™æ¬¡è¿è¡Œå‚æ•°å¾ˆæ­£ç¡®ï¼Œå› æ­¤ä¹Ÿæ²¡æœ‰ä»»ä½•é”™è¯¯ä¿¡æ¯äº§ç”Ÿï¼ŒåŒæ—¶ç”±äºæˆ‘ä»¬é‡å®šå‘äº†æ ‡å‡†è¾“å‡ºï¼Œå› æ­¤ç›¸åº”çš„è¾“å‡ºæ—¥å¿—ä¼šå†™å…¥åˆ° `output.txt` ä¸­ï¼Œæ‰“å¼€å¯ä»¥çœ‹åˆ°å¦‚ä¸‹å†…å®¹ï¼š

```shell
Are you nobody, too?
How dreary to be somebody!
```

è‡³æ­¤ï¼Œç®€æ˜“æœç´¢ç¨‹åº `minigrep` å·²ç»åŸºæœ¬å®Œæˆï¼Œä¸‹ä¸€ç« èŠ‚å°†ä½¿ç”¨è¿­ä»£å™¨è¿›è¡Œéƒ¨åˆ†æ”¹è¿›ï¼Œè¯·å¤§å®¶åœ¨çœ‹å®Œ[è¿­ä»£å™¨ç« èŠ‚](https://course.rs/advance/functional-programing/iterator.html)åï¼Œå†å›å¤´é˜…è¯»ã€‚


================================================
FILE: src/basic-practice/tests.md
================================================
# æµ‹è¯•é©±åŠ¨å¼€å‘

> å¼€å§‹ä¹‹å‰ï¼Œæ¨èå¤§å®¶å…ˆäº†è§£ä¸‹[å¦‚ä½•åœ¨ Rust ä¸­ç¼–å†™æµ‹è¯•ä»£ç ](https://course.rs/test/intro.html)ï¼Œè¿™å—å„¿å†…å®¹ä¸å¤æ‚ï¼Œå…ˆäº†è§£ä¸‹æœ‰åˆ©äºæœ¬ç« çš„ç»§ç»­é˜…è¯»

åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å®Œæˆäº†å¯¹é¡¹ç›®ç»“æ„çš„é‡æ„ï¼Œå¹¶å°†è¿›å…¥é€»è¾‘ä»£ç ç¼–ç¨‹çš„ç¯èŠ‚ï¼Œä½†åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç¼–å†™ä¸€äº›æµ‹è¯•ä»£ç ï¼Œä¹Ÿæ˜¯æœ€è¿‘é¢‡ä¸ºæµè¡Œçš„æµ‹è¯•é©±åŠ¨å¼€å‘æ¨¡å¼(TDD, Test Driven Development)ï¼š

1. ç¼–å†™ä¸€ä¸ªæ³¨å®šå¤±è´¥çš„æµ‹è¯•ï¼Œå¹¶ä¸”å¤±è´¥çš„åŸå› å’Œä½ æŒ‡å®šçš„ä¸€æ ·
2. ç¼–å†™ä¸€ä¸ªæˆåŠŸçš„æµ‹è¯•
3. ç¼–å†™ä½ çš„é€»è¾‘ä»£ç ï¼Œç›´åˆ°é€šè¿‡æµ‹è¯•

è¿™ä¸‰ä¸ªæ­¥éª¤å°†åœ¨æˆ‘ä»¬çš„å¼€å‘è¿‡ç¨‹ä¸­ä¸æ–­å¾ªç¯ï¼Œç›´åˆ°æ‰€æœ‰çš„ä»£ç éƒ½å¼€å‘å®Œæˆå¹¶æˆåŠŸé€šè¿‡æ‰€æœ‰æµ‹è¯•ã€‚

## æ³¨å®šå¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹

æ—¢ç„¶è¦æ·»åŠ æµ‹è¯•ï¼Œé‚£ä¹‹å‰çš„ `println!` è¯­å¥å°†æ²¡æœ‰å¤§çš„ç”¨å¤„ï¼Œæ¯•ç«Ÿ `println!` å­˜åœ¨çš„ç›®çš„å°±æ˜¯ä¸ºäº†è®©æˆ‘ä»¬çœ‹åˆ°ç»“æœæ˜¯å¦æ­£ç¡®ï¼Œè€Œç°åœ¨æµ‹è¯•ç”¨ä¾‹å°†å–è€Œä»£ä¹‹ã€‚

æ¥ä¸‹æ¥ï¼Œåœ¨ `lib.rs` æ–‡ä»¶ä¸­ï¼Œæ·»åŠ  `tests` æ¨¡å—å’Œ `test` å‡½æ•°: 

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```

æµ‹è¯•ç”¨ä¾‹å°†åœ¨æŒ‡å®šçš„å†…å®¹ä¸­æœç´¢ `duct` å­—ç¬¦ä¸²ï¼Œç›®æµ‹å¯å¾—ï¼šå…¶ä¸­æœ‰ä¸€è¡Œå†…å®¹æ˜¯åŒ…å«æœ‰ç›®æ ‡å­—ç¬¦ä¸²çš„ã€‚

ä½†ç›®å‰ä¸ºæ­¢ï¼Œè¿˜æ— æ³•è¿è¡Œè¯¥æµ‹è¯•ç”¨ä¾‹ï¼Œæ›´ä½•å†µè¿˜æƒ³å¹¸ç¾ä¹ç¥¸çš„çœ‹å…¶å¤±è´¥ï¼ŒåŸå› æ˜¯ `search` å‡½æ•°è¿˜æ²¡æœ‰å®ç°ï¼æ¯•ç«Ÿæ˜¯æµ‹è¯•é©±åŠ¨ã€æµ‹è¯•å…ˆè¡Œã€‚

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
```

å…ˆæ·»åŠ ä¸€ä¸ªç®€å•çš„ `search` å‡½æ•°å®ç°ï¼Œéå¸¸ç®€å•ç²—æš´çš„è¿”å›ä¸€ä¸ªç©ºçš„æ•°ç»„ï¼Œæ˜¾è€Œæ˜“è§æµ‹è¯•ç”¨ä¾‹å°†æˆåŠŸé€šè¿‡ï¼ŒçœŸæ˜¯ä¸€ä¸ªå±…å¿ƒåµæµ‹çš„æµ‹è¯•ç”¨ä¾‹ï¼

æ³¨æ„è¿™é‡Œç”Ÿå‘½å‘¨æœŸ `'a` çš„ä½¿ç”¨ï¼Œä¹‹å‰çš„ç« èŠ‚æœ‰[è¯¦ç»†ä»‹ç»](https://course.rs/basic/lifetime.html#å‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨)ï¼Œä¸å¤ªæ˜ç™½çš„åŒå­¦å¯ä»¥å›å¤´çœ‹çœ‹ã€‚

å–”ï¼Œè¿™ä¹ˆå¤æ‚çš„ä»£ç ï¼Œéƒ½ç”¨ä¸Šç”Ÿå‘½å‘¨æœŸäº†ï¼å˜šç‘Ÿä¸¤ä¸‹è¯•è¯•ï¼š

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

å¤ªæ£’äº†ï¼å®ƒå¤±è´¥äº†...

## åŠ¡å¿…æˆåŠŸçš„æµ‹è¯•ç”¨ä¾‹

æ¥ç€å°±æ˜¯æµ‹è¯•é©±åŠ¨çš„ç¬¬äºŒæ­¥ï¼šç¼–å†™æ³¨å®šæˆåŠŸçš„æµ‹è¯•ã€‚å½“ç„¶ï¼Œå‰ææ¡ä»¶æ˜¯å®ç°æˆ‘ä»¬çš„ `search` å‡½æ•°ã€‚å®ƒåŒ…å«ä»¥ä¸‹æ­¥éª¤ï¼š

- éå†è¿­ä»£ `contents` çš„æ¯ä¸€è¡Œ
- æ£€æŸ¥è¯¥è¡Œå†…å®¹æ˜¯å¦åŒ…å«æˆ‘ä»¬çš„ç›®æ ‡å­—ç¬¦ä¸²
- è‹¥åŒ…å«ï¼Œåˆ™æ”¾å…¥è¿”å›å€¼åˆ—è¡¨ä¸­ï¼Œå¦åˆ™å¿½ç•¥
- è¿”å›åŒ¹é…åˆ°çš„è¿”å›å€¼åˆ—è¡¨

### éå†è¿­ä»£æ¯ä¸€è¡Œ

Rust æä¾›äº†ä¸€ä¸ªå¾ˆä¾¿åˆ©çš„ `lines` æ–¹æ³•å°†ç›®æ ‡å­—ç¬¦ä¸²è¿›è¡ŒæŒ‰è¡Œåˆ†å‰²:

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
```

è¿™é‡Œçš„ `lines` è¿”å›ä¸€ä¸ª[è¿­ä»£å™¨](https://course.rs/advance/functional-programing/iterator.html)ï¼Œå…³äºè¿­ä»£å™¨åœ¨åç»­ç« èŠ‚ä¼šè¯¦ç»†è®²è§£ï¼Œç°åœ¨åªè¦çŸ¥é“ `for` å¯ä»¥éå†å–å‡ºè¿­ä»£å™¨ä¸­çš„å€¼å³å¯ã€‚

### åœ¨æ¯ä¸€è¡Œä¸­æŸ¥è¯¢ç›®æ ‡å­—ç¬¦ä¸²

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
```

ä¸ä¹‹å‰çš„ `lines` å‡½æ•°ç±»ä¼¼ï¼ŒRust çš„å­—ç¬¦ä¸²è¿˜æä¾›äº† `contains` æ–¹æ³•ï¼Œç”¨äºæ£€æŸ¥ `line` æ˜¯å¦åŒ…å«å¾…æŸ¥è¯¢çš„ `query`ã€‚

æ¥ä¸‹æ¥ï¼Œåªè¦è¿”å›åˆé€‚çš„å€¼ï¼Œå°±å¯ä»¥å®Œæˆ `search` å‡½æ•°çš„ç¼–å†™ã€‚


### å­˜å‚¨åŒ¹é…åˆ°çš„ç»“æœ

ç®€å•ï¼Œåˆ›å»ºä¸€ä¸ª `Vec` åŠ¨æ€æ•°ç»„ï¼Œç„¶åå°†æŸ¥è¯¢åˆ°çš„æ¯ä¸€ä¸ª `line` æ¨è¿›æ•°ç»„ä¸­å³å¯ï¼š

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

è‡³æ­¤ï¼Œ`search` å‡½æ•°å·²ç»å®Œæˆäº†æ—¢å®šç›®æ ‡ï¼Œä¸ºäº†æ£€æŸ¥åŠŸèƒ½æ˜¯å¦æ­£ç¡®ï¼Œè¿è¡Œä¸‹æˆ‘ä»¬ä¹‹å‰ç¼–å†™çš„æµ‹è¯•ç”¨ä¾‹:

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

æµ‹è¯•é€šè¿‡ï¼Œæ„å‘³ç€æˆ‘ä»¬çš„ä»£ç ä¹Ÿå®Œç¾è¿è¡Œï¼Œæ¥ä¸‹æ¥å°±æ˜¯åœ¨ `run` å‡½æ•°ä¸­å¤§æ˜¾èº«æ‰‹äº†ã€‚

### åœ¨ run å‡½æ•°ä¸­è°ƒç”¨ search å‡½æ•°

```rust
// in src/lib.rs
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&config.query, &contents) {
        println!("{line}");
    }

    Ok(())
}
```

å¥½ï¼Œå†è¿è¡Œä¸‹çœ‹çœ‹ç»“æœï¼Œçœ‹èµ·æ¥æˆ‘ä»¬è·ç¦»æˆåŠŸä»æœªå¦‚æ­¤ä¹‹è¿‘ï¼

```shell
$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```

é…·ï¼æˆåŠŸæŸ¥è¯¢åˆ°åŒ…å« `frog` çš„è¡Œï¼Œå†æ¥è¯•è¯• `body` :

```shell
$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```

å®Œç¾ï¼Œä¸‰è¡Œï¼Œä¸€è¡Œä¸å°‘ï¼Œä¸ºäº†ç¡®ä¿ä¸‡æ— ä¸€å¤±ï¼Œå†æ¥è¯•è¯•æŸ¥è¯¢ä¸€ä¸ªä¸å­˜åœ¨çš„å•è¯:

```shell
cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```

è‡³æ­¤ï¼Œç« èŠ‚å¼€å¤´çš„ç›®æ ‡å·²ç»å…¨éƒ¨å®Œæˆï¼Œæ¥ä¸‹æ¥æ€è€ƒä¸€ä¸ªå°é—®é¢˜ï¼šå¦‚æœè¦ä¸ºç¨‹åºåŠ ä¸Šå¤§å°å†™ä¸æ•æ„Ÿçš„æ§åˆ¶å‘½ä»¤ï¼Œç”±ç”¨æˆ·è¿›è¡Œè¾“å…¥ï¼Œè¯¥æ€ä¹ˆå®ç°æ¯”è¾ƒå¥½å‘¢ï¼Ÿæ¯•ç«Ÿåœ¨å®é™…æœç´¢æŸ¥è¯¢ä¸­ï¼ŒåŒæ—¶æ”¯æŒå¤§å°å†™æ•æ„Ÿå’Œä¸æ•æ„Ÿè¿˜æ˜¯å¾ˆé‡è¦çš„ã€‚

ç­”æ¡ˆç•™å¾…ä¸‹ä¸€ç« èŠ‚æ­æ™“ã€‚



================================================
FILE: src/cargo/getting-started.md
================================================
[Binary file]


================================================
FILE: src/cargo/git-auth.md
================================================
# é™„å½•ï¼šGité‰´æƒ



================================================
FILE: src/cargo/intro.md
================================================
# Cargo ä½¿ç”¨æŒ‡å—

Rust è¯­è¨€çš„åæ°”ä¹‹æ‰€ä»¥è¿™ä¹ˆå¤§ï¼Œä¿å®ˆä¼°è®¡ `Cargo` çš„è´¡çŒ®å°±å äº†ä¸‰åˆ†ä¹‹ä¸€ã€‚

`Cargo` æ˜¯åŒ…ç®¡ç†å·¥å…·ï¼Œå¯ä»¥ç”¨äºä¾èµ–åŒ…çš„ä¸‹è½½ã€ç¼–è¯‘ã€æ›´æ–°ã€åˆ†å‘ç­‰ï¼Œä¸ `Cargo` ä¸€æ ·æœ‰åçš„è¿˜æœ‰ [`crates.io`](https://crates.io)ï¼Œå®ƒæ˜¯ç¤¾åŒºæä¾›çš„åŒ…æ³¨å†Œä¸­å¿ƒï¼šç”¨æˆ·å¯ä»¥å°†è‡ªå·±çš„åŒ…å‘å¸ƒåˆ°è¯¥æ³¨å†Œä¸­å¿ƒï¼Œç„¶åå…¶å®ƒç”¨æˆ·é€šè¿‡æ³¨å†Œä¸­å¿ƒå¼•å…¥è¯¥åŒ…ã€‚

> æœ¬ç« å†…å®¹æ˜¯åŸºäº [Cargo Book](https://doc.rust-lang.org/stable/cargo/index.html) ç¿»è¯‘ï¼Œå¹¶åšäº†ä¸€äº›å†…å®¹ä¼˜åŒ–å’Œç›®å½•ç»„ç»‡ä¸Šçš„è°ƒæ•´

<img src="https://doc.rust-lang.org/stable/cargo/images/Cargo-Logo-Small.png" />




================================================
FILE: src/cargo/guide/build-cache.md
================================================
# æ„å»º( Build )ç¼“å­˜

`cargo build` çš„ç»“æœä¼šè¢«æ”¾å…¥é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ `target` æ–‡ä»¶å¤¹ä¸­ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªä½ç½®å¯ä»¥ä¸‰ç§æ–¹å¼æ›´æ”¹ï¼šè®¾ç½® `CARGO_TARGET_DIR` [ç¯å¢ƒå˜é‡](https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html)ã€[`build.target-dir`](https://course.rs/cargo/reference/configuration.html#é…ç½®æ–‡ä»¶æ¦‚è§ˆ) é…ç½®é¡¹ä»¥åŠ `--target-dir` å‘½ä»¤è¡Œå‚æ•°ã€‚

## target ç›®å½•ç»“æ„

`target` ç›®å½•çš„ç»“æ„å–å†³äºæ˜¯å¦ä½¿ç”¨ `--target` æ ‡å¿—ä¸ºç‰¹å®šçš„å¹³å°æ„å»ºã€‚

#### ä¸ä½¿ç”¨ --target

è‹¥ `--target` æ ‡å¿—æ²¡æœ‰æŒ‡å®šï¼Œ`Cargo` ä¼šæ ¹æ®å®¿ä¸»æœºæ¶æ„è¿›è¡Œæ„å»ºï¼Œæ„å»ºç»“æœä¼šæ”¾å…¥é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ `target` ç›®å½•ä¸­ï¼Œ`target` ä¸‹æ¯ä¸ªå­ç›®å½•ä¸­åŒ…å«äº†ç›¸åº”çš„ [`å‘å¸ƒé…ç½®profile`](https://course.rs/cargo/reference/profiles.html) çš„æ„å»ºç»“æœï¼Œä¾‹å¦‚ `release`ã€`debug` æ˜¯è‡ªå¸¦çš„`profile`ï¼Œå‰è€…å¾€å¾€ç”¨äºç”Ÿäº§ç¯å¢ƒï¼Œå› ä¸ºä¼šåšå¤§é‡çš„æ€§èƒ½ä¼˜åŒ–ï¼Œè€Œåè€…åˆ™ç”¨äºå¼€å‘ç¯å¢ƒï¼Œæ­¤æ—¶çš„ç¼–è¯‘æ•ˆç‡å’ŒæŠ¥é”™ä¿¡æ¯æ˜¯æœ€å¥½çš„ã€‚

é™¤æ­¤ä¹‹å¤–æˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰è‡ªå·±æƒ³è¦çš„ `profile` ï¼Œä¾‹å¦‚ç”¨äºæµ‹è¯•ç¯å¢ƒçš„ `profile`ï¼š `test`ï¼Œç”¨äºé¢„å‘ç¯å¢ƒçš„ `profile` ï¼š`pre-prod` ç­‰ã€‚

| ç›®å½•             | æè¿°                                                                    |
| ---------------- | ----------------------------------------------------------------------- |
| `target/debug/`  | åŒ…å«äº† `dev` profile çš„æ„å»ºè¾“å‡º(`cargo build` æˆ– `cargo build --debug`) |
| `target/release/` | `release` profile çš„æ„å»ºè¾“å‡ºï¼Œ`cargo build --release`                   |
| `target/foo/`    | è‡ªå®šä¹‰ `foo` profile çš„æ„å»ºè¾“å‡ºï¼Œ`cargo build --profile=foo`            |

å‡ºäºå†å²åŸå› :

- `dev` å’Œ `test` profile çš„æ„å»ºç»“æœéƒ½å­˜æ”¾åœ¨ `debug` ç›®å½•ä¸‹
- `release` å’Œ `bench` profile åˆ™å­˜æ”¾åœ¨ `release` ç›®å½•ä¸‹
- ç”¨æˆ·å®šä¹‰çš„ profile å­˜åœ¨åŒåçš„ç›®å½•ä¸‹

#### ä½¿ç”¨ --target

å½“ä½¿ç”¨ `--target XXX` ä¸ºç‰¹å®šçš„å¹³å°ç¼–è¯‘åï¼Œè¾“å‡ºä¼šæ”¾åœ¨ `target/XXX/` ç›®å½•ä¸‹:

| ç›®å½•                       | ç¤ºä¾‹                                    |
| -------------------------- | --------------------------------------- |
| `target/<triple>/debug/`    | `target/thumbv7em-none-eabihf/debug/`   |
| `target/<triple>/release/` | `target/thumbv7em-none-eabihf/release/` |

> **æ³¨æ„ï¼š**ï¼Œå½“æ²¡æœ‰ä½¿ç”¨ `--target` æ—¶ï¼Œ`Cargo` ä¼šä¸æ„å»ºè„šæœ¬å’Œè¿‡ç¨‹å®ä¸€èµ·å…±äº«ä½ çš„ä¾èµ–åŒ…ï¼Œå¯¹äºæ¯ä¸ª `rustc` å‘½ä»¤è°ƒç”¨è€Œè¨€ï¼Œ[`RUSTFLAGS`](https://course.rs/cargo/reference/configuration.html#é…ç½®æ–‡ä»¶æ¦‚è§ˆ) ä¹Ÿå°†è¢«å…±äº«ã€‚
>
> è€Œä½¿ç”¨ `--target` åï¼Œæ„å»ºè„šæœ¬ã€è¿‡ç¨‹å®ä¼šé’ˆå¯¹å®¿ä¸»æœºçš„ CPU æ¶æ„è¿›è¡Œå„è‡ªæ„å»ºï¼Œä¸”ä¸ä¼šå…±äº« `RUSTFLAGS`ã€‚

#### target å­ç›®å½•è¯´æ˜

åœ¨ profile æ–‡ä»¶å¤¹ä¸­(ä¾‹å¦‚ `debug` æˆ– `release`)ï¼ŒåŒ…å«ç¼–è¯‘åçš„æœ€ç»ˆæˆæœ:

| ç›®å½•                     | æè¿°                                                                                                                                  |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `target/debug/`          | åŒ…å«ç¼–è¯‘åçš„è¾“å‡ºï¼Œä¾‹å¦‚äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ã€[åº“å¯¹è±¡( library target )](https://course.rs/cargo/reference/cargo-target.html#åº“å¯¹è±¡library) |
| `target/debug/examples/` | åŒ…å«[ç¤ºä¾‹å¯¹è±¡( example target )](https://course.rs/cargo/reference/cargo-target.html#ç¤ºä¾‹å¯¹è±¡examples)                                |

è¿˜æœ‰ä¸€äº›å‘½ä»¤ä¼šåœ¨ `target` ä¸‹ç”Ÿæˆè‡ªå·±çš„ç‹¬ç«‹ç›®å½•:

| ç›®å½•              | æè¿°                                               |
| ----------------- | -------------------------------------------------- |
| `target/doc/`     | åŒ…å«é€šè¿‡ `cargo doc` ç”Ÿæˆçš„æ–‡æ¡£                    |
| `target/package/` | åŒ…å« `cargo package` æˆ– `cargo publish` ç”Ÿæˆçš„è¾“å‡º |

Cargo è¿˜ä¼šåˆ›å»ºå‡ ä¸ªç”¨äºæ„å»ºè¿‡ç¨‹çš„å…¶å®ƒç±»å‹ç›®å½•ï¼Œå®ƒä»¬çš„ç›®å½•ç»“æ„åªåº”è¯¥è¢« Cargo è‡ªèº«ä½¿ç”¨ï¼Œå› æ­¤å¯èƒ½ä¼šåœ¨æœªæ¥å‘ç”Ÿå˜åŒ–:

| ç›®å½•                       | æè¿°                                                                                                                    |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `target/debug/deps`        | ä¾èµ–å’Œå…¶å®ƒè¾“å‡ºæˆæœ                                                                                                      |
| `target/debug/incremental` | `rustc` [å¢é‡ç¼–è¯‘](https://course.rs/cargo/reference/profiles.html#incremental)çš„è¾“å‡ºï¼Œè¯¥ç¼“å­˜å¯ä»¥ç”¨äºæå‡åç»­çš„ç¼–è¯‘é€Ÿåº¦ |
| `target/debug/build/`      | [æ„å»ºè„šæœ¬](https://course.rs/cargo/reference/build-script/intro.html)çš„è¾“å‡º                                             |

## ä¾èµ–ä¿¡æ¯æ–‡ä»¶

åœ¨æ¯ä¸€ä¸ªç¼–è¯‘æˆæœçš„æ—è¾¹ï¼Œéƒ½æœ‰ä¸€ä¸ªä¾èµ–ä¿¡æ¯æ–‡ä»¶ï¼Œæ–‡ä»¶åç¼€æ˜¯ `.d`ã€‚è¯¥æ–‡ä»¶çš„è¯­æ³•ç±»ä¼¼äº `Makefile`ï¼Œç”¨äºè¯´æ˜æ„å»ºç¼–è¯‘æˆæœæ‰€éœ€çš„æ‰€æœ‰ä¾èµ–åŒ…ã€‚

è¯¥æ–‡ä»¶å¾€å¾€ç”¨äºæä¾›ç»™å¤–éƒ¨çš„æ„å»ºç³»ç»Ÿï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥åˆ¤æ–­ `Cargo` å‘½ä»¤æ˜¯å¦éœ€è¦å†æ¬¡è¢«æ‰§è¡Œã€‚

æ–‡ä»¶ä¸­çš„è·¯å¾„é»˜è®¤æ˜¯ç»å¯¹è·¯å¾„ï¼Œä½ å¯ä»¥é€šè¿‡ [`build.dep-info-basedir`](https://course.rs/cargo/reference/configuration.html#é…ç½®æ–‡ä»¶æ¦‚è§ˆ) é…ç½®é¡¹æ¥ä¿®æ”¹ä¸ºç›¸å¯¹è·¯å¾„ã€‚

```shell
# å…³äº `.d` æ–‡ä»¶çš„ä¸€ä¸ªç¤ºä¾‹ : target/debug/foo.d
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
```

## å…±äº«ç¼“å­˜

[sccache](https://github.com/mozilla/sccache) æ˜¯ä¸€ä¸ªä¸‰æ–¹å·¥å…·ï¼Œå¯ä»¥ç”¨äºåœ¨ä¸åŒçš„å·¥ä½œç©ºé—´ä¸­å…±äº«å·²ç»æ„å»ºå¥½çš„ä¾èµ–åŒ…ã€‚

ä¸ºäº†è®¾ç½® `sccache`ï¼Œé¦–å…ˆéœ€è¦ä½¿ç”¨ `cargo install sccache` è¿›è¡Œå®‰è£…ï¼Œç„¶ååœ¨è°ƒç”¨ `Cargo` ä¹‹å‰å°† `RUSTC_WRAPPER` ç¯å¢ƒå˜é‡è®¾ç½®ä¸º `sccache`ã€‚

- å¦‚æœç”¨çš„ `bash`ï¼Œå¯ä»¥å°† `export RUSTC_WRAPPER=sccache` æ·»åŠ åˆ° `.bashrc` ä¸­
- ä¹Ÿå¯ä»¥ä½¿ç”¨ [`build.rustc-wrapper`](https://course.rs/cargo/reference/configuration.html#é…ç½®æ–‡ä»¶æ¦‚è§ˆ) é…ç½®é¡¹



================================================
FILE: src/cargo/guide/cargo-cache.md
================================================
# Cargo ç¼“å­˜

Cargo ä½¿ç”¨äº†ç¼“å­˜çš„æ–¹å¼æå‡æ„å»ºæ•ˆç‡ï¼Œå½“æ„å»ºæ—¶ï¼ŒCargo ä¼šå°†å·²ä¸‹è½½çš„ä¾èµ–åŒ…æ”¾åœ¨ `CARGO_HOME` ç›®å½•ä¸‹ï¼Œä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹ã€‚

## Cargo Home

é»˜è®¤æƒ…å†µä¸‹ï¼ŒCargo Home æ‰€åœ¨çš„ç›®å½•æ˜¯ `$HOME/.cargo/`ï¼Œä¾‹å¦‚åœ¨ `macos` ï¼Œå¯¹åº”çš„ç›®å½•æ˜¯:

```shell
$ echo $HOME/.cargo/
/Users/sunfei/.cargo/
```

æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ä¿®æ”¹ `CARGO_HOME` ç¯å¢ƒå˜é‡çš„æ–¹å¼æ¥é‡æ–°è®¾å®šè¯¥ç›®å½•çš„ä½ç½®ã€‚è‹¥ä½ éœ€è¦åœ¨é¡¹ç›®ä¸­é€šè¿‡ä»£ç çš„æ–¹å¼æ¥è·å– `CARGO_HOME` ï¼Œ[`home`](https://crates.io/crates/home) åŒ…æä¾›äº†ç›¸åº”çš„ APIã€‚

> æ³¨æ„ï¼ Cargo Home ç›®å½•çš„å†…éƒ¨ç»“æ„å¹¶æ²¡æœ‰ç¨³å®šåŒ–ï¼Œåœ¨æœªæ¥å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–

## æ–‡ä»¶

- `config.toml` æ˜¯ Cargo çš„å…¨å±€é…ç½®æ–‡ä»¶ï¼Œå…·ä½“è¯·æŸ¥çœ‹[è¿™é‡Œ](https://course.rs/cargo/reference/configuration.html)
- `credentials.toml` ä¸º `cargo login` æä¾›ç§æœ‰åŒ–ç™»å½•è¯ä¹¦ï¼Œç”¨äºç™»å½• `package` æ³¨å†Œä¸­å¿ƒï¼Œä¾‹å¦‚ `crates.io`
- `.crates.toml`, `.crates2.json` è¿™ä¸¤ä¸ªæ˜¯éšè—æ–‡ä»¶ï¼ŒåŒ…å«äº†é€šè¿‡ `cargo install` å®‰è£…çš„åŒ…çš„ `package` ä¿¡æ¯ï¼Œ**è¯·ä¸è¦æ‰‹åŠ¨ä¿®æ”¹ï¼**

## ç›®å½•

- `bin` ç›®å½•åŒ…å«äº†é€šè¿‡ `cargo install` æˆ– `rustup` ä¸‹è½½çš„åŒ…ç¼–è¯‘å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚ä½ å¯ä»¥å°†è¯¥ç›®å½•åŠ å…¥åˆ° `$PATH` ç¯å¢ƒå˜é‡ä¸­ï¼Œä»¥å®ç°å¯¹è¿™äº›å¯æ‰§è¡Œæ–‡ä»¶çš„ç›´æ¥è®¿é—®
- `git` ä¸­å­˜å‚¨äº† `Git` çš„èµ„æºæ–‡ä»¶:
  - `git/db`ï¼Œå½“ä¸€ä¸ªåŒ…ä¾èµ–æŸä¸ª `git` ä»“åº“æ—¶ï¼Œ`Cargo` ä¼šå°†è¯¥ä»“åº“å…‹éš†åˆ° `git/db` ç›®å½•ä¸‹ï¼Œå¦‚æœæœªæ¥éœ€è¦è¿˜ä¼šå¯¹å…¶è¿›è¡Œæ›´æ–°
  - `git/checkouts`ï¼Œè‹¥æŒ‡å®šäº† `git` æºå’Œ `commit`ï¼Œé‚£ç›¸åº”çš„ä»“åº“å°±ä¼šä» `git/db` ä¸­ `checkout` åˆ°è¯¥ç›®å½•ä¸‹ï¼Œå› æ­¤åŒä¸€ä¸ªä»“åº“çš„ä¸åŒ `checkout` å…±å­˜æˆä¸ºäº†å¯èƒ½æ€§
- `registry` åŒ…å«äº†æ³¨å†Œä¸­å¿ƒ( ä¾‹å¦‚ `crates.io` )çš„å…ƒæ•°æ® å’Œ `packages`
  - `registry/index` æ˜¯ä¸€ä¸ª git ä»“åº“ï¼ŒåŒ…å«äº†æ³¨å†Œä¸­å¿ƒä¸­æ‰€æœ‰å¯ç”¨åŒ…çš„å…ƒæ•°æ®( ç‰ˆæœ¬ã€ä¾èµ–ç­‰ )
  - `registry/cache` ä¸­ä¿å­˜äº†å·²ä¸‹è½½çš„ä¾èµ–ï¼Œè¿™äº›ä¾èµ–åŒ…ä»¥ `gzip` çš„å‹ç¼©æ¡£æ¡ˆå½¢å¼ä¿å­˜ï¼Œåç¼€åä¸º `.crate`
  - `registry/src`ï¼Œè‹¥ä¸€ä¸ªå·²ä¸‹è½½çš„ `.crate` æ¡£æ¡ˆè¢«ä¸€ä¸ª `package` æ‰€éœ€è¦ï¼Œè¯¥æ¡£æ¡ˆä¼šè¢«è§£å‹ç¼©åˆ° `registry/src` æ–‡ä»¶å¤¹ä¸‹ï¼Œæœ€ç»ˆ `rustc` å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°æ‰€éœ€çš„ `.rs` æ–‡ä»¶

## åœ¨ CI æ—¶ç¼“å­˜ Cargo Home

ä¸ºäº†é¿å…æŒç»­é›†æˆæ—¶é‡å¤ä¸‹è½½æ‰€æœ‰çš„åŒ…ä¾èµ–ï¼Œæˆ‘ä»¬å¯ä»¥å°† `$CARGO_HOME` ç›®å½•è¿›è¡Œç¼“å­˜ï¼Œä½†ç¼“å­˜æ•´ä¸ªç›®å½•æ˜¯æ•ˆç‡ä½ä¸‹çš„ï¼ŒåŸå› æ˜¯æºæ–‡ä»¶å¯èƒ½ä¼šè¢«ç¼“å­˜ä¸¤æ¬¡ã€‚

ä¾‹å¦‚æˆ‘ä»¬ä¾èµ–ä¸€ä¸ªåŒ… `serde 1.0.92`ï¼Œå¦‚æœå°†æ•´ä¸ª `$CACHE_HOME` ç›®å½•ç¼“å­˜ï¼Œé‚£ä¹ˆ`serde` çš„æºæ–‡ä»¶å°±ä¼šè¢«ç¼“å­˜ä¸¤æ¬¡ï¼šåœ¨ `registry/cache` ä¸­çš„ `serde-1.0.92.crate` ä»¥åŠ `registry/src` ä¸‹è¢«è§£å‹ç¼©çš„ `.rs` æ–‡ä»¶ã€‚

å› æ­¤ï¼Œåœ¨ CI æ„å»ºæ—¶ï¼Œå‡ºäºæ•ˆç‡çš„è€ƒè™‘ï¼Œæˆ‘ä»¬ä»…åº”è¯¥ç¼“å­˜ä»¥ä¸‹ç›®å½•:

- `bin/`
- `registry/index/`
- `registry/cache/`
- `git/db/`

## æ¸…é™¤ç¼“å­˜

ç†è®ºä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨ç§»é™¤ç¼“å­˜ä¸­çš„ä»»ä½•ä¸€éƒ¨åˆ†ï¼Œå½“åç»­æœ‰åŒ…éœ€è¦æ—¶ `Cargo` ä¼šå°½å¯èƒ½å»æ¢å¤è¿™äº›èµ„æºï¼š

- è§£å‹ç¼© `registry/cache` ä¸‹çš„ `.crate` æ¡£æ¡ˆ
- ä» `.git` ä¸­ `checkout` ç¼“å­˜çš„ä»“åº“
- å¦‚æœä»¥ä¸Šéƒ½æ²¡äº†ï¼Œä¼šä»ç½‘ç»œä¸Šé‡æ–°ä¸‹è½½

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ [cargo-cache](https://crates.io/crates/cargo-cache) åŒ…æ¥é€‰æ‹©æ€§çš„æ¸…é™¤ `cache` ä¸­æŒ‡å®šçš„éƒ¨åˆ†ï¼Œå½“ç„¶ï¼Œå®ƒè¿˜å¯ä»¥ç”¨æ¥æŸ¥çœ‹ç¼“å­˜ä¸­çš„ç»„ä»¶å¤§å°ã€‚

## æ„å»ºæ—¶å¡ä½ï¼šBlocking waiting for file lock ..

åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ–å¤šæˆ–å°‘æˆ‘ä»¬éƒ½ä¼šç¢°åˆ°è¿™ç§é—®é¢˜ï¼Œä¾‹å¦‚ä½ åŒæ—¶æ‰“å¼€äº† VSCode IDE å’Œç»ˆç«¯ï¼Œç„¶ååœ¨ `Cargo.toml` ä¸­åˆšæ·»åŠ äº†ä¸€ä¸ªæ–°çš„ä¾èµ–ã€‚

æ­¤æ—¶ IDE ä¼šæ•æ‰åˆ°è¿™ä¸ªä¿®æ”¹ç„¶åè‡ªåŠ¨å»é‡æ–°ä¸‹è½½ä¾èµ–(è¿™ä¸ªè¿‡ç¨‹å¯èƒ½è¿˜ä¼šæ›´æ–° `crates.io` ä½¿ç”¨çš„ç´¢å¼•åˆ—è¡¨)ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œ Cargo ä¼šå°†ç›¸å…³ä¿¡æ¯å†™å…¥åˆ° `$HOME/.cargo/.package_cache` ä¸‹ï¼Œå¹¶å°†å…¶é”ä½ã€‚

å¦‚æœä½ è¯•å›¾åœ¨å¦ä¸€ä¸ªåœ°æ–¹(ä¾‹å¦‚ç»ˆç«¯)å¯¹åŒä¸€ä¸ªé¡¹ç›®è¿›è¡Œæ„å»ºï¼Œå°±ä¼šæŠ¥é”™: `Blocking waiting for file lock on package cache`ã€‚

è§£å†³åŠæ³•å¾ˆç®€å•ï¼š

- æ—¢ç„¶ä¸‹è½½æ…¢ï¼Œé‚£å°±ä½¿ç”¨[å›½å†…çš„æ³¨å†ŒæœåŠ¡](https://course.rs/cargo/reference/specify-deps.html#ä»å…¶å®ƒæ³¨å†ŒæœåŠ¡å¼•å…¥ä¾èµ–åŒ…)ï¼Œä¸å†ä½¿ç”¨ crates.io
- è€å¿ƒç­‰å¾…æŒæœ‰é”çš„ç”¨æˆ·æ„å»ºå®Œæˆ
- å¼ºè¡Œåœæ­¢æ­£åœ¨æ„å»ºçš„è¿›ç¨‹ï¼Œä¾‹å¦‚æ€æ‰ IDE ä½¿ç”¨çš„ rust-analyer æ’ä»¶è¿›ç¨‹ï¼Œç„¶ååˆ é™¤ `$HOME/.cargo/.package_cache` ç›®å½•




================================================
FILE: src/cargo/guide/cargo-toml-lock.md
================================================
# Cargo.toml vs Cargo.lock

`Cargo.toml` å’Œ `Cargo.lock` æ˜¯ `Cargo` çš„ä¸¤ä¸ªå…ƒé…ç½®æ–‡ä»¶ï¼Œä½†æ˜¯å®ƒä»¬æ‹¥æœ‰ä¸åŒçš„ç›®çš„:

- å‰è€…ä»ç”¨æˆ·çš„è§’åº¦å‡ºå‘æ¥æè¿°é¡¹ç›®ä¿¡æ¯å’Œä¾èµ–ç®¡ç†ï¼Œå› æ­¤å®ƒæ˜¯ç”±ç”¨æˆ·æ¥ç¼–å†™
- åè€…åŒ…å«äº†ä¾èµ–çš„ç²¾ç¡®æè¿°ä¿¡æ¯ï¼Œå®ƒæ˜¯ç”± `Cargo` è‡ªè¡Œç»´æŠ¤ï¼Œå› æ­¤ä¸è¦å»æ‰‹åŠ¨ä¿®æ”¹

å®ƒä»¬çš„å…³ç³»è·Ÿ `package.json` å’Œ `package-lock.json` éå¸¸ç›¸ä¼¼ï¼Œä» JavaScript è¿‡æ¥çš„åŒå­¦åº”è¯¥ä¼šæ¯”è¾ƒå¥½ç†è§£ã€‚

## æ˜¯å¦ä¸Šä¼ æœ¬åœ°çš„ `Cargo.lock`

å½“æœ¬åœ°å¼€å‘æ—¶ï¼Œ`Cargo.lock` è‡ªç„¶æ˜¯éå¸¸é‡è¦çš„ï¼Œä½†æ˜¯å½“ä½ è¦æŠŠé¡¹ç›®ä¸Šä¼ åˆ° `Git` æ—¶ï¼Œä¾‹å¦‚ `GitHub`ï¼Œé‚£æ˜¯å¦ä¸Šä¼  `Cargo.lock` å°±æˆäº†ä¸€ä¸ªé—®é¢˜ã€‚

å…³äºæ˜¯å¦ä¸Šä¼ ï¼Œæœ‰å¦‚ä¸‹ç»éªŒå‡†åˆ™:

- ä»å®è·µè§’åº¦å‡ºå‘ï¼Œå¦‚æœä½ æ„å»ºçš„æ˜¯ä¸‰æ–¹åº“ç±»å‹çš„æœåŠ¡ï¼Œè¯·æŠŠ `Cargo.lock` åŠ å…¥åˆ° `.gitignore` ä¸­ã€‚
- è‹¥æ„å»ºçš„æ˜¯ä¸€ä¸ªé¢å‘ç”¨æˆ·ç»ˆç«¯çš„äº§å“ï¼Œä¾‹å¦‚å¯ä»¥åƒå‘½ä»¤è¡Œå·¥å…·ã€åº”ç”¨ç¨‹åºä¸€æ ·æ‰§è¡Œï¼Œé‚£å°±æŠŠ `Cargo.lock` ä¸Šä¼ åˆ°æºä»£ç ç›®å½•ä¸­ã€‚

ä¾‹å¦‚ [`axum`](https://github.com/tokio-rs/axum) æ˜¯ web å¼€å‘æ¡†æ¶ï¼Œå®ƒå±äºä¸‰æ–¹åº“ç±»å‹çš„æœåŠ¡ï¼Œå› æ­¤æºç ç›®å½•ä¸­ä¸åº”è¯¥å‡ºç° `Cargo.lock` çš„èº«å½±ï¼Œå®ƒçš„å½’å®¿æ˜¯ `.gitignore`ã€‚è€Œ [`ripgrep`](https://github.com/BurntSushi/ripgrep) åˆ™æ°æ°ç›¸åï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªé¢å‘ç»ˆç«¯çš„äº§å“ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œæä¾›æœåŠ¡ã€‚

**é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œä¸ºä½•ä¼šæœ‰è¿™ç§é€‰æ‹©ï¼Ÿ**

åŸå› æ˜¯ `Cargo.lock` ä¼šè¯¦å°½æè¿°ä¸Šä¸€æ¬¡æˆåŠŸæ„å»ºçš„å„ç§ä¿¡æ¯ï¼šç¯å¢ƒçŠ¶æ€ã€ä¾èµ–ã€ç‰ˆæœ¬ç­‰ç­‰ï¼ŒCargo å¯ä»¥ä½¿ç”¨å®ƒæä¾›ç¡®å®šæ€§çš„æ„å»ºç¯å¢ƒå’Œæµç¨‹ï¼Œæ— è®ºä½•æ—¶ä½•åœ°ã€‚è¿™ç§ç‰¹æ€§å¯¹äºç»ˆç«¯æœåŠ¡æ˜¯éå¸¸é‡è¦çš„ï¼šèƒ½ç¡®å®šã€ç¨³å®šçš„åœ¨ç”¨æˆ·ç¯å¢ƒä¸­è¿è¡Œèµ·æ¥æ˜¯ç»ˆç«¯æœåŠ¡æœ€é‡è¦çš„ç‰¹æ€§ä¹‹ä¸€ã€‚

è€Œå¯¹äºä¸‰æ–¹åº“æ¥è¯´ï¼Œæƒ…å†µå°±æœ‰äº›ä¸åŒã€‚å®ƒä¸ä»…ä»…è¢«åº“çš„å¼€å‘è€…æ‰€ä½¿ç”¨ï¼Œè¿˜ä¼šé—´æ¥å½±å“ä¾èµ–é“¾ä¸‹æ¸¸çš„ä½¿ç”¨è€…ã€‚ç”¨æˆ·å¼•å…¥äº†ä¸‰æ–¹åº“æ˜¯ä¸ä¼šå»çœ‹å®ƒçš„ `Cargo.lock` ä¿¡æ¯çš„ï¼Œä¹Ÿä¸åº”è¯¥å—è¿™ä¸ªåº“çš„ç¡®å®šæ€§è¿è¡Œæ¡ä»¶æ‰€é™åˆ¶ã€‚

è¿˜æœ‰ä¸ªåŸå› ï¼Œåœ¨é¡¹ç›®ä¸­ï¼Œå¯èƒ½ä¼šæœ‰å‡ ä¸ªä¾èµ–åº“å¼•ç”¨åŒä¸€ä¸ªä¸‰æ–¹åº“çš„åŒä¸€ä¸ªç‰ˆæœ¬ï¼Œé‚£å¦‚æœè¯¥ä¸‰æ–¹åº“ä½¿ç”¨äº† `Cargo.lock` æ–‡ä»¶ï¼Œé‚£å¯èƒ½ä¸‰æ–¹åº“çš„å¤šä¸ªç‰ˆæœ¬ä¼šè¢«å¼•å…¥ä½¿ç”¨ï¼Œè¿™æ—¶å°±ä¼šé€ æˆç‰ˆæœ¬å†²çªã€‚æ¢å¥è¯è¯´ï¼Œé€šè¿‡æŒ‡å®šç‰ˆæœ¬çš„æ–¹å¼å¼•ç”¨ä¸€ä¸ªä¾èµ–åº“æ˜¯æ— æ³•çœ‹åˆ°è¯¥ä¾èµ–åº“çš„å®Œæ•´æƒ…å†µçš„ï¼Œè€Œåªæœ‰ç»ˆç«¯çš„äº§å“æ‰ä¼šçœ‹åˆ°è¿™äº›å®Œæ•´çš„æƒ…å†µã€‚

## å‡è®¾æ²¡æœ‰ `Cargo.lock`

`Cargo.toml` æ˜¯ä¸€ä¸ªæ¸…å•æ–‡ä»¶( `manifest` )åŒ…å«äº†æˆ‘ä»¬ `package` çš„æè¿°å…ƒæ•°æ®ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡ä»¥ä¸‹å†…å®¹å¯ä»¥è¯´æ˜å¯¹å¦ä¸€ä¸ª `package` çš„ä¾èµ– :

```rust
[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

å¯ä»¥çœ‹åˆ°ï¼Œåªæœ‰ä¸€ä¸ªä¾èµ–ï¼Œä¸”è¯¥ä¾èµ–çš„æ¥æºæ˜¯ `GitHub` ä¸Šä¸€ä¸ªç‰¹å®šçš„ä»“åº“ã€‚ç”±äºæˆ‘ä»¬æ²¡æœ‰æŒ‡å®šä»»ä½•ç‰ˆæœ¬ä¿¡æ¯ï¼Œ`Cargo` ä¼šè‡ªåŠ¨æ‹‰å–è¯¥ä¾èµ–åº“çš„æœ€æ–°ç‰ˆæœ¬( `master` æˆ– `main` åˆ†æ”¯ä¸Šçš„æœ€æ–° `commit` )ã€‚

è¿™ç§ä½¿ç”¨æ–¹å¼ï¼Œå…¶å®å°±é”™å¤±äº†åŒ…ç®¡ç†å·¥å…·çš„æœ€å¤§çš„ä¼˜ç‚¹ï¼šç‰ˆæœ¬ç®¡ç†ã€‚ä¾‹å¦‚ä½ åœ¨ä»Šå¤©æ„å»ºä½¿ç”¨äº†ç‰ˆæœ¬ `A`ï¼Œç„¶åè¿‡äº†ä¸€æ®µæ—¶é—´åï¼Œç”±äºä¾èµ–åŒ…çš„å‡çº§ï¼Œæ–°çš„æ„å»ºå´ä½¿ç”¨äº†å¤§æ›´æ–°ç‰ˆæœ¬ `B`ï¼Œç»“æœå› ä¸ºç‰ˆæœ¬ä¸å…¼å®¹ï¼Œå¯¼è‡´äº†æ„å»ºå¤±è´¥ã€‚

å¯ä»¥çœ‹å‡ºï¼Œç¡®ä¿ä¾èµ–ç‰ˆæœ¬çš„ç¡®å®šæ€§æ˜¯éå¸¸é‡è¦çš„:

```rust
[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }
```

è¿™æ¬¡ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†æŒ‡å®š `rev` ( `revision` ) çš„æ–¹å¼æ¥æ„å»ºï¼Œé‚£ä¹ˆä¸ç®¡æœªæ¥ä½•æ—¶å†æ¬¡æ„å»ºï¼Œä½¿ç”¨çš„ä¾èµ–åº“éƒ½ä¼šæ˜¯è¯¥ `rev` ï¼Œè€Œä¸æ˜¯æœ€æ–°çš„ `commit`ã€‚

ä½†æ˜¯ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼š`rev` éœ€è¦æ‰‹åŠ¨çš„ç®¡ç†ï¼Œä½ éœ€è¦åœ¨æ¯æ¬¡æ›´æ–°åŒ…çš„æ—¶å€™éƒ½æ€è€ƒä¸‹ `SHA-1`ï¼Œè¿™æ˜¾ç„¶éå¸¸éº»çƒ¦ã€‚

## å½“æœ‰äº† `Cargo.lock` å

å½“æœ‰äº† `Cargo.lock` åï¼Œæˆ‘ä»¬æ— éœ€æ‰‹åŠ¨è¿½è¸ªä¾èµ–åº“çš„ `rev`ï¼Œ`Cargo` ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬å®Œæˆï¼Œè¿˜æ˜¯ä¹‹å‰çš„æ¸…å•:

```rust
[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

ç¬¬ä¸€æ¬¡æ„å»ºæ—¶ï¼Œ`Cargo` ä¾ç„¶ä¼šæ‹‰å–æœ€æ–°çš„ `master commit`ï¼Œç„¶åå°†ä»¥ä¸‹ä¿¡æ¯å†™åˆ° `Cargo.lock` æ–‡ä»¶ä¸­:

```rust
[[package]]
name = "hello_world"
version = "0.1.0"
dependencies = [
 "regex 1.5.0 (git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831)",
]

[[package]]
name = "regex"
version = "1.5.0"
source = "git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831"
```

å¯ä»¥çœ‹å‡ºï¼Œå…¶ä¸­åŒ…å«äº†ä¾èµ–åº“çš„å‡†ç¡® `rev` ä¿¡æ¯ã€‚å½“æœªæ¥å†æ¬¡æ„å»ºæ—¶ï¼Œåªè¦é¡¹ç›®ä¸­è¿˜æœ‰è¯¥ `Cargo.lock` æ–‡ä»¶ï¼Œé‚£æ„å»ºä¾ç„¶ä¼šæ‹‰å–åŒä¸€ä¸ªç‰ˆæœ¬çš„ä¾èµ–åº“ï¼Œå¹¶ä¸”å†ä¹Ÿæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨å»ç®¡ç† `rev` çš„ `SHA` ä¿¡æ¯!

## æ›´æ–°ä¾èµ–

ç”±äº `Cargo.lock` ä¼šé”ä½ä¾èµ–çš„ç‰ˆæœ¬ï¼Œä½ éœ€è¦é€šè¿‡æ‰‹åŠ¨çš„æ–¹å¼å°†ä¾èµ–æ›´æ–°åˆ°æ–°çš„ç‰ˆæœ¬ï¼š

```rust
$ cargo update            # æ›´æ–°æ‰€æœ‰ä¾èµ–
$ cargo update -p regex   # åªæ›´æ–° â€œregexâ€
```

ä»¥ä¸Šå‘½ä»¤å°†ä½¿ç”¨æ–°çš„ç‰ˆæœ¬ä¿¡æ¯é‡æ–°ç”Ÿæˆ `Cargo.lock` ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ `cargo update -p regex` ä¼ é€’çš„å‚æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ª `Package ID`ï¼Œ `regex` åªæ˜¯ä¸€ä¸ªç®€å†™å½¢å¼ã€‚



================================================
FILE: src/cargo/guide/dependencies.md
================================================
# æ·»åŠ ä¾èµ–

[`crates.io`](https://crates.io) æ˜¯ Rust ç¤¾åŒºç»´æŠ¤çš„ä¸­å¿ƒåŒ–æ³¨å†ŒæœåŠ¡ï¼Œç”¨æˆ·å¯ä»¥åœ¨å…¶ä¸­å¯»æ‰¾å’Œä¸‹è½½æ‰€éœ€çš„åŒ…ã€‚å¯¹äº `cargo` æ¥è¯´ï¼Œé»˜è®¤å°±æ˜¯ä»è¿™é‡Œä¸‹è½½ä¾èµ–ã€‚

ä¸‹é¢æˆ‘ä»¬æ¥æ·»åŠ ä¸€ä¸ª `time` ä¾èµ–åŒ…ï¼Œè‹¥ä½ çš„ `Cargo.toml` æ–‡ä»¶ä¸­æ²¡æœ‰ `[dependencies]` éƒ¨åˆ†ï¼Œå°±æ‰‹åŠ¨æ·»åŠ ä¸€ä¸ªï¼Œå¹¶æ·»åŠ ç›®æ ‡åŒ…åå’Œç‰ˆæœ¬å·:

```toml
[dependencies]
time = "0.1.12"
```

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æŒ‡å®šäº† `time` åŒ…çš„ç‰ˆæœ¬å· "0.1.12"ï¼Œå…³äºç‰ˆæœ¬å·ï¼Œå®é™…ä¸Šè¿˜æœ‰å…¶å®ƒçš„æŒ‡å®šæ–¹å¼ï¼Œå…·ä½“å‚è§[æŒ‡å®šä¾èµ–é¡¹](https://course.rs/cargo/reference/specify-deps.html)ç« èŠ‚ã€‚

å¦‚æœæƒ³ç»§ç»­æ·»åŠ  `regexp` åŒ…ï¼Œåªéœ€åœ¨ `time` åŒ…åé¢æ·»åŠ å³å¯ :

```toml
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
```

æ­¤æ—¶ï¼Œå†é€šè¿‡è¿è¡Œ `cargo build` æ¥é‡æ–°æ„å»ºï¼Œé¦–å…ˆ `Cargo` ä¼šè·å–æ–°çš„ä¾èµ–ä»¥åŠä¾èµ–çš„ä¾èµ–, æ¥ç€å¯¹å®ƒä»¬è¿›è¡Œç¼–è¯‘å¹¶æ›´æ–° `Cargo.lock`:

```shell
$ cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
```

åœ¨ `Cargo.lock` ä¸­åŒ…å«äº†æˆ‘ä»¬é¡¹ç›®ä½¿ç”¨çš„æ‰€æœ‰ä¾èµ–çš„å‡†ç¡®ç‰ˆæœ¬ä¿¡æ¯ã€‚è¿™ä¸ªéå¸¸é‡è¦ï¼Œæœªæ¥å°±ç®— `regexp` çš„ä½œè€…å‡çº§äº†è¯¥åŒ…ï¼Œæˆ‘ä»¬ä¾ç„¶ä¼šä¸‹è½½ `Cargo.lock` ä¸­çš„ç‰ˆæœ¬ï¼Œè€Œä¸æ˜¯æœ€æ–°çš„ç‰ˆæœ¬ï¼Œåªæœ‰è¿™æ ·ï¼Œæ‰èƒ½ä¿è¯é¡¹ç›®ä¾èµ–åŒ…ä¸ä¼šè«åå…¶å¦™çš„å› ä¸ºæ›´æ–°å‡çº§å¯¼è‡´æ— æ³•ç¼–è¯‘ã€‚ å½“ç„¶ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨ `cargo update` æ¥æ‰‹åŠ¨æ›´æ–°åŒ…çš„ç‰ˆæœ¬ã€‚

æ­¤æ—¶ï¼Œå°±å¯ä»¥åœ¨ `src/main.rs` ä¸­ä½¿ç”¨æ–°å¼•å…¥çš„ `regexp` åŒ…:

```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    println!("Did our date match? {}", re.is_match("2014-01-01"));
}
```

è¿è¡Œåè¾“å‡º:

```shell
$ cargo run
   Running `target/hello_world`
Did our date match? true
```



================================================
FILE: src/cargo/guide/download-package.md
================================================
# ä¸‹è½½å¹¶æ„å»º Package

å¦‚æœçœ‹ä¸­ `GitHub` ä¸Šçš„æŸä¸ªå¼€æº Rust é¡¹ç›®ï¼Œé‚£ä¸‹è½½å¹¶æ„å»ºå®ƒå°†æ˜¯éå¸¸ç®€å•çš„ã€‚

```shell
$ git clone https://github.com/rust-lang/regex.git
$ cd regex
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œç›´æ¥ä» `GitHub` ä¸Šå…‹éš†ä¸‹æ¥æƒ³è¦çš„é¡¹ç›®ï¼Œç„¶åä½¿ç”¨ `cargo build` è¿›è¡Œæ„å»ºå³å¯ï¼š

```shell
$ cargo build
   Compiling regex v1.5.0 (file:///path/to/package/regex)
```

è¯¥å‘½ä»¤å°†ä¸‹è½½ç›¸å…³çš„ä¾èµ–åº“ï¼Œç­‰ä¸‹è½½æˆåŠŸåï¼Œå†å¯¹ `package` å’Œä¸‹è½½çš„ä¾èµ–è¿›è¡Œä¸€åŒçš„ç¼–è¯‘æ„å»ºã€‚

è¿™å°±æ˜¯åŒ…ç®¡ç†å·¥å…·çš„å¼ºå¤§ä¹‹å¤„ï¼Œ`cargo build` æå®šä¸€åˆ‡ï¼Œè€ŒèƒŒåéšè—çš„å¤æ‚é…ç½®ã€å‚æ•°ä½ éƒ½æ— éœ€å…³å¿ƒã€‚




================================================
FILE: src/cargo/guide/intro.md
================================================
# ä½¿ç”¨æ‰‹å†Œ

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  `Cargo` çš„è¯¦ç»†ä½¿ç”¨æ–¹å¼ï¼Œä¾‹å¦‚ `Package` çš„åˆ›å»ºä¸ç®¡ç†ã€ä¾èµ–æ‹‰å–ã€`Package` ç»“æ„æè¿°ç­‰ã€‚




================================================
FILE: src/cargo/guide/package-layout.md
================================================
# æ ‡å‡†çš„ Package ç›®å½•ç»“æ„

ä¸€ä¸ªå…¸å‹çš„ `Package` ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š

```shell
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ bin/
â”‚       â”œâ”€â”€ named-executable.rs
â”‚       â”œâ”€â”€ another-executable.rs
â”‚       â””â”€â”€ multi-file-executable/
â”‚           â”œâ”€â”€ main.rs
â”‚           â””â”€â”€ some_module.rs
â”œâ”€â”€ benches/
â”‚   â”œâ”€â”€ large-input.rs
â”‚   â””â”€â”€ multi-file-bench/
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ bench_module.rs
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ simple.rs
â”‚   â””â”€â”€ multi-file-example/
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ ex_module.rs
â””â”€â”€ tests/
    â”œâ”€â”€ some-integration-tests.rs
    â””â”€â”€ multi-file-test/
        â”œâ”€â”€ main.rs
        â””â”€â”€ test_module.rs
```

è¿™ä¹Ÿæ˜¯ `Cargo` æ¨èçš„ç›®å½•ç»“æ„ï¼Œè§£é‡Šå¦‚ä¸‹ï¼š

- `Cargo.toml` å’Œ `Cargo.lock` ä¿å­˜åœ¨ `package` æ ¹ç›®å½•ä¸‹
- æºä»£ç æ”¾åœ¨ `src` ç›®å½•ä¸‹
- é»˜è®¤çš„ `lib` åŒ…æ ¹æ˜¯ `src/lib.rs`
- é»˜è®¤çš„äºŒè¿›åˆ¶åŒ…æ ¹æ˜¯ `src/main.rs`
  - å…¶å®ƒäºŒè¿›åˆ¶åŒ…æ ¹æ”¾åœ¨ `src/bin/` ç›®å½•ä¸‹
- åŸºå‡†æµ‹è¯• benchmark æ”¾åœ¨ `benches` ç›®å½•ä¸‹
- ç¤ºä¾‹ä»£ç æ”¾åœ¨ `examples` ç›®å½•ä¸‹
- é›†æˆæµ‹è¯•ä»£ç æ”¾åœ¨ `tests` ç›®å½•ä¸‹

å…³äº Rust ä¸­çš„åŒ…å’Œæ¨¡å—ï¼Œ[ä¹‹å‰çš„ç« èŠ‚](https://course.rs/basic/crate-module/intro.html)æœ‰æ›´è¯¦ç»†çš„è§£é‡Šã€‚

æ­¤å¤–ï¼Œ`bin`ã€`tests`ã€`examples` ç­‰ç›®å½•è·¯å¾„éƒ½å¯ä»¥é€šè¿‡é…ç½®æ–‡ä»¶è¿›è¡Œé…ç½®ï¼Œå®ƒä»¬è¢«ç»Ÿä¸€ç§°ä¹‹ä¸º [Cargo Target](https://course.rs/cargo/reference/cargo-target.html)ã€‚




================================================
FILE: src/cargo/guide/tests-ci.md
================================================
[Binary file]


================================================
FILE: src/cargo/guide/why-exist.md
================================================
# ä¸ºä½•ä¼šæœ‰ Cargo

æ ¹æ®ä¹‹å‰å­¦ä¹ çš„çŸ¥è¯†ï¼ŒRust æœ‰ä¸¤ç§ç±»å‹çš„åŒ…: åº“åŒ…å’ŒäºŒè¿›åˆ¶åŒ…ï¼Œå‰è€…æ˜¯æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„ä¾èµ–åŒ…ï¼Œç”¨äºè¢«å…¶å®ƒåŒ…æ‰€å¼•å…¥ï¼Œè€Œåè€…æ˜¯ä¸€ä¸ªåº”ç”¨æœåŠ¡ï¼Œå¯ä»¥ç¼–è¯‘æˆäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶è¿›è¡Œè¿è¡Œã€‚

åŒ…æ˜¯é€šè¿‡ Rust ç¼–è¯‘å™¨ `rustc` è¿›è¡Œç¼–è¯‘çš„:

```rust
$ rustc hello.rs
$ ./hello
Hello, world!
```

ä¸Šé¢æˆ‘ä»¬ç›´æ¥ä½¿ç”¨ `rustc` å¯¹äºŒè¿›åˆ¶åŒ… `hello.rs` è¿›è¡Œç¼–è¯‘ï¼Œç”ŸæˆäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ `hello`ï¼Œå¹¶å¯¹å…¶è¿›è¡Œè¿è¡Œã€‚

è¯¥æ–¹å¼è™½ç„¶ç®€å•ï¼Œä½†æœ‰å‡ ä¸ªé—®é¢˜ï¼š

- å¿…é¡»è¦æŒ‡å®šæ–‡ä»¶åç¼–è¯‘ï¼Œå½“é¡¹ç›®å¤æ‚åï¼Œè¿™ç§ç¼–è¯‘æ–¹å¼ä¹Ÿéšä¹‹æ›´åŠ å¤æ‚
- å¦‚æœè¦æŒ‡å®šç¼–è¯‘å‚æ•°ï¼Œæƒ…å†µå°†æ›´åŠ å¤æ‚

æœ€å…³é”®çš„æ˜¯ï¼Œå¤–éƒ¨ä¾èµ–åº“çš„å¼•å…¥ä¹Ÿå°†æ˜¯ä¸€ä¸ªå¤§é—®é¢˜ã€‚å¤§éƒ¨åˆ†å®é™…çš„é¡¹ç›®éƒ½æœ‰ä¸å°‘ä¾èµ–åŒ…ï¼Œè€Œè¿™äº›ä¾èµ–åŒ…åˆé—´æ¥çš„ä¾èµ–äº†æ–°çš„ä¾èµ–åŒ…ï¼Œåœ¨è¿™ç§å¤æ‚æƒ…å†µä¸‹ï¼Œå¦‚ä½•ç®¡ç†ä¾èµ–åŒ…åŠå…¶ç‰ˆæœ¬ä¹Ÿæˆä¸ºä¸€ä¸ªç›¸å½“æ£˜æ‰‹çš„é—®é¢˜ã€‚

æ­£æ˜¯å› ä¸ºè¿™äº›åŸå› ï¼Œä¸å…¶ä½¿ç”¨ `rustc` ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¼ºå¤§çš„åŒ…ç®¡ç†å·¥å…·æ¥è§£å†³é—®é¢˜ï¼šæ¬¢è¿ `Cargo` é—ªäº®ç™»åœºã€‚

## Cargo

`Cargo` è§£å†³äº†ä¹‹å‰æè¿°çš„æ‰€æœ‰é—®é¢˜ï¼ŒåŒæ—¶å®ƒä¿è¯äº†æ¯æ¬¡é‡å¤çš„æ„å»ºéƒ½ä¸ä¼šæ”¹å˜ä¸Šä¸€æ¬¡æ„å»ºçš„ç»“æœï¼Œè¿™èƒŒåæ˜¯é€šè¿‡å®Œå–„ä¸”å¼ºå¤§çš„ä¾èµ–åŒ…ç‰ˆæœ¬ç®¡ç†æ¥å®ç°çš„ã€‚

æ€»ä¹‹ï¼Œ`Cargo` ä¸ºäº†å®ç°ç›®æ ‡ï¼Œåšäº†å››ä»¶äº‹ï¼š

- å¼•å…¥ä¸¤ä¸ªå…ƒæ•°æ®æ–‡ä»¶ï¼ŒåŒ…å«é¡¹ç›®çš„æ–¹æ–¹é¢é¢ä¿¡æ¯: `Cargo.toml` å’Œ `Cargo.lock`
- è·å–å’Œæ„å»ºé¡¹ç›®çš„ä¾èµ–ï¼Œä¾‹å¦‚ `Cargo.toml` ä¸­çš„ä¾èµ–åŒ…ç‰ˆæœ¬æè¿°ï¼Œä»¥åŠä» `crates.io` ä¸‹è½½åŒ…
- è°ƒç”¨ `rustc` (æˆ–å…¶å®ƒç¼–è¯‘å™¨) å¹¶ä½¿ç”¨çš„æ­£ç¡®çš„å‚æ•°æ¥æ„å»ºé¡¹ç›®ï¼Œä¾‹å¦‚ `cargo build`
- å¼•å…¥ä¸€äº›æƒ¯ä¾‹ï¼Œè®©é¡¹ç›®çš„ä½¿ç”¨æ›´åŠ ç®€å•

æ¯«ä¸å¤¸å¼ çš„è¯´ï¼Œå¾—ç›Šäº `Cargo` çš„æ ‡å‡†åŒ–ï¼Œåªè¦ä½ ä½¿ç”¨å®ƒæ„å»ºè¿‡ä¸€ä¸ªé¡¹ç›®ï¼Œé‚£æ„å»ºå…¶å®ƒä½¿ç”¨ `Cargo` çš„é¡¹ç›®ï¼Œä¹Ÿå°†ä¸å­˜åœ¨ä»»ä½•å›°éš¾ã€‚




================================================
FILE: src/cargo/reference/cargo-target.md
================================================
# Cargo Target

**Cargo é¡¹ç›®ä¸­åŒ…å«æœ‰ä¸€äº›å¯¹è±¡ï¼Œå®ƒä»¬åŒ…å«çš„æºä»£ç æ–‡ä»¶å¯ä»¥è¢«ç¼–è¯‘æˆç›¸åº”çš„åŒ…ï¼Œè¿™äº›å¯¹è±¡è¢«ç§°ä¹‹ä¸º Cargo Target**ã€‚ä¾‹å¦‚[ä¹‹å‰ç« èŠ‚](https://course.rs/cargo/guide/package-layout.html)æåˆ°çš„åº“å¯¹è±¡ `Library` ã€äºŒè¿›åˆ¶å¯¹è±¡ `Binary`ã€ç¤ºä¾‹å¯¹è±¡ `Examples`ã€æµ‹è¯•å¯¹è±¡ `Tests` å’Œ åŸºå‡†æ€§èƒ½å¯¹è±¡ `Benches` éƒ½æ˜¯ Cargo Targetã€‚

æœ¬ç« èŠ‚æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•åœ¨ `Cargo.toml` æ¸…å•ä¸­é…ç½®è¿™äº›å¯¹è±¡ï¼Œå½“ç„¶ï¼Œå¤§éƒ¨åˆ†æ—¶å€™éƒ½æ— éœ€æ‰‹åŠ¨é…ç½®ï¼Œå› ä¸ºé»˜è®¤çš„é…ç½®é€šå¸¸ç”±é¡¹ç›®ç›®å½•çš„å¸ƒå±€è‡ªåŠ¨æ¨æ–­å‡ºæ¥ã€‚

## å¯¹è±¡ä»‹ç»

åœ¨å¼€å§‹è®²è§£å¦‚ä½•é…ç½®å¯¹è±¡å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¿™äº›å¯¹è±¡ç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼Œä¼°è®¡è¿˜æœ‰äº›åŒå­¦å¯¹æ­¤æœ‰äº›è¿·ç³Š :)

#### åº“å¯¹è±¡(Library)

åº“å¯¹è±¡ç”¨äºå®šä¹‰ä¸€ä¸ªåº“ï¼Œè¯¥åº“å¯ä»¥è¢«å…¶å®ƒçš„åº“æˆ–è€…å¯æ‰§è¡Œæ–‡ä»¶æ‰€é“¾æ¥ã€‚**è¯¥å¯¹è±¡åŒ…å«çš„é»˜è®¤æ–‡ä»¶åæ˜¯ `src/lib.rs`ï¼Œä¸”é»˜è®¤æƒ…å†µä¸‹ï¼Œåº“å¯¹è±¡çš„åç§°[è·Ÿé¡¹ç›®åæ˜¯ä¸€è‡´çš„](https://course.rs/basic/crate-module/crate.html#package)**ï¼Œ

ä¸€ä¸ªå·¥ç¨‹åªèƒ½æœ‰ä¸€ä¸ªåº“å¯¹è±¡ï¼Œå› æ­¤ä¹Ÿåªèƒ½æœ‰ä¸€ä¸ª `src/lib.rs` æ–‡ä»¶ï¼Œä»¥ä¸‹æ˜¯ä¸€ç§è‡ªå®šä¹‰é…ç½®:

```shell
# ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼šåœ¨ Cargo.toml ä¸­å®šåˆ¶åŒ–åº“å¯¹è±¡
[lib]
crate-type = ["cdylib"]
bench = false
```

#### äºŒè¿›åˆ¶å¯¹è±¡(Binaries)

äºŒè¿›åˆ¶å¯¹è±¡åœ¨è¢«ç¼–è¯‘åå¯ä»¥ç”Ÿæˆå¯æ‰§è¡Œçš„æ–‡ä»¶ï¼Œé»˜è®¤çš„æ–‡ä»¶åæ˜¯ `src/main.rs`ï¼ŒäºŒè¿›åˆ¶å¯¹è±¡çš„åç§°è·Ÿé¡¹ç›®åä¹Ÿæ˜¯ç›¸åŒçš„ã€‚

å¤§å®¶åº”è¯¥è¿˜è®°å¾—ï¼Œä¸€ä¸ªé¡¹ç›®æ‹¥æœ‰å¤šä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå› æ­¤ä¸€ä¸ªé¡¹ç›®å¯ä»¥æ‹¥æœ‰å¤šä¸ªäºŒè¿›åˆ¶å¯¹è±¡ã€‚å½“æ‹¥æœ‰å¤šä¸ªå¯¹è±¡æ—¶ï¼Œå¯¹è±¡çš„æ–‡ä»¶é»˜è®¤ä¼šè¢«æ”¾åœ¨ `src/bin/` ç›®å½•ä¸‹ã€‚

äºŒè¿›åˆ¶å¯¹è±¡å¯ä»¥ä½¿ç”¨åº“å¯¹è±¡æä¾›çš„å…¬å…± APIï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `[dependencies]` æ¥å¼•å…¥å¤–éƒ¨çš„ä¾èµ–åº“ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `cargo run --bin <bin-name>` çš„æ–¹å¼æ¥è¿è¡ŒæŒ‡å®šçš„äºŒè¿›åˆ¶å¯¹è±¡ï¼Œä»¥ä¸‹æ˜¯äºŒè¿›åˆ¶å¯¹è±¡çš„é…ç½®ç¤ºä¾‹ï¼š

```toml
# Example of customizing binaries in Cargo.toml.
[[bin]]
name = "cool-tool"
test = false
bench = false

[[bin]]
name = "frobnicator"
required-features = ["frobnicate"]
```

#### ç¤ºä¾‹å¯¹è±¡(Examples)

ç¤ºä¾‹å¯¹è±¡çš„æ–‡ä»¶åœ¨æ ¹ç›®å½•ä¸‹çš„ `examples` ç›®å½•ä¸­ã€‚æ—¢ç„¶æ˜¯ç¤ºä¾‹ï¼Œè‡ªç„¶æ˜¯ä½¿ç”¨é¡¹ç›®ä¸­çš„åº“å¯¹è±¡çš„åŠŸèƒ½è¿›è¡Œæ¼”ç¤ºã€‚ç¤ºä¾‹å¯¹è±¡ç¼–è¯‘åçš„æ–‡ä»¶ä¼šå­˜å‚¨åœ¨ `target/debug/examples` ç›®å½•ä¸‹ã€‚

å¦‚ä¸Šæ‰€ç¤ºï¼Œç¤ºä¾‹å¯¹è±¡å¯ä»¥ä½¿ç”¨åº“å¯¹è±¡çš„å…¬å…± APIï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `[dependencies]` æ¥å¼•å…¥å¤–éƒ¨çš„ä¾èµ–åº“ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œç¤ºä¾‹å¯¹è±¡éƒ½æ˜¯å¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶( å¸¦æœ‰ `fn main()` å‡½æ•°å…¥å£)ï¼Œæ¯•ç«Ÿä¾‹å­æ˜¯ç”¨æ¥æµ‹è¯•å’Œæ¼”ç¤ºæˆ‘ä»¬çš„åº“å¯¹è±¡ï¼Œæ˜¯ç”¨æ¥è¿è¡Œçš„ã€‚è€Œä½ å®Œå…¨å¯ä»¥å°†ç¤ºä¾‹å¯¹è±¡æ”¹æˆåº“çš„ç±»å‹:

```toml
[[example]]
name = "foo"
crate-type = ["staticlib"]
```

å¦‚æœæƒ³è¦æŒ‡å®šè¿è¡ŒæŸä¸ªç¤ºä¾‹å¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨ `cargo run --example <example-name>` å‘½ä»¤ã€‚å¦‚æœæ˜¯åº“ç±»å‹çš„ç¤ºä¾‹å¯¹è±¡ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ `cargo build --example <example-name>` è¿›è¡Œæ„å»ºã€‚

ä¸æ­¤ç±»ä¼¼ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `cargo install --example <example-name>` æ¥å°†ç¤ºä¾‹å¯¹è±¡ç¼–è¯‘å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶å®‰è£…åˆ°é»˜è®¤çš„ç›®å½•ä¸­ï¼Œå°†è¯¥ç›®å½•æ·»åŠ åˆ° `$PATH` ç¯å¢ƒå˜é‡ä¸­ï¼Œå°±å¯ä»¥ç›´æ¥å…¨å±€è¿è¡Œå®‰è£…çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚

æœ€åï¼Œ`cargo test` å‘½ä»¤é»˜è®¤ä¼šå¯¹ç¤ºä¾‹å¯¹è±¡è¿›è¡Œç¼–è¯‘ï¼Œä»¥é˜²æ­¢ç¤ºä¾‹ä»£ç å› ä¸ºé•¿ä¹…æ²¡è¿è¡Œï¼Œå¯¼è‡´ä¸¥é‡è¿‡æœŸä»¥è‡³äºæ— æ³•è¿è¡Œã€‚

#### æµ‹è¯•å¯¹è±¡(Tests)

æµ‹è¯•å¯¹è±¡çš„æ–‡ä»¶ä½äºæ ¹ç›®å½•ä¸‹çš„ `tests` ç›®å½•ä¸­ï¼Œå¦‚æœå¤§å®¶è¿˜æœ‰å°è±¡çš„è¯ï¼Œå°±çŸ¥é“è¯¥ç›®å½•æ˜¯[é›†æˆæµ‹è¯•](https://course.rs/test/unit-integration-test.html#é›†æˆæµ‹è¯•)æ‰€ä½¿ç”¨çš„ã€‚

å½“è¿è¡Œ `cargo test` æ—¶ï¼Œé‡Œé¢çš„æ¯ä¸ªæ–‡ä»¶éƒ½ä¼šè¢«ç¼–è¯‘æˆç‹¬ç«‹çš„åŒ…ï¼Œç„¶åè¢«æ‰§è¡Œã€‚

æµ‹è¯•å¯¹è±¡å¯ä»¥ä½¿ç”¨åº“å¯¹è±¡æä¾›çš„å…¬å…± APIï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `[dependencies]` æ¥å¼•å…¥å¤–éƒ¨çš„ä¾èµ–åº“ã€‚

#### åŸºå‡†æ€§èƒ½å¯¹è±¡(Benches)

è¯¥å¯¹è±¡çš„æ–‡ä»¶ä½äº `benches` ç›®å½•ä¸‹ï¼Œå¯ä»¥é€šè¿‡ `cargo bench` å‘½ä»¤æ¥è¿è¡Œï¼Œå…³äºåŸºå‡†æµ‹è¯•ï¼Œå¯ä»¥é€šè¿‡[è¿™ç¯‡æ–‡ç« ](https://course.rs/test/benchmark.html)äº†è§£æ›´å¤šã€‚

## é…ç½®ä¸€ä¸ªå¯¹è±¡

æˆ‘ä»¬å¯ä»¥é€šè¿‡ `Cargo.toml` ä¸­çš„ `[lib]`ã€`[[bin]]`ã€`[[example]]`ã€`[[test]]` å’Œ `[[bench]]` éƒ¨åˆ†å¯¹ä»¥ä¸Šå¯¹è±¡è¿›è¡Œé…ç½®ã€‚

> å¤§å®¶å¯èƒ½ä¼šç–‘æƒ‘ `[lib]` å’Œ `[[bin]]` çš„å†™æ³•ä¸ºä½•ä¸ä¸€è‡´ï¼ŒåŸå› æ˜¯è¿™ç§è¯­æ³•æ˜¯ `TOML` æä¾›çš„[æ•°ç»„ç‰¹æ€§](https://toml.io/en/v1.0.0-rc.3#array-of-tables)ï¼Œ `[[bin]]` è¿™ç§å†™æ³•æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨ Cargo.toml ä¸­åˆ›å»ºå¤šä¸ª `[[bin]]` ï¼Œæ¯ä¸€ä¸ªå¯¹åº”ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
>
> ä¸Šæ–‡æåˆ°è¿‡ï¼Œæˆ‘ä»¬åªèƒ½æŒ‡å®šä¸€ä¸ªåº“å¯¹è±¡ï¼Œå› æ­¤è¿™é‡Œåªèƒ½ä½¿ç”¨ `[lib]` å½¢å¼

ç”±äºå®ƒä»¬çš„é…ç½®å†…å®¹éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œå› æ­¤æˆ‘ä»¬ä»¥ `[lib]` ä¸ºä¾‹æ¥è¯´æ˜ç›¸åº”çš„é…ç½®é¡¹:

```toml
[lib]
name = "foo"           # å¯¹è±¡åç§°: åº“å¯¹è±¡ã€`src/main.rs` äºŒè¿›åˆ¶å¯¹è±¡çš„åç§°é»˜è®¤æ˜¯é¡¹ç›®å
path = "src/lib.rs"    # å¯¹è±¡çš„æºæ–‡ä»¶è·¯å¾„
test = true            # èƒ½å¦è¢«æµ‹è¯•ï¼Œé»˜è®¤æ˜¯ true
doctest = true         # æ–‡æ¡£æµ‹è¯•æ˜¯å¦å¼€å¯ï¼Œé»˜è®¤æ˜¯ true
bench = true           # åŸºå‡†æµ‹è¯•æ˜¯å¦å¼€å¯
doc = true             # æ–‡æ¡£åŠŸèƒ½æ˜¯å¦å¼€å¯
plugin = false         # æ˜¯å¦å¯ä»¥ç”¨äºç¼–è¯‘å™¨æ’ä»¶(deprecated).
proc-macro = false     # æ˜¯å¦æ˜¯è¿‡ç¨‹å®ç±»å‹çš„åº“
harness = true         # æ˜¯å¦ä½¿ç”¨libtest harness : https://doc.rust-lang.org/stable/rustc/tests/index.html
edition = "2015"       # å¯¹è±¡ä½¿ç”¨çš„ Rust Edition
crate-type = ["lib"]   # ç”Ÿæˆçš„åŒ…ç±»å‹
required-features = [] # æ„å»ºå¯¹è±¡æ‰€éœ€çš„ Cargo Features (N/A for lib).
```

#### name

å¯¹äºåº“å¯¹è±¡å’Œé»˜è®¤çš„äºŒè¿›åˆ¶å¯¹è±¡( `src/main.rs `)ï¼Œé»˜è®¤çš„åç§°æ˜¯é¡¹ç›®çš„åç§°( `package.name` )ã€‚

å¯¹äºå…¶å®ƒç±»å‹çš„å¯¹è±¡ï¼Œé»˜è®¤æ˜¯ç›®å½•æˆ–æ–‡ä»¶åã€‚

é™¤äº† `[lib]` å¤–ï¼Œ`name` å­—æ®µå¯¹äºå…¶ä»–å¯¹è±¡éƒ½æ˜¯å¿…é¡»çš„ã€‚

#### proc-macro

è¯¥å­—æ®µçš„ä½¿ç”¨æ–¹å¼åœ¨[è¿‡ç¨‹å®ç« èŠ‚](https://course.rs/advance/macro.html#å®šä¹‰è¿‡ç¨‹å®)æœ‰è¯¦ç»†çš„ä»‹ç»ã€‚

#### edition

å¯¹ä½¿ç”¨çš„ Rust Edition ç‰ˆæœ¬è¿›è¡Œè®¾ç½®ã€‚

å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œåˆ™é»˜è®¤ä½¿ç”¨ `[package]` ä¸­é…ç½®çš„ `package.edition`ï¼Œé€šå¸¸æ¥è¯´ï¼Œè¿™ä¸ªå­—æ®µä¸åº”è¯¥è¢«å•ç‹¬è®¾ç½®ï¼Œåªæœ‰åœ¨ä¸€äº›ç‰¹æ®Šåœºæ™¯ä¸­æ‰å¯èƒ½ç”¨åˆ°ï¼šä¾‹å¦‚å°†ä¸€ä¸ªå¤§å‹é¡¹ç›®é€æ­¥å‡çº§ä¸ºæ–°çš„ edition ç‰ˆæœ¬ã€‚

#### crate-type

è¯¥å­—æ®µå®šä¹‰äº†å¯¹è±¡ç”Ÿæˆçš„[åŒ…ç±»å‹](https://doc.rust-lang.org/stable/reference/linkage.html)ã€‚å®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå› æ­¤ä¸ºåŒä¸€ä¸ªå¯¹è±¡æŒ‡å®šå¤šä¸ªåŒ…ç±»å‹ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåªæœ‰åº“å¯¹è±¡å’Œç¤ºä¾‹å¯¹è±¡å¯ä»¥è¢«æŒ‡å®šï¼Œå› ä¸ºå…¶ä»–çš„äºŒè¿›åˆ¶ã€æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•å¯¹è±¡åªèƒ½æ˜¯ `bin` è¿™ä¸ªåŒ…ç±»å‹ã€‚

é»˜è®¤çš„åŒ…ç±»å‹å¦‚ä¸‹:

| å¯¹è±¡           | åŒ…ç±»å‹       |
| -------------- | ------------ |
| æ­£å¸¸çš„åº“å¯¹è±¡   | "lib"        |
| è¿‡ç¨‹å®çš„åº“å¯¹è±¡ | "proc-macro" |
| ç¤ºä¾‹å¯¹è±¡       | "bin"        |

å¯ç”¨çš„é€‰é¡¹åŒ…æ‹¬ `bin`ã€`lib`ã€`rlib`ã€`dylib`ã€`cdylib`ã€`staticlib` å’Œ `proc-macro` ï¼Œå¦‚æœå¤§å®¶æƒ³äº†è§£æ›´å¤šï¼Œå¯ä»¥çœ‹ä¸‹å®˜æ–¹çš„[å‚è€ƒæ‰‹å†Œ](https://doc.rust-lang.org/stable/reference/linkage.html)ã€‚

#### required-features

è¯¥å­—æ®µç”¨äºæŒ‡å®šåœ¨æ„å»ºå¯¹è±¡æ—¶æ‰€éœ€çš„ [`features`](https://course.rs/cargo/reference/features.html) åˆ—è¡¨ã€‚

è¯¥å­—æ®µåªå¯¹ `[[bin]]`ã€ `[[bench]]`ã€ `[[test]]` å’Œ `[[example]]` æœ‰æ•ˆï¼Œå¯¹äº `[lib]` æ²¡æœ‰ä»»ä½•æ•ˆæœã€‚

```toml
[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = "my-pg-tool"
required-features = ["postgres", "tools"]
```

## å¯¹è±¡è‡ªåŠ¨å‘ç°

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`Cargo` ä¼šåŸºäºé¡¹ç›®çš„[ç›®å½•æ–‡ä»¶å¸ƒå±€](https://course.rs/cargo/guide/package-layout.html)è‡ªåŠ¨å‘ç°å’Œç¡®å®šå¯¹è±¡ï¼Œè€Œä¹‹å‰çš„é…ç½®é¡¹åˆ™å…è®¸æˆ‘ä»¬å¯¹å…¶è¿›è¡Œæ‰‹åŠ¨çš„é…ç½®ä¿®æ”¹(è‹¥é¡¹ç›®å¸ƒå±€è·Ÿæ ‡å‡†çš„ä¸ä¸€æ ·æ—¶)ã€‚

è€Œè¿™ç§è‡ªåŠ¨å‘ç°å¯¹è±¡çš„è®¾å®šå¯ä»¥é€šè¿‡ä»¥ä¸‹é…ç½®æ¥ç¦ç”¨:

```toml
[package]
# ...
autobins = false
autoexamples = false
autotests = false
autobenches = false
```

åªæœ‰åœ¨ç‰¹å®šåœºæ™¯ä¸‹æ‰åº”è¯¥ç¦ç”¨è‡ªåŠ¨å¯¹è±¡å‘ç°ã€‚ä¾‹å¦‚ï¼Œä½ æœ‰ä¸€ä¸ªæ¨¡å—æƒ³è¦å‘½åä¸º `bin`ï¼Œç›®å½•ç»“æ„å¦‚ä¸‹:

```shell
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
 Â Â  â”œâ”€â”€ lib.rs
 Â Â  â””â”€â”€ bin
 Â Â   Â Â  â””â”€â”€ mod.rs
```

è¿™åœ¨é»˜è®¤æƒ…å†µä¸‹ä¼šå¯¼è‡´é—®é¢˜ï¼Œå› ä¸º `Cargo` ä¼šä½¿ç”¨ `src/bin` ä½œä¸ºå­˜æ”¾äºŒè¿›åˆ¶å¯¹è±¡çš„åœ°æ–¹ã€‚

ä¸ºäº†é˜»æ­¢è¿™ä¸€ç‚¹ï¼Œå¯ä»¥è®¾ç½® `autobins = false` :

```toml
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
 Â Â  â”œâ”€â”€ lib.rs
 Â Â  â””â”€â”€ bin
 Â Â   Â Â  â””â”€â”€ mod.rs
```



================================================
FILE: src/cargo/reference/configuration.md
================================================
# é€šè¿‡ config.toml å¯¹ Cargo è¿›è¡Œé…ç½®

Cargo ç›¸å…³çš„é…ç½®æœ‰ä¸¤ç§ï¼Œç¬¬ä¸€ç§æ˜¯å¯¹è‡ªèº«è¿›è¡Œé…ç½®ï¼Œç¬¬äºŒç§æ˜¯å¯¹æŒ‡å®šçš„é¡¹ç›®è¿›è¡Œé…ç½®ï¼Œå…³äºåè€…è¯·æŸ¥çœ‹ [Cargo.toml æ¸…å•](https://course.rs/cargo/reference/manifest.html)ã€‚å¯¹äºæ™®é€šç”¨æˆ·è€Œè¨€ç¬¬äºŒç§æ‰æ˜¯æˆ‘ä»¬æœ€å¸¸ä½¿ç”¨çš„ã€‚

æœ¬æ–‡è®²è¿°çš„æ˜¯å¦‚ä½•å¯¹ Cargo ç›¸å…³çš„å·¥å…·è¿›è¡Œé…ç½®ï¼Œè¯¥é…ç½®ä¸­çš„éƒ¨åˆ†å†…å®¹å¯èƒ½ä¼šè¦†ç›–æ‰ `Cargo.toml` ä¸­å¯¹åº”çš„éƒ¨åˆ†ï¼Œä¾‹å¦‚å…³äº `profile` çš„å†…å®¹ã€‚

## å±‚çº§ç»“æ„

åœ¨å‰é¢æˆ‘ä»¬å·²ç»è§è¯†è¿‡å¦‚ä½•ä¸º Cargo è¿›è¡Œå…¨å±€é…ç½®ï¼š`$HOME/.cargo/config.toml`ï¼Œäº‹å®ä¸Šï¼Œè¿˜æ”¯æŒåœ¨ä¸€ä¸ª `package` å†…å¯¹å®ƒè¿›è¡Œé…ç½®ã€‚

æ€»ä½“åŸåˆ™æ˜¯ï¼š`Cargo` ä¼šé¡ºç€å½“å‰ç›®å½•å¾€ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡é…ç½®æ–‡ä»¶ã€‚ä¾‹å¦‚æˆ‘ä»¬åœ¨ç›®å½• `/projects/foo/bar/baz` ä¸‹è°ƒç”¨ Cargo å‘½ä»¤ï¼Œé‚£æŸ¥æ‰¾è·¯å¾„å¦‚ä¸‹æ‰€ç¤ºï¼š

- `/projects/foo/bar/baz/.cargo/config.toml`
- `/projects/foo/bar/.cargo/config.toml`
- `/projects/foo/.cargo/config.toml`
- `/projects/.cargo/config.toml`
- `/.cargo/config.toml`
- `$CARGO_HOME/config.toml` é»˜è®¤æ˜¯ :
  - Windows: `%USERPROFILE%\.cargo\config.toml`
  - Unix: `$HOME/.cargo/config.toml`

æœ‰äº†è¿™ç§æœºåˆ¶ï¼Œæˆ‘ä»¬æ—¢å¯ä»¥åœ¨å…¨å±€ä¸­è®¾ç½®é»˜è®¤çš„é…ç½®ï¼Œåˆå¯ä»¥æ¯ä¸ªåŒ…éƒ½è®¾å®šç‹¬ç«‹çš„é…ç½®ï¼Œç”šè‡³è¿˜èƒ½åšç‰ˆæœ¬æ§åˆ¶ã€‚

å¦‚æœä¸€ä¸ª `key` åœ¨å¤šä¸ªé…ç½®ä¸­å‡ºç°ï¼Œé‚£è¿™äº› `key` åªä¼šä¿ç•™ä¸€ä¸ªï¼šæœ€é è¿‘ Cargo æ‰§è¡Œç›®å½•çš„é…ç½®æ–‡ä»¶ä¸­çš„ key çš„å€¼å°†è¢«æœ€ç»ˆä½¿ç”¨(å› æ­¤ï¼Œ $HOME ä¸‹çš„éƒ½æ˜¯æœ€ä½ä¼˜å…ˆçº§)ã€‚**éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ `key` çš„å€¼æ˜¯æ•°ç»„ï¼Œé‚£ç›¸åº”çš„å€¼å°†è¢«åˆå¹¶( join )**ã€‚

å¯¹äºå·¥ä½œç©ºé—´è€Œè¨€ï¼Œ`Cargo` çš„æœç´¢ç­–ç•¥æ˜¯ä» root å¼€å§‹ï¼Œå¯¹äºå†…éƒ¨æˆå‘˜ä¸­åŒ…å«çš„ `.cargo.toml` ä¼šè‡ªåŠ¨å¿½ç•¥ã€‚ä¾‹å¦‚ä¸€ä¸ªå·¥ä½œç©ºé—´æ‹¥æœ‰ä¸¤ä¸ªæˆå‘˜ï¼Œæ¯ä¸ªæˆå‘˜éƒ½æœ‰é…ç½®æ–‡ä»¶: `/projects/foo/bar/baz/mylib/.cargo/config.toml` å’Œ `/projects/foo/bar/baz/mybin/.cargo/config.toml`ï¼Œä½†æ˜¯ `Cargo` å¹¶ä¸ä¼šè¯»å–å®ƒä»¬è€Œæ˜¯ä»å·¥ä½œç©ºé—´çš„æ ¹( `/projects/foo/bar/baz/` )å¼€å§‹å¾€ä¸ŠæŸ¥æ‰¾ã€‚

> æ³¨æ„ï¼šCargo è¿˜æ”¯æŒæ²¡æœ‰ `.toml` åç¼€çš„ `.cargo/config` æ–‡ä»¶ã€‚å¯¹äº `.toml` çš„æ”¯æŒæ˜¯ä» Rust 1.39 ç‰ˆæœ¬å¼€å§‹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç›®å‰æœ€æ¨èçš„æ–¹å¼ã€‚**ä½†è‹¥åŒæ—¶å­˜åœ¨æœ‰åç¼€å’Œæ— åç¼€çš„æ–‡ä»¶ï¼ŒCargo å°†ä½¿ç”¨æ— åç¼€çš„!**

## é…ç½®æ–‡ä»¶æ¦‚è§ˆ

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„é…ç½®æ–‡ä»¶ï¼Œå¹¶å¯¹**å¸¸ç”¨çš„é€‰é¡¹**è¿›è¡Œäº†ç¿»è¯‘ï¼Œå¤§å®¶å¯ä»¥å‚è€ƒä¸‹:

```toml
paths = ["/path/to/override"] # è¦†ç›– `Cargo.toml` ä¸­é€šè¿‡ path å¼•å…¥çš„æœ¬åœ°ä¾èµ–

[alias]     # å‘½ä»¤åˆ«å
b = "build"
c = "check"
t = "test"
r = "run"
rr = "run --release"
space_example = ["run", "--release", "--", "\"command list\""]

[build]
jobs = 1                      # å¹¶è¡Œæ„å»ºä»»åŠ¡çš„æ•°é‡ï¼Œé»˜è®¤ç­‰äº CPU çš„æ ¸å¿ƒæ•°
rustc = "rustc"               # rust ç¼–è¯‘å™¨
rustc-wrapper = "â€¦"           # ä½¿ç”¨è¯¥ wrapper æ¥æ›¿ä»£ rustc
rustc-workspace-wrapper = "â€¦" # ä¸ºå·¥ä½œç©ºé—´çš„æˆå‘˜ä½¿ç”¨ è¯¥ wrapper æ¥æ›¿ä»£ rustc
rustdoc = "rustdoc"           # æ–‡æ¡£ç”Ÿæˆå·¥å…·
target = "triple"             # ä¸º target triple æ„å»º ( `cargo install` ä¼šå¿½ç•¥è¯¥é€‰é¡¹)
target-dir = "target"         # å­˜æ”¾ç¼–è¯‘è¾“å‡ºç»“æœçš„ç›®å½•
rustflags = ["â€¦", "â€¦"]        # è‡ªå®šä¹‰flagsï¼Œä¼šä¼ é€’ç»™æ‰€æœ‰çš„ç¼–è¯‘å™¨å‘½ä»¤è°ƒç”¨
rustdocflags = ["â€¦", "â€¦"]     # è‡ªå®šä¹‰flagsï¼Œä¼ é€’ç»™ rustdoc
incremental = true            # æ˜¯å¦å¼€å¯å¢é‡ç¼–è¯‘
dep-info-basedir = "â€¦"        # path for the base directory for targets in depfiles
pipelining = true             # rustc pipelining

[doc]
browser = "chromium"          # `cargo doc --open` ä½¿ç”¨çš„æµè§ˆå™¨,
                              # å¯ä»¥é€šè¿‡ `BROWSER` ç¯å¢ƒå˜é‡è¿›è¡Œé‡å†™

[env]
# Set ENV_VAR_NAME=value for any process run by Cargo
ENV_VAR_NAME = "value"
# Set even if already present in environment
ENV_VAR_NAME_2 = { value = "value", force = true }
# Value is relative to .cargo directory containing `config.toml`, make absolute
ENV_VAR_NAME_3 = { value = "relative/path", relative = true }

[cargo-new]
vcs = "none"              # æ‰€ä½¿ç”¨çš„ VCS  ('git', 'hg', 'pijul', 'fossil', 'none')

[http]
debug = false               # HTTP debugging
proxy = "host:port"         # HTTP ä»£ç†ï¼Œlibcurl æ ¼å¼
ssl-version = "tlsv1.3"     # TLS version to use
ssl-version.max = "tlsv1.3" # æœ€é«˜æ”¯æŒçš„ TLS ç‰ˆæœ¬
ssl-version.min = "tlsv1.1" # æœ€å°æ”¯æŒçš„ TLS ç‰ˆæœ¬
timeout = 30                # HTTP è¯·æ±‚çš„è¶…æ—¶æ—¶é—´ï¼Œç§’
low-speed-limit = 10        # ç½‘ç»œè¶…æ—¶é˜ˆå€¼ (bytes/sec)
cainfo = "cert.pem"         # path to Certificate Authority (CA) bundle
check-revoke = true         # check for SSL certificate revocation
multiplexing = true         # HTTP/2 multiplexing
user-agent = "â€¦"            # the user-agent header

[install]
root = "/some/path"         # `cargo install` å®‰è£…åˆ°çš„ç›®æ ‡ç›®å½•

[net]
retry = 2                   # ç½‘ç»œé‡è¯•æ¬¡æ•°
git-fetch-with-cli = true   # æ˜¯å¦ä½¿ç”¨ `git` å‘½ä»¤æ¥æ‰§è¡Œ git æ“ä½œ
offline = true              # ä¸èƒ½è®¿é—®ç½‘ç»œ

[patch.<registry>]
# Same keys as for [patch] in Cargo.toml

[profile.<name>]         # profile é…ç½®ï¼Œè¯¦æƒ…è§"å¦‚ä½•åœ¨ Cargo.toml ä¸­é…ç½® profile" : https://course.rs/cargo/reference/profiles.html#profileè®¾ç½®
opt-level = 0
debug = true
split-debuginfo = '...'
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 16
rpath = false
[profile.<name>.build-override]
[profile.<name>.package.<name>]

[registries.<name>]  # è®¾ç½®å…¶å®ƒçš„æ³¨å†ŒæœåŠ¡ï¼š https://course.rs/cargo/reference/specify-deps.html#ä»å…¶å®ƒæ³¨å†ŒæœåŠ¡å¼•å…¥ä¾èµ–åŒ…
index = "â€¦"          # æ³¨å†ŒæœåŠ¡ç´¢å¼•åˆ—è¡¨çš„ URL
token = "â€¦"          # è¿æ¥æ³¨å†ŒæœåŠ¡æ‰€éœ€çš„é‰´æƒ token

[registry]
default = "â€¦"        # é»˜è®¤çš„æ³¨å†ŒæœåŠ¡åç§°: crates.io
token = "â€¦"

[source.<name>]      # æ³¨å†ŒæœåŠ¡æºå’Œæ›¿æ¢source definition and replacement
replace-with = "â€¦"   # ä½¿ç”¨ç»™å®šçš„ source æ¥æ›¿æ¢å½“å‰çš„ sourceï¼Œä¾‹å¦‚ä½¿ç”¨ç§‘å¤§æºæ¥æ›¿æ¢crates.ioæºä»¥æå‡å›½å†…çš„ä¸‹è½½é€Ÿåº¦ï¼š[source.crates-io] replace-with = 'ustc'
directory = "â€¦"      # path to a directory source
registry = "â€¦"       # æ³¨å†Œæºçš„ URL ï¼Œä¾‹å¦‚ç§‘å¤§æº: [source.ustc] registry = "git://mirrors.ustc.edu.cn/crates.io-index"
local-registry = "â€¦" # path to a local registry source
git = "â€¦"            # URL of a git repository source
branch = "â€¦"         # branch name for the git repository
tag = "â€¦"            # tag name for the git repository
rev = "â€¦"            # revision for the git repository

[target.<triple>]
linker = "â€¦"            # linker to use
runner = "â€¦"            # wrapper to run executables
rustflags = ["â€¦", "â€¦"]  # custom flags for `rustc`

[target.<cfg>]
runner = "â€¦"            # wrapper to run executables
rustflags = ["â€¦", "â€¦"]  # custom flags for `rustc`

[target.<triple>.<links>] # `links` build script override
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = ["-L", "/some/path"]
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["â€¦"]
metadata_key1 = "value"
metadata_key2 = "value"

[term]
verbose = false        # whether cargo provides verbose output
color = 'auto'         # whether cargo colorizes output
progress.when = 'auto' # whether cargo shows progress bar
progress.width = 80    # width of progress bar
```

## ç¯å¢ƒå˜é‡

é™¤äº† `config.toml` é…ç½®æ–‡ä»¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ç¯å¢ƒå˜é‡çš„æ–¹å¼å¯¹ Cargo è¿›è¡Œé…ç½®ã€‚

é…ç½®æ–‡ä»¶çš„ä¸­çš„ key `foo.bar` å¯¹åº”çš„ç¯å¢ƒå˜é‡å½¢å¼ä¸º `CARGO_FOO_BAR`ï¼Œå…¶ä¸­çš„`.`ã€`-` è¢«è½¬æ¢æˆ `_`ï¼Œä¸”å­—æ¯éƒ½å˜æˆå¤§å†™çš„ã€‚ä¾‹å¦‚ï¼Œ`target.x86_64-unknown-linux-gnu.runner` key è½¬æ¢æˆç¯å¢ƒå˜é‡åå˜æˆ `CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER`ã€‚

å°±ä¼˜å…ˆçº§è€Œè¨€ï¼Œç¯å¢ƒå˜é‡æ˜¯æ¯”é…ç½®æ–‡ä»¶æ›´é«˜çš„ã€‚é™¤äº†ä¸Šé¢çš„æœºåˆ¶ï¼ŒCargo è¿˜æ”¯æŒä¸€äº›[é¢„å®šä¹‰çš„ç¯å¢ƒå˜é‡](https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html)ã€‚

> å®˜æ–¹ Cargo Book ä¸­æœ¬æ–‡çš„å†…å®¹è¿˜æœ‰[å¾ˆå¤š](https://doc.rust-lang.org/stable/cargo/reference/config.html#configuration-keys)ï¼Œä½†æ˜¯å‰©ä½™å†…å®¹å¯¹äºç»å¤§å¤šæ•°ç”¨æˆ·éƒ½ç”¨ä¸åˆ°ï¼Œå› æ­¤æˆ‘ä»¬å¹¶æ²¡æœ‰æ¶µç›–å…¶ä¸­ã€‚



================================================
FILE: src/cargo/reference/deps-overriding.md
================================================
# ä¾èµ–è¦†ç›–

ä¾èµ–è¦†ç›–å¯¹äºæœ¬åœ°å¼€å‘æ¥è¯´ï¼Œæ˜¯å¾ˆå¸¸è§çš„ï¼Œå¤§éƒ¨åˆ†åŸå› éƒ½æ˜¯æˆ‘ä»¬å¸Œæœ›åœ¨æŸä¸ªåŒ…å‘å¸ƒåˆ° `crates.io` ä¹‹å‰ä½¿ç”¨å®ƒï¼Œä¾‹å¦‚ï¼š

- ä½ æ­£åœ¨åŒæ—¶å¼€å‘ä¸€ä¸ªåŒ…å’Œä¸€ä¸ªé¡¹ç›®ï¼Œè€Œåè€…ä¾èµ–äºå‰è€…ï¼Œä½ å¸Œæœ›èƒ½åœ¨è¯¥é¡¹ç›®ä¸­å¯¹æ­£åœ¨å¼€å‘çš„åŒ…è¿›è¡Œæµ‹è¯•
- ä½ å¼•å…¥çš„ä¸€ä¸ªä¾èµ–åŒ…åœ¨ `master` åˆ†æ”¯å‘å¸ƒäº†æ–°çš„ä»£ç ï¼Œæ°å¥½ä¿®å¤äº†æŸä¸ª bugï¼Œå› æ­¤ä½ å¸Œæœ›èƒ½å•ç‹¬å¯¹è¯¥åˆ†æ”¯è¿›è¡Œä¸‹æµ‹è¯•
- ä½ å³å°†å‘å¸ƒä¸€ä¸ªåŒ…çš„æ–°ç‰ˆæœ¬ï¼Œä¸ºäº†ç¡®ä¿æ–°ç‰ˆæœ¬æ­£å¸¸å·¥ä½œï¼Œä½ éœ€è¦å¯¹å…¶è¿›è¡Œé›†æˆæµ‹è¯•
- ä½ ä¸ºé¡¹ç›®çš„æŸä¸ªä¾èµ–åŒ…æäº†ä¸€ä¸ª PR å¹¶è§£å†³äº†ä¸€ä¸ªé‡è¦ bugï¼Œåœ¨ç­‰å¾…åˆå¹¶åˆ° `master` åˆ†æ”¯ï¼Œä½†æ˜¯æ—¶é—´ä¸ç­‰äººï¼Œå› æ­¤ä½ å†³å®šå…ˆä½¿ç”¨è‡ªå·±ä¿®æ”¹çš„ç‰ˆæœ¬ï¼Œç­‰æœªæ¥åˆå¹¶åï¼Œå†ç»§ç»­ä½¿ç”¨å®˜æ–¹ç‰ˆæœ¬

ä¸‹é¢æˆ‘ä»¬æ¥å…·ä½“çœ‹çœ‹ç±»ä¼¼çš„é—®é¢˜è¯¥å¦‚ä½•è§£å†³ã€‚

> ä¸Šä¸€ç« èŠ‚ä¸­æˆ‘ä»¬è®²äº†å¦‚æœé€šè¿‡[å¤šç§å¼•ç”¨æ–¹å¼](https://course.rs/cargo/reference/specify-deps/intro.html#å¤šå¼•ç”¨æ–¹å¼æ··åˆ)æ¥å¼•å…¥ä¸€ä¸ªåŒ…ï¼Œå…¶å®è¿™ä¹Ÿæ˜¯ä¸€ç§ä¾èµ–è¦†ç›–ã€‚

## æµ‹è¯• bugfix ç‰ˆæœ¬

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªé¡¹ç›®æ­£åœ¨ä½¿ç”¨ [`uuid`](https://crates.io/crates/uuid) ä¾èµ–åŒ…ï¼Œä½†æ˜¯å´ä¸å¹¸åœ°å‘ç°äº†ä¸€ä¸ª bugï¼Œç”±äºè¿™ä¸ª bug å½±å“äº†ä½¿ç”¨ï¼Œæ²¡åŠæ³•ç­‰åˆ°å®˜æ–¹æäº¤æ–°ç‰ˆæœ¬ï¼Œå› æ­¤è¿˜æ˜¯è‡ªå·±ä¿®å¤ä¸ºå¥½ã€‚

æˆ‘ä»¬é¡¹ç›®çš„ `Cargo.toml` å†…å®¹å¦‚ä¸‹ï¼š

```toml
[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "0.8.2"
```

ä¸ºäº†ä¿®å¤ `bug`ï¼Œé¦–å…ˆéœ€è¦å°† `uuid` çš„æºç å…‹éš†åˆ°æœ¬åœ°ï¼Œç¬”è€…æ˜¯å…‹éš†åˆ°å’Œé¡¹ç›®åŒçº§çš„ç›®å½•ä¸‹:

```shell
git clone https://github.com/uuid-rs/uuid
```

ä¸‹é¢ï¼Œä¿®æ”¹é¡¹ç›®çš„ `Cargo.toml` æ·»åŠ ä»¥ä¸‹å†…å®¹ä»¥å¼•å…¥æœ¬åœ°å…‹éš†çš„ç‰ˆæœ¬:

```toml
[patch.crates-io]
uuid = { path = "../uuid" }
```

è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨è‡ªå·±ä¿®æ”¹è¿‡çš„ `patch` æ¥è¦†ç›–æ¥è‡ª `crates.io` çš„ç‰ˆæœ¬ï¼Œç”±äºå…‹éš†ä¸‹æ¥çš„ `uuid` ç›®å½•å’Œæˆ‘ä»¬çš„é¡¹ç›®åŒçº§ï¼Œå› æ­¤é€šè¿‡ç›¸å¯¹è·¯å¾„ "../uuid" å³å¯å®šä½åˆ°ã€‚

åœ¨æˆåŠŸä¸º `uuid` æ‰“äº†æœ¬åœ°è¡¥ä¸åï¼Œç°åœ¨å°è¯•åœ¨é¡¹ç›®ä¸‹è¿è¡Œ `cargo build`ï¼Œä½†æ˜¯å´æŠ¥é”™äº†ï¼Œè€Œä¸”æŠ¥é”™å†…å®¹æœ‰ä¸€äº›çœ‹ä¸å¤ªæ‡‚ï¼š

```shell
$ cargo build
    Updating crates.io index
warning: Patch `uuid v1.0.0-alpha.1 (/Users/sunfei/development/rust/demos/uuid)` was not used in the crate graph.
Check that the patched package version and available features are compatible
with the dependency requirements. If the patch has a different version from
what is locked in the Cargo.lock file, run `cargo update` to use the new
version. This may also occur with an optional dependency that is not enabled.
```

å…·ä½“åŸå› æ¯”è¾ƒå¤æ‚ï¼Œä½†æ˜¯ä»”ç»†è§‚å¯Ÿï¼Œä¼šå‘ç°å…‹éš†ä¸‹æ¥çš„ `uuid` çš„ç‰ˆæœ¬æ˜¯ `v1.0.0-alpha.1` (åœ¨ `"../uuid/Cargo.toml"` ä¸­å¯ä»¥æŸ¥çœ‹)ï¼Œç„¶åæˆ‘ä»¬æœ¬åœ°å¼•å…¥çš„ `uuid` ç‰ˆæœ¬æ˜¯ `0.8.2`ï¼Œæ ¹æ®ä¹‹å‰è®²è¿‡çš„ `crates.io` çš„[ç‰ˆæœ¬è§„åˆ™](https://course.rs/cargo/reference/specify-deps/intro.html#ä»-cratesio-å¼•å…¥ä¾èµ–åŒ…)ï¼Œè¿™ä¸¤è€…æ˜¯ä¸å…¼å®¹çš„ï¼Œ`0.8.2` åªèƒ½å‡çº§åˆ° `0.8.z`ï¼Œä¾‹å¦‚ `0.8.3`ã€‚

æ—¢ç„¶å¦‚æ­¤ï¼Œæˆ‘ä»¬å…ˆå°† "../uuid/Cargo.toml" ä¸­çš„ `version = "1.0.0-alpha.1"` ä¿®æ”¹ä¸º `version = "0.8.3"` ï¼Œç„¶åçœ‹çœ‹ç»“æœå…ˆ:

```shell
$ cargo build
    Updating crates.io index
   Compiling uuid v0.8.3 (/Users/sunfei/development/rust/demos/uuid)
```

å¤§å®¶æ³¨æ„åˆ°æœ€åä¸€è¡Œäº†å—ï¼Ÿæˆ‘ä»¬æˆåŠŸä½¿ç”¨æœ¬åœ°çš„ `0.8.3` ç‰ˆæœ¬çš„ `uuid` ä½œä¸ºæœ€æ–°çš„ä¾èµ–ï¼Œå› æ­¤ä¹Ÿä¾§é¢è¯æ˜äº†ï¼Œè¡¥ä¸ `patch` çš„ç‰ˆæœ¬ä¹Ÿå¿…é¡»éµå¾ªç›¸åº”çš„ç‰ˆæœ¬å…¼å®¹è§„åˆ™ï¼

å¦‚æœä¿®æ”¹åè¿˜æ˜¯æœ‰é—®é¢˜ï¼Œå¤§å®¶å¯ä»¥è¯•è¯•ä»¥ä¸‹å‘½ä»¤ï¼ŒæŒ‡å®šç‰ˆæœ¬è¿›è¡Œæ›´æ–°:

```shell
% cargo update -p uuid --precise 0.8.3
    Updating crates.io index
    Updating uuid v0.8.3 (/Users/sunfei/development/rust/demos/uuid) -> v0.8.3
```

ä¿®å¤ bug åï¼Œæˆ‘ä»¬å¯ä»¥æäº¤ pr ç»™ `uuid`ï¼Œä¸€æ—¦ pr è¢«åˆå¹¶åˆ°äº† `master` åˆ†æ”¯ï¼Œä½ å¯ä»¥ç›´æ¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥ä½¿ç”¨è¡¥ä¸:

```toml
[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

ç­‰æœªæ¥æ–°çš„å†…å®¹æ›´æ–°åˆ° `crates.io` åï¼Œå¤§å®¶å°±å¯ä»¥ç§»é™¤è¿™ä¸ªè¡¥ä¸ï¼Œç›´æ¥æ›´æ–° `[dependencies]` ä¸­çš„ `uuid` ç‰ˆæœ¬å³å¯ï¼

## ä½¿ç”¨æœªå‘å¸ƒçš„å°ç‰ˆæœ¬

è¿˜æ˜¯ `uuid` åŒ…ï¼Œè¿™æ¬¡å‡è®¾æˆ‘ä»¬è¦ä¸ºå®ƒæ–°å¢ä¸€ä¸ªç‰¹æ€§ï¼ŒåŒæ—¶æˆ‘ä»¬å·²ç»ä¿®æ”¹å®Œæ¯•ï¼Œåœ¨æœ¬åœ°æµ‹è¯•è¿‡ï¼Œå¹¶æäº¤äº†ç›¸åº”çš„ prï¼Œä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•åœ¨å®ƒå‘å¸ƒåˆ° `crates.io` ä¹‹å‰ç»§ç»­ä½¿ç”¨ã€‚

å†åšä¸€ä¸ªå‡è®¾ï¼Œå¯¹äº `uuid` æ¥è¯´ï¼Œç›®å‰ `crates.io` ä¸Šçš„ç‰ˆæœ¬æ˜¯ `1.0.0`ï¼Œåœ¨æˆ‘ä»¬æäº¤äº† pr å¹¶åˆå¹¶åˆ° `master` åˆ†æ”¯åï¼Œ`master` ä¸Šçš„ç‰ˆæœ¬å˜æˆäº† `1.0.1`ï¼Œè¿™æ„å‘³ç€æœªæ¥ `crates.io` ä¸Šçš„ç‰ˆæœ¬ä¹Ÿå°†å˜æˆ `1.0.1`ã€‚

ä¸ºäº†ä½¿ç”¨æ–°åŠ çš„ç‰¹æ€§ï¼ŒåŒæ—¶å½“è¯¥åŒ…åœ¨æœªæ¥å‘å¸ƒåˆ° `crates.io` åï¼Œæˆ‘ä»¬å¯ä»¥è‡ªåŠ¨ä½¿ç”¨ `crates.io` ä¸Šçš„æ–°ç‰ˆæœ¬ï¼Œè€Œæ— éœ€å†ä½¿ç”¨ `patch` è¡¥ä¸ï¼Œå¯ä»¥è¿™æ ·ä¿®æ”¹ `Cargo.toml`ï¼š

```toml
[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

æ³¨æ„ï¼Œæˆ‘ä»¬å°† `[dependencies]` ä¸­çš„ `uuid` ç‰ˆæœ¬æå‰ä¿®æ”¹ä¸º `1.0.1`ï¼Œç”±äºè¯¥ç‰ˆæœ¬åœ¨ `crates.io` å°šæœªå‘å¸ƒï¼Œå› æ­¤ `patch` ç‰ˆæœ¬ä¼šè¢«ä½¿ç”¨ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬çš„é¡¹ç›®æ˜¯åŸºäº `patch` ç‰ˆæœ¬çš„ `uuid` æ¥æ„å»ºï¼Œä¹Ÿå°±æ˜¯ä» `gihtub` çš„ `master` åˆ†æ”¯ä¸­æ‹‰å–æœ€æ–°çš„ `commit` æ¥æ„å»ºã€‚ä¸€æ—¦æœªæ¥ `crates.io` ä¸Šæœ‰äº† `1.0.1` ç‰ˆæœ¬ï¼Œé‚£é¡¹ç›®å°±ä¼šç»§ç»­åŸºäº `crates.io` æ¥æ„å»ºï¼Œæ­¤æ—¶ï¼Œ`patch` å°±å¯ä»¥åˆ é™¤äº†ã€‚

#### é—´æ¥ä½¿ç”¨ `patch`

ç°åœ¨å‡è®¾é¡¹ç›® `A` çš„ä¾èµ–æ˜¯ `B` å’Œ `uuid`ï¼Œè€Œ `B` çš„ä¾èµ–ä¹Ÿæ˜¯ `uuid`ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥è®© `A` å’Œ `B` éƒ½ä½¿ç”¨æ¥è‡ª `GitHub` çš„ `patch` ç‰ˆæœ¬ï¼Œé…ç½®å¦‚ä¸‹:

```toml
[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œ`patch` ä¸ä»…ä»…å¯¹äº `my-binary` é¡¹ç›®æœ‰ç”¨ï¼Œå¯¹äº `my-binary` çš„ä¾èµ– `my-library` æ¥è¯´ï¼Œä¸€æ ·å¯ä»¥é—´æ¥ç”Ÿæ•ˆã€‚

#### é crates.io çš„ patch

è‹¥æˆ‘ä»¬æƒ³è¦è¦†ç›–çš„ä¾èµ–å¹¶ä¸æ˜¯æ¥è‡ª `crates.io` ï¼Œå°±éœ€è¦å¯¹ `[patch]` åšä¸€äº›ä¿®æ”¹ã€‚ä¾‹å¦‚ä¾èµ–æ˜¯ `git` ä»“åº“ï¼Œç„¶åä½¿ç”¨æœ¬åœ°è·¯å¾„æ¥è¦†ç›–å®ƒ:

```toml
[patch."https://github.com/your/repository"]
my-library = { path = "../my-library/path" }
```

easyï¼Œè½»æ¾æå®š!

## ä½¿ç”¨æœªå‘å¸ƒçš„å¤§ç‰ˆæœ¬

ç°åœ¨å‡è®¾æˆ‘ä»¬è¦å‘å¸ƒä¸€ä¸ªå¤§ç‰ˆæœ¬ `2.0.0`ï¼Œä¸ä¹‹å‰ç±»ä¼¼ï¼Œå¯ä»¥å°† `Cargo.toml` ä¿®æ”¹å¦‚ä¸‹:

```toml
[dependencies]
uuid = "2.0"

[patch.crates-io]
uuid = { git = "https://github.com/uuid-rs/uuid", branch = "2.0.0" }
```

æ­¤æ—¶ `2.0` ç‰ˆæœ¬åœ¨ `crates.io` ä¸Šè¿˜ä¸å­˜åœ¨ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨äº† `patch` ç‰ˆæœ¬ä¸”æŒ‡å®šäº† `branch = "2.0.0"`ã€‚

#### é—´æ¥ä½¿ç”¨ `patch`

è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œ**ä¸ä¹‹å‰çš„å°ç‰ˆæœ¬ä¸åŒï¼Œå¤§ç‰ˆæœ¬çš„ `patch` ä¸ä¼šå‘ç”Ÿé—´æ¥çš„ä¼ é€’ï¼**ï¼Œä¾‹å¦‚ï¼š

```toml
[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid', branch = '2.0.0' }
```

ä»¥ä¸Šé…ç½®ä¸­, `my-binary` å°†ç»§ç»­ä½¿ç”¨ `1.x.y` ç³»åˆ—çš„ç‰ˆæœ¬ï¼Œè€Œ `my-library` å°†ä½¿ç”¨æœ€æ–°çš„ `2.0.0` patchã€‚

åŸå› æ˜¯ï¼Œå¤§ç‰ˆæœ¬æ›´æ–°å¾€å¾€ä¼šå¸¦æ¥ç ´åæ€§çš„åŠŸèƒ½ï¼ŒRust ä¸ºäº†è®©æˆ‘ä»¬å¹³ç¨³çš„å‡çº§ï¼Œé‡‡ç”¨äº†æ»šåŠ¨çš„æ–¹å¼ï¼šåœ¨ä¾èµ–å›¾ä¸­é€æ­¥æ¨è¿›æ›´æ–°ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡æ€§å…¨éƒ¨æ›´æ–°ã€‚

## å¤šç‰ˆæœ¬[patch]

åœ¨ä¹‹å‰ç« èŠ‚ï¼Œæˆ‘ä»¬ä»‹ç»è¿‡å¦‚ä½•ä½¿ç”¨ `package key` æ¥[é‡å‘½åä¾èµ–åŒ…](https://course.rs/cargo/reference/specify-deps/intro.html#åœ¨-cargotoml-ä¸­é‡å‘½åä¾èµ–)ï¼Œç°åœ¨æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨å®ƒåŒæ—¶å¼•å…¥å¤šä¸ª `patch`ã€‚

å‡è®¾ï¼Œæˆ‘ä»¬å¯¹ `serde` æœ‰ä¸¤ä¸ªæ–°çš„ `patch` éœ€æ±‚:

- `serde` å®˜æ–¹è§£å†³äº†ä¸€ä¸ª `bug` ä½†æ˜¯è¿˜æ²¡å‘å¸ƒåˆ° `crates.io`ï¼Œæˆ‘ä»¬æƒ³ç›´æ¥ä» `git` ä»“åº“çš„æœ€æ–° `commit` æ‹‰å–ç‰ˆæœ¬ `1.*`
- æˆ‘ä»¬è‡ªå·±ä¸º `serde` æ·»åŠ äº†æ–°çš„åŠŸèƒ½ï¼Œå‘½åä¸º `2.0.0` ç‰ˆæœ¬ï¼Œå¹¶å°†è¯¥ç‰ˆæœ¬ä¸Šä¼ åˆ°è‡ªå·±çš„ `git` ä»“åº“ä¸­

ä¸ºäº†æ»¡è¶³è¿™ä¸¤ä¸ª `patch`ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å†…å®¹çš„ `Cargo.toml`ï¼š

```toml
[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde' }
serde2 = { git = 'https://github.com/example/serde', package = 'serde', branch = 'v2' }
```

ç¬¬ä¸€è¡Œè¯´æ˜ï¼Œç¬¬ä¸€ä¸ª `patch` ä»å®˜æ–¹ä»“åº“ `main` åˆ†æ”¯çš„æœ€æ–° `commit` æ‹‰å–ï¼Œè€Œç¬¬äºŒä¸ªåˆ™ä»æˆ‘ä»¬è‡ªå·±çš„ä»“åº“æ‹‰å– `v2` åˆ†æ”¯ï¼ŒåŒæ—¶å°†å…¶é‡å‘½åä¸º `serde2`ã€‚

è¿™æ ·ï¼Œåœ¨ä»£ç ä¸­å°±å¯ä»¥åˆ†åˆ«é€šè¿‡ `serde` å’Œ `serde2` å¼•ç”¨ä¸åŒç‰ˆæœ¬çš„ä¾èµ–åº“äº†ã€‚

## é€šè¿‡[path]æ¥è¦†ç›–ä¾èµ–

æœ‰æ—¶æˆ‘ä»¬åªæ˜¯ä¸´æ—¶æ€§åœ°å¯¹ä¸€ä¸ªé¡¹ç›®è¿›è¡Œå¤„ç†ï¼Œå› æ­¤å¹¶ä¸æƒ³å»ä¿®æ”¹å®ƒçš„ `Cargo.toml`ã€‚æ­¤æ—¶å¯ä»¥ä½¿ç”¨ `Cargo` æä¾›çš„è·¯å¾„è¦†ç›–æ–¹æ³•: **æ³¨æ„ï¼Œè¿™ä¸ªæ–¹æ³•é™åˆ¶è¾ƒå¤šï¼Œå¦‚æœå¯ä»¥ï¼Œè¿˜æ˜¯è¦ä½¿ç”¨ [patch]**ã€‚

ä¸ `[patch]` ä¿®æ”¹ `Cargo.toml` ä¸åŒï¼Œè·¯å¾„è¦†ç›–ä¿®æ”¹çš„æ˜¯ `Cargo` è‡ªèº«çš„[é…ç½®æ–‡ä»¶](https://course.rs/cargo/guide/cargo-cache.html#cargo-home) `$Home/.cargo/config.toml`:

```toml
paths = ["/path/to/uuid"]
```

`paths` æ•°ç»„ä¸­çš„å…ƒç´ æ˜¯ä¸€ä¸ªåŒ…å« `Cargo.toml` çš„ç›®å½•(ä¾èµ–åŒ…)ï¼Œåœ¨å½“å‰ä¾‹å­ä¸­ï¼Œç”±äºæˆ‘ä»¬åªæœ‰ä¸€ä¸ª `uuid`ï¼Œå› æ­¤åªéœ€è¦è¦†ç›–å®ƒå³å¯ã€‚ç›®æ ‡è·¯å¾„å¯ä»¥æ˜¯ç›¸å¯¹çš„ï¼Œä¹Ÿæ˜¯ç»å¯¹çš„ï¼Œéœ€è¦æ³¨æ„ï¼Œå¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œé‚£æ˜¯ç›¸å¯¹åŒ…å« `.cargo` çš„ `$Home` æ¥è¯´çš„ã€‚

## ä¸æ¨èçš„[replace]

> `[replace]` å·²ç»è¢«æ ‡è®°ä¸º `deprecated`ï¼Œå¹¶å°†åœ¨æœªæ¥è¢«ç§»é™¤ï¼Œè¯·ä½¿ç”¨ `[patch]` æ›¿ä»£

è™½ç„¶ä¸å»ºè®®ä½¿ç”¨ï¼Œä½†æ˜¯å¦‚æœå¤§å®¶é˜…è¯»å…¶å®ƒé¡¹ç›®æ—¶ä¾ç„¶å¯èƒ½ä¼šç¢°åˆ°è¿™ç§ç”¨æ³•:

```toml
[replace]
"foo:0.1.0" = { git = 'https://github.com/example/foo' }
"bar:1.0.2" = { path = 'my/local/bar' }
```

è¯­æ³•çœ‹ä¸Šå»è¿˜æ˜¯å¾ˆæ¸…æ™°çš„ï¼Œ`[replace]` ä¸­çš„æ¯ä¸€ä¸ª `key` éƒ½æ˜¯ `Package ID` æ ¼å¼ï¼Œé€šè¿‡è¿™ç§å†™æ³•å¯ä»¥åœ¨ä¾èµ–å›¾ä¸­ä»»æ„æŒ‘é€‰ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œè¦†ç›–ã€‚



================================================
FILE: src/cargo/reference/env.md
================================================
# ç¯å¢ƒå˜é‡



================================================
FILE: src/cargo/reference/intro.md
================================================
# è¿›é˜¶æŒ‡å—

è¿›é˜¶æŒ‡å—åŒ…å«äº† Cargo çš„å‚è€ƒçº§å†…å®¹ï¼Œå¤§å®¶å¯ä»¥å…ˆçœ‹ä¸€éäº†è§£ä¸‹å¤§æ¦‚æœ‰ä»€ä¹ˆï¼Œç„¶ååœ¨åé¢éœ€è¦æ—¶ï¼Œå†å›æ¥æŸ¥è¯¢å¦‚ä½•ä½¿ç”¨ã€‚




================================================
FILE: src/cargo/reference/manifest.md
================================================
# Cargo.toml æ ¼å¼è®²è§£

`Cargo.toml` åˆè¢«ç§°ä¸ºæ¸…å•( `manifest` )ï¼Œæ–‡ä»¶æ ¼å¼æ˜¯ `TOML`ï¼Œæ¯ä¸€ä¸ªæ¸…å•æ–‡ä»¶éƒ½ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

- [`cargo-features`](unstable.md) â€” åªèƒ½ç”¨äº `nightly`ç‰ˆæœ¬çš„ `feature`
- [`[package]`](#package) â€” å®šä¹‰é¡¹ç›®( `package` )çš„å…ƒä¿¡æ¯
  - [`name`](#name) â€” åç§°
  - [`version`](#version) â€” ç‰ˆæœ¬
  - [`authors`](#authors) â€” å¼€å‘ä½œè€…
  - [`edition`](#edition) â€” Rust edition.
  - [`rust-version`](#rust-version) â€” æ”¯æŒçš„æœ€å°åŒ– Rust ç‰ˆæœ¬
  - [`description`](#description) â€” æè¿°
  - [`documentation`](#documentation) â€” æ–‡æ¡£ URL
  - [`readme`](#readme) â€” README æ–‡ä»¶çš„è·¯å¾„
  - [`homepage`](#homepage) - ä¸»é¡µ URL
  - [`repository`](#repository) â€” æºä»£ç ä»“åº“çš„ URL
  - [`license`](#licenseå’Œlicense-file) â€” å¼€æºåè®® License.
  - [`license-file`](#licenseå’Œlicense-file) â€” License æ–‡ä»¶çš„è·¯å¾„.
  - [`keywords`](#keywords) â€” é¡¹ç›®çš„å…³é”®è¯
  - [`categories`](#categories) â€” é¡¹ç›®åˆ†ç±»
  - [`workspace`](#workspace) â€” å·¥ä½œç©ºé—´ workspace çš„è·¯å¾„
  - [`build`](#build) â€” æ„å»ºè„šæœ¬çš„è·¯å¾„
  - [`links`](#links) â€” æœ¬åœ°é“¾æ¥åº“çš„åç§°
  - [`exclude`](#excludeå’Œinclude) â€” å‘å¸ƒæ—¶æ’é™¤çš„æ–‡ä»¶
  - [`include`](#excludeå’Œinclude) â€” å‘å¸ƒæ—¶åŒ…å«çš„æ–‡ä»¶
  - [`publish`](#the-publish-field) â€” ç”¨äºé˜»æ­¢é¡¹ç›®çš„å‘å¸ƒ
  - [`metadata`](#metadata) â€” é¢å¤–çš„é…ç½®ä¿¡æ¯ï¼Œç”¨äºæä¾›ç»™å¤–éƒ¨å·¥å…·
  - [`default-run`](#default-run) â€” [`cargo run`] æ‰€ä½¿ç”¨çš„é»˜è®¤å¯æ‰§è¡Œæ–‡ä»¶( binary )
  - [`autobins`](https://course.rs/cargo/reference/cargo-target.html#å¯¹è±¡è‡ªåŠ¨å‘ç°) â€” ç¦æ­¢å¯æ‰§è¡Œæ–‡ä»¶çš„è‡ªåŠ¨å‘ç°
  - [`autoexamples`](https://course.rs/cargo/reference/cargo-target.html#å¯¹è±¡è‡ªåŠ¨å‘ç°) â€” ç¦æ­¢ç¤ºä¾‹æ–‡ä»¶çš„è‡ªåŠ¨å‘ç°
  - [`autotests`](https://course.rs/cargo/reference/cargo-target.html#å¯¹è±¡è‡ªåŠ¨å‘ç°) â€” ç¦æ­¢æµ‹è¯•æ–‡ä»¶çš„è‡ªåŠ¨å‘ç°
  - [`autobenches`](https://course.rs/cargo/reference/cargo-target.html#å¯¹è±¡è‡ªåŠ¨å‘ç°) â€” ç¦æ­¢ bench æ–‡ä»¶çš„è‡ªåŠ¨å‘ç°
  - [`resolver`](resolver.md#resolver-versions) â€” è®¾ç½®ä¾èµ–è§£æå™¨( dependency resolver)
- Cargo Target åˆ—è¡¨: (æŸ¥çœ‹ [Target é…ç½®](https://course.rs/cargo/reference/cargo-target.html#Targeté…ç½®) è·å–è¯¦ç»†è®¾ç½®)
  - [`[lib]`](https://course.rs/cargo/reference/cargo-target.html#åº“å¯¹è±¡library) â€” Library target è®¾ç½®.
  - [`[[bin]]`](https://course.rs/cargo/reference/cargo-target.html#äºŒè¿›åˆ¶å¯¹è±¡binaries) â€” Binary target è®¾ç½®.
  - [`[[example]]`](https://course.rs/cargo/reference/cargo-target.html#ç¤ºä¾‹å¯¹è±¡examples) â€” Example target è®¾ç½®.
  - [`[[test]]`](https://course.rs/cargo/reference/cargo-target.html#æµ‹è¯•å¯¹è±¡tests) â€” Test target è®¾ç½®.
  - [`[[bench]]`](https://course.rs/cargo/reference/cargo-target.html#åŸºå‡†æ€§èƒ½å¯¹è±¡benches) â€” Benchmark target è®¾ç½®.
- Dependency tables:
  - [`[dependencies]`](https://course.rs/cargo/reference/specify-deps.html) â€” é¡¹ç›®ä¾èµ–åŒ…
  - [`[dev-dependencies]`](https://course.rs/cargo/reference/specify-deps.html#dev-dependencies) â€” ç”¨äº examplesã€tests å’Œ benchmarks çš„ä¾èµ–åŒ…
  - [`[build-dependencies]`](https://course.rs/cargo/reference/specify-deps.html#build-dependencies) â€” ç”¨äºæ„å»ºè„šæœ¬çš„ä¾èµ–åŒ…
  - [`[target]`](https://course.rs/cargo/reference/specify-deps.html#æ ¹æ®å¹³å°å¼•å…¥ä¾èµ–) â€” å¹³å°ç‰¹å®šçš„ä¾èµ–åŒ…
- [`[badges]`](#badges) â€” ç”¨äºåœ¨æ³¨å†ŒæœåŠ¡(ä¾‹å¦‚ crates.io ) ä¸Šæ˜¾ç¤ºé¡¹ç›®çš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ï¼Œä¾‹å¦‚å½“å‰çš„ç»´æŠ¤çŠ¶æ€ï¼šæ´»è·ƒä¸­ã€å¯»æ‰¾ç»´æŠ¤è€…ã€deprecated
- [`[features]`](https://course.rs/cargo/reference/features/intro.html) â€” `features` å¯ä»¥ç”¨äºæ¡ä»¶ç¼–è¯‘
- [`[patch]`](https://course.rs/cargo/reference/deps-overriding.html) â€” æ¨èä½¿ç”¨çš„ä¾èµ–è¦†ç›–æ–¹å¼
- [`[replace]`](https://course.rs/cargo/reference/deps-overriding.html#ä¸æ¨èçš„replace) â€” ä¸æ¨èä½¿ç”¨çš„ä¾èµ–è¦†ç›–æ–¹å¼ (deprecated).
- [`[profile]`](https://course.rs/cargo/reference/profiles.html) â€” ç¼–è¯‘å™¨è®¾ç½®å’Œä¼˜åŒ–
- [`[workspace]`](https://course.rs/cargo/reference/workspaces.html) â€” å·¥ä½œç©ºé—´çš„å®šä¹‰

ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å¯¹å…¶ä¸­ä¸€äº›éƒ¨åˆ†è¿›è¡Œè¯¦ç»†è®²è§£ã€‚

## [package]

`Cargo.toml` ä¸­ç¬¬ä¸€ä¸ªéƒ¨åˆ†å°±æ˜¯ `package`ï¼Œç”¨äºè®¾ç½®é¡¹ç›®çš„ç›¸å…³ä¿¡æ¯ï¼š

```toml
[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
authors = ["Alice <a@example.com>", "Bob <b@example.com>"]
```

å…¶ä¸­ï¼Œåªæœ‰ `name` å’Œ `version` å­—æ®µæ˜¯**å¿…é¡»å¡«å†™çš„**ã€‚å½“å‘å¸ƒåˆ°æ³¨å†ŒæœåŠ¡æ—¶ï¼Œå¯èƒ½ä¼šæœ‰é¢å¤–çš„å­—æ®µè¦æ±‚ï¼Œå…·ä½“å‚è§[å‘å¸ƒåˆ° crates.io](publishing-on-crates.io.md)ã€‚

#### name

é¡¹ç›®åç”¨äºå¼•ç”¨ä¸€ä¸ªé¡¹ç›®( `package` )ï¼Œå®ƒæœ‰å‡ ä¸ªç”¨é€”ï¼š

- å…¶å®ƒé¡¹ç›®å¼•ç”¨æˆ‘ä»¬çš„ `package` æ—¶ï¼Œä¼šä½¿ç”¨è¯¥ `name`
- ç¼–è¯‘å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶(bin target)çš„é»˜è®¤åç§°

`name` åªèƒ½ä½¿ç”¨ [`alphanumeric`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_alphanumeric) å­—ç¬¦ã€ `-` å’Œ `_`ï¼Œå¹¶ä¸”ä¸èƒ½ä¸ºç©ºã€‚

äº‹å®ä¸Šï¼Œ`name` çš„é™åˆ¶ä¸æ­¢å¦‚æ­¤ï¼Œä¾‹å¦‚:

- **å½“ä½¿ç”¨ `cargo new` æˆ– `cargo init` åˆ›å»ºæ—¶**ï¼Œ`name` è¿˜ä¼šè¢«æ–½åŠ é¢å¤–çš„é™åˆ¶ï¼Œä¾‹å¦‚ä¸èƒ½ä½¿ç”¨ Rust å…³é”®å­—åç§°ä½œä¸º `name`
- **å¦‚æœè¦å‘å¸ƒåˆ° `crates.io` ï¼Œé‚£è¿˜æœ‰æ›´å¤šçš„é™åˆ¶**: `name` ä½¿ç”¨ `ASCII` ç ï¼Œä¸èƒ½ä½¿ç”¨å·²ç»è¢«ä½¿ç”¨çš„åç§°ï¼Œä¾‹å¦‚ `uuid` å·²ç»åœ¨ `crates.io` ä¸Šè¢«ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬åªèƒ½ä½¿ç”¨ç±»å¦‚ `uuid_v1` çš„åç§°ï¼Œæ‰èƒ½å°†é¡¹ç›®å‘å¸ƒåˆ° `crates.io` ä¸Š

#### version

Cargo ä½¿ç”¨äº†[è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶](https://semver.org)çš„æ¦‚å¿µï¼Œä¾‹å¦‚å­—ç¬¦ä¸² `"0.1.12"` æ˜¯ä¸€ä¸ª `semver` æ ¼å¼çš„ç‰ˆæœ¬å·ï¼Œç¬¦åˆ `"x.y.z"` çš„å½¢å¼ï¼Œå…¶ä¸­ `x` è¢«ç§°ä¸ºä¸»ç‰ˆæœ¬`major`, `y` è¢«ç§°ä¸ºå°ç‰ˆæœ¬ `minor` ï¼Œè€Œ `z` è¢«ç§°ä¸ºè¡¥ä¸ `patch`ï¼Œå¯ä»¥çœ‹å‡ºä»å·¦åˆ°å³ï¼Œç‰ˆæœ¬çš„å½±å“èŒƒå›´é€æ­¥é™ä½ï¼Œè¡¥ä¸çš„æ›´æ–°æ˜¯æ— å…³ç—›ç—’çš„ï¼Œå¹¶ä¸ä¼šé€ æˆ API çš„å…¼å®¹æ€§è¢«ç ´åã€‚

ä½¿ç”¨è¯¥è§„åˆ™ï¼Œä½ è¿˜éœ€è¦éµå¾ªä¸€äº›åŸºæœ¬è§„åˆ™:

- ä½¿ç”¨æ ‡å‡†çš„ `x.y.z` å½¢å¼çš„ç‰ˆæœ¬å·ï¼Œä¾‹å¦‚ `1.0.0` è€Œä¸æ˜¯ `1.0`
- åœ¨ç‰ˆæœ¬åˆ°è¾¾ `1.0.0` ä¹‹å‰ï¼Œæ€ä¹ˆéƒ½è¡Œï¼Œä½†æ˜¯å¦‚æœæœ‰ç ´åæ€§å˜æ›´( breaking changes )ï¼Œéœ€è¦å¢åŠ  `minor` ç‰ˆæœ¬å·ã€‚ä¾‹å¦‚ï¼Œä¸ºç»“æ„ä½“æ–°å¢å­—æ®µæˆ–ä¸ºæšä¸¾æ–°å¢æˆå‘˜å°±æ˜¯ä¸€ç§ç ´åæ€§å˜æ›´
- åœ¨ `1.0.0` ä¹‹åï¼Œå¦‚æœå‘ç”Ÿç ´åæ€§å˜æ›´ï¼Œéœ€è¦å¢åŠ  `major` ç‰ˆæœ¬å·
- åœ¨ `1.0.0` ä¹‹åä¸è¦å»ç ´åæ„å»ºæµç¨‹
- åœ¨ `1.0.0` ä¹‹åï¼Œä¸è¦åœ¨ `patch` æ›´æ–°ä¸­æ·»åŠ æ–°çš„ `api` ( `pub` å£°æ˜)ï¼Œå¦‚æœè¦æ·»åŠ æ–°çš„ `pub` ç»“æ„ä½“ã€ç‰¹å¾ã€ç±»å‹ã€å‡½æ•°ã€æ–¹æ³•ç­‰å¯¹è±¡æ—¶ï¼Œå¢åŠ  `minor` ç‰ˆæœ¬å·

å¦‚æœå¤§å®¶æƒ³çŸ¥é“ Rust å¦‚ä½•ä½¿ç”¨ç‰ˆæœ¬å·æ¥è§£æä¾èµ–ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™é‡Œ](https://doc.rust-lang.org/stable/cargo/reference/resolver.html)ã€‚åŒæ—¶ [SemVer å…¼å®¹æ€§](https://doc.rust-lang.org/stable/cargo/reference/semver.html) æä¾›äº†æ›´ä¸ºè¯¦å°½çš„ç ´åæ€§å˜æ›´åˆ—è¡¨ã€‚

#### authors

```toml
[package]
authors = ["Sunfei <contact@im.dev>"]
```

è¯¥å­—æ®µä»…ç”¨äºé¡¹ç›®çš„å…ƒä¿¡æ¯æè¿°å’Œ `build.rs` ç”¨åˆ°çš„ `CARGO_PKG_AUTHORS` ç¯å¢ƒå˜é‡ï¼Œå®ƒå¹¶ä¸ä¼šæ˜¾ç¤ºåœ¨ `crates.io` ç•Œé¢ä¸Šã€‚

> è­¦å‘Šï¼šæ¸…å•ä¸­çš„ `[package]` éƒ¨åˆ†ä¸€æ—¦å‘å¸ƒåˆ° `crates.io` å°±æ— æ³•è¿›è¡Œæ›´æ”¹ï¼Œå› æ­¤å¯¹äºå·²å‘å¸ƒçš„åŒ…æ¥è¯´ï¼Œ`authors` å­—æ®µæ˜¯æ— æ³•ä¿®æ”¹çš„

#### edition

å¯é€‰å­—æ®µï¼Œç”¨äºæŒ‡å®šé¡¹ç›®æ‰€ä½¿ç”¨çš„ [Rust Edition](https://course.rs/appendix/rust-version.html)ã€‚

è¯¥é…ç½®å°†å½±å“é¡¹ç›®ä¸­çš„æ‰€æœ‰ `Cargo Target` å’ŒåŒ…ï¼Œå‰è€…åŒ…å«æµ‹è¯•ç”¨ä¾‹ã€benchmarkã€å¯æ‰§è¡Œæ–‡ä»¶ã€ç¤ºä¾‹ç­‰ã€‚

```toml
[package]
# ...
edition = '2021'
```

å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬éƒ½æ— éœ€æ‰‹åŠ¨æŒ‡å®šï¼Œå› ä¸º `cargo new` çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬æ·»åŠ ã€‚è‹¥ `edition` é…ç½®ä¸å­˜åœ¨ï¼Œé‚£ `2015 Edition` ä¼šè¢«é»˜è®¤ä½¿ç”¨ã€‚

#### rust-version

å¯é€‰å­—æ®µï¼Œç”¨äºè¯´æ˜ä½ çš„é¡¹ç›®æ”¯æŒçš„æœ€ä½ Rust ç‰ˆæœ¬(ç¼–è¯‘å™¨èƒ½é¡ºåˆ©å®Œæˆç¼–è¯‘)ã€‚ä¸€æ—¦ä½ ä½¿ç”¨çš„ Rust ç‰ˆæœ¬æ¯”è¿™ä¸ªå­—æ®µè®¾ç½®çš„è¦ä½ï¼Œ`Cargo` å°±ä¼šæŠ¥é”™ï¼Œç„¶åå‘Šè¯‰ç”¨æˆ·æ‰€éœ€çš„æœ€ä½ç‰ˆæœ¬ã€‚

è¯¥å­—æ®µæ˜¯åœ¨ Rust 1.56 å¼•å…¥çš„ï¼Œè‹¥å¤§å®¶ä½¿ç”¨çš„ Rust ç‰ˆæœ¬ä½äºè¯¥ç‰ˆæœ¬ï¼Œåˆ™è¯¥å­—æ®µä¼šè¢«è‡ªåŠ¨å¿½ç•¥æ—¶ã€‚

```toml
[package]
# ...
edition = '2021'
rust-version = "1.56"
```

è¿˜æœ‰ä¸€ç‚¹ï¼Œ`rust-version` å¿…é¡»æ¯”ç¬¬ä¸€ä¸ªå¼•å…¥ `edition` çš„ Rust ç‰ˆæœ¬è¦æ–°ã€‚ä¾‹å¦‚ Rust Edition 2021 æ˜¯åœ¨ Rust 1.56 ç‰ˆæœ¬å¼•å…¥çš„ï¼Œè‹¥ä½ ä½¿ç”¨äº† `edition = '2021'` çš„ `[package]` é…ç½®ï¼Œåˆ™æŒ‡å®šçš„ `rust version` å­—æ®µå¿…é¡»è¦è¦å¤§äºç­‰äº `1.56` ç‰ˆæœ¬ã€‚

è¿˜å¯ä»¥ä½¿ç”¨ `--ignore-rust-version` å‘½ä»¤è¡Œå‚æ•°æ¥å¿½ç•¥ `rust-version`ã€‚

è¯¥å­—æ®µå°†å½±å“é¡¹ç›®ä¸­çš„æ‰€æœ‰ `Cargo Target` å’ŒåŒ…ï¼Œå‰è€…åŒ…å«æµ‹è¯•ç”¨ä¾‹ã€benchmarkã€å¯æ‰§è¡Œæ–‡ä»¶ã€ç¤ºä¾‹ç­‰ã€‚

## description

è¯¥å­—æ®µæ˜¯é¡¹ç›®çš„ç®€ä»‹ï¼Œ`crates.io` ä¼šåœ¨é¡¹ç›®é¦–é¡µä½¿ç”¨è¯¥å­—æ®µåŒ…å«çš„å†…å®¹ï¼Œ**ä¸æ”¯æŒ `Markdown` æ ¼å¼**ã€‚

```toml
[package]
# ...
description = "A short description of my package"
```

> æ³¨æ„: è‹¥å‘å¸ƒ `crates.io` ï¼Œåˆ™è¯¥å­—æ®µæ˜¯å¿…é¡»çš„

## documentation

è¯¥å­—æ®µç”¨äºè¯´æ˜é¡¹ç›®æ–‡æ¡£çš„åœ°å€ï¼Œè‹¥æ²¡æœ‰è®¾ç½®ï¼Œ`crates.io` ä¼šè‡ªåŠ¨é“¾æ¥åˆ° `docs.rs` ä¸Šçš„ç›¸åº”é¡µé¢ã€‚

```toml
[package]
# ...
documentation = "https://docs.rs/bitflags"
```

#### readme

`readme` å­—æ®µæŒ‡å‘é¡¹ç›®çš„ `README.md` æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶åº”è¯¥å­˜åœ¨é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹(è·Ÿ `Cargo.toml` åŒçº§)ï¼Œç”¨äºå‘ç”¨æˆ·æè¿°é¡¹ç›®çš„è¯¦ç»†ä¿¡æ¯ï¼Œæ”¯æŒ `Markdown` æ ¼å¼ã€‚å¤§å®¶çœ‹åˆ°çš„ `crates.io` ä¸Šçš„é¡¹ç›®é¦–é¡µå°±æ˜¯åŸºäºè¯¥æ–‡ä»¶çš„å†…å®¹è¿›è¡Œæ¸²æŸ“çš„ã€‚

```toml
[package]
# ...
readme = "README.md"
```

è‹¥è¯¥å­—æ®µæœªè®¾ç½®ä¸”é¡¹ç›®æ ¹ç›®å½•ä¸‹å­˜åœ¨ `README.md`ã€`README.txt` æˆ– `README` æ–‡ä»¶ï¼Œåˆ™è¯¥æ–‡ä»¶çš„åç§°å°†è¢«é»˜è®¤ä½¿ç”¨ã€‚

ä½ ä¹Ÿå¯ä»¥é€šè¿‡å°† `readme` è®¾ç½®ä¸º `false` æ¥ç¦æ­¢è¯¥åŠŸèƒ½ï¼Œè‹¥è®¾ç½®ä¸º `true` ï¼Œåˆ™é»˜è®¤å€¼ `README.md` å°†è¢«ä½¿ç”¨ã€‚

#### homepage

è¯¥å­—æ®µç”¨äºè®¾ç½®é¡¹ç›®ä¸»é¡µçš„ URL:

```toml
[package]
# ...
homepage = "https://serde.rs/"
```

#### repository

è®¾ç½®é¡¹ç›®çš„æºä»£ç ä»“åº“åœ°å€ï¼Œä¾‹å¦‚ `GitHub` é“¾æ¥:

```toml
[package]
# ...
repository = "https://github.com/rust-lang/cargo/"
```

#### license å’Œ license-file

`license` å­—æ®µç”¨äºæè¿°é¡¹ç›®æ‰€éµå¾ªçš„å¼€æºåè®®ã€‚è€Œ `license-file` åˆ™ç”¨äºæŒ‡å®šåŒ…å«å¼€æºåè®®çš„æ–‡ä»¶æ‰€åœ¨çš„è·¯å¾„(ç›¸å¯¹äº `Cargo.toml`)ã€‚

å¦‚æœè¦å‘å¸ƒåˆ° `crates.io` ï¼Œåˆ™è¯¥åè®®å¿…é¡»æ˜¯ [SPDX2.1 åè®®è¡¨è¾¾å¼](https://spdx.dev/spdx-specification-21-web-version/#h.jxpfx0ykyb60)ã€‚åŒæ—¶ `license` åç§°å¿…é¡»æ˜¯æ¥è‡ªäº [SPDX åè®®åˆ—è¡¨ 3.11](https://github.com/spdx/license-list-data/tree/v3.11)ã€‚

SPDX åªæ”¯æŒä½¿ç”¨ `AND` ã€`OR` æ¥ç»„åˆå¤šä¸ªå¼€æºåè®®:

```toml
[package]
# ...
license = "MIT OR Apache-2.0"
```

`OR` ä»£è¡¨ç”¨æˆ·å¯ä»¥ä»»é€‰ä¸€ä¸ªåè®®è¿›è¡Œéµå¾ªï¼Œè€Œ `AND` è¡¨ç¤ºç”¨æˆ·å¿…é¡»è¦åŒæ—¶éµå¾ªä¸¤ä¸ªåè®®ã€‚è¿˜å¯ä»¥é€šè¿‡ `WITH` æ¥åœ¨æŒ‡å®šåè®®ä¹‹å¤–æ·»åŠ é¢å¤–çš„è¦æ±‚:

- `MIT OR Apache-2.0`
- `LGPL-2.1-only AND MIT AND BSD-2-Clause`
- `GPL-2.0-or-later WITH Bison-exception-2.2`

**è‹¥é¡¹ç›®ä½¿ç”¨äº†éæ ‡å‡†çš„åè®®**ï¼Œä½ å¯ä»¥é€šè¿‡æŒ‡å®š `license-file` å­—æ®µæ¥æ›¿ä»£ `license` çš„ä½¿ç”¨:

```toml
[package]
# ...
license-file = "LICENSE.txt"
```

> æ³¨æ„ï¼šcrates.io è¦æ±‚å¿…é¡»è®¾ç½® `license` æˆ– `license-file`

#### keywords

è¯¥å­—æ®µä½¿ç”¨å­—ç¬¦ä¸²æ•°ç»„çš„æ–¹å¼æ¥æŒ‡å®šé¡¹ç›®çš„å…³é”®å­—åˆ—è¡¨ï¼Œå½“ç”¨æˆ·åœ¨ `crates.io` ä¸Šæœç´¢æ—¶ï¼Œè¿™äº›å…³é”®å­—å¯ä»¥æä¾›ç´¢å¼•çš„åŠŸèƒ½ã€‚

```toml
[package]
# ...
keywords = ["gamedev", "graphics"]
```

> æ³¨æ„ï¼š`crates.io` æœ€å¤šåªæ”¯æŒ 5 ä¸ªå…³é”®å­—ï¼Œæ¯ä¸ªå…³é”®å­—éƒ½å¿…é¡»æ˜¯åˆæ³•çš„ `ASCII` æ–‡æœ¬ï¼Œä¸”éœ€è¦ä½¿ç”¨å­—æ¯ä½œä¸ºå¼€å¤´ï¼Œåªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€`_` å’Œ `-`ï¼Œæœ€å¤šæ”¯æŒ 20 ä¸ªå­—ç¬¦é•¿åº¦

#### categories

`categories` ç”¨äºæè¿°é¡¹ç›®æ‰€å±çš„ç±»åˆ«:

```toml
categories = ["command-line-utilities", "development-tools::cargo-plugins"]
```

> æ³¨æ„ï¼š`crates.io` æœ€å¤šåªæ”¯æŒ 5 ä¸ªç±»åˆ«ï¼Œç›®å‰ä¸æ”¯æŒç”¨æˆ·éšæ„è‡ªå®šä¹‰ç±»åˆ«ï¼Œä½ æ‰€ä½¿ç”¨çš„ç±»åˆ«éœ€è¦è·Ÿ [https://crates.io/category_slugs](https://crates.io/category_slugs) ä¸Šçš„ç±»åˆ«**ç²¾å‡†åŒ¹é…**ã€‚

#### workspace

è¯¥å­—æ®µç”¨äºé…ç½®å½“å‰é¡¹ç›®æ‰€å±çš„å·¥ä½œç©ºé—´ã€‚

è‹¥æ²¡æœ‰è®¾ç½®ï¼Œåˆ™å°†æ²¿ç€æ–‡ä»¶ç›®å½•å‘ä¸Šå¯»æ‰¾ï¼Œç›´è‡³æ‰¾åˆ°ç¬¬ä¸€ä¸ª è®¾ç½®äº† `[workspace]` çš„`Cargo.toml`ã€‚å› æ­¤ï¼Œå½“ä¸€ä¸ªæˆå‘˜ä¸åœ¨å·¥ä½œç©ºé—´çš„å­ç›®å½•æ—¶ï¼Œè®¾ç½®è¯¥å­—æ®µå°†éå¸¸æœ‰ç”¨ã€‚

```toml
[package]
# ...
workspace = "path/to/workspace/root"
```

éœ€è¦æ³¨æ„çš„æ˜¯ `Cargo.toml` æ¸…å•è¿˜æœ‰ä¸€ä¸ª `[workspace]` éƒ¨åˆ†ä¸“é—¨ç”¨äºè®¾ç½®å·¥ä½œç©ºé—´ï¼Œè‹¥å®ƒè¢«è®¾ç½®äº†ï¼Œåˆ™ `package` ä¸­çš„ `workspace` å­—æ®µå°†æ— æ³•è¢«æŒ‡å®šã€‚è¿™æ˜¯å› ä¸ºä¸€ä¸ªåŒ…æ— æ³•åŒæ—¶æ»¡è¶³ä¸¤ä¸ªè§’è‰²ï¼š

- è¯¥åŒ…æ˜¯å·¥ä½œç©ºé—´çš„æ ¹åŒ…(root crate)ï¼Œé€šè¿‡ `[workspace]` æŒ‡å®š)
- è¯¥åŒ…æ˜¯å¦ä¸€ä¸ªå·¥ä½œç©ºé—´çš„æˆå‘˜ï¼Œé€šè¿‡ `package.workspace` æŒ‡å®š

è‹¥è¦äº†è§£å·¥ä½œç©ºé—´çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§[è¿™é‡Œ](https://course.rs/cargo/reference/workspaces.html)ã€‚

#### build

`build` ç”¨äºæŒ‡å®šä½äºé¡¹ç›®æ ¹ç›®å½•ä¸­çš„æ„å»ºè„šæœ¬ï¼Œå…³äºæ„å»ºè„šæœ¬çš„æ›´å¤šä¿¡æ¯ï¼Œå¯ä»¥é˜…è¯» [æ„å»ºè„šæœ¬](https://course.rs/cargo/reference/build-script/intro.html) ä¸€ç« ã€‚

```toml
[package]
# ...
build = "build.rs"
```

è¿˜å¯ä»¥ä½¿ç”¨ `build = false` æ¥ç¦æ­¢æ„å»ºè„šæœ¬çš„è‡ªåŠ¨æ£€æµ‹ã€‚

#### links

ç”¨äºæŒ‡å®šé¡¹ç›®é“¾æ¥çš„æœ¬åœ°åº“çš„åç§°ï¼Œæ›´å¤šçš„ä¿¡æ¯è¯·çœ‹æ„å»ºè„šæœ¬ç« èŠ‚çš„ [links](https://course.rs/cargo/reference/build-script/intro.html#links)

```toml
[package]
# ...
links = "foo"
```

#### exclude å’Œ include

è¿™ä¸¤ä¸ªå­—æ®µå¯ä»¥ç”¨äºæ˜¾å¼åœ°æŒ‡å®šæƒ³è¦åŒ…å«åœ¨å¤–æˆ–åœ¨å†…çš„æ–‡ä»¶åˆ—è¡¨ï¼Œå¾€å¾€ç”¨äºå‘å¸ƒåˆ°æ³¨å†ŒæœåŠ¡æ—¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ `cargo package --list` æ¥æ£€æŸ¥å“ªäº›æ–‡ä»¶è¢«åŒ…å«åœ¨é¡¹ç›®ä¸­ã€‚

```toml
[package]
# ...
exclude = ["/ci", "images/", ".*"]
```

```toml
[package]
# ...
include = ["/src", "COPYRIGHT", "/examples", "!/examples/big_example"]
```

å°½ç®¡å¤§å®¶å¯èƒ½æ²¡æœ‰æŒ‡å®š `include` æˆ– `exclude`ï¼Œä½†æ˜¯ä»»ç„¶ä¼šæœ‰äº›è§„åˆ™è‡ªåŠ¨è¢«åº”ç”¨ï¼Œä¸€èµ·æ¥çœ‹çœ‹ã€‚

è‹¥ `include` æ²¡æœ‰è¢«æŒ‡å®šï¼Œåˆ™ä»¥ä¸‹æ–‡ä»¶å°†è¢«æ’é™¤åœ¨å¤–:

- é¡¹ç›®ä¸æ˜¯ git ä»“åº“ï¼Œåˆ™æ‰€æœ‰ä»¥ `.` å¼€å¤´çš„éšè—æ–‡ä»¶ä¼šè¢«æ’é™¤
- é¡¹ç›®æ˜¯ git ä»“åº“ï¼Œé€šè¿‡ `.gitignore` é…ç½®çš„æ–‡ä»¶ä¼šè¢«æ’é™¤

æ— è®º `include` æˆ– `exclude` æ˜¯å¦è¢«æŒ‡å®šï¼Œä»¥ä¸‹æ–‡ä»¶éƒ½ä¼šè¢«æ’é™¤åœ¨å¤–:

- ä»»ä½•åŒ…å« `Cargo.toml` çš„å­ç›®å½•ä¼šè¢«æ’é™¤
- æ ¹ç›®å½•ä¸‹çš„ `target` ç›®å½•ä¼šè¢«æ’é™¤

ä»¥ä¸‹æ–‡ä»¶ä¼šæ°¸è¿œè¢« `include` ï¼Œä½ æ— éœ€æ˜¾å¼åœ°æŒ‡å®šï¼š

- `Cargo.toml`
- è‹¥é¡¹ç›®åŒ…å«å¯æ‰§è¡Œæ–‡ä»¶æˆ–ç¤ºä¾‹ä»£ç ï¼Œåˆ™æœ€å°åŒ–çš„ `Cargo.lock` ä¼šè‡ªåŠ¨è¢«åŒ…å«
- `license-file` æŒ‡å®šçš„åè®®æ–‡ä»¶

> è¿™ä¸¤ä¸ªå­—æ®µå¾ˆå¼ºå¤§ï¼Œä½†æ˜¯å¯¹äºç”Ÿäº§å®è·µè€Œè¨€ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ¨èé€šè¿‡ `.gitignore` æ¥æ§åˆ¶ï¼Œå› ä¸ºè¿™æ ·åä½œè€…æ›´å®¹æ˜“çœ‹æ‡‚ã€‚å¦‚æœå¤§å®¶å¸Œæœ›æ›´æ·±å…¥çš„äº†è§£ `include/exclude`ï¼Œå¯ä»¥å‚è€ƒä¸‹å®˜æ–¹çš„ `Cargo` [æ–‡æ¡£](https://doc.rust-lang.org/stable/cargo/reference/manifest.html?search=#the-exclude-and-include-fields)

#### publish

è¯¥å­—æ®µå¸¸å¸¸ç”¨äºé˜²æ­¢é¡¹ç›®å› ä¸ºå¤±è¯¯è¢«å‘å¸ƒåˆ° `crates.io` ç­‰æ³¨å†ŒæœåŠ¡ä¸Šï¼Œä¾‹å¦‚å¦‚æœå¸Œæœ›é¡¹ç›®åœ¨å…¬å¸å†…éƒ¨ç§æœ‰åŒ–ï¼Œä½ åº”è¯¥è®¾ç½®ï¼š

```toml
[package]
# ...
publish = false
```

ä¹Ÿå¯ä»¥é€šè¿‡å­—ç¬¦ä¸²æ•°ç»„çš„æ–¹å¼æ¥æŒ‡å®šå…è®¸å‘å¸ƒåˆ°çš„æ³¨å†ŒæœåŠ¡åç§°:

```toml
[package]
# ...
publish = ["some-registry-name"]
```

è‹¥ `publish` æ•°ç»„ä¸­åŒ…å«äº†ä¸€ä¸ªæ³¨å†ŒæœåŠ¡åç§°ï¼Œåˆ™ `cargo publish` å‘½ä»¤ä¼šä½¿ç”¨è¯¥æ³¨å†ŒæœåŠ¡ï¼Œé™¤éä½ é€šè¿‡ `--registry` æ¥è®¾å®šé¢å¤–çš„è§„åˆ™ã€‚

#### metadata

Cargo é»˜è®¤æƒ…å†µä¸‹ä¼šå¯¹ `Cargo.toml` ä¸­æœªä½¿ç”¨çš„ `key` è¿›è¡Œè­¦å‘Šï¼Œä»¥å¸®åŠ©å¤§å®¶æå‰å‘ç°é£é™©ã€‚ä½†æ˜¯ `package.metadata` å¹¶ä¸åœ¨å…¶ä¸­ï¼Œå› ä¸ºå®ƒæ˜¯ç”±ç”¨æˆ·è‡ªå®šä¹‰çš„æä¾›ç»™å¤–éƒ¨å·¥å…·çš„é…ç½®æ–‡ä»¶ã€‚ä¾‹å¦‚ï¼š

```toml
[package]
name = "..."
# ...

# ä»¥ä¸‹é…ç½®å…ƒæ•°æ®å¯ä»¥åœ¨ç”Ÿæˆå®‰å“ APK æ—¶ä½¿ç”¨
[package.metadata.android]
package-name = "my-awesome-android-app"
assets = "path/to/static"
```

ä¸å…¶ç›¸ä¼¼çš„è¿˜æœ‰ `[workspace.metadata]`ï¼Œéƒ½å¯ä»¥ä½œä¸ºå¤–éƒ¨å·¥å…·çš„é…ç½®ä¿¡æ¯æ¥ä½¿ç”¨ã€‚

#### default-run

å½“å¤§å®¶ä½¿ç”¨ `cargo run` æ¥è¿è¡Œé¡¹ç›®æ—¶ï¼Œè¯¥å‘½ä»¤ä¼šä½¿ç”¨é»˜è®¤çš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ä½œä¸ºç¨‹åºå¯åŠ¨å…¥å£ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ `default-run` æ¥ä¿®æ”¹é»˜è®¤çš„å…¥å£ï¼Œä¾‹å¦‚ç°åœ¨æœ‰ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ `src/bin/a.rs` å’Œ `src/bin/b.rs`ï¼Œé€šè¿‡ä»¥ä¸‹é…ç½®å¯ä»¥å°†å…¥å£è®¾ç½®ä¸ºå‰è€…:

```toml
[package]
default-run = "a"
```

## [badges]

è¯¥éƒ¨åˆ†ç”¨äºæŒ‡å®šé¡¹ç›®å½“å‰çš„çŠ¶æ€ï¼Œè¯¥çŠ¶æ€ä¼šå±•ç¤ºåœ¨ `crates.io` çš„é¡¹ç›®ä¸»é¡µä¸­ï¼Œä¾‹å¦‚ä»¥ä¸‹é…ç½®å¯ä»¥è®¾ç½®é¡¹ç›®çš„ç»´æŠ¤çŠ¶æ€:

```toml
[badges]
# `maintenance` æ˜¯é¡¹ç›®çš„å½“å‰ç»´æŠ¤çŠ¶æ€ï¼Œå®ƒå¯èƒ½ä¼šè¢«å…¶å®ƒæ³¨å†ŒæœåŠ¡æ‰€ä½¿ç”¨ï¼Œä½†æ˜¯ç›®å‰è¿˜æ²¡æœ‰è¢« `crates.io` ä½¿ç”¨:  https://github.com/rust-lang/crates.io/issues/2437
#
# `status` å­—æ®µæ—¶å¿…é¡»çš„ï¼Œä»¥ä¸‹æ˜¯å¯ç”¨çš„é€‰é¡¹:
# - `actively-developed`: æ–°ç‰¹æ€§æ­£åœ¨ç§¯ææ·»åŠ ä¸­ï¼Œbug åœ¨æŒç»­ä¿®å¤ä¸­
# - `passively-maintained`: ç›®å‰æ²¡æœ‰è®¡åˆ’å»æ”¯æŒæ–°çš„ç‰¹æ€§ï¼Œä½†æ˜¯é¡¹ç›®ç»´æŠ¤è€…å¯èƒ½ä¼šå›ç­”ä½ æå‡ºçš„ issue
# - `as-is`: è¯¥é¡¹ç›®çš„åŠŸèƒ½å·²ç»å®Œç»“ï¼Œç»´æŠ¤è€…ä¸å‡†å¤‡ç»§ç»­å¼€å‘å’Œæä¾›æ”¯æŒäº†ï¼Œä½†æ˜¯å®ƒçš„åŠŸèƒ½å·²ç»è¾¾åˆ°äº†é¢„æœŸ
# - `experimental`: ä½œè€…å¸Œæœ›åŒå¤§å®¶åˆ†äº«ï¼Œä½†æ˜¯è¿˜ä¸å‡†å¤‡æ»¡è¶³ä»»ä½•äººçš„ç‰¹æ®Šè¦æ±‚
# - `looking-for-maintainer`: å½“å‰ç»´æŠ¤è€…å¸Œæœ›å°†é¡¹ç›®è½¬ç§»ç»™æ–°çš„ç»´æŠ¤è€…
# - `deprecated`: ä¸å†æ¨èä½¿ç”¨è¯¥é¡¹ç›®ï¼Œéœ€è¦è¯´æ˜åŸå› ä»¥åŠæ¨èçš„æ›¿ä»£é¡¹ç›®
# - `none`:  ä¸æ˜¾ç¤ºä»»ä½• badge ï¼Œå› æ­¤ç»´æŠ¤è€…æ²¡æœ‰è¯´æ˜ä»–ä»¬çš„çŠ¶æ€ï¼Œç”¨æˆ·éœ€è¦è‡ªå·±å»è°ƒæŸ¥å‘ç”Ÿäº†ä»€ä¹ˆ
maintenance = { status = "..." }
```

## [dependencies]

åœ¨[ä¹‹å‰ç« èŠ‚](https://course.rs/cargo/reference/specify-deps.html)ä¸­ï¼Œæˆ‘ä»¬å·²ç»è¯¦ç»†ä»‹ç»è¿‡ `[dependencies]` ã€ `[dev-dependencies]` å’Œ `[build-dependencies]`ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚

## [profile.*]

è¯¥éƒ¨åˆ†å¯ä»¥å¯¹ç¼–è¯‘å™¨è¿›è¡Œé…ç½®ï¼Œä¾‹å¦‚ debug å’Œä¼˜åŒ–ï¼Œåœ¨åç»­çš„[ç¼–è¯‘å™¨ä¼˜åŒ–](https://course.rs/cargo/reference/profiles.html)ç« èŠ‚æœ‰è¯¦ç»†ä»‹ç»ã€‚




================================================
FILE: src/cargo/reference/package-id.md
================================================
# Package ID è¯´æ˜



================================================
FILE: src/cargo/reference/profile.md
================================================
# å‘å¸ƒé…ç½® profile todo



================================================
FILE: src/cargo/reference/profiles.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/publishing-on-crates.io.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/specify-deps.md
================================================
# æŒ‡å®šä¾èµ–é¡¹

æˆ‘ä»¬çš„é¡¹ç›®å¯ä»¥å¼•ç”¨åœ¨ `crates.io` æˆ– `GitHub` ä¸Šçš„ä¾èµ–åŒ…ï¼Œä¹Ÿå¯ä»¥å¼•ç”¨å­˜æ”¾åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¾èµ–åŒ…ã€‚

å¤§å®¶å¯èƒ½ä¼šæƒ³ï¼Œç›´æ¥ä»å‰ä¸¤ä¸ªå¼•ç”¨å³å¯ï¼Œä¸ºä½•è¿˜æä¾›äº†æœ¬åœ°æ–¹å¼ï¼Ÿå¯ä»¥è®¾æƒ³ä¸‹ï¼Œå¦‚æœä½ è¦æœ‰ä¸€ä¸ªæ­£å¤„äºå¼€å‘ä¸­çš„åŒ…ï¼Œç„¶åéœ€è¦åœ¨æœ¬åœ°çš„å¦ä¸€ä¸ªé¡¹ç›®ä¸­å¼•ç”¨æµ‹è¯•ï¼Œé‚£æ˜¯å°†è¯¥åŒ…å…ˆä¼ åˆ°ç½‘ä¸Šï¼Œç„¶åå†å¼•ç”¨ç®€å•ï¼Œè¿˜æ˜¯ç›´æ¥ä»æœ¬åœ°è·¯å¾„çš„æ–¹å¼å¼•ç”¨ç®€å•å‘¢ï¼Ÿç­”æ¡ˆæ˜¾ç„¶ä¸è¨€è€Œå–»ã€‚

æœ¬ç« èŠ‚ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹æœ‰å“ªäº›æ–¹å¼å¯ä»¥æŒ‡å®šå’Œå¼•ç”¨ä¸‰æ–¹ä¾èµ–åŒ…ã€‚

## ä» `crates.io` å¼•å…¥ä¾èµ–åŒ…

é»˜è®¤è®¾ç½®ä¸‹ï¼Œ`Cargo` å°±ä» [crates.io](https://crates.io) ä¸Šä¸‹è½½ä¾èµ–åŒ…ï¼Œåªéœ€è¦ä¸€ä¸ªåŒ…åå’Œç‰ˆæœ¬å·å³å¯ï¼š

```toml
[dependencies]
time = "0.1.12"
```

å­—ç¬¦ä¸² `"0.1.12"` æ˜¯ä¸€ä¸ª [`semver`](https://semver.org) æ ¼å¼çš„ç‰ˆæœ¬å·ï¼Œç¬¦åˆ `"x.y.z"` çš„å½¢å¼ï¼Œå…¶ä¸­ `x` è¢«ç§°ä¸ºä¸»ç‰ˆæœ¬`major`, `y` è¢«ç§°ä¸ºå°ç‰ˆæœ¬ `minor` ï¼Œè€Œ `z` è¢«ç§°ä¸ºè¡¥ä¸ `patch`ï¼Œå¯ä»¥çœ‹å‡ºä»å·¦åˆ°å³ï¼Œç‰ˆæœ¬çš„å½±å“èŒƒå›´é€æ­¥é™ä½ï¼Œè¡¥ä¸çš„æ›´æ–°æ˜¯æ— å…³ç—›ç—’çš„ï¼Œå¹¶ä¸ä¼šé€ æˆ API çš„å…¼å®¹æ€§è¢«ç ´åã€‚

`"0.1.12"` ä¸­å¹¶æ²¡æœ‰ä»»ä½•é¢å¤–çš„ç¬¦å·ï¼Œåœ¨ç‰ˆæœ¬è¯­ä¹‰ä¸Šï¼Œå®ƒè·Ÿä½¿ç”¨äº† `^` çš„ `"^0.1.12"` æ˜¯ç›¸åŒçš„ï¼Œéƒ½æ˜¯æŒ‡å®šéå¸¸å…·ä½“çš„ç‰ˆæœ¬è¿›è¡Œå¼•å…¥ã€‚

ä½†æ˜¯ `^` èƒ½åšçš„æ›´å¤šã€‚

> npm ä½¿ç”¨çš„å°±æ˜¯ `semver` ç‰ˆæœ¬å·ï¼Œä» `JavaScript` è¿‡æ¥çš„åŒå­¦åº”è¯¥éå¸¸ç†Ÿæ‚‰ã€‚

#### `^` æŒ‡å®šç‰ˆæœ¬

ä¸ä¹‹å‰çš„ `"0.1.12"` ä¸åŒï¼Œ `^` å¯ä»¥æŒ‡å®šä¸€ä¸ªç‰ˆæœ¬å·èŒƒå›´ï¼Œ**ç„¶åä¼šä½¿ç”¨è¯¥èŒƒå›´å†…çš„æœ€å¤§ç‰ˆæœ¬å·æ¥å¼•ç”¨å¯¹åº”çš„åŒ…**ã€‚

åªè¦æ–°çš„ç‰ˆæœ¬å·æ²¡æœ‰ä¿®æ”¹æœ€å·¦è¾¹çš„éé›¶æ•°å­—ï¼Œé‚£è¯¥ç‰ˆæœ¬å·å°±åœ¨å…è®¸çš„ç‰ˆæœ¬å·èŒƒå›´ä¸­ã€‚ä¾‹å¦‚ `"^0.1.12"` æœ€å·¦è¾¹çš„éé›¶æ•°å­—æ˜¯ `1`ï¼Œå› æ­¤ï¼Œåªè¦æ–°çš„ç‰ˆæœ¬å·æ˜¯ `"0.1.z"` å°±å¯ä»¥è½åœ¨èŒƒå›´å†…ï¼Œè€Œ`0.2.0` æ˜¾ç„¶å°±æ²¡æœ‰è½åœ¨èŒƒå›´å†…ï¼Œå› æ­¤é€šè¿‡ `"^0.1.12"` å¼•å…¥çš„ä¾èµ–åŒ…æ˜¯æ— æ³•è¢«å‡çº§åˆ° `0.2.0` ç‰ˆæœ¬çš„ã€‚

åŒç†ï¼Œè‹¥æ˜¯ `"^1.0"`ï¼Œåˆ™ `1.1` åœ¨èŒƒå›´ä¸­ï¼Œ`2.0` åˆ™ä¸åœ¨ã€‚ å¤§å®¶æ€è€ƒä¸‹ï¼Œ`"^0.0.1"` ä¸å“ªäº›ç‰ˆæœ¬å…¼å®¹ï¼Ÿç­”æ¡ˆæ˜¯ï¼šæ— ï¼Œå› ä¸ºå®ƒæœ€å·¦è¾¹çš„æ•°å­—æ˜¯ `1` ï¼Œè€Œè¯¥æ•°å­—å·²ç»é€€æ— å¯é€€ï¼Œæˆ‘ä»¬åˆä¸èƒ½ä¿®æ”¹ `1`ï¼Œå› æ­¤æ²¡æœ‰ç‰ˆæœ¬è½åœ¨èŒƒå›´ä¸­ã€‚

```shell
^1.2.3  :=  >=1.2.3, <2.0.0
^1.2    :=  >=1.2.0, <2.0.0
^1      :=  >=1.0.0, <2.0.0
^0.2.3  :=  >=0.2.3, <0.3.0
^0.2    :=  >=0.2.0, <0.3.0
^0.0.3  :=  >=0.0.3, <0.0.4
^0.0    :=  >=0.0.0, <0.1.0
^0      :=  >=0.0.0, <1.0.0
```

ä»¥ä¸Šæ˜¯æ›´å¤šçš„ä¾‹å­ï¼Œ**äº‹å®ä¸Šï¼Œè¿™ä¸ªè§„åˆ™è·Ÿ `SemVer` è¿˜æœ‰æ‰€ä¸åŒ**ï¼Œå› ä¸ºå¯¹äº `SemVer` è€Œè¨€ï¼Œ`0.x.y` çš„ç‰ˆæœ¬æ˜¯æ²¡æœ‰å…¶å®ƒç‰ˆæœ¬ä¸å…¶å…¼å®¹çš„ï¼Œè€Œå¯¹äº Rustï¼Œåªè¦ç‰ˆæœ¬å· `0.x.y` æ»¡è¶³ ï¼š `z>=y` ä¸” `x>0` çš„æ¡ä»¶ï¼Œé‚£å®ƒå°±èƒ½æ›´æ–°åˆ° `0.x.z` ç‰ˆæœ¬ã€‚

#### `~` æŒ‡å®šç‰ˆæœ¬

`~` æŒ‡å®šäº†æœ€å°åŒ–ç‰ˆæœ¬ :

```rust
~1.2.3  := >=1.2.3, <1.3.0
~1.2    := >=1.2.0, <1.3.0
~1      := >=1.0.0, <2.0.0
```

#### `*` é€šé…ç¬¦

è¿™ç§æ–¹å¼å…è®¸å°† `*` æ‰€åœ¨çš„ä½ç½®æ›¿æ¢æˆä»»ä½•æ•°å­—:

```rust
*     := >=0.0.0
1.*   := >=1.0.0, <2.0.0
1.2.* := >=1.2.0, <1.3.0
```

ä¸è¿‡ `crates.io` å¹¶ä¸å…è®¸æˆ‘ä»¬åªä½¿ç”¨å­¤é›¶é›¶ä¸€ä¸ª `*` æ¥æŒ‡å®šç‰ˆæœ¬å· : `*`ã€‚

#### æ¯”è¾ƒç¬¦

å¯ä»¥ä½¿ç”¨æ¯”è¾ƒç¬¦çš„æ–¹å¼æ¥æŒ‡å®šä¸€ä¸ªç‰ˆæœ¬å·èŒƒå›´æˆ–ä¸€ä¸ªç²¾ç¡®çš„ç‰ˆæœ¬å·:

```rust
>= 1.2.0
> 1
< 2
= 1.2.3
```

åŒæ—¶è¿˜èƒ½ä½¿ç”¨æ¯”è¾ƒç¬¦è¿›è¡Œç»„åˆï¼Œå¹¶é€šè¿‡é€—å·åˆ†éš”ï¼š

```rust
>= 1.2, < 1.5
```

éœ€è¦æ³¨æ„ï¼Œä»¥ä¸Šçš„ç‰ˆæœ¬å·è§„åˆ™ä»…ä»…é’ˆå¯¹ `crate.io` å’ŒåŸºäºå®ƒæ­å»ºçš„æ³¨å†ŒæœåŠ¡(ä¾‹å¦‚ç§‘å¤§æœåŠ¡æº) ï¼Œå…¶å®ƒæ³¨å†ŒæœåŠ¡(ä¾‹å¦‚ GitHub )æœ‰è‡ªå·±ç›¸åº”çš„è§„åˆ™ã€‚

## ä»å…¶å®ƒæ³¨å†ŒæœåŠ¡å¼•å…¥ä¾èµ–åŒ…

ä¸ºäº†ä½¿ç”¨ `crates.io` ä¹‹å¤–çš„æ³¨å†ŒæœåŠ¡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ `$HOME/.cargo/config.toml` ($CARGO_HOME ä¸‹) æ–‡ä»¶è¿›è¡Œé…ç½®ï¼Œæ·»åŠ æ–°çš„æœåŠ¡æä¾›å•†ï¼Œæœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å®ç°ã€‚

> ç”±äºå›½å†…è®¿é—®å›½å¤–æ³¨å†ŒæœåŠ¡çš„ä¸ç¨³å®šæ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨[ç§‘å¤§çš„æ³¨å†ŒæœåŠ¡](http://mirrors.ustc.edu.cn/help/crates.io-index.html)æ¥æå‡ä¸‹è½½é€Ÿåº¦ï¼Œä»¥ä¸‹æ³¨å†ŒæœåŠ¡çš„é“¾æ¥éƒ½æ˜¯ç§‘å¤§çš„

**é¦–å…ˆæ˜¯åœ¨ `crates.io` ä¹‹å¤–æ·»åŠ æ–°çš„æ³¨å†ŒæœåŠ¡**ï¼Œä¿®æ”¹ `.cargo/config.toml` æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š

```toml
[registries]
ustc = { index = "https://mirrors.ustc.edu.cn/crates.io-index/" }
```

å¯¹äºè¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬çš„é¡¹ç›®çš„ `Cargo.toml` ä¸­çš„ä¾èµ–åŒ…å¼•å…¥æ–¹å¼ä¹Ÿæœ‰æ‰€ä¸åŒï¼š

```toml
[dependencies]
time = {  registry = "ustc" }
```

åœ¨é‡æ–°é…ç½®åï¼Œåˆæ¬¡æ„å»ºå¯èƒ½è¦è¾ƒä¹…çš„æ—¶é—´ï¼Œå› ä¸ºè¦ä¸‹è½½æ›´æ–° `ustc` æ³¨å†ŒæœåŠ¡çš„ç´¢å¼•æ–‡ä»¶ï¼Œè¿˜æŒºå¤§çš„...

æ³¨æ„ï¼Œè¿™ä¸€ç§ä½¿ç”¨æ–¹å¼æœ€å¤§çš„ç¼ºç‚¹å°±æ˜¯åœ¨å¼•ç”¨ä¾èµ–åŒ…æ—¶è¦æŒ‡å®šæ³¨å†ŒæœåŠ¡: `time = { registry = "ustc" }`ã€‚

**è€Œç¬¬äºŒç§æ–¹å¼å°±ä¸éœ€è¦ï¼Œå› ä¸ºå®ƒæ˜¯ç›´æ¥ä½¿ç”¨æ–°æ³¨å†ŒæœåŠ¡æ¥æ›¿ä»£é»˜è®¤çš„ `crates.io`**ã€‚

```toml
[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

ä¸Šé¢é…ç½®ä¸­çš„ç¬¬ä¸€ä¸ªéƒ¨åˆ†ï¼Œé¦–å…ˆå°†æº `source.crates-io` æ›¿æ¢ä¸º `ustc`ï¼Œç„¶ååœ¨ç¬¬äºŒéƒ¨åˆ†æŒ‡å®šäº† `ustc` æºçš„åœ°å€ã€‚

> æ³¨æ„ï¼Œå¦‚æœä½ è¦å‘å¸ƒåŒ…åˆ° `crates.io` ä¸Šï¼Œé‚£è¯¥åŒ…çš„ä¾èµ–ä¹Ÿå¿…é¡»åœ¨ `crates.io` ä¸Š

#### å¼•å…¥ git ä»“åº“ä½œä¸ºä¾èµ–åŒ…

è‹¥è¦å¼•å…¥ git ä»“åº“ä¸­çš„åº“ä½œä¸ºä¾èµ–åŒ…ï¼Œä½ è‡³å°‘éœ€è¦æä¾›ä¸€ä¸ªä»“åº“çš„åœ°å€:

```toml
[dependencies]
regex = { git = "https://github.com/rust-lang/regex" }
```

ç”±äºæ²¡æœ‰æŒ‡å®šç‰ˆæœ¬ï¼ŒCargo ä¼šå‡å®šæˆ‘ä»¬ä½¿ç”¨ `master` æˆ– `main` åˆ†æ”¯çš„æœ€æ–° `commit` ã€‚ä½ å¯ä»¥ä½¿ç”¨ `rev`ã€`tag` æˆ– `branch` æ¥æŒ‡å®šæƒ³è¦æ‹‰å–çš„ç‰ˆæœ¬ã€‚ä¾‹å¦‚ä¸‹é¢ä»£ç æ‹‰å–äº† `next` åˆ†æ”¯ä¸Šçš„æœ€æ–° `commit`ï¼š

```toml
[dependencies]
regex = { git = "https://github.com/rust-lang/regex", branch = "next" }
```

ä»»ä½•é `tag` å’Œ `branch` çš„ç±»å‹éƒ½å¯ä»¥é€šè¿‡ `rev` æ¥å¼•å…¥ï¼Œä¾‹å¦‚é€šè¿‡æœ€è¿‘ä¸€æ¬¡ `commit` çš„å“ˆå¸Œå€¼å¼•å…¥: `rev = "4c59b707"`ï¼Œå†æ¯”å¦‚è¿œç¨‹ä»“åº“æä¾›çš„çš„å…·åå¼•ç”¨: `rev = "refs/pull/493/head"`ã€‚

ä¸€æ—¦ `git` ä¾èµ–è¢«æ‹‰å–ä¸‹æ¥ï¼Œè¯¥ç‰ˆæœ¬å°±ä¼šè¢«è®°å½•åˆ° `Cargo.lock` ä¸­è¿›è¡Œé”å®šã€‚å› æ­¤ `git` ä»“åº“ä¸­åç»­æ–°çš„æäº¤ä¸å†ä¼šè¢«è‡ªåŠ¨æ‹‰å–ï¼Œé™¤éä½ é€šè¿‡ `cargo update` æ¥å‡çº§ã€‚éœ€è¦æ³¨æ„çš„æ˜¯é”å®šä¸€æ—¦è¢«åˆ é™¤ï¼Œé‚£ Cargo ä¾ç„¶ä¼šæŒ‰ç…§ `Cargo.toml` ä¸­é…ç½®çš„åœ°å€å’Œç‰ˆæœ¬å»æ‹‰å–æ–°çš„ç‰ˆæœ¬ï¼Œå¦‚æœä½ é…ç½®çš„ç‰ˆæœ¬ä¸æ­£ç¡®ï¼Œé‚£å¯èƒ½ä¼šæ‹‰å–ä¸‹æ¥ä¸€ä¸ªä¸å…¼å®¹çš„æ–°ç‰ˆæœ¬ï¼

**å› æ­¤ä¸è¦ä¾èµ–é”å®šæ¥å®Œæˆç‰ˆæœ¬çš„æ§åˆ¶ï¼Œè€Œåº”è¯¥è€è€å®å®çš„åœ¨ `Cargo.toml` å°å¿ƒé…ç½®ä½ å¸Œæœ›ä½¿ç”¨çš„ç‰ˆæœ¬ã€‚**

å¦‚æœè®¿é—®çš„æ˜¯ç§æœ‰ä»“åº“ï¼Œä½ å¯èƒ½éœ€è¦æˆæƒæ¥è®¿é—®è¯¥ä»“åº“ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™é‡Œ](https://course.rs/cargo/git-auth.html)äº†è§£æˆæƒçš„æ–¹å¼ã€‚

#### é€šè¿‡è·¯å¾„å¼•å…¥æœ¬åœ°ä¾èµ–åŒ…

Cargo æ”¯æŒé€šè¿‡è·¯å¾„çš„æ–¹å¼æ¥å¼•å…¥æœ¬åœ°çš„ä¾èµ–åŒ…ï¼šä¸€èˆ¬æ¥è¯´ï¼Œæœ¬åœ°ä¾èµ–åŒ…éƒ½æ˜¯åŒä¸€ä¸ªé¡¹ç›®å†…çš„å†…éƒ¨åŒ…ï¼Œä¾‹å¦‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª `hello_world` é¡¹ç›®( package )ï¼Œç°åœ¨åœ¨å…¶æ ¹ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªåŒ…:

```shell
#  åœ¨ hello_world/ ç›®å½•ä¸‹
$ cargo new hello_utils
```

æ–°å»ºçš„ `hello_utils` æ–‡ä»¶å¤¹è·Ÿ `src`ã€`Cargo.toml` åŒçº§ï¼Œç°åœ¨ä¿®æ”¹ `Cargo.toml` è®© `hello_world` é¡¹ç›®å¼•å…¥æ–°å»ºçš„åŒ…:

```toml
[dependencies]
hello_utils = { path = "hello_utils" }
# ä»¥ä¸‹è·¯å¾„ä¹Ÿå¯ä»¥
# hello_utils = { path = "./hello_utils" }
# hello_utils = { path = "../hello_world/hello_utils" }
```

ä½†æ˜¯ï¼Œæ­¤æ—¶çš„ `hello_world` æ˜¯æ— æ³•å‘å¸ƒåˆ° `crates.io` ä¸Šçš„ã€‚æƒ³è¦å‘å¸ƒï¼Œéœ€è¦å…ˆå°† `hello_utils` å…ˆå‘å¸ƒåˆ° `crates.io` ä¸Šï¼Œç„¶åå†é€šè¿‡ `crates.io` çš„æ–¹å¼æ¥å¼•å…¥:

```toml
[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
```

> æ³¨æ„ï¼ä½¿ç”¨ `path` æŒ‡å®šä¾èµ–çš„ package å°†æ— æ³•å‘å¸ƒåˆ° `crates.io`ï¼Œé™¤é `path` å­˜åœ¨äº [[dev-dependencies]](#dev-dependencies) ä¸­ã€‚å½“ç„¶ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨å¤šç§å¼•ç”¨æ··åˆçš„æ–¹å¼æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸‹é¢å°†è¿›è¡Œä»‹ç»

## å¤šå¼•ç”¨æ–¹å¼æ··åˆ

å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥åŒæ—¶ä½¿ç”¨å¤šç§æ–¹å¼æ¥å¼•å…¥åŒä¸€ä¸ªåŒ…ï¼Œä¾‹å¦‚æœ¬åœ°å¼•å…¥å’Œ `crates.io` :

```toml
[dependencies]
# æœ¬åœ°ä½¿ç”¨æ—¶ï¼Œé€šè¿‡ path å¼•å…¥,
# å‘å¸ƒåˆ° `crates.io` æ—¶ï¼Œé€šè¿‡ `crates.io` çš„æ–¹å¼å¼•å…¥ï¼š  version = "1.0"
bitflags = { path = "my-bitflags", version = "1.0" }

# æœ¬åœ°ä½¿ç”¨æ—¶ï¼Œé€šè¿‡ git ä»“åº“å¼•å…¥
# å½“å‘å¸ƒæ—¶ï¼Œé€šè¿‡ `crates.io` å¼•å…¥ï¼š version = "1.0"
smallvec = { git = "https://github.com/servo/rust-smallvec", version = "1.0" }

# N.B. è‹¥ version æ— æ³•åŒ¹é…ï¼ŒCargo å°†æ— æ³•ç¼–è¯‘
```

è¿™ç§æ–¹å¼è·Ÿä¸‹ç« èŠ‚å°†è¦è®²è¿°çš„ä¾èµ–è¦†ç›–ç±»ä¼¼ï¼Œä½†æ˜¯å‰è€…åªä¼šåº”ç”¨åˆ°å½“å‰å£°æ˜çš„ä¾èµ–åŒ…ä¸Šã€‚

## æ ¹æ®å¹³å°å¼•å…¥ä¾èµ–

æˆ‘ä»¬è¿˜å¯ä»¥æ ¹æ®ç‰¹å®šçš„å¹³å°æ¥å¼•å…¥ä¾èµ–:

```toml
[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }
```

æ­¤å¤„çš„è¯­æ³•è·Ÿ Rust çš„ [`#[cfg]`](https://doc.rust-lang.org/stable/reference/conditional-compilation.html) è¯­æ³•éå¸¸ç›¸åƒï¼Œå› æ­¤æˆ‘ä»¬è¿˜èƒ½ä½¿ç”¨é€»è¾‘æ“ä½œç¬¦è¿›è¡Œæ§åˆ¶:

```toml
[target.'cfg(not(unix))'.dependencies]
openssl = "1.0.1"
```

è¿™é‡Œçš„æ„æ€æ˜¯ï¼Œå½“ä¸æ˜¯ `unix` æ“ä½œç³»ç»Ÿæ—¶ï¼Œæ‰å¯¹ `openssl` è¿›è¡Œå¼•å…¥ã€‚

å¦‚æœä½ æƒ³è¦çŸ¥é“ `cfg` èƒ½å¤Ÿä½œç”¨çš„ç›®æ ‡ï¼Œå¯ä»¥åœ¨ç»ˆç«¯ä¸­è¿è¡Œ `rustc --print=cfg` è¿›è¡ŒæŸ¥è¯¢ã€‚å½“ç„¶ï¼Œä½ å¯ä»¥æŒ‡å®šå¹³å°æŸ¥è¯¢: `rustc --print=cfg --target=x86_64-pc-windows-msvc`ï¼Œè¯¥å‘½ä»¤å°†å¯¹ `64bit` çš„ Windows è¿›è¡ŒæŸ¥è¯¢ã€‚

èªæ˜çš„åŒå­¦å·²ç»å‘ç°ï¼Œè¿™éå¸¸ç±»ä¼¼äºæ¡ä»¶ä¾èµ–å¼•å…¥ï¼Œé‚£æˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥æ ¹æ®è‡ªå®šä¹‰çš„æ¡ä»¶æ¥å†³å®šæ˜¯å¦å¼•å…¥æŸä¸ªä¾èµ–å‘¢ï¼Ÿå…·ä½“ç­”æ¡ˆå‚è§åç»­çš„ [feature](https://course.rs/cargo/reference/features.html) ç« èŠ‚ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹:

```toml
[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]
```

ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½ å¦‚æœå¦„å›¾é€šè¿‡ `cfg(feature)`ã€`cfg(debug_assertions)`, `cfg(test)` å’Œ `cfg(proc_macro)` çš„æ–¹å¼æ¥æ¡ä»¶å¼•å…¥ä¾èµ–ï¼Œé‚£æ˜¯ä¸å¯è¡Œçš„ã€‚

`Cargo` è¿˜å…è®¸é€šè¿‡ä¸‹é¢çš„æ–¹å¼æ¥å¼•å…¥å¹³å°ç‰¹å®šçš„ä¾èµ–:

```toml
[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
```

## è‡ªå®šä¹‰ target å¼•å…¥

å¦‚æœä½ åœ¨ä½¿ç”¨è‡ªå®šä¹‰çš„ `target` ï¼šä¾‹å¦‚ `--target bar.json`ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹å¼æ¥å¼•å…¥ä¾èµ–:

```toml
[target.bar.dependencies]
winhttp = "0.4.0"

[target.my-special-i686-platform.dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }
```

> éœ€è¦æ³¨æ„ï¼Œè¿™ç§ä½¿ç”¨æ–¹å¼åœ¨ `stable` ç‰ˆæœ¬çš„ Rust ä¸­æ— æ³•è¢«ä½¿ç”¨ï¼Œå»ºè®®å¤§å®¶å¦‚æœæ²¡æœ‰ç‰¹åˆ«çš„éœ€æ±‚ï¼Œè¿˜æ˜¯ä½¿ç”¨ä¹‹å‰æåˆ°çš„ feature æ–¹å¼

## [dev-dependencies]

ä½ è¿˜å¯ä»¥ä¸ºé¡¹ç›®æ·»åŠ åªåœ¨æµ‹è¯•æ—¶éœ€è¦çš„ä¾èµ–åº“ï¼Œç±»ä¼¼äº `package.json`( Nodejs )æ–‡ä»¶ä¸­çš„ `devDependencies`ï¼Œå¯ä»¥åœ¨ `Cargo.toml` ä¸­æ·»åŠ  `[dev-dependencies]` æ¥å®ç°:

```toml
[dev-dependencies]
tempdir = "0.3"
```

è¿™é‡Œçš„ä¾èµ–åªä¼šåœ¨è¿è¡Œæµ‹è¯•ã€ç¤ºä¾‹å’Œ benchmark æ—¶æ‰ä¼šè¢«å¼•å…¥ã€‚å¹¶ä¸”ï¼Œå‡è®¾`A` åŒ…å¼•ç”¨äº† `B`ï¼Œè€Œ `B` é€šè¿‡ `[dev-dependencies]` çš„æ–¹å¼å¼•ç”¨äº† `C` åŒ…ï¼Œ é‚£ `A` æ˜¯ä¸ä¼šå¼•ç”¨ `C` åŒ…çš„ã€‚

å½“ç„¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šå¹³å°ç‰¹å®šçš„æµ‹è¯•ä¾èµ–åŒ…:

```toml
[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
```

> æ³¨æ„ï¼Œå½“å‘å¸ƒåŒ…åˆ° crates.io æ—¶ï¼Œ`[dev-dependencies]` ä¸­çš„ä¾èµ–åªæœ‰æŒ‡å®šäº† `version` çš„æ‰ä¼šè¢«åŒ…å«åœ¨å‘å¸ƒåŒ…ä¸­ã€‚å†µä¸”ï¼Œå†åŠ ä¸Šæµ‹è¯•ç¨³å®šæ€§çš„è€ƒè™‘ï¼Œæˆ‘ä»¬å»ºè®®ä¸º `[dev-dependencies]` ä¸­çš„åŒ…æŒ‡å®šç›¸åº”çš„ç‰ˆæœ¬å·

## [build-dependencies]

æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šæŸäº›ä¾èµ–ä»…ç”¨äºæ„å»ºè„šæœ¬:

```toml
[build-dependencies]
cc = "1.0.3"
```

å½“ç„¶ï¼Œå¹³å°ç‰¹å®šçš„ä¾ç„¶å¯ä»¥ä½¿ç”¨ï¼š

```toml
[target.'cfg(unix)'.build-dependencies]
cc = "1.0.3"
```

æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼šæ„å»ºè„šæœ¬(` build.rs` )å’Œé¡¹ç›®çš„æ­£å¸¸ä»£ç æ˜¯å½¼æ­¤ç‹¬ç«‹ï¼Œå› æ­¤å®ƒä»¬çš„ä¾èµ–ä¸èƒ½äº’é€šï¼š æ„å»ºè„šæœ¬æ— æ³•ä½¿ç”¨ `[dependencies]` æˆ– `[dev-dependencies]` ä¸­çš„ä¾èµ–ï¼Œè€Œ `[build-dependencies]` ä¸­çš„ä¾èµ–ä¹Ÿæ— æ³•è¢«æ„å»ºè„šæœ¬ä¹‹å¤–çš„ä»£ç æ‰€ä½¿ç”¨ã€‚

## é€‰æ‹© features

å¦‚æœä½ ä¾èµ–çš„åŒ…æä¾›äº†æ¡ä»¶æ€§çš„ `features`ï¼Œä½ å¯ä»¥æŒ‡å®šä½¿ç”¨å“ªä¸€ä¸ª:

```toml
[dependencies.awesome]
version = "1.3.5"
default-features = false # ä¸è¦åŒ…å«é»˜è®¤çš„ featuresï¼Œè€Œæ˜¯é€šè¿‡ä¸‹é¢çš„æ–¹å¼æ¥æŒ‡å®š
features = ["secure-password", "civet"]
```

æ›´å¤šçš„ä¿¡æ¯å‚è§ [Features ç« èŠ‚](https://course.rs/cargo/reference/features.html)

## åœ¨ Cargo.toml ä¸­é‡å‘½åä¾èµ–

å¦‚æœä½ æƒ³è¦å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

- é¿å…åœ¨ Rust ä»£ç ä¸­ä½¿ç”¨ `use foo as bar`
- ä¾èµ–æŸä¸ªåŒ…çš„å¤šä¸ªç‰ˆæœ¬
- ä¾èµ–æ¥è‡ªäºä¸åŒæ³¨å†ŒæœåŠ¡çš„åŒååŒ…

é‚£å¯ä»¥ä½¿ç”¨ Cargo æä¾›çš„ `package key` :

```toml
[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
```

æ­¤æ—¶ï¼Œä½ çš„ä»£ç ä¸­å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªåŒ…ï¼š

```rust
extern crate foo; // æ¥è‡ª crates.io
extern crate bar; // æ¥è‡ª git repository
extern crate baz; // æ¥è‡ª registry `custom`
```

æœ‰è¶£çš„æ˜¯ï¼Œç”±äºè¿™ä¸‰ä¸ª `package` çš„åç§°éƒ½æ˜¯ `foo`(åœ¨å„è‡ªçš„ `Cargo.toml` ä¸­å®šä¹‰)ï¼Œå› æ­¤æˆ‘ä»¬æ˜¾å¼çš„é€šè¿‡ `package = "foo"` çš„æ–¹å¼å‘Šè¯‰ Cargoï¼šæˆ‘ä»¬éœ€è¦çš„å°±æ˜¯è¿™ä¸ª `foo package`ï¼Œè™½ç„¶å®ƒè¢«é‡å‘½åä¸º `bar` æˆ– `baz`ã€‚

æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œå½“ä½¿ç”¨å¯é€‰ä¾èµ–æ—¶ï¼Œå¦‚æœä½ å°† `foo` åŒ…é‡å‘½åä¸º `bar` åŒ…ï¼Œé‚£å¼•ç”¨å‰è€…çš„ feature æ—¶çš„è·¯å¾„åä¹Ÿè¦åšç›¸åº”çš„ä¿®æ”¹:

```toml
[dependencies]
bar = { version = "0.1", package = 'foo', optional = true }

[features]
log-debug = ['bar/log-debug'] # è‹¥ä½¿ç”¨ 'foo/log-debug' ä¼šå¯¼è‡´æŠ¥é”™
```




================================================
FILE: src/cargo/reference/workspaces.md
================================================
# å·¥ä½œç©ºé—´ Workspace

ä¸€ä¸ªå·¥ä½œç©ºé—´æ˜¯ç”±å¤šä¸ª `package` ç»„æˆçš„é›†åˆï¼Œå®ƒä»¬å…±äº«åŒä¸€ä¸ª `Cargo.lock` æ–‡ä»¶ã€è¾“å‡ºç›®å½•å’Œä¸€äº›è®¾ç½®(ä¾‹å¦‚ profiles : ç¼–è¯‘å™¨è®¾ç½®å’Œä¼˜åŒ–)ã€‚ç»„æˆå·¥ä½œç©ºé—´çš„ `packages` è¢«ç§°ä¹‹ä¸ºå·¥ä½œç©ºé—´çš„æˆå‘˜ã€‚

## å·¥ä½œç©ºé—´çš„ä¸¤ç§ç±»å‹

å·¥ä½œç©ºé—´æœ‰ä¸¤ç§ç±»å‹ï¼š`root package` å’Œè™šæ‹Ÿæ¸…å•( virtual manifest )ã€‚

#### æ ¹ package

**è‹¥ä¸€ä¸ª `package` çš„ `Cargo.toml` åŒ…å«äº†`[package]` çš„åŒæ—¶åˆåŒ…å«äº† `[workspace]` éƒ¨åˆ†ï¼Œåˆ™è¯¥ `package` è¢«ç§°ä¸ºå·¥ä½œç©ºé—´çš„æ ¹ `package`**ã€‚

æ¢è€Œè¨€ä¹‹ï¼Œä¸€ä¸ªå·¥ä½œç©ºé—´çš„æ ¹( root )æ˜¯è¯¥å·¥ä½œç©ºé—´çš„ `Cargo.toml` æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰å¤šä¸ª `package`ï¼Œå®ƒä»¬çš„ç›®å½•æ˜¯åµŒå¥—å…³ç³»ï¼Œç„¶åæˆ‘ä»¬åœ¨æœ€å¤–å±‚çš„ `package`ï¼Œä¹Ÿå°±æ˜¯æœ€å¤–å±‚ç›®å½•ä¸­çš„ `Cargo.toml` ä¸­å®šä¹‰ä¸€ä¸ª `[workspace]`ï¼Œæ­¤æ—¶è¿™ä¸ªæœ€å¤–å±‚çš„ `package` å°±æ˜¯å·¥ä½œç©ºé—´çš„æ ¹ã€‚

å†ä¸¾ä¸ªä¾‹å­ï¼Œå¤§åé¼é¼çš„ [ripgrep](https://github.com/BurntSushi/ripgrep/blob/master/Cargo.toml) å°±åœ¨æœ€å¤–å±‚çš„ `package` ä¸­å®šä¹‰äº† `[workspace]` :

```toml
[workspace]
members = [
  "crates/globset",
  "crates/grep",
  "crates/cli",
  "crates/matcher",
  "crates/pcre2",
  "crates/printer",
  "crates/regex",
  "crates/searcher",
  "crates/ignore",
]
```

é‚£ä¹ˆ[æœ€å¤–å±‚çš„ç›®å½•](https://github.com/BurntSushi/ripgrep)å°±æ˜¯ `ripgrep` çš„å·¥ä½œç©ºé—´çš„æ ¹ã€‚

#### è™šæ‹Ÿæ¸…å•

è‹¥ä¸€ä¸ª `Cargo.toml` æœ‰ `[workspace]` ä½†æ˜¯æ²¡æœ‰ `[package]` éƒ¨åˆ†ï¼Œåˆ™å®ƒæ˜¯è™šæ‹Ÿæ¸…å•ç±»å‹çš„å·¥ä½œç©ºé—´ã€‚

**å¯¹äºæ²¡æœ‰ä¸» `package` çš„åœºæ™¯æˆ–ä½ å¸Œæœ›å°†æ‰€æœ‰çš„ `package` ç»„ç»‡åœ¨å•ç‹¬çš„ç›®å½•ä¸­æ—¶ï¼Œè¿™ç§æ–¹å¼å°±éå¸¸é€‚åˆã€‚**

ä¾‹å¦‚ [rust-analyzer](https://github.com/rust-analyzer/rust-analyzer) å°±æ˜¯è¿™æ ·çš„é¡¹ç›®ï¼Œå®ƒçš„æ ¹ç›®å½•ä¸­çš„ `Cargo.toml` ä¸­å¹¶æ²¡æœ‰ `[package]`ï¼Œè¯´æ˜è¯¥æ ¹ç›®å½•ä¸æ˜¯ä¸€ä¸ª `package`ï¼Œä½†æ˜¯å´æœ‰ `[workspace]` :

```toml
[workspace]
members = ["xtask/", "lib/*", "crates/*"]
exclude = ["crates/proc_macro_test/imp"]
```

ç»“åˆ rust-analyzer çš„ç›®å½•å¸ƒå±€å¯ä»¥çœ‹å‡ºï¼Œ**è¯¥å·¥ä½œç©ºé—´çš„æ‰€æœ‰æˆå‘˜ `package` éƒ½åœ¨å•ç‹¬çš„ç›®å½•ä¸­ï¼Œå› æ­¤è¿™ç§æ–¹å¼å¾ˆé€‚åˆè™šæ‹Ÿæ¸…å•çš„å·¥ä½œç©ºé—´ã€‚**

## å…³é”®ç‰¹æ€§

å·¥ä½œç©ºé—´çš„å‡ ä¸ªå…³é”®ç‚¹åœ¨äº:

- æ‰€æœ‰çš„ `package` å…±äº«åŒä¸€ä¸ª `Cargo.lock` æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶ä½äºå·¥ä½œç©ºé—´çš„æ ¹ç›®å½•ä¸­
- æ‰€æœ‰çš„ `package` å…±äº«åŒä¸€ä¸ª[è¾“å‡ºç›®å½•](https://course.rs/cargo/guide/build-cache.html)ï¼Œè¯¥ç›®å½•é»˜è®¤çš„åç§°æ˜¯ `target` ï¼Œä½äºå·¥ä½œç©ºé—´æ ¹ç›®å½•ä¸‹
- åªæœ‰å·¥ä½œç©ºé—´æ ¹ç›®å½•çš„ `Cargo.toml` æ‰èƒ½åŒ…å« `[patch]`, `[replace]` å’Œ `[profile.*]`ï¼Œè€Œæˆå‘˜çš„ `Cargo.toml` ä¸­çš„ç›¸åº”éƒ¨åˆ†å°†è¢«è‡ªåŠ¨å¿½ç•¥

## [workspace]

`Cargo.toml` ä¸­çš„ `[workspace]` éƒ¨åˆ†ç”¨äºå®šä¹‰å“ªäº› `packages` å±äºå·¥ä½œç©ºé—´çš„æˆå‘˜:

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

è‹¥æŸä¸ªæœ¬åœ°ä¾èµ–åŒ…æ˜¯é€šè¿‡ [`path`](https://course.rs/cargo/reference/specify-deps.html#é€šè¿‡è·¯å¾„å¼•å…¥æœ¬åœ°ä¾èµ–åŒ…) å¼•å…¥ï¼Œä¸”è¯¥åŒ…ä½äºå·¥ä½œç©ºé—´çš„ç›®å½•ä¸­ï¼Œåˆ™è¯¥åŒ…è‡ªåŠ¨æˆä¸ºå·¥ä½œç©ºé—´çš„æˆå‘˜ã€‚

å‰©ä½™çš„æˆå‘˜éœ€è¦é€šè¿‡ `workspace.members` æ¥æŒ‡å®šï¼Œé‡Œé¢åŒ…å«äº†å„ä¸ªæˆå‘˜æ‰€åœ¨çš„ç›®å½•(æˆå‘˜ç›®å½•ä¸­åŒ…å«äº† Cargo.toml )ã€‚

`members` è¿˜æ”¯æŒä½¿ç”¨ [`glob`](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) æ¥åŒ¹é…å¤šä¸ªè·¯å¾„ï¼Œä¾‹å¦‚ä¸Šé¢çš„ä¾‹å­ä¸­ä½¿ç”¨ `crates/*` åŒ¹é… `crates` ç›®å½•ä¸‹çš„æ‰€æœ‰åŒ…ã€‚

`exclude` å¯ä»¥å°†æŒ‡å®šçš„ç›®å½•æ’é™¤åœ¨å·¥ä½œç©ºé—´ä¹‹å¤–ï¼Œä¾‹å¦‚è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­ï¼Œ`crates/*` åœ¨åŒ…å«äº† `crates` ç›®å½•ä¸‹çš„æ‰€æœ‰åŒ…åï¼Œåˆé€šè¿‡ `exclude` ä¸­ `crates/foo` å°† `crates` ä¸‹çš„ `foo` ç›®å½•æ’é™¤åœ¨å¤–ã€‚

ä½ ä¹Ÿå¯ä»¥å°†ä¸€ä¸ªç©ºçš„ `[workspace]` ç›´æ¥è”åˆ `[package]` ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

```toml
[package]
name = "hello"
version = "0.1.0"

[workspace]
```

æ­¤æ—¶çš„å·¥ä½œç©ºé—´çš„æˆå‘˜åŒ…å«:

- æ ¹ `package` : "hello"
- æ‰€æœ‰é€šè¿‡ `path` å¼•å…¥çš„æœ¬åœ°ä¾èµ–(ä½äºå·¥ä½œç©ºé—´ç›®å½•ä¸‹)

## é€‰æ‹©å·¥ä½œç©ºé—´

é€‰æ‹©å·¥ä½œç©ºé—´æœ‰ä¸¤ç§æ–¹å¼ï¼š`Cargo` è‡ªåŠ¨æŸ¥æ‰¾ã€æ‰‹åŠ¨æŒ‡å®š `package.workspace` å­—æ®µã€‚

å½“ä½äºå·¥ä½œç©ºé—´çš„å­ç›®å½•ä¸­æ—¶ï¼Œ`Cargo` ä¼šè‡ªåŠ¨åœ¨è¯¥ç›®å½•çš„çˆ¶ç›®å½•ä¸­å¯»æ‰¾å¸¦æœ‰ `[workspace]` å®šä¹‰çš„ `Cargo.toml`ï¼Œç„¶åå†å†³å®šä½¿ç”¨å“ªä¸ªå·¥ä½œç©ºé—´ã€‚

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹æ³•æ¥è¦†ç›– `Cargo` è‡ªåŠ¨æŸ¥æ‰¾åŠŸèƒ½ï¼šå°†æˆå‘˜åŒ…ä¸­çš„ `package.workspace` å­—æ®µä¿®æ”¹ä¸ºå·¥ä½œåŒºé—´æ ¹ç›®å½•çš„ä½ç½®ï¼Œè¿™æ ·å°±èƒ½æ˜¾å¼åœ°è®©ä¸€ä¸ªæˆå‘˜ä½¿ç”¨æŒ‡å®šçš„å·¥ä½œç©ºé—´ã€‚

å½“æˆå‘˜ä¸åœ¨å·¥ä½œç©ºé—´çš„å­ç›®å½•ä¸‹æ—¶ï¼Œè¿™ç§æ‰‹åŠ¨é€‰æ‹©å·¥ä½œç©ºé—´çš„æ–¹æ³•å°±éå¸¸é€‚ç”¨ã€‚æ¯•ç«Ÿ `Cargo` çš„è‡ªåŠ¨æœç´¢æ˜¯æ²¿ç€çˆ¶ç›®å½•å¾€ä¸ŠæŸ¥æ‰¾ï¼Œè€Œæˆå‘˜å¹¶ä¸åœ¨å·¥ä½œç©ºé—´çš„å­ç›®å½•ä¸‹ï¼Œè¿™æ„å‘³ç€é¡ºç€æˆå‘˜çš„çˆ¶ç›®å½•å¾€ä¸Šæ‰¾æ˜¯æ— æ³•æ‰¾åˆ°è¯¥å·¥ä½œç©ºé—´çš„ `Cargo.toml` çš„ï¼Œæ­¤æ—¶å°±åªèƒ½æ‰‹åŠ¨æŒ‡å®šäº†ã€‚

## é€‰æ‹© package

åœ¨å·¥ä½œç©ºé—´ä¸­ï¼Œ`package` ç›¸å…³çš„ `Cargo` å‘½ä»¤(ä¾‹å¦‚ `cargo build` )å¯ä»¥ä½¿ç”¨ `-p` ã€ `--package` æˆ– `--workspace` å‘½ä»¤è¡Œå‚æ•°æ¥æŒ‡å®šæƒ³è¦æ“ä½œçš„ `package`ã€‚

è‹¥æ²¡æœ‰æŒ‡å®šä»»ä½•å‚æ•°ï¼Œåˆ™ `Cargo` å°†ä½¿ç”¨å½“å‰å·¥ä½œç›®å½•çš„ä¸­çš„ `package` ã€‚è‹¥å·¥ä½œç›®å½•æ˜¯è™šæ‹Ÿæ¸…å•ç±»å‹çš„å·¥ä½œç©ºé—´ï¼Œåˆ™è¯¥å‘½ä»¤å°†ä½œç”¨åœ¨æ‰€æœ‰æˆå‘˜ä¸Š(å°±å¥½åƒæ˜¯ä½¿ç”¨äº† `--workspace` å‘½ä»¤è¡Œå‚æ•°)ã€‚è€Œ `default-members` å¯ä»¥åœ¨å‘½ä»¤è¡Œå‚æ•°æ²¡æœ‰è¢«æä¾›æ—¶ï¼Œæ‰‹åŠ¨æŒ‡å®šæ“ä½œçš„æˆå‘˜:

```toml
[workspace]
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]
default-members = ["path/to/member2", "path/to/member3/foo"]
```

è¿™æ ·ä¸€æ¥ï¼Œ `cargo build` å°±ä¸ä¼šåº”ç”¨åˆ°è™šæ‹Ÿæ¸…å•å·¥ä½œç©ºé—´çš„æ‰€æœ‰æˆå‘˜ï¼Œè€Œæ˜¯æŒ‡å®šçš„æˆå‘˜ä¸Šã€‚

## workspace.metadata

ä¸ [package.metadata](https://course.rs/cargo/reference/manifest.html#metadata) éå¸¸ç±»ä¼¼ï¼Œ`workspace.metadata` ä¼šè¢« `Cargo` è‡ªåŠ¨å¿½ç•¥ï¼Œå°±ç®—æ²¡æœ‰è¢«ä½¿ç”¨ä¹Ÿä¸ä¼šå‘å‡ºè­¦å‘Šã€‚

è¿™ä¸ªéƒ¨åˆ†å¯ä»¥ç”¨äºè®©å·¥å…·åœ¨ `Cargo.toml` ä¸­å­˜å‚¨ä¸€äº›å·¥ä½œç©ºé—´çš„é…ç½®å…ƒä¿¡æ¯ã€‚ä¾‹å¦‚:

```toml
[workspace]
members = ["member1", "member2"]

[workspace.metadata.webcontents]
root = "path/to/webproject"
tool = ["npm", "run", "build"]
# ...
```



================================================
FILE: src/cargo/reference/build-script/examples.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/build-script/intro.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/features/examples.md
================================================
# Features ç¤ºä¾‹

ä»¥ä¸‹æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹ä¸€äº›æ¥è‡ªçœŸå®ä¸–ç•Œçš„ç¤ºä¾‹ã€‚

### æœ€å°åŒ–æ„å»ºæ—¶é—´å’Œæ–‡ä»¶å¤§å°

å¦‚æœä¸€äº›åŒ…çš„éƒ¨åˆ†ç‰¹æ€§ä¸å†å¯ç”¨ï¼Œå°±å¯ä»¥å‡å°‘è¯¥åŒ…å ç”¨çš„å¤§å°ä»¥åŠç¼–è¯‘æ—¶é—´:

- [`syn`](https://crates.io/crates/syn) åŒ…å¯ä»¥ç”¨æ¥è§£æ Rust ä»£ç ï¼Œç”±äºå®ƒå¾ˆå—æ¬¢è¿ï¼Œå¤§é‡çš„é¡¹ç›®éƒ½åœ¨å¼•ç”¨ï¼Œå› æ­¤å®ƒç»™å‡ºäº†[éå¸¸æ¸…æ™°çš„æ–‡æ¡£](https://docs.rs/syn/1.0.54/syn/#optional-features)å…³äºå¦‚ä½•æœ€å°åŒ–ä½¿ç”¨å®ƒåŒ…å«çš„ `features`
- [`regex`](https://crates.io/crates/regex) ä¹Ÿæœ‰å…³äº features çš„[æè¿°æ–‡æ¡£](https://docs.rs/regex/1.4.2/regex/#crate-features)ï¼Œä¾‹å¦‚ç§»é™¤ Unicode æ”¯æŒçš„ feature å¯ä»¥é™ä½æœ€ç»ˆç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°
- [`winapi`](https://crates.io/crates/winapi) æ‹¥æœ‰[ä¼—å¤š features](https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431)ï¼Œè¿™äº› `feature` å¯¹ç”¨äº†å„ç§ Windows APIï¼Œä½ å¯ä»¥åªå¼•å…¥ä»£ç ä¸­ç”¨åˆ°çš„ API æ‰€å¯¹åº”çš„ feature.

### è¡Œä¸ºæ‰©å±•

[`serde_json`](https://crates.io/crates/serde_json) æ‹¥æœ‰ä¸€ä¸ª [`preserve_order` feature](https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56)ï¼Œå¯ä»¥ç”¨äºåœ¨åºåˆ—åŒ–æ—¶ä¿ç•™ JSON é”®å€¼å¯¹çš„é¡ºåºã€‚åŒæ—¶ï¼Œè¯¥ feature è¿˜ä¼šå¯ç”¨ä¸€ä¸ªå¯é€‰ä¾èµ– [indexmap](https://crates.io/crates/indexmap)ã€‚

å½“è¿™ä¹ˆåšæ—¶ï¼Œä¸€å®šè¦å°å¿ƒä¸è¦ç ´åäº† SemVer çš„ç‰ˆæœ¬å…¼å®¹æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼šå¯ç”¨ feature åï¼Œä»£ç ä¾ç„¶è¦èƒ½æ­£å¸¸å·¥ä½œã€‚

### no_std æ”¯æŒ

ä¸€äº›åŒ…å¸Œæœ›èƒ½åŒæ—¶æ”¯æŒ [`no_std`](https://doc.rust-lang.org/stable/reference/names/preludes.html#the-no_std-attribute) å’Œ `std` ç¯å¢ƒï¼Œä¾‹å¦‚è¯¥åŒ…å¸Œæœ›æ”¯æŒåµŒå…¥å¼ç³»ç»Ÿæˆ–èµ„æºç´§å¼ çš„ç³»ç»Ÿï¼Œä¸”åˆå¸Œæœ›èƒ½æ”¯æŒå…¶å®ƒçš„å¹³å°ï¼Œæ­¤æ—¶è¿™ç§åšæ³•æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œå› ä¸ºæ ‡å‡†åº“ `std` ä¼šå¤§å¹…å¢åŠ ç¼–è¯‘å‡ºæ¥çš„æ–‡ä»¶çš„å¤§å°ï¼Œå¯¹äºèµ„æºç´§å¼ çš„ç³»ç»Ÿæ¥è¯´ï¼Œ`no_std` æ‰æ˜¯æœ€åˆé€‚çš„ã€‚

[wasm-bindgen](https://crates.io/crates/wasm-bindgen) å®šä¹‰äº†ä¸€ä¸ª [std feature](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25)ï¼Œå®ƒæ˜¯[é»˜è®¤å¯ç”¨çš„](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25)ã€‚é¦–å…ˆï¼Œåœ¨åº“çš„é¡¶éƒ¨ï¼Œå®ƒ[æ— æ¡ä»¶çš„å¯ç”¨äº† `no_std` å±æ€§](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8)ï¼Œå®ƒå¯ä»¥ç¡®ä¿ `std` å’Œ [`std prelude`](https://doc.rust-lang.org/stable/std/prelude/index.html) ä¸ä¼šè‡ªåŠ¨å¼•å…¥åˆ°ä½œç”¨åŸŸä¸­æ¥ã€‚å…¶æ¬¡ï¼Œåœ¨ä¸åŒçš„åœ°æ–¹([ç¤ºä¾‹ 1](https://doc.rust-lang.org/stable/std/prelude/index.html)ï¼Œ[ç¤ºä¾‹ 2](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75))ï¼Œå®ƒé€šè¿‡ `#[cfg(feature = "std")]` å¯ç”¨ `std` feature æ¥æ·»åŠ  `std` æ ‡å‡†åº“æ”¯æŒã€‚

## å¯¹ä¾èµ–åº“çš„ features è¿›è¡Œå†å¯¼å‡º

ä»ä¾èµ–åº“å†å¯¼å‡º features åœ¨æœ‰äº›åœºæ™¯ä¸­ä¼šç›¸å½“æœ‰ç”¨ï¼Œè¿™æ ·ç”¨æˆ·å°±å¯ä»¥é€šè¿‡ä¾èµ–åŒ…çš„ features æ¥æ§åˆ¶åŠŸèƒ½è€Œä¸æ˜¯è‡ªå·±å»æ‰‹åŠ¨å®šä¹‰ã€‚

ä¾‹å¦‚ [`regex`](https://crates.io/crates/regex) å°† [`regex_syntax`](https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32) åŒ…çš„ features è¿›è¡Œäº†[å†å¯¼å‡º](https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89)ï¼Œè¿™æ · `regex` çš„ç”¨æˆ·æ— éœ€çŸ¥é“ `regex_syntax` åŒ…ï¼Œä½†æ˜¯ä¾ç„¶å¯ä»¥è®¿é—®åè€…åŒ…å«çš„ featuresã€‚

## feature ä¼˜å…ˆçº§

ä¸€äº›åŒ…å¯èƒ½ä¼šæ‹¥æœ‰å½¼æ­¤äº’æ–¥çš„ features(æ— æ³•å…±å­˜ï¼Œä¸Šä¸€ç« èŠ‚ä¸­æœ‰è®²åˆ°)ï¼Œå…¶ä¸­ä¸€ä¸ªåŠæ³•å°±æ˜¯ä¸º feature å®šä¹‰ä¼˜å…ˆçº§ï¼Œè¿™æ ·å…¶ä¸­ä¸€ä¸ªå°±ä¼šä¼˜äºå¦ä¸€ä¸ªè¢«å¯ç”¨ã€‚

ä¾‹å¦‚ [`log`](https://crates.io/crates/log) åŒ…ï¼Œå®ƒæœ‰[å‡ ä¸ª features](https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42) å¯ä»¥ç”¨äºåœ¨ç¼–è¯‘æœŸé€‰æ‹©æœ€å¤§çš„[æ—¥å¿—çº§åˆ«](https://docs.rs/log/0.4.11/log/#compile-time-filters)ï¼Œè¿™é‡Œï¼Œå®ƒå°±ä½¿ç”¨äº† [`cfg-if`](https://crates.io/crates/cfg-if) çš„æ–¹å¼æ¥[è®¾ç½®ä¼˜å…ˆçº§](https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448)ã€‚ä¸€æ—¦å¤šä¸ª `features` è¢«å¯ç”¨ï¼Œé‚£æ›´é«˜ä¼˜å…ˆçº§çš„å°±ä¼šä¼˜å…ˆè¢«å¯ç”¨ã€‚

## è¿‡ç¨‹å®åŒ…

ä¸€äº›åŒ…æ‹¥æœ‰è¿‡ç¨‹å®ï¼Œè¿™äº›å®å¿…é¡»å®šä¹‰åœ¨ä¸€ä¸ªç‹¬ç«‹çš„åŒ…ä¸­ã€‚ä½†æ˜¯ä¸æ˜¯æ‰€æœ‰çš„ç”¨æˆ·éƒ½éœ€è¦è¿‡ç¨‹å®çš„ï¼Œå› æ­¤ä¹Ÿæ— éœ€å¼•å…¥è¯¥åŒ…ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°†è¿‡ç¨‹å®æ‰€åœ¨çš„åŒ…å®šä¹‰ä¸ºå¯é€‰ä¾èµ–ï¼Œæ˜¯å¾ˆä¸é”™çš„é€‰æ‹©ã€‚è¿™æ ·åšè¿˜æœ‰ä¸€ä¸ªå¥½å¤„ï¼šæœ‰æ—¶è¿‡ç¨‹å®çš„ç‰ˆæœ¬å¿…é¡»è¦è·Ÿçˆ¶åŒ…è¿›è¡ŒåŒæ­¥ï¼Œä½†æ˜¯æˆ‘ä»¬åˆä¸å¸Œæœ›æ‰€æœ‰çš„ç”¨æˆ·éƒ½è¿›è¡ŒåŒæ­¥ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­å°±æ˜¯ [serde](https://crates.io/crates/serde) ï¼Œå®ƒæœ‰ä¸€ä¸ª [derive](https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35) feature å¯ä»¥å¯ç”¨ [serde_derive](https://crates.io/crates/serde_derive) è¿‡ç¨‹å®ã€‚ç”±äº `serde_derive` åŒ…è·Ÿ `serde` çš„å…³ç³»éå¸¸ç´§å¯†ï¼Œå› æ­¤å®ƒä½¿ç”¨äº†[ç‰ˆæœ¬ç›¸åŒçš„éœ€æ±‚](https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17)æ¥ä¿è¯ä¸¤è€…çš„ç‰ˆæœ¬åŒæ­¥æ€§ã€‚

## åªèƒ½ç”¨äº nightly çš„ feature

Rust æœ‰äº›å®éªŒæ€§çš„ API æˆ–è¯­è¨€ç‰¹æ€§åªèƒ½åœ¨ nightly ç‰ˆæœ¬ä¸‹ä½¿ç”¨ï¼Œä½†æŸäº›ä½¿ç”¨äº†è¿™äº› API çš„åŒ…å¹¶ä¸æƒ³å¼ºåˆ¶ä»–ä»¬çš„ç”¨æˆ·ä¹Ÿä½¿ç”¨ `nightly` ç‰ˆæœ¬ï¼Œå› æ­¤ä»–ä»¬ä¼šé€šè¿‡ feature çš„æ–¹å¼æ¥æ§åˆ¶ã€‚

è‹¥ç”¨æˆ·å¸Œæœ›ä½¿ç”¨è¿™äº› API æ—¶ï¼Œéœ€è¦å¯ç”¨ç›¸åº”çš„ feature ï¼Œè€Œè¿™äº› feature åªèƒ½åœ¨ nightly ä¸‹ä½¿ç”¨ã€‚è‹¥ç”¨æˆ·ä¸éœ€è¦ä½¿ç”¨è¿™äº› APIï¼Œå°±æ— éœ€å¼€å¯ ç›¸åº”çš„ featureï¼Œè‡ªç„¶ä¹Ÿä¸éœ€è¦ä½¿ç”¨ nightly ç‰ˆæœ¬ã€‚

ä¾‹å¦‚ [`rand`](https://crates.io/crates/rand) åŒ…æœ‰ä¸€ä¸ª [simd_support](https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40) feature å°±åªèƒ½åœ¨ nightly ä¸‹ä½¿ç”¨ï¼Œè‹¥æˆ‘ä»¬ä¸ä½¿ç”¨è¯¥ featureï¼Œåˆ™åœ¨ stable ä¸‹ä¾ç„¶å¯ä»¥ä½¿ç”¨ `rand`ã€‚

## å®éªŒæ€§ feature

æœ‰ä¸€äº›åŒ…ä¼šæå‰å°†ä¸€äº›å®éªŒæ€§çš„ API æ”¾å‡ºå»ï¼Œæ—¢ç„¶æ˜¯å®éªŒæ€§çš„ï¼Œè‡ªç„¶æ— æ³•ä¿è¯å…¶ç¨³å®šæ€§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé€šå¸¸ä¼šåœ¨æ–‡æ¡£ä¸­å°†ç›¸åº”çš„ features æ ‡è®°ä¸ºå®éªŒæ€§ï¼Œæ„å‘³ç€å®ƒä»¬åœ¨æœªæ¥å¯èƒ½ä¼šå‘ç”Ÿå¤§çš„æ”¹å˜(ç”šè‡³ minor ç‰ˆæœ¬éƒ½å¯èƒ½å‘ç”Ÿ)ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­æ˜¯ [async-std](https://crates.io/crates/async-std) åŒ…ï¼Œå®ƒæ‹¥æœ‰ä¸€ä¸ª [unstable feature](https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42)ï¼Œç”¨æ¥[æ ‡è®°ä¸€äº›æ–°çš„ API](https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46)ï¼Œè¡¨ç¤ºäººä»¬å·²ç»å¯ä»¥é€‰æ‹©æ€§çš„ä½¿ç”¨ä½†æ˜¯è¿˜æ²¡æœ‰å‡†å¤‡å¥½å»ä¾èµ–å®ƒã€‚




================================================
FILE: src/cargo/reference/features/intro.md
================================================
# æ¡ä»¶ç¼–è¯‘ Features

`Cargo Feature` æ˜¯éå¸¸å¼ºå¤§çš„æœºåˆ¶ï¼Œå¯ä»¥ä¸ºå¤§å®¶æä¾›[æ¡ä»¶ç¼–è¯‘](https://doc.rust-lang.org/stable/reference/conditional-compilation.html)å’Œå¯é€‰ä¾èµ–çš„é«˜çº§ç‰¹æ€§ã€‚

## [features]

`Feature` å¯ä»¥é€šè¿‡ `Cargo.toml` ä¸­çš„ `[features]` éƒ¨åˆ†æ¥å®šä¹‰ï¼šå…¶ä¸­æ¯ä¸ª `feature` é€šè¿‡åˆ—è¡¨çš„æ–¹å¼æŒ‡å®šäº†å®ƒæ‰€èƒ½å¯ç”¨çš„å…¶ä»– `feature` æˆ–å¯é€‰ä¾èµ–ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª 2D å›¾åƒå¤„ç†åº“ï¼Œç„¶åè¯¥åº“æ‰€æ”¯æŒçš„å›¾ç‰‡æ ¼å¼å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å¯ç”¨ï¼š

```toml
[features]
# å®šä¹‰ä¸€ä¸ª feature : webp, ä½†å®ƒå¹¶æ²¡æœ‰å¯ç”¨å…¶å®ƒ feature
webp = []
```

å½“å®šä¹‰äº† `webp` åï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ä»£ç ä¸­é€šè¿‡ [`cfg` è¡¨è¾¾å¼](https://doc.rust-lang.org/stable/reference/conditional-compilation.html)æ¥è¿›è¡Œæ¡ä»¶ç¼–è¯‘ã€‚ä¾‹å¦‚é¡¹ç›®ä¸­çš„ `lib.rs` å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç å¯¹ `webp` æ¨¡å—è¿›è¡Œæ¡ä»¶å¼•å…¥:

```toml
#[cfg(feature = "webp")]
pub mod webp;
```

`#[cfg(feature = "webp")]` çš„å«ä¹‰æ˜¯ï¼šåªæœ‰åœ¨ `webp` feature è¢«å®šä¹‰åï¼Œä»¥ä¸‹çš„ `webp` æ¨¡å—æ‰èƒ½è¢«å¼•å…¥è¿›æ¥ã€‚ç”±äºæˆ‘ä»¬ä¹‹å‰åœ¨ `[features]` é‡Œå®šä¹‰äº† `webp`ï¼Œå› æ­¤ä»¥ä¸Šä»£ç çš„ `webp` æ¨¡å—ä¼šè¢«æˆåŠŸå¼•å…¥ã€‚

åœ¨ `Cargo.toml` ä¸­å®šä¹‰çš„ `feature` ä¼šè¢« `Cargo` é€šè¿‡å‘½ä»¤è¡Œå‚æ•° `--cfg` ä¼ ç»™ `rustc`ï¼Œæœ€ç»ˆç”±åè€…å®Œæˆç¼–è¯‘ï¼šä¾‹å¦‚ï¼Œå®šä¹‰ "hello" å’Œ "hi" ä¸¤ä¸ª `feature`ï¼Œç­‰ä»·äº `rustc --cfg 'feature="hello"' --cfg 'feature="hi" ...'`ã€‚è‹¥é¡¹ç›®ä¸­çš„ä»£ç æƒ³è¦æµ‹è¯• `feature` æ˜¯å¦å­˜åœ¨ï¼Œå¯ä»¥ä½¿ç”¨ [`cfg` å±æ€§](https://doc.rust-lang.org/stable/reference/conditional-compilation.html#the-cfg-attribute)æˆ– [`cfg` å®](https://doc.rust-lang.org/stable/std/macro.cfg.html)ã€‚

ä¹‹å‰æˆ‘ä»¬æåˆ°äº†ä¸€ä¸ª `feature` è¿˜å¯ä»¥å¼€å¯å…¶ä»– `feature`ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œä¾‹å¦‚ ICO å›¾ç‰‡æ ¼å¼åŒ…å« BMP å’Œ PNG æ ¼å¼ï¼Œå› æ­¤å½“ `ico` è¢«å¯ç”¨åï¼Œå®ƒè¿˜å¾—ç¡®ä¿å¯ç”¨ `bmp` å’Œ `png` ï¼š

```toml
[features]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

å¯¹æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºï¼š **`bmp` å’Œ `png` æ˜¯å¼€å¯ `ico` çš„å…ˆå†³æ¡ä»¶**ï¼ˆæ³¨ï¼šå¼€å¯ `ico`ï¼Œä¼šè‡ªåŠ¨å¼€å¯ `bmp`, `png`ï¼‰ã€‚

Feature åç§°å¯ä»¥åŒ…å«æ¥è‡ª [Unicode XID standard]() å®šä¹‰çš„å­—æ¯ï¼Œå…è®¸ä½¿ç”¨ `_` æˆ– `0-9` çš„æ•°å­—ä½œä¸ºèµ·å§‹å­—ç¬¦ï¼Œåœ¨èµ·å§‹å­—ç¬¦åï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `-`ã€`+` æˆ– `.` ã€‚

ä½†æ˜¯æˆ‘ä»¬**è¿˜æ˜¯æ¨èæŒ‰ç…§ crates.io çš„æ–¹å¼æ¥è®¾ç½® Feature åç§°** : `crate.io` è¦æ±‚åç§°åªèƒ½ç”± ASCII å­—æ¯æ•°å­—ã€`_`ã€`-` æˆ– `+` ç»„æˆã€‚

## default feature

é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰çš„ `feature` éƒ½ä¼šè¢«è‡ªåŠ¨ç¦ç”¨ï¼Œå¯ä»¥é€šè¿‡ `default` æ¥å¯ç”¨å®ƒä»¬ï¼š

```toml
[features]
default = ["ico", "webp"]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

ä½¿ç”¨å¦‚ä¸Šé…ç½®çš„é¡¹ç›®è¢«æ„å»ºæ—¶ï¼Œ`default` feature é¦–å…ˆä¼šè¢«å¯ç”¨ï¼Œç„¶åå®ƒæ¥ç€å¯ç”¨äº† `ico` å’Œ `webp` featureï¼Œå½“ç„¶æˆ‘ä»¬è¿˜å¯ä»¥å…³é—­ `default`ï¼š

- `--no-default-features` å‘½ä»¤è¡Œå‚æ•°å¯ä»¥ç¦ç”¨ `default` feature
- `default-features = false` é€‰é¡¹å¯ä»¥åœ¨ä¾èµ–å£°æ˜ä¸­æŒ‡å®š

> å½“ä½ è¦å»æ”¹å˜æŸä¸ªä¾èµ–åº“çš„ `default` å¯ç”¨çš„ feature åˆ—è¡¨æ—¶(ä¾‹å¦‚è§‰å¾—è¯¥åº“å¼•å…¥çš„ feature è¿‡å¤šï¼Œå¯¼è‡´æœ€ç»ˆç¼–è¯‘å‡ºçš„æ–‡ä»¶è¿‡å¤§)ï¼Œéœ€è¦æ ¼å¤–çš„å°å¿ƒï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æŸäº›åŠŸèƒ½çš„ç¼ºå¤±

## å¯é€‰ä¾èµ–

å½“ä¾èµ–è¢«æ ‡è®°ä¸º "å¯é€‰ optional" æ—¶ï¼Œæ„å‘³ç€å®ƒé»˜è®¤ä¸ä¼šè¢«ç¼–è¯‘ã€‚å‡è®¾æˆ‘ä»¬çš„ 2D å›¾ç‰‡å¤„ç†åº“éœ€è¦ç”¨åˆ°ä¸€ä¸ªå¤–éƒ¨çš„åŒ…æ¥å¤„ç† GIF å›¾ç‰‡ï¼š

```toml
[dependencies]
gif = { version = "0.11.1", optional = true }
```

**è¿™ç§å¯é€‰ä¾èµ–çš„å†™æ³•ä¼šè‡ªåŠ¨å®šä¹‰ä¸€ä¸ªä¸ä¾èµ–åŒåçš„ featureï¼Œä¹Ÿå°±æ˜¯ `gif` feature**ï¼Œè¿™æ ·ä¸€æ¥ï¼Œå½“æˆ‘ä»¬å¯ç”¨ `gif` feature æ—¶ï¼Œè¯¥ä¾èµ–åº“ä¹Ÿä¼šè¢«è‡ªåŠ¨å¼•å…¥å¹¶å¯ç”¨ï¼šä¾‹å¦‚é€šè¿‡ `--features gif` çš„æ–¹å¼å¯ç”¨ feature ã€‚

> æ³¨æ„ï¼šç›®å‰æ¥è¯´ï¼Œ`[feature]` ä¸­å®šä¹‰çš„ feature è¿˜ä¸èƒ½ä¸å·²å¼•å…¥çš„ä¾èµ–åº“åŒåã€‚ä½†æ˜¯åœ¨ `nightly` ä¸­å·²ç»æä¾›äº†å®éªŒæ€§çš„åŠŸèƒ½ç”¨äºæ”¹å˜è¿™ä¸€ç‚¹: [namespaced features](https://doc.rust-lang.org/stable/cargo/reference/unstable.html#namespaced-features)

å½“ç„¶ï¼Œ**æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡æ˜¾å¼å®šä¹‰ feature çš„æ–¹å¼æ¥å¯ç”¨è¿™äº›å¯é€‰ä¾èµ–åº“**ï¼Œä¾‹å¦‚ä¸ºäº†æ”¯æŒ AVIF å›¾ç‰‡æ ¼å¼ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥ä¸¤ä¸ªä¾èµ–åŒ…ï¼Œç”±äº `avif` æ˜¯é€šè¿‡ feature å¼•å…¥çš„å¯é€‰æ ¼å¼ï¼Œå› æ­¤å®ƒä¾èµ–çš„ä¸¤ä¸ªåŒ…ä¹Ÿå¿…é¡»å£°æ˜ä¸ºå¯é€‰çš„:

```toml
[dependencies]
ravif = { version = "0.6.3", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
avif = ["ravif", "rgb"]
```

ä¹‹åï¼Œ`avif` feature ä¸€æ—¦è¢«å¯ç”¨ï¼Œé‚£è¿™ä¸¤ä¸ªä¾èµ–åº“ä¹Ÿå°†è‡ªåŠ¨è¢«å¼•å…¥ã€‚

> æ³¨æ„ï¼šæˆ‘ä»¬ä¹‹å‰ä¹Ÿè®²è¿‡æ¡ä»¶å¼•å…¥ä¾èµ–çš„æ–¹æ³•ï¼Œé‚£å°±æ˜¯ä½¿ç”¨[å¹³å°ç›¸å…³çš„ä¾èµ–](https://course.rs/cargo/reference/specify-deps.html#æ ¹æ®å¹³å°å¼•å…¥ä¾èµ–)ï¼Œä¸åŸºäº feature çš„å¯é€‰ä¾èµ–ä¸åŒï¼Œå®ƒä»¬æ˜¯åŸºäºç‰¹å®šå¹³å°çš„å¯é€‰ä¾èµ–

## ä¾èµ–åº“è‡ªèº«çš„ feature

å°±åƒæˆ‘ä»¬çš„é¡¹ç›®å¯ä»¥å®šä¹‰ `feature` ä¸€æ ·ï¼Œä¾èµ–åº“ä¹Ÿå¯ä»¥å®šä¹‰å®ƒè‡ªå·±çš„ `feature`ï¼Œä¹Ÿæœ‰éœ€è¦å¯ç”¨çš„ `feature` åˆ—è¡¨ï¼Œå½“å¼•å…¥è¯¥ä¾èµ–åº“æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¸ºå…¶å¯ç”¨ç›¸å…³çš„ `features` :

```toml
[dependencies]
serde = { version = "1.0.118", features = ["derive"] }
```

ä»¥ä¸Šé…ç½®ä¸º `serde` ä¾èµ–å¼€å¯äº† `derive` featureï¼Œè¿˜å¯ä»¥é€šè¿‡ `default-features = false` æ¥ç¦ç”¨ä¾èµ–åº“çš„ `default` feature :

```toml
[dependencies]
flate2 = { version = "1.0.3", default-features = false, features = ["zlib"] }
```

è¿™é‡Œæˆ‘ä»¬ç¦ç”¨äº† `flate2` çš„ `default` featureï¼Œä½†åˆæ‰‹åŠ¨ä¸ºå®ƒå¯ç”¨äº† `zlib` featureã€‚

> æ³¨æ„ï¼šè¿™ç§æ–¹å¼æœªå¿…èƒ½æˆåŠŸç¦ç”¨ `default`ï¼ŒåŸå› æ˜¯å¯èƒ½ä¼šæœ‰å…¶å®ƒä¾èµ–ä¹Ÿå¼•å…¥äº† `flate2`ï¼Œå¹¶ä¸”æ²¡æœ‰å¯¹ `default` è¿›è¡Œç¦ç”¨ï¼Œé‚£æ­¤æ—¶ `default` ä¾ç„¶ä¼šè¢«å¯ç”¨ã€‚
>
> æŸ¥çœ‹ä¸‹æ–‡çš„ [feature åŒä¸€åŒ–](#feature-åŒä¸€åŒ–) è·å–æ›´å¤šä¿¡æ¯

é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜èƒ½é€šè¿‡ä¸‹é¢çš„æ–¹å¼æ¥é—´æ¥å¼€å¯ä¾èµ–åº“çš„ feature :

```toml
[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false }

[features]
# Enables parallel processing support by enabling the "rayon" feature of jpeg-decoder.
parallel = ["jpeg-decoder/rayon"]
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª `parallel` featureï¼ŒåŒæ—¶ä¸ºå…¶å¯ç”¨äº† `jpeg-decoder` ä¾èµ–çš„ `rayon` featureã€‚

> æ³¨æ„: ä¸Šé¢çš„ "package-name/feature-name" è¯­æ³•å½¢å¼ä¸ä»…ä¼šå¼€å¯æŒ‡å®šä¾èµ–çš„æŒ‡å®š featureï¼Œè‹¥è¯¥ä¾èµ–æ˜¯å¯é€‰ä¾èµ–ï¼Œé‚£è¿˜ä¼šè‡ªåŠ¨å°†å…¶å¼•å…¥
>
> åœ¨ `nightly` ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥å¯¹è¿™ç§è¡Œä¸ºè¿›è¡Œç¦ç”¨ï¼š[weak dependency features]("package-name/feature-name")

## é€šè¿‡å‘½ä»¤è¡Œå‚æ•°å¯ç”¨ feature

ä»¥ä¸‹çš„å‘½ä»¤è¡Œå‚æ•°å¯ä»¥å¯ç”¨æŒ‡å®šçš„ `feature` :

- `--features FEATURES`: å¯ç”¨ç»™å‡ºçš„ feature åˆ—è¡¨ï¼Œå¯ä»¥ä½¿ç”¨é€—å·æˆ–ç©ºæ ¼è¿›è¡Œåˆ†éš”ï¼Œè‹¥ä½ æ˜¯åœ¨ç»ˆç«¯ä¸­ä½¿ç”¨ï¼Œè¿˜éœ€è¦åŠ ä¸ŠåŒå¼•å·ï¼Œä¾‹å¦‚ `--features "foo bar"`ã€‚ è‹¥åœ¨å·¥ä½œç©ºé—´ä¸­æ„å»ºå¤šä¸ª `package`ï¼Œå¯ä»¥ä½¿ç”¨ `package-name/feature-name` ä¸ºç‰¹å®šçš„æˆå‘˜å¯ç”¨ features
- `--all-features`: å¯ç”¨å‘½ä»¤è¡Œä¸Šæ‰€é€‰æ‹©çš„æ‰€æœ‰åŒ…çš„æ‰€æœ‰ features
- `--no-default-features`: å¯¹é€‰æ‹©çš„åŒ…ç¦ç”¨ `default` feature

## feature åŒä¸€åŒ–

`feature` åªæœ‰åœ¨å®šä¹‰çš„åŒ…ä¸­æ‰æ˜¯å”¯ä¸€çš„ï¼Œä¸åŒåŒ…ä¹‹é—´çš„ `feature` å…è®¸åŒåã€‚å› æ­¤ï¼Œåœ¨ä¸€ä¸ªåŒ…ä¸Šå¯ç”¨ `feature` ä¸ä¼šå¯¼è‡´å¦ä¸€ä¸ªåŒ…çš„åŒå `feature` è¢«è¯¯å¯ç”¨ã€‚

**å½“ä¸€ä¸ªä¾èµ–è¢«å¤šä¸ªåŒ…æ‰€ä½¿ç”¨æ—¶ï¼Œè¿™äº›åŒ…å¯¹è¯¥ä¾èµ–æ‰€è®¾ç½®çš„ `feature` å°†è¢«è¿›è¡Œåˆå¹¶ï¼Œè¿™æ ·æ‰èƒ½ç¡®ä¿è¯¥ä¾èµ–åªæœ‰ä¸€ä¸ªæ‹·è´å­˜åœ¨ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±è¢«ç§°ä¹‹ä¸ºåŒä¸€åŒ–**ã€‚å¤§å®¶å¯ä»¥æŸ¥çœ‹[è¿™é‡Œ](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#features)äº†è§£ä¸‹è§£æå™¨å¦‚ä½•å¯¹ feature è¿›è¡Œè§£æå¤„ç†ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ `winapi` ä¸ºä¾‹æ¥è¯´æ˜è¿™ä¸ªè¿‡ç¨‹ã€‚é¦–å…ˆï¼Œ`winapi` ä½¿ç”¨äº†å¤§é‡çš„ `features`ï¼›ç„¶åæˆ‘ä»¬æœ‰ä¸¤ä¸ªåŒ… `foo` å’Œ `bar` åˆ†åˆ«ä½¿ç”¨äº†å®ƒçš„ä¸¤ä¸ª featuresï¼Œé‚£ä¹ˆåœ¨åˆå¹¶åï¼Œæœ€ç»ˆ `winapi` å°†åŒæ—¶å¯å››ä¸ª features :

<img src="https://pic2.zhimg.com/80/v2-251973b0cc83f35cd6858bf21dd00ed6_1440w.png" />

ç”±äºè¿™ç§ä¸å¯æ§æ€§ï¼Œæˆ‘ä»¬éœ€è¦è®© `å¯ç”¨feature = æ·»åŠ ç‰¹æ€§` è¿™ä¸ªç­‰å¼æˆç«‹ï¼Œæ¢è€Œè¨€ä¹‹ï¼Œ**å¯ç”¨ä¸€ä¸ª feature ä¸åº”è¯¥å¯¼è‡´æŸä¸ªåŠŸèƒ½è¢«ç¦æ­¢**ã€‚è¿™æ ·æ‰èƒ½è®©å¤šä¸ªåŒ…å¯ç”¨åŒä¸€ä¸ªä¾èµ–çš„ä¸åŒ featuresã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³å¯é€‰çš„æ”¯æŒ `no_std` ç¯å¢ƒ(ä¸ä½¿ç”¨æ ‡å‡†åº“)ï¼Œé‚£ä¹ˆæœ‰ä¸¤ç§åšæ³•ï¼š

- é»˜è®¤ä»£ç ä½¿ç”¨æ ‡å‡†åº“çš„ï¼Œå½“ `no_std` feature å¯ç”¨æ—¶ï¼Œç¦ç”¨ç›¸å…³çš„æ ‡å‡†åº“ä»£ç 
- é»˜è®¤ä»£ç ä½¿ç”¨éæ ‡å‡†åº“çš„ï¼Œå½“ `std` feature å¯ç”¨æ—¶ï¼Œæ‰ä½¿ç”¨æ ‡å‡†åº“çš„ä»£ç 

å‰è€…å°±æ˜¯åŠŸèƒ½å‰Šå‡ï¼Œä¸ä¹‹ç›¸å¯¹ï¼Œåè€…æ˜¯åŠŸèƒ½æ·»åŠ ï¼Œæ ¹æ®ä¹‹å‰çš„å†…å®¹ï¼Œæˆ‘ä»¬åº”è¯¥é€‰æ‹©åè€…çš„åšæ³•ï¼š

```rust
#![no_std]

#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "std")]
pub fn function_that_requires_std() {
    // ...
}
```

#### å½¼æ­¤äº’æ–¥çš„ feature

æŸæå°‘æ•°æƒ…å†µä¸‹ï¼Œfeatures ä¹‹é—´å¯èƒ½ä¼šäº’ç›¸ä¸å…¼å®¹ã€‚æˆ‘ä»¬åº”è¯¥é¿å…è¿™ç§è®¾è®¡ï¼Œå› ä¸ºå¦‚æœä¸€æ—¦è¿™ä¹ˆè®¾è®¡äº†ï¼Œé‚£ä½ å¯èƒ½éœ€è¦ä¿®æ”¹ä¾èµ–å›¾çš„å¾ˆå¤šåœ°æ–¹æ‰èƒ½é¿å…ä¸¤ä¸ªä¸å…¼å®¹ feature çš„åŒæ—¶å¯ç”¨ã€‚

å¦‚æœå®åœ¨æ²¡æœ‰åŠæ³•ï¼Œå¯ä»¥è€ƒè™‘å¢åŠ ä¸€ä¸ªç¼–è¯‘é”™è¯¯æ¥è®©æŠ¥é”™æ›´æ¸…æ™°:

```toml
#[cfg(all(feature = "foo", feature = "bar"))]
compile_error!("feature \"foo\" and feature \"bar\" cannot be enabled at the same time");
```

å½“åŒæ—¶å¯ç”¨ `foo` å’Œ `bar` æ—¶ï¼Œç¼–è¯‘å™¨å°±ä¼šçˆ†å‡ºä¸€ä¸ªæ›´æ¸…æ™°çš„é”™è¯¯ï¼šfeature `foo` å’Œ `bar` æ— æ³•åŒæ—¶å¯ç”¨ã€‚

æ€»ä¹‹ï¼Œæˆ‘ä»¬è¿˜æ˜¯åº”è¯¥åœ¨è®¾è®¡ä¸Šé¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œä¾‹å¦‚ï¼š

- å°†æŸä¸ªåŠŸèƒ½åˆ†å‰²åˆ°å¤šä¸ªåŒ…ä¸­
- å½“å†²çªæ—¶ï¼Œè®¾ç½® feature ä¼˜å…ˆçº§ï¼Œ[cfg-if](https://crates.io/crates/cfg-if) åŒ…å¯ä»¥å¸®åŠ©æˆ‘ä»¬å†™å‡ºæ›´å¤æ‚çš„ `cfg` è¡¨è¾¾å¼

#### æ£€è§†å·²è§£æçš„ features

åœ¨å¤æ‚çš„ä¾èµ–å›¾ä¸­ï¼Œå¦‚æœæƒ³è¦äº†è§£ä¸åŒçš„ features æ˜¯å¦‚ä½•è¢«å¤šä¸ªåŒ…å¤šå¯ç”¨çš„ï¼Œè¿™æ˜¯ç›¸å½“å›°éš¾çš„ã€‚å¥½åœ¨ `cargo tree` å‘½ä»¤æä¾›äº†å‡ ä¸ªé€‰é¡¹å¯ä»¥å¸®ç»„æˆ‘ä»¬æ›´å¥½çš„æ£€è§†å“ªäº› features è¢«å¯ç”¨äº†:

`cargo tree -e features` ï¼Œè¯¥å‘½ä»¤ä»¥ä¾èµ–å›¾çš„æ–¹å¼æ¥å±•ç¤ºå·²å¯ç”¨çš„ featuresï¼ŒåŒ…å«äº†æ¯ä¸ªä¾èµ–åŒ…æ‰€å¯ç”¨çš„ç‰¹æ€§ï¼š

```shell
$ cargo tree -e features
test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
â””â”€â”€ uuid feature "default"
    â”œâ”€â”€ uuid v0.8.2
    â””â”€â”€ uuid feature "std"
        â””â”€â”€ uuid v0.8.2
```

`cargo tree -f "{p} {f}"` å‘½ä»¤ä¼šæä¾›ä¸€ä¸ªæ›´åŠ ç´§å‡‘çš„è§†å›¾ï¼š

```shell
$ cargo tree -f "{p} {f}"
test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
â””â”€â”€ uuid v0.8.2 default,std
```

`cargo tree -e features -i foo`ï¼Œè¯¥å‘½ä»¤ä¼šæ˜¾ç¤º `features` ä¼šå¦‚ä½•"æµå…¥"æŒ‡å®šçš„åŒ… `foo` ä¸­:

```shell
$ cargo tree -e features -i uuid
uuid v0.8.2
â”œâ”€â”€ uuid feature "default"
â”‚   â””â”€â”€ test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
â”‚       â””â”€â”€ test_cargo feature "default" (command-line)
â””â”€â”€ uuid feature "std"
    â””â”€â”€ uuid feature "default" (*)
```

è¯¥å‘½ä»¤åœ¨ä¾èµ–å›¾è¾ƒä¸ºå¤æ‚æ—¶éå¸¸æœ‰ç”¨ï¼Œä½¿ç”¨å®ƒå¯ä»¥è®©ä½ äº†è§£æŸä¸ªä¾èµ–åŒ…ä¸Šå¼€å¯äº†å“ªäº› `features` ä»¥åŠå…¶ä¸­çš„åŸå› ã€‚

å¤§å®¶å¯ä»¥æŸ¥çœ‹å®˜æ–¹çš„ `cargo tree` [æ–‡æ¡£](https://doc.rust-lang.org/stable/cargo/commands/cargo-tree.html)è·å–æ›´åŠ è¯¦ç»†çš„ä½¿ç”¨ä¿¡æ¯ã€‚

## Feature è§£æå™¨ V2 ç‰ˆæœ¬

æˆ‘ä»¬è¿˜èƒ½é€šè¿‡ä»¥ä¸‹é…ç½®æŒ‡å®šä½¿ç”¨ V2 ç‰ˆæœ¬çš„è§£æå™¨( [resolver](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#resolver-versions) ):

```toml
[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
```

V2 ç‰ˆæœ¬çš„è§£æå™¨å¯ä»¥åœ¨æŸäº›æƒ…å†µä¸‹é¿å… feature åŒä¸€åŒ–çš„å‘ç”Ÿï¼Œå…·ä½“çš„æƒ…å†µåœ¨[è¿™é‡Œ](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#feature-resolver-version-2)æœ‰æè¿°ï¼Œä¸‹é¢åšä¸‹ç®€å•çš„æ€»ç»“:

- ä¸ºç‰¹å®šå¹³å°å¼€å¯çš„ `features` ä¸”æ­¤æ—¶å¹¶æ²¡æœ‰è¢«æ„å»ºï¼Œä¼šè¢«å¿½ç•¥
- `build-dependencies` å’Œ `proc-macros` ä¸å†è·Ÿæ™®é€šçš„ä¾èµ–å…±äº« `features`
- `dev-dependencies` çš„ `features` ä¸ä¼šè¢«å¯ç”¨ï¼Œé™¤éæ­£åœ¨æ„å»ºçš„å¯¹è±¡éœ€è¦å®ƒä»¬(ä¾‹å¦‚æµ‹è¯•å¯¹è±¡ã€ç¤ºä¾‹å¯¹è±¡ç­‰)

å¯¹äºéƒ¨åˆ†åœºæ™¯è€Œè¨€ï¼Œfeature åŒä¸€åŒ–ç¡®å®æ˜¯éœ€è¦é¿å…çš„ï¼Œä¾‹å¦‚ï¼Œä¸€ä¸ªæ„å»ºä¾èµ–å¼€å¯äº† `std` featureï¼Œè€ŒåŒä¸€ä¸ªä¾èµ–åˆè¢«ç”¨äº `no_std` ç¯å¢ƒï¼Œå¾ˆæ˜æ˜¾ï¼Œå¼€å¯ `std` å°†å¯¼è‡´é”™è¯¯çš„å‘ç”Ÿã€‚

è¯´å®Œä¼˜ç‚¹ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ V2 çš„ç¼ºç‚¹ï¼Œå…¶ä¸­å¢åŠ ç¼–è¯‘æ„å»ºæ—¶é—´å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ï¼ŒåŸå› æ˜¯åŒä¸€ä¸ªä¾èµ–ä¼šè¢«æ„å»ºå¤šæ¬¡(æ¯ä¸ªéƒ½æ‹¥æœ‰ä¸åŒçš„ feature åˆ—è¡¨)ã€‚

> ç”±äºæ­¤éƒ¨åˆ†å†…å®¹å¯èƒ½åªæœ‰æå°‘æ•°çš„ç”¨æˆ·éœ€è¦ï¼Œå› æ­¤æˆ‘ä»¬å¹¶æ²¡æœ‰å¯¹å…¶è¿›è¡Œæ‰©å±•ï¼Œå¦‚æœå¤§å®¶å¸Œæœ›äº†è§£æ›´å¤šå…³äº V2 çš„å†…å®¹ï¼Œå¯ä»¥æŸ¥çœ‹[å®˜æ–¹æ–‡æ¡£](https://doc.rust-lang.org/stable/cargo/reference/features.html#feature-resolver-version-2)

## æ„å»ºè„šæœ¬

[æ„å»ºè„šæœ¬](https://course.rs/cargo/reference/build-script/intro.html)å¯ä»¥é€šè¿‡ `CARGO_FEATURE_<name>` ç¯å¢ƒå˜é‡è·å–å¯ç”¨çš„ `feature` åˆ—è¡¨ï¼Œå…¶ä¸­ `<name>` æ˜¯ feature çš„åç§°ï¼Œè¯¥åç§°è¢«è½¬æ¢æˆå¤§å…¨å†™å­—æ¯ï¼Œä¸” `-` è¢«è½¬æ¢ä¸º `_`ã€‚

## required-features

è¯¥å­—æ®µå¯ä»¥ç”¨äºç¦ç”¨ç‰¹å®šçš„ Cargo Targetï¼šå½“æŸä¸ª feature æ²¡æœ‰è¢«å¯ç”¨æ—¶ï¼ŒæŸ¥çœ‹[è¿™é‡Œ](https://course.rs/cargo/reference/cargo-target.html#required-features)è·å–æ›´å¤šä¿¡æ¯ã€‚

## SemVer å…¼å®¹æ€§

å¯ç”¨ä¸€ä¸ª feature ä¸åº”è¯¥å¼•å…¥ä¸€ä¸ªä¸å…¼å®¹ SemVer çš„æ”¹å˜ã€‚ä¾‹å¦‚ï¼Œå¯ç”¨çš„ feature ä¸åº”è¯¥æ”¹å˜ç°æœ‰çš„ APIï¼Œå› ä¸ºè¿™ä¼šç»™ç”¨æˆ·é€ æˆä¸å…¼å®¹çš„ç ´åæ€§å˜æ›´ã€‚ å¦‚æœå¤§å®¶æƒ³çŸ¥é“å“ªäº›å˜åŒ–æ˜¯å…¼å®¹çš„ï¼Œå¯ä»¥å‚è§[å®˜æ–¹æ–‡æ¡£](https://doc.rust-lang.org/stable/cargo/reference/semver.html)ã€‚

æ€»ä¹‹ï¼Œåœ¨æ–°å¢/ç§»é™¤ feature æˆ–å¯é€‰ä¾èµ–æ—¶ï¼Œä½ éœ€è¦å°å¿ƒï¼Œå› æ­¤è¿™äº›å¯èƒ½ä¼šé€ æˆå‘åä¸å…¼å®¹æ€§ã€‚æ›´å¤šä¿¡æ¯å‚è§[è¿™é‡Œ](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo)ï¼Œç®€å•æ€»ç»“å¦‚ä¸‹ï¼š

- åœ¨å‘å¸ƒ `minor` ç‰ˆæœ¬æ—¶ï¼Œä»¥ä¸‹é€šå¸¸æ˜¯å®‰å…¨çš„:
  - [æ–°å¢ feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-add) æˆ–[å¯é€‰ä¾èµ–](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-dep-add)
  - [ä¿®æ”¹æŸä¸ªä¾èµ–çš„ features](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-change-dep-feature)
- åœ¨å‘å¸ƒ `minor` ç‰ˆæœ¬æ—¶ï¼Œä»¥ä¸‹æ“ä½œåº”è¯¥é¿å…ï¼š
  - [ç§»é™¤ feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-remove) æˆ–[å¯é€‰ä¾èµ–](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-remove-opt-dep)
  - [å°†ç°æœ‰çš„å…¬æœ‰ä»£ç æ”¾åœ¨æŸä¸ª feature ä¹‹å](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-remove-opt-dep)
  - [ä» feature åˆ—è¡¨ä¸­ç§»é™¤ä¸€ä¸ª feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-remove-another)

## feature æ–‡æ¡£å’Œå‘ç°

å°†ä½ çš„é¡¹ç›®æ”¯æŒçš„ feature ä¿¡æ¯å†™å…¥åˆ°æ–‡æ¡£ä¸­æ˜¯éå¸¸å¥½çš„é€‰æ‹©:

- æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ `lib.rs` çš„é¡¶éƒ¨æ·»åŠ [æ–‡æ¡£æ³¨é‡Š](https://course.rs/basic/comment.html#æ–‡æ¡£æ³¨é‡Š)çš„æ–¹å¼æ¥å®ç°ã€‚ä¾‹å¦‚ `regex` å°±æ˜¯[è¿™ä¹ˆåšçš„](https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583)ã€‚
- è‹¥é¡¹ç›®æ‹¥æœ‰ä¸€ä¸ªç”¨æˆ·æ‰‹å†Œï¼Œé‚£ä¹Ÿå¯ä»¥åœ¨é‚£é‡Œæ·»åŠ è¯´æ˜ï¼Œä¾‹å¦‚ [serde.rs](https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583)ã€‚
- è‹¥é¡¹ç›®æ˜¯äºŒè¿›åˆ¶ç±»å‹(å¯è¿è¡Œçš„åº”ç”¨æœåŠ¡ï¼ŒåŒ…å« `fn main` å…¥å£)ï¼Œå¯ä»¥å°†è¯´æ˜æ”¾åœ¨ `README` æ–‡ä»¶æˆ–å…¶ä»–æ–‡æ¡£ä¸­ï¼Œä¾‹å¦‚ [sccache](https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements)ã€‚

ç‰¹åˆ«æ˜¯å¯¹äºä¸ç¨³å®šçš„æˆ–è€…ä¸è¯¥å†è¢«ä½¿ç”¨çš„ feature è€Œè¨€ï¼Œå®ƒä»¬æ›´åº”è¯¥è¢«æ”¾åœ¨æ–‡æ¡£ä¸­è¿›è¡Œæ¸…æ™°çš„è¯´æ˜ã€‚

å½“æ„å»ºå‘å¸ƒåˆ° `docs.rs` ä¸Šçš„æ–‡æ¡£æ—¶ï¼Œä¼šä½¿ç”¨ `Cargo.toml` ä¸­çš„å…ƒæ•°æ®æ¥æ§åˆ¶å“ªäº› features ä¼šè¢«å¯ç”¨ã€‚æŸ¥çœ‹ [docs.rs æ–‡æ¡£](https://docs.rs/about/metadata)è·å–æ›´å¤šä¿¡æ¯ã€‚

#### å¦‚ä½•å‘ç° features

è‹¥ä¾èµ–åº“çš„æ–‡æ¡£ä¸­å¯¹å…¶ä½¿ç”¨çš„ `features` åšäº†è¯¦ç»†æè¿°ï¼Œé‚£ä½ ä¼šæ›´å®¹æ˜“çŸ¥é“ä»–ä»¬ä½¿ç”¨äº†å“ªäº› `features` ä»¥åŠè¯¥å¦‚ä½•ä½¿ç”¨ã€‚

å½“ä¾èµ–åº“çš„æ–‡æ¡£æ²¡æœ‰ç›¸å…³ä¿¡æ¯æ—¶ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡æºç ä»“åº“çš„ `Cargo.toml` æ–‡ä»¶æ¥è·å–ï¼Œä½†æ˜¯æœ‰äº›æ—¶å€™ï¼Œä½¿ç”¨è¿™ç§æ–¹å¼æ¥è·Ÿè¸ªå¹¶è·å–å…¨éƒ¨ç›¸å…³çš„ä¿¡æ¯æ˜¯ç›¸å½“å›°éš¾çš„ã€‚



================================================
FILE: src/compiler/intro.md
================================================
# å¾æœç¼–è¯‘é”™è¯¯



================================================
FILE: src/compiler/fight-with-compiler/intro.md
================================================
# å¯¹æŠ—ç¼–è¯‘æ£€æŸ¥



================================================
FILE: src/compiler/fight-with-compiler/phantom-data.md
================================================
# å¹½çµæ•°æ®



================================================
FILE: src/compiler/fight-with-compiler/unconstrained.md
================================================
# ç±»å‹æœªé™åˆ¶



================================================
FILE: src/compiler/fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/borrowing/intro.md
================================================
# é‡å¤å€Ÿç”¨

æœ¬ç« è®²è¿°å¦‚ä½•è§£å†³ç±»ä¼¼`cannot borrow *self as mutable because it is also borrowed as immutable`è¿™ç§é‡å¤å€Ÿç”¨çš„é”™è¯¯ã€‚




================================================
FILE: src/compiler/fight-with-compiler/borrowing/ref-exist-in-out-fn.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/lifetime/closure-with-static.md
================================================
# å½“é—­åŒ…ç¢°åˆ°ç‰¹å¾å¯¹è±¡ 1

ç‰¹å¾å¯¹è±¡æ˜¯ä¸€ä¸ªå¥½ä¸œè¥¿ï¼Œé—­åŒ…ä¹Ÿæ˜¯ä¸€ä¸ªå¥½ä¸œè¥¿ï¼Œä½†æ˜¯å¦‚æœä¸¤è€…ä½ éƒ½æƒ³è¦æ—¶ï¼Œå¯èƒ½å°±ä¼šç«æ˜Ÿæ’åœ°çƒï¼Œboom! è‡³äºè¿™ä¸¤è€…ä¸ºä½•ä¼šå‹¾æ­åˆ°ä¸€èµ·ï¼Ÿè€ƒè™‘ä¸€ä¸ªå¸¸ç”¨åœºæ™¯ï¼šä½¿ç”¨é—­åŒ…ä½œä¸ºå›è°ƒå‡½æ•°.

## å­¦ä¹ ç›®æ ‡

å¦‚ä½•ä½¿ç”¨é—­åŒ…ä½œä¸ºç‰¹å¾å¯¹è±¡ï¼Œå¹¶è§£å†³ä»¥ä¸‹é”™è¯¯ï¼š`the parameter type ` \`impl Fn(&str) -> Res\` ` may not live long enough`

## æŠ¥é”™çš„ä»£ç 

åœ¨ä¸‹é¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡é—­åŒ…å®ç°äº†ä¸€ä¸ªç®€å•çš„å›è°ƒå‡½æ•°(é”™è¯¯ä»£ç å·²ç»æ ‡æ³¨)ï¼š

```rust
pub struct Res<'a> {
    value: &'a str,
}

impl<'a> Res<'a> {
    pub fn new(value: &str) -> Res {
        Res { value }
    }
}

pub struct Container<'a> {
    name: &'a str,
    callback: Option<Box<dyn Fn(&str) -> Res>>,
}

impl<'a> Container<'a> {
    pub fn new(name: &str) -> Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&mut self, cb: impl Fn(&str) -> Res) {
        self.callback = Some(Box::new(cb));
    }
}

fn main() {
    let mut inl = Container::new("Inline");

    inl.set(|val| {
        println!("Inline: {}", val);
        Res::new("inline")
    });

    if let Some(cb) = inl.callback {
        cb("hello, world");
    }
}
```

```
error[E0310]: the parameter type `impl Fn(&str) -> Res` may not live long enough
  --> src/main.rs:25:30
   |
24 |     pub fn set(&mut self, cb: impl Fn(&str) -> Res) {
   |                               -------------------- help: consider adding an explicit lifetime bound...: `impl Fn(&str) -> Res + 'static`
25 |         self.callback = Some(Box::new(cb));
   |                              ^^^^^^^^^^^^ ...so that the type `impl Fn(&str) -> Res` will meet its required lifetime bounds
```

ä»ç¬¬ä¸€æ„Ÿè§‰æ¥è¯´ï¼ŒæŠ¥é”™å±å®ä¸åº”è¯¥ï¼Œå› ä¸ºæˆ‘ä»¬è¿å¼•ç”¨éƒ½æ²¡æœ‰ç”¨ï¼Œç”Ÿå‘½å‘¨æœŸéƒ½ä¸æ¶‰åŠï¼Œæ€ä¹ˆå°±æŠ¥é”™äº†ï¼Ÿåœ¨ç»§ç»­æ·±å…¥ä¹‹å‰ï¼Œå…ˆæ¥è§‚å¯Ÿä¸‹è¯¥é—­åŒ…æ˜¯å¦‚ä½•è¢«ä½¿ç”¨çš„ï¼š

```rust
callback: Option<Box<dyn Fn(&str) -> Res>>,
```

ä¼—æ‰€å‘¨çŸ¥ï¼Œé—­åŒ…è·Ÿå“ˆå§†é›·ç‰¹ä¸€æ ·ï¼Œæ¯ä¸€ä¸ªéƒ½æœ‰[è‡ªå·±çš„ç±»å‹](https://course.rs/advance/functional-programing/closure.html#é—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›å€¼)ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•é€šè¿‡ç±»å‹æ ‡æ³¨çš„æ–¹å¼æ¥å£°æ˜ä¸€ä¸ªé—­åŒ…ï¼Œé‚£ä¹ˆåªæœ‰ä¸€ä¸ªåŠæ³•ï¼Œå°±æ˜¯ä½¿ç”¨ç‰¹å¾å¯¹è±¡ï¼Œå› æ­¤ä¸Šé¢ä»£ç ä¸­ï¼Œé€šè¿‡`Box<dyn Trait>`çš„æ–¹å¼æŠŠé—­åŒ…ç‰¹å¾å°è£…æˆä¸€ä¸ªç‰¹å¾å¯¹è±¡ã€‚

## æ·±å…¥æŒ–æ˜æŠ¥é”™åŸå› 

äº‹å‡ºè¯¡å¼‚å¿…æœ‰å¦–ï¼Œé‚£æ¥ä¸‹æ¥æˆ‘ä»¬ä¸€èµ·å»ä¼šä¼šè¿™åªå¦–ã€‚

#### ç‰¹å¾å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ

é¦–å…ˆç¼–è¯‘å™¨æŠ¥é”™æç¤ºæˆ‘ä»¬é—­åŒ…æ´»å¾—ä¸å¤Ÿä¹…ï¼Œé‚£å¯ä»¥å¤§èƒ†æ¨æµ‹ï¼Œæ­£å› ä¸ºä½¿ç”¨äº†é—­åŒ…ä½œä¸ºç‰¹å¾å¯¹è±¡ï¼Œæ‰€ä»¥æ‰æ´»å¾—ä¸å¤Ÿä¹…ã€‚å› æ­¤é¦–å…ˆéœ€è¦è°ƒæŸ¥ä¸‹ç‰¹å¾å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚

é¦–å…ˆç»™å‡ºç»“è®ºï¼š**ç‰¹å¾å¯¹è±¡éšå¼çš„å…·æœ‰`'static`ç”Ÿå‘½å‘¨æœŸ**ã€‚

å…¶å®åœ¨ Rust ä¸­ï¼Œ`'static`ç”Ÿå‘½å‘¨æœŸå¾ˆå¸¸è§ï¼Œä¾‹å¦‚ä¸€ä¸ªæ²¡æœ‰å¼•ç”¨å­—æ®µçš„ç»“æ„ä½“å®ƒå…¶å®ä¹Ÿæ˜¯`'static`ã€‚å½“`'static`ç”¨äºä¸€ä¸ªç±»å‹æ—¶ï¼Œè¯¥ç±»å‹ä¸èƒ½åŒ…å«ä»»ä½•é`'static`å¼•ç”¨å­—æ®µï¼Œä¾‹å¦‚ä»¥ä¸‹ç»“æ„ä½“ï¼š

```rust
struct Foo<'a> {
    x : &'a [u8]
};
```

é™¤é`x`å­—æ®µå€Ÿç”¨äº†`'static`çš„å¼•ç”¨ï¼Œå¦åˆ™`'a`è‚¯å®šæ¯”`'static`è¦å°ï¼Œé‚£ä¹ˆè¯¥ç»“æ„ä½“å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸè‚¯å®šä¸æ˜¯`'static`: `'a: 'static`çš„é™åˆ¶ä¸ä¼šè¢«æ»¡è¶³([HRTB](https://course.rs/advance/lifetime/advance.html#ç”Ÿå‘½å‘¨æœŸçº¦æŸHRTB))ã€‚

å¯¹äºç‰¹å¾å¯¹è±¡æ¥è¯´ï¼Œå®ƒæ²¡æœ‰åŒ…å«é`'static`çš„å¼•ç”¨ï¼Œå› æ­¤å®ƒéšå¼çš„å…·æœ‰`'static`ç”Ÿå‘½å‘¨æœŸ, `Box<dyn Trait>`å°±è·Ÿ`Box<dyn Trait + 'static>`æ˜¯ç­‰ä»·çš„ã€‚

#### 'static é—­åŒ…çš„é™åˆ¶

å…¶å®ä»¥ä¸Šä»£ç çš„é”™è¯¯å¾ˆå¥½è§£å†³ï¼Œç”šè‡³ç¼–è¯‘å™¨ä¹Ÿæç¤ºäº†æˆ‘ä»¬ï¼š

```console
help: consider adding an explicit lifetime bound...: `impl Fn(&str) -> Res + 'static`
```

ä½†æ˜¯è§£å†³é—®é¢˜ä¸æ˜¯æœ¬æ–‡çš„ç›®æ ‡ï¼Œæˆ‘ä»¬è¿˜æ˜¯è¦ç»§ç»­æ·±æŒ–ä¸€ä¸‹ï¼Œå¦‚æœé—­åŒ…ä½¿ç”¨äº†`'static`ä¼šé€ æˆä»€ä¹ˆé—®é¢˜ã€‚

##### 1. æ— æœ¬åœ°å˜é‡è¢«æ•è·

```rust
inl.set(|val| {
    println!("Inline: {}", val);
    Res::new("inline")
});
```

ä»¥ä¸Šä»£ç åªä½¿ç”¨äº†é—­åŒ…ä¸­ä¼ å…¥çš„å‚æ•°ï¼Œå¹¶æ²¡æœ‰æœ¬åœ°å˜é‡è¢«æ•è·ï¼Œå› æ­¤`'static`é—­åŒ…ä¸€åˆ‡ OKã€‚

##### 2. æœ‰æœ¬åœ°å˜é‡è¢«æ•è·

```rust
let local = "hello".to_string();

// ç¼–è¯‘é”™è¯¯ï¼š é—­åŒ…ä¸æ˜¯'static!
inl.set(|val| {
    println!("Inline: {}", val);
    println!("{}", local);
    Res::new("inline")
});
```

è¿™é‡Œæˆ‘ä»¬åœ¨é—­åŒ…ä¸­æ•è·äº†æœ¬åœ°ç¯å¢ƒå˜é‡`local`ï¼Œå› ä¸º`local`ä¸æ˜¯`'static`ï¼Œé‚£ä¹ˆé—­åŒ…ä¹Ÿä¸å†æ˜¯`'static`ã€‚

##### 3. å°†æœ¬åœ°å˜é‡ move è¿›é—­åŒ…

```rust
let local = "hello".to_string();

inl.set(move |val| {
    println!("Inline: {}", val);
    println!("{}", local);
    Res::new("inline")
});

// ç¼–è¯‘é”™è¯¯: localå·²ç»è¢«ç§»åŠ¨åˆ°é—­åŒ…ä¸­ï¼Œè¿™é‡Œæ— æ³•å†è¢«å€Ÿç”¨
// println!("{}", local);
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œä½ ä¹Ÿå¯ä»¥é€‰æ‹©å°†æœ¬åœ°å˜é‡çš„æ‰€æœ‰æƒ`move`è¿›é—­åŒ…ä¸­ï¼Œæ­¤æ—¶é—­åŒ…å†æ¬¡å…·æœ‰`'static`ç”Ÿå‘½å‘¨æœŸ

##### 4. éè¦æ•è·æœ¬åœ°å˜é‡çš„å¼•ç”¨ï¼Ÿ

å¯¹äºç¬¬ 2 ç§æƒ…å†µï¼Œå¦‚æœéè¦è¿™ä¹ˆå¹²ï¼Œé‚£`'static`è‚¯å®šæ˜¯æ²¡åŠæ³•äº†ï¼Œæˆ‘ä»¬åªèƒ½ç»™äºˆé—­åŒ…ä¸€ä¸ªæ–°çš„ç”Ÿå‘½å‘¨æœŸ:

```rust
pub struct Container<'a, 'b> {
    name: &'a str,
    callback: Option<Box<dyn Fn(&str) -> Res + 'b>>,
}

impl<'a, 'b> Container<'a, 'b> {
    pub fn new(name: &str) -> Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&mut self, cb: impl Fn(&str) -> Res + 'b) {
        self.callback = Some(Box::new(cb));
    }
}
```

è‚‰çœ¼å¯è§ï¼Œä»£ç å¤æ‚åº¦å“å“å“æå‡ï¼Œä¸å¾—ä¸è¯´`'static`çœŸé¦™ï¼

å‹æƒ…æç¤ºï¼šç”±æ­¤ä¿®æ”¹å¼•å‘çš„ä¸€ç³»åˆ—é”™è¯¯ï¼Œéœ€è¦ä½ è‡ªè¡Œä¿®å¤: ) (å†æ¬¡å‹æƒ…å°æç¤ºï¼Œå¯ä»¥è€ƒè™‘æŠŠ`main`ä¸­çš„`local`å˜é‡å£°æ˜ä½ç½®æŒªåˆ°`inl`å£°æ˜ä½ç½®ä¹‹å‰)

## å§—å§—æ¥è¿Ÿçš„æ­£ç¡®ä»£ç 

å…¶å®ï¼Œå¤§å®¶åº”è¯¥éƒ½çŸ¥é“è¯¥å¦‚ä½•ä¿®æ”¹äº†ï¼Œä¸è¿‡å‡ºäºä¸¥è°¨ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç»§ç»­ç»™å‡ºå®Œæ•´çš„æ­£ç¡®ä»£ç :

```rust
pub fn set(&mut self, cb: impl Fn(&str) -> Res + 'static) {
```

å¯èƒ½å¤§å®¶è§‰å¾—æˆ‘é‡æ–°å®šä¹‰äº†`å®Œæ•´`ä¸¤ä¸ªå­—ï¼Œå…¶å®æ˜¯æˆ‘ä¸æƒ³æ°´ç¯‡å¹…:)

## æ€»ç»“

é—­åŒ…å’Œç‰¹å¾å¯¹è±¡çš„ç›¸çˆ±ç›¸æ€ä¸»è¦åŸå› å°±åœ¨äºç‰¹å¾å¯¹è±¡é»˜è®¤å…·å¤‡`'static`çš„ç”Ÿå‘½å‘¨æœŸï¼ŒåŒæ—¶æˆ‘ä»¬è¿˜å¯¹ä»€ä¹ˆæ ·çš„ç±»å‹å…·å¤‡`'static`è¿›è¡Œäº†ç®€å•çš„åˆ†æã€‚

åŒæ—¶ï¼Œå¦‚æœä¸€ä¸ªé—­åŒ…æ‹¥æœ‰`'static`ç”Ÿå‘½å‘¨æœŸï¼Œé‚£é—­åŒ…æ— æ³•é€šè¿‡å¼•ç”¨çš„æ–¹å¼æ¥æ•è·æœ¬åœ°ç¯å¢ƒä¸­çš„å˜é‡ã€‚å¦‚æœä½ æƒ³è¦éè¦æ•è·ï¼Œåªèƒ½ä½¿ç”¨é`'static`ã€‚



================================================
FILE: src/compiler/fight-with-compiler/lifetime/intro.md
================================================
# ç”Ÿå‘½å‘¨æœŸ

æœ¬ç« å¹¶ä¸è®²å¤ªå¤šçš„æ¦‚å¿µï¼Œä¸»è¦æ˜¯ç”¨ä¾‹å­æ¥å¼•å¯¼å¤§å®¶å»æ€è€ƒè¯¥å¦‚ä½•å¯¹æŠ—ç¼–è¯‘æ£€æŸ¥ã€‚



================================================
FILE: src/compiler/fight-with-compiler/lifetime/loop.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/lifetime/too-long1.md
================================================
# ç”Ÿå‘½å‘¨æœŸå£°æ˜çš„èŒƒå›´è¿‡å¤§

åœ¨å¤§å¤šæ—¶å€™ï¼ŒRust çš„ç”Ÿå‘½å‘¨æœŸä½ åªè¦æ ‡è¯†äº†ï¼Œå³å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯æ€»æ˜¯å­˜åœ¨ä¸€äº›æƒ…å†µï¼Œä¼šå¯¼è‡´ç¼–è¯‘æ— æ³•é€šè¿‡ï¼Œæœ¬æ–‡å°±è®²è¿°è¿™æ ·ä¸€ç§æƒ…å†µï¼šå› ä¸ºç”Ÿå‘½å‘¨æœŸå£°æ˜çš„èŒƒå›´è¿‡å¤§ï¼Œå¯¼è‡´äº†ç¼–è¯‘æ— æ³•é€šè¿‡ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢

## ä¾‹å­ 1

```rust
struct Interface<'a> {
    manager: &'a mut Manager<'a>
}

impl<'a> Interface<'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface(&'a mut self) -> Interface {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

è¿è¡ŒåæŠ¥é”™ï¼š

```console
error[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable // `list`æ— æ³•è¢«å€Ÿç”¨ï¼Œå› ä¸ºå·²ç»è¢«å¯å˜å€Ÿç”¨
  --> src/main.rs:40:14
   |
34 |     list.get_interface().noop();
   |     ---- mutable borrow occurs here // å¯å˜å€Ÿç”¨å‘ç”Ÿåœ¨è¿™é‡Œ
...
40 |     use_list(&list);
   |              ^^^^^
   |              |
   |              immutable borrow occurs here // æ–°çš„ä¸å¯å˜å€Ÿç”¨å‘ç”Ÿåœ¨è¿™
   |              mutable borrow later used here // å¯å˜å€Ÿç”¨åœ¨è¿™é‡Œç»“æŸ
```

è¿™æ®µä»£ç çœ‹ä¸Šå»å¹¶ä¸å¤æ‚ï¼Œå®é™…ä¸Šéš¾åº¦æŒºé«˜çš„ï¼Œé¦–å…ˆåœ¨ç›´è§‰ä¸Šï¼Œ`list.get_interface()`å€Ÿç”¨çš„å¯å˜å¼•ç”¨ï¼ŒæŒ‰ç†æ¥è¯´åº”è¯¥åœ¨è¿™è¡Œä»£ç ç»“æŸåï¼Œå°±å½’è¿˜äº†ï¼Œä¸ºä½•èƒ½æŒç»­åˆ°`use_list(&list)`åé¢å‘¢ï¼Ÿ

è¿™æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨`get_interface`æ–¹æ³•ä¸­å£°æ˜çš„`lifetime`æœ‰é—®é¢˜ï¼Œè¯¥æ–¹æ³•çš„å‚æ•°çš„ç”Ÿæ˜å‘¨æœŸæ˜¯`'a`ï¼Œè€Œ`List`çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯`'a`ï¼Œè¯´æ˜è¯¥æ–¹æ³•è‡³å°‘æ´»å¾—è·Ÿ`List`ä¸€æ ·ä¹…ï¼Œå†å›åˆ°`main`å‡½æ•°ä¸­ï¼Œ`list`å¯ä»¥æ´»åˆ°`main`å‡½æ•°çš„ç»“æŸï¼Œå› æ­¤`list.get_interface()`å€Ÿç”¨çš„å¯å˜å¼•ç”¨ä¹Ÿä¼šæ´»åˆ°`main`å‡½æ•°çš„ç»“æŸï¼Œåœ¨æ­¤æœŸé—´ï¼Œè‡ªç„¶æ— æ³•å†è¿›è¡Œå€Ÿç”¨äº†ã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¸º`get_interface`æ–¹æ³•çš„å‚æ•°ç»™äºˆä¸€ä¸ªä¸åŒäº`List<'a>`çš„ç”Ÿå‘½å‘¨æœŸ`'b`ï¼Œæœ€ç»ˆä»£ç å¦‚ä¸‹ï¼š

```rust
struct Interface<'b, 'a: 'b> {
    manager: &'b mut Manager<'a>
}

impl<'b, 'a: 'b> Interface<'b, 'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface<'b>(&'b mut self) -> Interface<'b, 'a>
    where 'a: 'b {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {

    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

å½“ç„¶ï¼Œå’±è¿˜å¯ä»¥ç»™ç”Ÿå‘½å‘¨æœŸç»™äºˆæ›´æœ‰æ„ä¹‰çš„åç§°ï¼š

```rust
struct Interface<'text, 'manager> {
    manager: &'manager mut Manager<'text>
}

impl<'text, 'manager> Interface<'text, 'manager> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'text> {
    text: &'text str
}

struct List<'text> {
    manager: Manager<'text>,
}

impl<'text> List<'text> {
    pub fn get_interface<'manager>(&'manager mut self) -> Interface<'text, 'manager>
    where 'text: 'manager {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```



================================================
FILE: src/compiler/fight-with-compiler/lifetime/too-long2.md
================================================
# ç”Ÿå‘½å‘¨æœŸè¿‡å¤§-02

ç»§ä¸Šç¯‡æ–‡ç« åï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€æ®µ**å¯èƒ½**æ¶‰åŠç”Ÿå‘½å‘¨æœŸè¿‡å¤§å¯¼è‡´çš„æ— æ³•ç¼–è¯‘é—®é¢˜:

```rust
fn bar(writer: &mut Writer) {
    baz(writer.indent());
    writer.write("world");
}

fn baz(writer: &mut Writer) {
    writer.write("hello");
}

pub struct Writer<'a> {
    target: &'a mut String,
    indent: usize,
}

impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> &'a mut Self {
        &mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```console
error[E0623]: lifetime mismatch
 --> src/main.rs:2:16
  |
1 | fn bar(writer: &mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(writer.indent());
  |                ^^^^^^ ...but data from `writer` flows into `writer` here
```

WTFï¼Œè¿™ä»€ä¹ˆæŠ¥é”™ï¼Œä¹‹å‰éƒ½æ²¡æœ‰è§è¿‡ï¼Œè€Œä¸”å¾ˆéš¾ç†è§£ï¼Œä»€ä¹ˆå«`writer`æ»‘å…¥äº†å¦ä¸€ä¸ª`writer`ï¼Ÿ

åˆ«æ€¥ï¼Œæˆ‘ä»¬å…ˆæ¥ä»”ç»†çœ‹ä¸‹ä»£ç ï¼Œæ³¨æ„è¿™ä¸€æ®µï¼š

```rust
impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> &'a mut Self {
        &mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }
```

è¿™é‡Œçš„ç”Ÿå‘½å‘¨æœŸå®šä¹‰è¯´æ˜`indent`æ–¹æ³•ä½¿ç”¨çš„ã€‚ã€‚ã€‚ç­‰ç­‰ï¼ä½ çš„ä»£ç é”™äº†ï¼Œä½ æ€ä¹ˆèƒ½åœ¨ä¸€ä¸ªå‡½æ•°ä¸­è¿”å›ä¸€ä¸ªæ–°åˆ›å»ºå®ä¾‹çš„å¼•ç”¨ï¼Ÿï¼ï¼æœ€é‡è¦çš„æ˜¯ï¼Œç¼–è¯‘å™¨ä¸æç¤ºè¿™ä¸ªé”™è¯¯ï¼Œç«Ÿç„¶æç¤ºä¸€ä¸ªè«åå…¶å¦™çœ‹ä¸æ‡‚çš„ä¸œä¸œã€‚

è¡Œï¼Œé‚£æˆ‘ä»¬å…ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°†è¯¥æ–¹æ³•ä¿®æ”¹ä¸º:

```rust
fn indent(&'a mut self) -> Writer<'a> {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
```

æ€€ç€æƒ´æƒ´è¿™å¿ƒï¼Œå†ä¸€æ¬¡è¿è¡Œç¨‹åºï¼Œæœä¸å…¶ç„¶ï¼Œç¼–è¯‘å™¨åˆæœæˆ‘ä»¬æ‰”äº†ä¸€å¨é”™è¯¯ï¼š

```console
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     baz(writer.indent());
  |         ^^^^^^^^^^^^^^^
  |         |
  |         expected `&mut Writer<'_>`, found struct `Writer`
  |         help: consider mutably borrowing here: `&mut writer.indent()`
```

å“¦ï¼Œè¿™æ¬¡é”™è¯¯å¾ˆæ˜æ˜¾ï¼Œå› ä¸º`baz`éœ€è¦`&mut Writer`ï¼Œä½†æ˜¯å’±ä»¬`writer.indent`è¿”å›äº†ä¸€ä¸ª`Writer`ï¼Œå› æ­¤ä¿®æ”¹ä¸‹å³å¯:

```rust
fn bar(writer: &mut Writer) {
    baz(&mut writer.indent());
    writer.write("world");
}
```

è¿™æ¬¡æ€»è¯¥æˆåŠŸäº†å§ï¼Ÿå†æ¬¡å¿ƒæ…Œæ…Œçš„è¿è¡Œç¼–è¯‘å™¨ï¼Œå“ï¼š

```console
error[E0623]: lifetime mismatch
 --> src/main.rs:2:21
  |
1 | fn bar(writer: &mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(&mut writer.indent());
  |                     ^^^^^^ ...but data from `writer` flows into `writer` here
```

å¯æ¶ï¼Œè¿˜æ˜¯è¿™ä¸ªçœ‹ä¸æ‡‚çš„é”™è¯¯ï¼Œä»”ç»†æ£€æŸ¥äº†ä¸‹ä»£ç ï¼Œè¿™æ¬¡çœŸçš„æ²¡æœ‰å…¶ä»–é”™è¯¯äº†ï¼Œåªèƒ½ç¡¬ç€å¤´çš®ä¸Šã€‚

å¤§æ¦‚çš„æ„æ€å¯ä»¥åˆ†æï¼Œç”Ÿå‘½å‘¨æœŸèŒƒå›´ä¸åŒ¹é…ï¼Œè¯´æ˜ä¸€ä¸ªå¤§ä¸€ä¸ªå°ï¼Œç„¶åä¸€ä¸ª`writer`ä¸­æµå…¥åˆ°å¦ä¸€ä¸ª`writer`è¯´æ˜ï¼Œä¸¤ä¸ª`writer`çš„ç”Ÿå‘½å‘¨æœŸå®šä¹‰é”™äº†ï¼Œæ—¢ç„¶è¿™é‡Œæåˆ°äº†`indent`æ–¹æ³•è°ƒç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å†å»ä»”ç»†çœ‹ä¸€çœ¼ï¼š

```rust
impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> Writer<'a> {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }
    ...
}
```

å¥½åƒæœ‰ç‚¹é—®é¢˜ï¼Œ`indent`è¿”å›çš„`Writer`çš„ç”Ÿå‘½å‘¨æœŸå’Œå¤–é¢è°ƒç”¨è€…çš„`Writer`çš„ç”Ÿå‘½å‘¨æœŸä¸€æ¨¡ä¸€æ ·ï¼Œè¿™å¾ˆä¸åˆç†ï¼Œä¸€çœ¼å°±èƒ½çœ‹å‡ºå‰è€…è¿œå°äºåè€…ã€‚

è¿™é‡Œç¨å¾®å±•å¼€ä»¥ä¸‹ï¼Œä¸ºä½•`indent`æ–¹æ³•è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½ä¸å‚æ•°ä¸­çš„`self`ç›¸åŒã€‚**é¦–å…ˆï¼Œæˆ‘ä»¬å‡è®¾å®ƒä»¬å¯ä»¥ç›¸åŒï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„ä»£ç å¯ä»¥ç¼–è¯‘é€šè¿‡**ï¼Œç”±äºæ­¤æ—¶åœ¨è¿”å›å€¼ä¸­å€Ÿç”¨äº†`self`çš„å¯å˜å¼•ç”¨ï¼Œæ„å‘³ç€**å¦‚æœä½ åœ¨è¿”å›å€¼è¢«ä½¿ç”¨åï¼Œè¿˜ç»§ç»­ä½¿ç”¨`self` ä¼šå¯¼è‡´é‡å¤å€Ÿç”¨çš„é”™è¯¯ï¼Œå› ä¸ºè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå°†æŒç»­åˆ° `self` ç»“æŸ**ã€‚

æ—¢ç„¶ä¸èƒ½ç›¸åŒï¼Œé‚£æˆ‘ä»¬å°è¯•ç€ä¿®æ”¹ä¸‹`indent`:

```rust
 fn indent<'b>(&'b mut self) -> Writer<'b> {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
```

Bang! ç¼–è¯‘æˆåŠŸï¼Œä¸è¿‡ç¨ç­‰ï¼Œå›æƒ³ä¸‹ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤çš„è§„åˆ™ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å®ç°çš„æ›´ä¼˜é›…ï¼š

```rust
fn bar(writer: &mut Writer) {
    baz(&mut writer.indent());
    writer.write("world");
}

fn baz(writer: &mut Writer) {
    writer.write("hello");
}

pub struct Writer<'a> {
    target: &'a mut String,
    indent: usize,
}

impl<'a> Writer<'a> {
    fn indent(&mut self) -> Writer {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
```

è‡³æ­¤ï¼Œé—®é¢˜å½»åº•è§£å†³ï¼Œå¤ªå¥½äº†ï¼Œæˆ‘æ„Ÿè§‰æˆ‘åˆå˜å¼ºäº†ã€‚å¯æ˜¯é»˜é»˜çœ‹äº†çœ¼è‡ªå·±çš„å¤´å‘ï¼Œåªèƒ½ä»¥`å“ï½`ä¸€å£°å¹æ¯ç»“æŸæœ¬ç« å†…å®¹ã€‚




================================================
FILE: src/compiler/pitfalls/arithmetic-overflow.md
================================================
# ç®—æœ¯æº¢å‡ºå¯¼è‡´çš„ panic

åœ¨ Rust ä¸­ï¼Œæº¢å‡ºåçš„æ•°å€¼è¢«æˆªæ–­æ˜¯å¾ˆæ­£å¸¸çš„:

```rust
let x: u16 = 65535;
let v = x as u8;
println!("{}", v)
```

æœ€ç»ˆç¨‹åºä¼šè¾“å‡º`255`, å› æ­¤å¤§å®¶å¯èƒ½ä¼šä¸‹æ„è¯†åœ°å°±è§‰å¾—ç®—æ•°æ“ä½œåœ¨ Rust ä¸­åªä¼šå¯¼è‡´ç»“æœçš„ä¸æ­£ç¡®ï¼Œå¹¶ä¸ä¼šå¯¼è‡´å¼‚å¸¸ã€‚ä½†æ˜¯å®é™…ä¸Šï¼Œå¦‚æœæ˜¯å› ä¸ºç®—æœ¯æ“ä½œç¬¦å¯¼è‡´çš„æº¢å‡ºï¼Œå°±ä¼šè®©æ•´ä¸ªç¨‹åº panic:

```rust
fn main() {
    let x: u8 = 10;

    let v = x + u8::MAX;
    println!("{}", v)
}
```

è¾“å‡ºç»“æœå¦‚ä¸‹:

```console
thread 'main' panicked at 'attempt to add with overflow', src/main.rs:5:13
```

é‚£ä¹ˆå½“æˆ‘ä»¬ç¡®å®æœ‰è¿™ç§éœ€æ±‚æ—¶ï¼Œè¯¥å¦‚ä½•åšå‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨ Rust æä¾›çš„`checked_xxx`ç³»åˆ—æ–¹æ³•ï¼š

```rust
fn main() {
    let x: u8 = 10;

    let v = x.checked_add(u8::MAX).unwrap_or(0);
    println!("{}", v)
}
```

ä¹Ÿè®¸ä½ ä¼šè§‰å¾—æœ¬ç« å†…å®¹å…¶å®ç®—ä¸ä¸Šä»€ä¹ˆé™·é˜±ï¼Œä½†æ˜¯åœ¨å®é™…é¡¹ç›®å¿«é€Ÿè¿­ä»£ä¸­ï¼Œè¶Šæ˜¯ä¸èµ·çœ¼çš„åœ°æ–¹è¶Šæ˜¯å®¹æ˜“å‡ºé”™ï¼š

```rust
fn main() {
    let v = production_rate_per_hour(5);
    println!("{}", v);
}

pub fn production_rate_per_hour(speed: u8) -> f64 {
    let cph: u8 = 221;
    match speed {
        1..=4 => (speed * cph) as f64,
        5..=8 => (speed * cph) as f64 * 0.9,
        9..=10 => (speed * cph) as f64 * 0.77,
        _ => 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -> u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}
```

ä¸Šè¿°ä»£ç ä¸­ï¼Œ`speed * cph`å°±ä¼šç›´æ¥ panic:

```console
thread 'main' panicked at 'attempt to multiply with overflow', src/main.rs:10:18
```

æ˜¯ä¸æ˜¯è¿˜è—çš„æŒºéšè”½çš„ï¼Ÿå› æ­¤å¤§å®¶åœ¨ Rust ä¸­åšæ•°å­¦è¿ç®—æ—¶ï¼Œè¦å¤šç•™ä¸€ä¸ªå¿ƒçœ¼ï¼Œå…å¾—ä¸Šäº†ç”Ÿäº§æ‰å‘ç°é—®é¢˜æ‰€åœ¨ã€‚æˆ–è€…ï¼Œä½ ä¹Ÿå¯ä»¥åšå¥½å•å…ƒæµ‹è¯•:)




================================================
FILE: src/compiler/pitfalls/closure-with-lifetime.md
================================================
# é—­åŒ…ä¸Šå¥‡æ€ªçš„ç”Ÿå‘½å‘¨æœŸ

Rust ä¸€é“ç‹¬ç‰¹çš„é“ä¸½é£æ™¯å°±æ˜¯ç”Ÿå‘½å‘¨æœŸï¼Œä¹Ÿæ˜¯åå¤æŠ˜ç£¨æ–°æ‰‹çš„æœ€å¤§é»‘æ‰‹ï¼Œå°±è¿è€æ‰‹ï¼Œå¯èƒ½ä¸€ä¸æ³¨æ„å°±ä¼šé‡åˆ°ä¸€äº›ç”Ÿå‘½å‘¨æœŸä¸Šçš„é™·é˜±ï¼Œä¾‹å¦‚é—­åŒ…ä¸Šä½¿ç”¨å¼•ç”¨ã€‚

## ä¸€æ®µç®€å•çš„ä»£ç 

å…ˆæ¥çœ‹ä¸€æ®µç®€å•çš„ä»£ç :

```rust
fn fn_elision(x: &i32) -> &i32 { x }
let closure_slision = |x: &i32| -> &i32 { x };
```

ä¹ä¸€çœ‹ï¼Œè¿™æ®µä»£ç æ¯”å¤å¤©ä¹è¿˜å¹³å¹³æ— å¥‡ï¼Œèƒ½æœ‰ä»€ä¹ˆé—®é¢˜å‘¢ï¼Ÿæ¥ï¼Œèµ°ä¸¤åœˆè¯•è¯•ï¼š

```console
error: lifetime may not live long enough
  --> src/main.rs:39:39
   |
39 |     let closure = |x: &i32| -> &i32 { x }; // fails
   |                       -        -      ^ returning this value requires that `'1` must outlive `'2`
   |                       |        |
   |                       |        let's call the lifetime of this reference `'2`
   |                       let's call the lifetime of this reference `'1`
```

å’¦ï¼Ÿç«Ÿç„¶æŠ¥é”™äº†ï¼Œæ˜æ˜ä¸¤ä¸ªä¸€æ¨¡ä¸€æ ·åŠŸèƒ½çš„å‡½æ•°ï¼Œä¸€ä¸ªæ­£å¸¸ç¼–è¯‘ï¼Œä¸€ä¸ªå´æŠ¥é”™ï¼Œé”™è¯¯åŸå› æ˜¯ç¼–è¯‘å™¨æ— æ³•æ¨æµ‹è¿”å›çš„å¼•ç”¨å’Œä¼ å…¥çš„å¼•ç”¨è°æ´»å¾—æ›´ä¹…ï¼

çœŸçš„æ˜¯éå¸¸å¥‡æ€ªçš„é”™è¯¯ï¼Œå­¦è¿‡[Rust ç”Ÿå‘½å‘¨æœŸ](https://course.rs/basic/lifetime.html#ä¸‰æ¡æ¶ˆé™¤è§„åˆ™)çš„è¯»è€…åº”è¯¥éƒ½è®°å¾—è¿™æ ·ä¸€æ¡ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™: **å¦‚æœå‡½æ•°å‚æ•°ä¸­åªæœ‰ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼Œé‚£è¯¥å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«è‡ªåŠ¨åˆ†é…ç»™æ‰€æœ‰çš„è¿”å›å¼•ç”¨**ã€‚æˆ‘ä»¬å½“å‰çš„æƒ…å†µå®Œç¾ç¬¦åˆï¼Œ`fn_elision`å‡½æ•°çš„é¡ºåˆ©ç¼–è¯‘é€šè¿‡ï¼Œå°±å……åˆ†è¯´æ˜äº†é—®é¢˜ã€‚

é‚£ä¸ºä½•é—­åŒ…å°±å‡ºé—®é¢˜äº†ï¼Ÿ

## ä¸€æ®µå¤æ‚çš„ä»£ç 

ä¸ºäº†éªŒè¯é—­åŒ…æ— æ³•åº”ç”¨ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ï¼Œå†æ¥çœ‹ä¸€ä¸ªå¤æ‚ä¸€äº›çš„ä¾‹å­:

```rust
use std::marker::PhantomData;

trait Parser<'a>: Sized + Copy {
    fn parse(&self, tail: &'a str) -> &'a str {
        tail
    }
    fn wrap(self) -> Wrapper<'a, Self> {
        Wrapper {
            parser: self,
            marker: PhantomData,
        }
    }
}

#[derive(Copy, Clone)]
struct T<'x> {
    int: &'x i32,
}

impl<'a, 'x> Parser<'a> for T<'x> {}

struct Wrapper<'a, P>
where
    P: Parser<'a>,
{
    parser: P,
    marker: PhantomData<&'a ()>,
}

fn main() {
    // Error.
    let closure_wrap = |parser: T| parser.wrap();

    // No error.
    fn parser_wrap(parser: T<'_>) -> Wrapper<'_, T<'_>> {
        parser.wrap()
    }
}
```

è¯¥ä¾‹å­ä¹‹æ‰€ä»¥è¿™ä¹ˆå¤æ‚ï¼Œçº¯ç²¹æ˜¯ä¸ºäº†è¯æ˜é—­åŒ…ä¸Šç”Ÿå‘½å‘¨æœŸä¼šå¤±æ•ˆï¼Œè¯»è€…å¤§å¤§è½»æ‹:) ç¼–è¯‘åï¼Œä¸å‡ºæ‰€æ–™çš„æŠ¥é”™äº†ï¼š

```console
error: lifetime may not live long enough
  --> src/main.rs:32:36
   |
32 |     let closure_wrap = |parser: T| parser.wrap();
   |                         ------   - ^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`
   |                         |        |
   |                         |        return type of closure is Wrapper<'_, T<'2>>
   |                         has type `T<'1>`
```

## æ·±å…¥è°ƒæŸ¥

ä¸€æ¨¡ä¸€æ ·çš„æŠ¥é”™ï¼Œè¯´æ˜åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸçš„æ¶ˆé™¤è§„åˆ™ä¹Ÿæ²¡æœ‰ç”Ÿæ•ˆï¼Œçœ‹æ¥äº‹æƒ…ç¡®å®ä¸ç®€å•ï¼Œæˆ‘çœ‰å¤´ä¸€çš±ï¼Œå†³å®šæ·±å…¥è°ƒæŸ¥ï¼Œæœ€åè¿˜çœŸç¿»åˆ°äº†ä¸€äº›è®¨è®ºï¼Œç»è¿‡æ•´ç†åï¼Œå¤§æ¦‚åˆ†äº«ç»™å¤§å®¶ã€‚

é¦–å…ˆç»™å‡ºä¸€ä¸ªç»“è®ºï¼š**è¿™ä¸ªé—®é¢˜ï¼Œå¯èƒ½å¾ˆéš¾è¢«è§£å†³ï¼Œå»ºè®®å¤§å®¶é‡åˆ°åï¼Œè¿˜æ˜¯è€è€å®å®ç”¨æ­£å¸¸çš„å‡½æ•°ï¼Œä¸è¦ç§€é—­åŒ…äº†**ã€‚

å¯¹äºå‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸè€Œè¨€ï¼Œå®ƒçš„æ¶ˆé™¤è§„åˆ™ä¹‹æ‰€ä»¥èƒ½ç”Ÿæ•ˆæ˜¯å› ä¸ºå®ƒçš„ç”Ÿå‘½å‘¨æœŸå®Œå…¨ä½“ç°åœ¨ç­¾åçš„å¼•ç”¨ç±»å‹ä¸Šï¼Œåœ¨å‡½æ•°ä½“ä¸­æ— éœ€ä»»ä½•ä½“ç°:

```rust
fn fn_elision(x: &i32) -> &i32 {..}
```

å› æ­¤ç¼–è¯‘å™¨å¯ä»¥åšå„ç§ç¼–è¯‘ä¼˜åŒ–ï¼Œä¹Ÿå¾ˆå®¹æ˜“æ ¹æ®å‚æ•°å’Œè¿”å›å€¼è¿›è¡Œç”Ÿå‘½å‘¨æœŸçš„åˆ†æï¼Œæœ€ç»ˆå¾—å‡ºæ¶ˆé™¤è§„åˆ™ã€‚

å¯æ˜¯é—­åŒ…ï¼Œå¹¶æ²¡æœ‰å‡½æ•°é‚£ä¹ˆç®€å•ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸåˆ†æ•£åœ¨å‚æ•°å’Œé—­åŒ…å‡½æ•°ä½“ä¸­(ä¸»è¦æ˜¯å®ƒæ²¡æœ‰ç¡®åˆ‡çš„è¿”å›å€¼ç­¾å)ï¼š

```rust
let closure_slision = |x: &i32| -> &i32 { x };
```

ç¼–è¯‘å™¨å°±å¿…é¡»æ·±å…¥åˆ°é—­åŒ…å‡½æ•°ä½“ä¸­ï¼Œå»åˆ†æå’Œæ¨æµ‹ç”Ÿå‘½å‘¨æœŸï¼Œå¤æ‚åº¦å› æ­¤æå…·æå‡ï¼šè¯•æƒ³ä¸€ä¸‹ï¼Œç¼–è¯‘å™¨è¯¥å¦‚ä½•ä»å¤æ‚çš„ä¸Šä¸‹æ–‡ä¸­åˆ†æå‡ºå‚æ•°å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå’Œé—­åŒ…ä½“ä¸­ç”Ÿå‘½å‘¨æœŸçš„å…³ç³»ï¼Ÿ

ç”±äºä¸Šè¿°åŸå› (å½“ç„¶ï¼Œå®é™…æƒ…å†µå¤æ‚çš„å¤š)ï¼Œ Rust è¯­è¨€å¼€å‘è€…å…¶å®ç›®å‰æ˜¯æœ‰æ„ä¸ºä¹‹ï¼Œé’ˆå¯¹å‡½æ•°å’Œé—­åŒ…å®ç°äº†ä¸¤ç§ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ã€‚

## æ€»ç»“

è™½ç„¶æˆ‘è¨€ä¹‹å‡¿å‡¿ï¼Œé—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸæ— æ³•è§£å†³ï¼Œä½†æ˜¯æœªæ¥è°åˆçŸ¥é“å‘¢ã€‚æœ€å¤§çš„å¯èƒ½æ€§å°±æ˜¯ä¹‹å‰å¼€å¤´é‚£ç§ç®€å•çš„åœºæ™¯ï¼Œå¯ä»¥è¢«è‡ªåŠ¨è¯†åˆ«å’Œæ¶ˆé™¤ã€‚

æ€»ä¹‹ï¼Œå¦‚æœæœ‰è¿™ç§éœ€æ±‚ï¼Œè¿˜æ˜¯åƒå¤å¤©ä¹ä¸€æ ·åšä¸€ä¸ªå¹³å¹³æ— å¥‡çš„ç”·äººï¼Œè€è€å®å®ä½¿ç”¨å‡½æ•°å§ã€‚




================================================
FILE: src/compiler/pitfalls/index.md
================================================
# Rust é™·é˜±ç³»åˆ—

æœ¬ç« æ”¶å½•ä¸€äº› Rust å¸¸è§çš„é™·é˜±ï¼Œä¸€ä¸å°å¿ƒå°±ä¼šå‘ä½ çš„é‚£ç§(å½“ç„¶ï¼Œè¿™ä¸æ˜¯ Rust è¯­è¨€çš„é—®é¢˜ï¼Œè€Œæ˜¯ä¸€äº›è¾¹è¾¹è§’è§’çš„çŸ¥è¯†ç‚¹)ã€‚




================================================
FILE: src/compiler/pitfalls/iterator-everywhere.md
================================================
# æ— å¤„ä¸åœ¨çš„è¿­ä»£å™¨

Rust çš„è¿­ä»£å™¨æ— å¤„ä¸åœ¨ï¼Œç›´è‡³ä½ åœ¨å®ƒä¸Šé¢æ ½äº†è·Ÿå¤´ï¼Œç»è¿‡æ·±å…¥è°ƒæŸ¥æ‰å‘ç°ï¼šå“¦ï¼ŒåŸæ¥æ˜¯è¿­ä»£å™¨çš„é”…ã€‚ä¸ä¿¡çš„è¯ï¼Œçœ‹çœ‹è¿™ä¸ªæŠ¥é”™ä½ èƒ½æƒ³åˆ°æ˜¯è¿­ä»£å™¨çš„é—®é¢˜å—: `borrow of moved value: words`.

## æŠ¥é”™çš„ä»£ç 

ä»¥ä¸‹çš„ä»£ç éå¸¸ç®€å•ï¼Œç”¨æ¥ç»Ÿè®¡æ–‡æœ¬ä¸­å­—è¯çš„æ•°é‡ï¼Œå¹¶æ‰“å°å‡ºæ¥ï¼š

```rust
fn main() {
    let s = "hello world";
    let mut words = s.split(" ");
    let n = words.count();
    println!("{:?}",words);
}
```

å››è¡Œä»£ç ï¼Œè¡Œäº‘æµæ°´ï¼Œä¸€æ°”å‘µæˆï¼Œä¸”çœ‹æˆæ•ˆï¼š

```console
error[E0382]: borrow of moved value: `words`
   --> src/main.rs:5:21
    |
3   |     let mut words = s.split(" ");
    |         --------- move occurs because `words` has type `std::str::Split<'_, &str>`, which does not implement the `Copy` trait
4   |     let n = words.count();
    |                   ------- `words` moved due to this method call
5   |     println!("{:?}",words);
    |                     ^^^^^ value borrowed here after move
```

ä¸–äº‹éš¾æ–™ï¼Œæˆ‘ä»¥ä¸ºåªæœ‰çš„ç”Ÿå‘½å‘¨æœŸã€é—­åŒ…æ‰å®¹æ˜“èƒŒå›é©å‘½ï¼Œæ²¡æƒ³åˆ°ä¸€ä¸ªä½ æµ“çœ‰å¤§çœ¼çš„`count`æ–¹æ³•ä¹ŸèƒŒå›é©å‘½ã€‚ä»æŠ¥é”™æ¥çœ‹ï¼Œæ˜¯å› ä¸º`count`æ–¹æ³•æ‹¿èµ°äº†`words`çš„æ‰€æœ‰æƒï¼Œæ¥çœ‹çœ‹ç­¾åï¼š

```rust
fn count(self) -> usize
```

ä»ç­¾åæ¥çœ‹ï¼Œç¼–è¯‘å™¨çš„æŠ¥é”™æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆä¸€ä¸ªç®€å•çš„æ ‡å‡†åº“`count`æ–¹æ³•å°±æ•¢æ‹¿èµ°æ‰€æœ‰æƒï¼Ÿ

## è¿­ä»£å™¨å›é¡¾

åœ¨[è¿­ä»£å™¨](https://course.rs/advance/functional-programing/iterator.html#æ¶ˆè´¹è€…ä¸é€‚é…å™¨)ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬æ›¾ç»å­¦ä¹ è¿‡ä¸¤ä¸ªæ¦‚å¿µï¼šè¿­ä»£å™¨é€‚é…å™¨å’Œæ¶ˆè´¹è€…é€‚é…å™¨ï¼Œå‰è€…ç”¨äºå¯¹è¿­ä»£å™¨ä¸­çš„å…ƒç´ è¿›è¡Œæ“ä½œï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œä¾‹å¦‚`map`ã€`filter`ç­‰æ–¹æ³•ï¼›è€Œåè€…ç”¨äºæ¶ˆè´¹æ‰è¿­ä»£å™¨ï¼Œæœ€ç»ˆäº§ç”Ÿä¸€ä¸ªç»“æœï¼Œä¾‹å¦‚`collect`æ–¹æ³•, ä¸€ä¸ªå…¸å‹çš„ç¤ºä¾‹å¦‚ä¸‹ï¼š

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

åœ¨å…¶ä¸­ï¼Œæˆ‘ä»¬è¿˜æåˆ°ä¸€ä¸ªç»†èŠ‚ï¼Œæ¶ˆè´¹è€…é€‚é…å™¨ä¼šæ‹¿èµ°è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼Œé‚£ä¹ˆè¿™ä¸ªæ˜¯å¦ä¸æˆ‘ä»¬æœ€å¼€å§‹ç¢°åˆ°çš„é—®é¢˜æœ‰å…³ç³»ï¼Ÿ

## æ·±å…¥è°ƒæŸ¥

è¦è§£é‡Šè¿™ä¸ªé—®é¢˜ï¼Œå¿…é¡»è¦æ‰¾åˆ°`words`æ˜¯æ¶ˆè´¹è€…é€‚é…å™¨çš„è¯æ®ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ·±å…¥æºç è¿›è¡ŒæŸ¥çœ‹ã€‚

å…¶å®ã€‚ã€‚ä¹Ÿä¸éœ€è¦å¤šæ·±ï¼Œåªè¦è¿›å…¥`words`çš„æºç ï¼Œå°±èƒ½çœ‹å‡ºå®ƒå±äº`Iterator`ç‰¹å¾ï¼Œé‚£è¯´æ˜`split`æ–¹æ³•äº§ç”Ÿäº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Ÿå†æ¥çœ‹çœ‹ï¼š

```rust
pub fn split<'a, P>(&'a self, pat: P) -> Split<'a, P>
where
    P: Pattern<'a>,
//An iterator over substrings of this string slice, separated by characters matched by a pattern.
```

è¿˜çœŸæ˜¯ï¼Œä»ä»£ç æ³¨é‡Šæ¥çœ‹ï¼Œ`Split`å°±æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ç±»å‹ï¼Œç”¨æ¥è¿­ä»£è¢«åˆ†éš”ç¬¦éš”å¼€çš„å­å­—ç¬¦ä¸²é›†åˆã€‚

çœŸç›¸å¤§ç™½äº†ï¼Œ`split`äº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ï¼Œè€Œ`count`æ–¹æ³•æ˜¯ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨ï¼Œç”¨äºæ¶ˆè€—æ‰å‰è€…äº§ç”Ÿçš„è¿­ä»£å™¨ï¼Œæœ€ç»ˆç”Ÿæˆå­—è¯ç»Ÿè®¡çš„ç»“æœã€‚

æœ¬èº«é—®é¢˜ä¸å¤æ‚ï¼Œä½†æ˜¯åœ¨**è§£å†³æ–¹æ³•ä¸Šï¼Œå¯èƒ½è¿˜æœ‰ç‚¹åœ¨å„ä½å®¢å®˜çš„æ„æ–™ä¹‹å¤–**ï¼Œä¸”çœ‹ä¸‹æ–‡ã€‚

## æœ€ rusty çš„è§£å†³æ–¹æ³•

ä½ å¯èƒ½ä¼šæƒ³ç”¨`collect`æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…ˆæ”¶é›†æˆä¸€ä¸ªé›†åˆï¼Œç„¶åè¿›è¡Œç»Ÿè®¡ã€‚å½“ç„¶æ­¤æ–¹æ³•å®Œå…¨å¯è¡Œï¼Œä½†æ˜¯å¾ˆä¸`rusty`(å¾ˆç¬¦åˆ rust è§„èŒƒã€æ½®æµçš„æ„æ€)ï¼Œä»¥ä¸‹ç»™å‡ºæœ€`rusty`çš„è§£å†³æ–¹æ¡ˆï¼š

```rust
let words = s.split(",");
let n = words.clone().count();
```

åœ¨ç»§ç»­ä¹‹å‰ï¼Œæˆ‘å¾—å…ˆæ‰¾ä¸€ä¸ªåœ°æ–¹è—å¥½ï¼Œå› ä¸ºä¿ºæœ‰ä¸€ä¸ªæ„Ÿè§‰ï¼Œçƒ‚è¥¿çº¢æŸ¿æ­£åœ¨é“ºå¤©ç›–åœ°çš„å‘¼å•¸è€Œæ¥ï¼Œä¼´éšè€Œæ¥çš„æ˜¯è¯»è€…çš„æ­£ä¹‰å‘µæ–¥ï¼š
**ä½ ç®¡`clone`å«æœ€å¥½ã€æœ€`rusty`çš„è§£å†³æ–¹æ³•ï¼Ÿï¼Ÿ**

å¤§å®¶ä¸”å¬æˆ‘æ…¢æ…¢é“æ¥ï¼Œäº‹å®ä¸Šï¼Œåœ¨ Rust ä¸­`clone`ä¸æ€»æ˜¯æ€§èƒ½ä½ä¸‹çš„ä»£åè¯ï¼Œå› ä¸º`clone`çš„è¡Œä¸ºå®Œå…¨å–å†³äºå®ƒçš„å…·ä½“å®ç°ã€‚

#### è¿­ä»£å™¨çš„`clone`ä»£ä»·

å¯¹äºè¿­ä»£å™¨è€Œè¨€ï¼Œå®ƒå…¶å®å¹¶ä¸éœ€è¦æŒæœ‰æ•°æ®æ‰èƒ½è¿›è¡Œè¿­ä»£ï¼Œäº‹å®ä¸Šå®ƒåŒ…å«ä¸€ä¸ªå¼•ç”¨ï¼Œè¯¥å¼•ç”¨æŒ‡å‘äº†ä¿å­˜åœ¨å †ä¸Šçš„æ•°æ®ï¼Œè€Œè¿­ä»£å™¨è‡ªèº«çš„ç»“æ„æ˜¯ä¿å­˜åœ¨æ ˆä¸Šã€‚

å› æ­¤å¯¹è¿­ä»£å™¨çš„`clone`ä»…ä»…æ˜¯å¤åˆ¶äº†ä¸€ä»½æ ˆä¸Šçš„ç®€å•ç»“æ„ï¼Œæ€§èƒ½éå¸¸é«˜æ•ˆï¼Œä¾‹å¦‚:

```rust
pub struct Split<'a, T: 'a, P>
where
    P: FnMut(&T) -> bool,
{
    // Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods
    pub(crate) v: &'a [T],
    pred: P,
    // Used for `SplitAsciiWhitespace` `as_str` method
    pub(crate) finished: bool,
}

impl<T, P> Clone for Split<'_, T, P>
where
    P: Clone + FnMut(&T) -> bool,
{
    fn clone(&self) -> Self {
        Split { v: self.v, pred: self.pred.clone(), finished: self.finished }
    }
}
```

ä»¥ä¸Šä»£ç å®ç°äº†å¯¹`Split`è¿­ä»£å™¨çš„å…‹éš†ï¼Œå¯ä»¥çœ‹å‡ºï¼Œåº•å±‚çš„çš„æ•°ç»„`self.v`å¹¶æ²¡æœ‰è¢«å…‹éš†è€Œæ˜¯ç®€å•çš„å¤åˆ¶äº†ä¸€ä¸ªå¼•ç”¨ï¼Œä¾ç„¶æŒ‡å‘äº†åº•å±‚çš„æ•°ç»„`&[T]`ï¼Œå› æ­¤è¿™ä¸ªå…‹éš†éå¸¸é«˜æ•ˆã€‚

## æ€»ç»“

çœ‹èµ·æ¥æ˜¯æ— æ•ˆå€Ÿç”¨å¯¼è‡´çš„é”™è¯¯ï¼Œå®é™…ä¸Šæ˜¯è¿­ä»£å™¨è¢«æ¶ˆè´¹äº†å¯¼è‡´çš„é—®é¢˜ï¼Œè¿™è¯´æ˜ Rust ç¼–è¯‘å™¨è™½ç„¶ä¼šå‘Šè¯‰ä½ é”™è¯¯åŸå› ï¼Œä½†æ˜¯è¿™ä¸ªåŸå› ä¸æ€»æ˜¯æ ¹æœ¬åŸå› ã€‚æˆ‘ä»¬éœ€è¦ä¸€åŒæ…§çœ¼å’Œå‹¤åŠ³çš„æ‰‹ï¼Œæ¥æŒ–æ˜å‡ºè¿™ä¸ªå®è—ï¼Œæœ€åä¸ºå·±æ‰€ç”¨ã€‚

åŒæ—¶ï¼Œå…‹éš†åœ¨ Rust ä¸­ä¹Ÿå¹¶ä¸æ€»æ˜¯**bad guy**çš„ä»£åè¯ï¼Œæœ‰çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥å¤§èƒ†å»ä½¿ç”¨ï¼Œå½“ç„¶å‰ææ˜¯äº†è§£ä½ çš„ä»£ç åœºæ™¯å’Œå…·ä½“çš„`clone`å®ç°ï¼Œè¿™æ ·ä½ ä¹Ÿèƒ½åƒæ–‡ä¸­é‚£æ ·ä½œå‡ºéå¸¸`rusty`çš„é€‰æ‹©ã€‚




================================================
FILE: src/compiler/pitfalls/lazy-iterators.md
================================================
# ä¸å¤ªå‹¤å¿«çš„è¿­ä»£å™¨

è¿­ä»£å™¨ï¼Œåœ¨ Rust ä¸­æ˜¯ä¸€ä¸ªéå¸¸è€€çœ¼çš„å­˜åœ¨ï¼Œå®ƒå…‰é²œäº®ä¸½ï¼Œå®ƒè®© Rust å¤§é“è‡³ç®€ï¼Œå®ƒå¤‡å—ç”¨æˆ·çš„å–œçˆ±ã€‚å¯æ˜¯ï¼Œå®ƒä¹Ÿæ˜¯æ‡’æƒ°çš„ï¼Œä¸ä¿¡ï¼Ÿä¸€èµ·æ¥çœ‹çœ‹ã€‚

## for å¾ªç¯ vs è¿­ä»£å™¨

åœ¨è¿­ä»£å™¨å­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬æåˆ°è¿‡è¿­ä»£å™¨åœ¨åŠŸèƒ½ä¸Šå¯ä»¥æ›¿ä»£å¾ªç¯ï¼Œæ€§èƒ½ä¸Šç•¥å¾®ä¼˜äºå¾ªç¯(é¿å…è¾¹ç•Œæ£€æŸ¥),å®‰å…¨æ€§ä¸Šä¼˜äºå¾ªç¯ï¼Œå› æ­¤åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨å¾€å¾€éƒ½æ˜¯æ›´ä¼˜çš„é€‰æ‹©ï¼Œå‰ææ˜¯è¿­ä»£å™¨å¾—å‘æŒ¥ä½œç”¨ã€‚

åœ¨ä¸‹é¢ä»£ç ä¸­ï¼Œåˆ†åˆ«æ˜¯ä½¿ç”¨`for`å¾ªç¯å’Œè¿­ä»£å™¨å»ç”Ÿæˆä¸€ä¸ª`HashMap`ã€‚

ä½¿ç”¨å¾ªç¯:

```rust
use std::collections::HashMap;
#[derive(Debug)]
struct Account {
    id: u32,
}

fn main() {
    let accounts = [Account { id: 1 }, Account { id: 2 }, Account { id: 3 }];

    let mut resolvers = HashMap::new();
    for a in accounts {
        resolvers.entry(a.id).or_insert(Vec::new()).push(a);
    }

    println!("{:?}",resolvers);
}
```

ä½¿ç”¨è¿­ä»£å™¨:

```rust
let mut resolvers = HashMap::new();
accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
println!("{:?}",resolvers);
```

#### é¢„æ–™ä¹‹å¤–çš„ç»“æœ

ä¸¤ç«¯ä»£ç ä¹ä¸€çœ‹(å¾ˆå¤šæ—¶å€™æˆ‘ä»¬å¿«é€Ÿæµè§ˆä»£ç çš„æ—¶å€™ï¼Œä¸ä¼šå»ç»†çœ‹)éƒ½å¾ˆæ­£å¸¸, è¿è¡Œä¸‹è¯•è¯•:

- `for`å¾ªç¯å¾ˆæ­£å¸¸ï¼Œè¾“å‡º`{2: [Account { id: 2 }], 1: [Account { id: 1 }], 3: [Account { id: 3 }]}`
- è¿­ä»£å™¨å¾ˆã€‚ã€‚ã€‚ä¸æ­£å¸¸ï¼Œè¾“å‡ºäº†ä¸€ä¸ª`{}`, é»‘äººé—®å·`? ?` **?**

åœ¨ç»§ç»­æ·±æŒ–ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥ç®€å•å›é¡¾ä¸‹è¿­ä»£å™¨ã€‚

## å›é¡¾ä¸‹è¿­ä»£å™¨

åœ¨è¿­ä»£å™¨ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬æ›¾ç»æåˆ°è¿‡ï¼Œè¿­ä»£å™¨çš„[é€‚é…å™¨](https://course.rs/advance/functional-programing/iterator.html#æ¶ˆè´¹è€…ä¸é€‚é…å™¨)åˆ†ä¸ºä¸¤ç§ï¼šæ¶ˆè´¹è€…é€‚é…å™¨å’Œè¿­ä»£å™¨é€‚é…å™¨ï¼Œå‰è€…ç”¨æ¥å°†ä¸€ä¸ªè¿­ä»£å™¨å˜ä¸ºæŒ‡å®šçš„é›†åˆç±»å‹ï¼Œå¾€å¾€é€šè¿‡`collect`å®ç°ï¼›åè€…ç”¨äºç”Ÿæˆä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œä¾‹å¦‚ä¸Šä¾‹ä¸­çš„`map`ã€‚

è¿˜æåˆ°è¿‡éå¸¸é‡è¦çš„ä¸€ç‚¹: **è¿­ä»£å™¨é€‚é…å™¨éƒ½æ˜¯æ‡’æƒ°çš„ï¼Œåªæœ‰é…åˆæ¶ˆè´¹è€…é€‚é…å™¨ä½¿ç”¨æ—¶ï¼Œæ‰ä¼šè¿›è¡Œæ±‚å€¼**.

## æ‡’æƒ°æ˜¯æ ¹å› 

åœ¨æˆ‘ä»¬ä¹‹å‰çš„è¿­ä»£å™¨ç¤ºä¾‹ä¸­ï¼Œåªæœ‰ä¸€ä¸ªè¿­ä»£å™¨é€‚é…å™¨`map`:

```rust
accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
```

é¦–å…ˆ, `accounts`è¢«æ‹¿èµ°æ‰€æœ‰æƒåè½¬æ¢æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œå…¶æ¬¡è¯¥è¿­ä»£å™¨é€šè¿‡`map`æ–¹æ³•ç”Ÿæˆä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œæœ€åï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­æ²¡æœ‰ä»¥ç±»å¦‚`collect`çš„æ¶ˆè´¹è€…é€‚é…å™¨æ”¶å°¾ã€‚

å› æ­¤åœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­ï¼Œ`map`å®Œå…¨æ˜¯æ‡’æƒ°çš„ï¼Œå®ƒæ²¡æœ‰åšä»»ä½•äº‹æƒ…ï¼Œå®ƒåœ¨ç­‰ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨å‘Šè¯‰å®ƒï¼šèµ¶ç´§èµ·åºŠï¼Œä»»åŠ¡å¯ä»¥å¼€å§‹äº†ï¼Œå®ƒæ‰ä¼šå¼€å§‹è¡ŒåŠ¨ã€‚

è‡ªç„¶ï¼Œæˆ‘ä»¬çš„æ’å€¼è®¡åˆ’ä¹Ÿå¤±è´¥äº†ã€‚

> äº‹å®ä¸Šï¼ŒIDE å’Œç¼–è¯‘å™¨éƒ½ä¼šå¯¹è¿™ç§ä»£ç ç»™å‡ºè­¦å‘Šï¼šiterators are lazy and do nothing unless consumed

## è§£å†³åŠæ³•

åŸå› éå¸¸æ¸…æ™°ï¼Œå¦‚æœè¯»è€…è¿˜æœ‰ç–‘æƒ‘ï¼Œå»ºè®®æ·±åº¦äº†è§£ä¸‹ä¸Šé¢ç»™å‡ºçš„è¿­ä»£å™¨é“¾æ¥ï¼Œæˆ‘ä»¬è¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚

ä¸‹é¢åˆ—å‡ºä¸‰ç§åˆç†çš„è§£å†³åŠæ³•ï¼š

1. ä¸å†ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨`map`ï¼Œæ”¹æˆ`for_each`:

```rust
let mut resolvers = HashMap::new();
accounts.into_iter().for_each(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
```

ä½†æ˜¯ï¼Œç›¸å…³çš„æ–‡æ¡£ä¹Ÿå‹å–„çš„æç¤ºäº†æˆ‘ä»¬ï¼Œé™¤éä½œä¸ºé“¾å¼è°ƒç”¨çš„æ”¶å°¾ï¼Œå¦åˆ™æ›´å»ºè®®ä½¿ç”¨`for`å¾ªç¯æ¥å¤„ç†è¿™ç§æƒ…å†µã€‚å“ï¼Œå¿™å¿™ç¢Œç¢Œï¼Œåˆå›åˆ°äº†åŸç‚¹ï¼Œä¸ç¦è®©äººæ„Ÿå¹ï¼šå¤©é“æœ‰è½®å›ã€‚

2. ä½¿ç”¨æ¶ˆè´¹è€…é€‚é…å™¨`collect`æ¥æ”¶å°¾ï¼Œå°†`map`äº§ç”Ÿçš„è¿­ä»£å™¨æ”¶é›†æˆä¸€ä¸ªé›†åˆç±»å‹:

```rust
let resolvers: HashMap<_, _> = accounts
.into_iter()
.map(|a| (a.id, a))
.collect();
```

å—¯ï¼Œè¿˜æŒºç®€æ´ï¼ŒæŒº`rusty`.

3. ä½¿ç”¨`fold`ï¼Œè¯­ä¹‰è¡¨è¾¾æ›´å¼º:

```rust
let resolvers = account.into_iter().fold(HashMap::new(), |mut resolvers, a|{
    resolvers.entry(a.id).or_insert(Vec::new()).push(a);
    resolvers
});
```

## æ€»ç»“

åœ¨ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œè¦æ¸…æ™°çš„è®¤è¯†åˆ°éœ€è¦ç”¨åˆ°çš„æ–¹æ³•æ˜¯è¿­ä»£å‹è¿˜æ˜¯æ¶ˆè´¹å‹é€‚é…å™¨ï¼Œå¦‚æœä¸€ä¸ªè°ƒç”¨é“¾ä¸­æ²¡æœ‰ä»¥æ¶ˆè´¹å‹é€‚é…å™¨ç»“å°¾ï¼Œå°±éœ€è¦æ‰“èµ·ç²¾ç¥äº†ï¼Œä¹Ÿè®¸ï¼Œä¸è¿œå¤„å°±æ˜¯ä¸€ä¸ªé™·é˜±åœ¨ç­‰ä½ è·³:)



================================================
FILE: src/compiler/pitfalls/main-with-channel-blocked.md
================================================
# çº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯å¯¼è‡´ä¸»çº¿ç¨‹æ— æ³•ç»“æŸ

æœ¬ç¯‡é™·é˜±è¾ƒçŸ­ï¼Œä¸»è¦è§£å†³æ–°æ‰‹åœ¨å¤šçº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯æ—¶å¯èƒ½ä¼šé‡åˆ°çš„ä¸€ä¸ªé—®é¢˜ï¼šä¸»çº¿ç¨‹ä¼šä¸€ç›´é˜»å¡ï¼Œæ— æ³•ç»“æŸã€‚

Rust æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªæ¶ˆæ¯é€šé“ï¼Œéå¸¸å¥½ç”¨ï¼Œä¹Ÿç›¸å½“ç®€å•æ˜äº†ï¼Œä½†æ˜¯ä½†æ˜¯åœ¨ä½¿ç”¨èµ·æ¥è¿˜æ˜¯å¯èƒ½å­˜åœ¨å‘ï¼š

```rust
use std::sync::mpsc;
fn main() {

    use std::thread;

    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {
            thread_send.send(i).unwrap();
            println!("thread {:?} finished", i);
        });
    }

    for x in recv {
        println!("Got: {}", x);
    }
    println!("finished iterating");
}
```

ä»¥ä¸Šä»£ç çœ‹èµ·æ¥éå¸¸æ­£å¸¸ï¼Œè¿è¡Œä¸‹è¯•è¯•:

```console
thread 0 finished
thread 1 finished
Got: 0
Got: 1
thread 2 finished
Got: 2
```

å¥‡æ€ªï¼Œä¸»çº¿ç¨‹ç«Ÿç„¶å¡æ­»äº†ï¼Œæœ€åä¸€è¡Œ` println!("finished iterating");`ä¸€ç›´æ²¡æœ‰è¢«è¾“å‡ºã€‚

å…¶å®ï¼Œä¸Šé¢çš„æè¿°æœ‰é—®é¢˜ï¼Œä¸»çº¿ç¨‹å¹¶ä¸æ˜¯å¡æ­»ï¼Œè€Œæ˜¯`for`å¾ªç¯å¹¶æ²¡æœ‰ç»“æŸï¼Œè‡³äº`for`å¾ªç¯ä¸ç»“æŸçš„åŸå› æ˜¯æ¶ˆæ¯é€šé“æ²¡æœ‰è¢«å…³é—­ã€‚

å›å¿†ä¸€ä¸‹ Rust æ¶ˆæ¯é€šé“å…³é—­çš„ä¸¤ä¸ªæ¡ä»¶ï¼šæ‰€æœ‰å‘é€è€…å…¨éƒ¨è¢«`drop`æˆ–æ¥æ”¶è€…è¢«`drop`ï¼Œç”±äº`for`å¾ªç¯è¿˜åœ¨ä½¿ç”¨æ¥æ”¶è€…ï¼Œå› ä¸ºåè€…æ¡ä»¶æ— æ³•è¢«æ»¡è¶³ï¼Œé‚£ä¹ˆåªèƒ½å‘é€è€…å…¨éƒ¨è¢«`drop`ï¼Œæ‰èƒ½è®©ä¾‹å­ä¸­çš„æ¶ˆæ¯é€šé“å…³é—­ã€‚

æ¥åˆ†æä¸‹ä»£ç ï¼Œæ¯ä¸€ä¸ªå­çº¿ç¨‹éƒ½ä»`send`è·å–äº†ä¸€ä¸ªæ‹·è´ï¼Œç„¶åè¯¥æ‹·è´åœ¨å­çº¿ç¨‹ç»“æŸæ—¶è‡ªåŠ¨è¢«`drop`ï¼Œçœ‹ä¸Šå»æ²¡é—®é¢˜å•Šã€‚ç­‰ç­‰ï¼Œå¥½åƒ`send`æœ¬èº«å¹¶æ²¡æœ‰è¢«`drop`ï¼Œå› ä¸º`send`è¦ç­‰åˆ°`main`å‡½æ•°ç»“æŸæ‰ä¼šè¢«`drop`ï¼Œé‚£ä¹ˆä»£ç å°±é™·å…¥äº†ä¸€ä¸ªå°´å°¬çš„å¢ƒåœ°ï¼š`main`å‡½æ•°è¦ç»“æŸéœ€è¦`for`å¾ªç¯ç»“æŸï¼Œ`for`å¾ªç¯ç»“æŸéœ€è¦`send`è¢«`drop`ï¼Œè€Œ`send`è¦è¢«`drop`éœ€è¦`main`å‡½æ•°ç»“æŸã€‚ã€‚ã€‚

ç ´å±€ç‚¹åªæœ‰ä¸€ä¸ªï¼Œé‚£å°±æ˜¯ä¸»åŠ¨`drop`æ‰`send`ï¼Œè¿™ä¸ªç®€å•ï¼Œä½¿ç”¨`std::mem::drop`å‡½æ•°å³å¯ï¼Œå¾—ç›Šäº`prelude`ï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨`drop`:

```rust
use std::sync::mpsc;
fn main() {

    use std::thread;

    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {

            thread_send.send(i).unwrap();
            println!("thread {:?} finished", i);
        });
    }

    drop(send);
    for x in recv {
        println!("Got: {}", x);
    }
    println!("finished iterating");
}
```

æ­¤æ—¶å†è¿è¡Œï¼Œä¸»çº¿ç¨‹å°†é¡ºåˆ©ç»“æŸã€‚

## æ€»ç»“

æœ¬æ–‡æ€»ç»“äº†ä¸€ä¸ªæ–°æ‰‹åœ¨ä½¿ç”¨æ¶ˆæ¯é€šé“æ—¶å¸¸è§çš„é”™è¯¯ï¼Œé‚£å°±æ˜¯å¿˜è®°å¤„ç†åˆ›å»ºé€šé“æ—¶å¾—åˆ°çš„å‘é€è€…ï¼Œæœ€åç”±äºè¯¥å‘é€è€…çš„å­˜æ´»å¯¼è‡´é€šé“æ— æ³•è¢«å…³é—­ï¼Œæœ€ç»ˆä¸»çº¿ç¨‹é˜»å¡ï¼Œé€ æˆç¨‹åºé”™è¯¯ã€‚



================================================
FILE: src/compiler/pitfalls/multiple-mutable-references.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/stack-overflow.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/the-disabled-mutability.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/use-vec-in-for.md
================================================
# for å¾ªç¯ä¸­ä½¿ç”¨å¤–éƒ¨æ•°ç»„

ä¸€èˆ¬æ¥è¯´ï¼Œ`for`å¾ªç¯èƒ½åšåˆ°çš„ï¼Œ`while`ä¹Ÿå¯ä»¥ï¼Œåä¹‹äº¦ç„¶ï¼Œä½†æ˜¯æœ‰ä¸€ç§æƒ…å†µï¼Œè¿˜çœŸä¸è¡Œï¼Œå…ˆæ¥çœ‹ä»£ç :

```rust
let mut v = vec![1,2,3];

for i in 0..v.len() {
    v.push(i);
    println!("{:?}",v);
}
```

æˆ‘ä»¬çš„ç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ªæ— é™å¢é•¿çš„æ•°ç»„ï¼Œå¾€é‡Œé¢æ’å…¥`0..`(çœ‹ä¸æ‡‚è¯¥è¡¨è¾¾å¼çš„åŒå­¦è¯·æŸ¥é˜…[æµç¨‹æ§åˆ¶](https://course.rs/basic/flow-control.html))çš„æ•°å€¼åºåˆ—ã€‚

çœ‹èµ·æ¥ä¸Šé¢ä»£ç å¯ä»¥å®Œæˆï¼Œå› ä¸ºéšç€æ•°ç»„ä¸åœå¢é•¿ï¼Œ`v.len()`ä¹Ÿä¼šä¸åœå˜å¤§ï¼Œä½†æ˜¯äº‹å®ä¸ŠçœŸçš„å¦‚æ­¤å—ï¼Ÿ

```console
[1, 2, 3, 0]
[1, 2, 3, 0, 1]
[1, 2, 3, 0, 1, 2]
```

è¾“å‡ºå¾ˆæ¸…æ™°çš„è¡¨æ˜ï¼Œåªæ–°æ’å…¥äº†ä¸‰ä¸ªå…ƒç´ ï¼š`0..=2`ï¼Œåˆšå¥½æ˜¯`v`çš„åˆå§‹é•¿åº¦ã€‚

è¿™æ˜¯å› ä¸ºï¼š**åœ¨ for å¾ªç¯ä¸­,`v.len`åªä¼šåœ¨å¾ªç¯ä¼Šå§‹ä¹‹æ—¶è¿›è¡Œæ±‚å€¼ï¼Œä¹‹åå°±ä¸€ç›´ä½¿ç”¨è¯¥å€¼**ã€‚

è¡Œï¼Œé—®é¢˜ç®—æ˜¯æ¸…æ¥šäº†ï¼Œé‚£è¯¥å¦‚ä½•è§£å†³å‘¢ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`while`å¾ªç¯ï¼Œè¯¥å¾ªç¯ä¸`for`ç›¸åï¼Œæ¯æ¬¡éƒ½ä¼šé‡æ–°æ±‚å€¼ï¼š

```rust
let mut v = vec![1,2,3];

let mut i = 0;
while i < v.len() {
    v.push(i);
    i+=1;
    println!("{:?}",v);
}
```

å‹æƒ…æç¤ºï¼Œåœ¨ä½ è¿è¡Œä¸Šè¿°ä»£ç æ—¶ï¼Œåƒä¸‡è¦åŠæ—¶åœæ­¢ï¼Œå¦åˆ™ä¼š`Boom` - ç‚¸ç¿»æ§åˆ¶å°ã€‚



================================================
FILE: src/compiler/pitfalls/utf8-performance.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/weird-ranges.md
================================================
# å¥‡æ€ªçš„åºåˆ—x..y

@todo

https://www.reddit.com/r/rust/comments/rrgxr0/a_critique_of_rusts_range_types/


================================================
FILE: src/difficulties/cow.md
================================================
# å†™æ—¶æ‹·è´Cow todo



================================================
FILE: src/difficulties/eq.md
================================================
# Eq å’Œ PartialEq
åœ¨ Rust ä¸­ï¼Œæƒ³è¦é‡è½½æ“ä½œç¬¦ï¼Œä½ å°±éœ€è¦å®ç°å¯¹åº”çš„ç‰¹å¾ã€‚

ä¾‹å¦‚ `<`ã€`<=`ã€`>` å’Œ `>=` éœ€è¦å®ç° `PartialOrd` ç‰¹å¾:
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

å†æ¯”å¦‚ï¼Œ `+` å·éœ€è¦å®ç° `std::ops::Add` ç‰¹å¾ï¼Œè€Œæœ¬æ–‡çš„ä¸»è§’ `Eq` å’Œ `PartialEq` æ­£æ˜¯ `==` å’Œ `!=` æ‰€éœ€çš„ç‰¹å¾ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè¿™ä¸¤ä¸ªç‰¹å¾æœ‰ä½•åŒºåˆ«ï¼Ÿ

æˆ‘ç›¸ä¿¡å¾ˆå¤šåŒå­¦éƒ½è¯´ä¸å¤ªæ¸…æ¥šï¼ŒåŒ…æ‹¬ä¸€äº›è€å¸æœºï¼Œè€Œä¸”å°±ç®—æ˜¯ç¿»æ–‡æ¡£ï¼Œå¯èƒ½ä¹Ÿæ‰¾ä¸åˆ°ç‰¹åˆ«æ˜ç¡®çš„è§£é‡Šã€‚å¦‚æœå¤§å®¶çœ‹è¿‡æ ‡å‡†åº“ç¤ºä¾‹ï¼Œå¯èƒ½ä¼šçœ‹è¿‡è¿™ä¸ªä¾‹å­ï¼š
```rust
enum BookFormat { Paperback, Hardback, Ebook }
struct Book {
    isbn: i32,
    format: BookFormat,
}
impl PartialEq for Book {
    fn eq(&self, other: &Self) -> bool {
        self.isbn == other.isbn
    }
}
impl Eq for Book {}
```

è¿™é‡Œåªå®ç°äº† `PartialEq`ï¼Œå¹¶æ²¡æœ‰å®ç° `Eq`ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨äº†é»˜è®¤å®ç° `impl Eq for Book {}`ï¼Œå¥‡äº†æ€ªäº†ï¼Œåˆ«æ€¥ï¼Œè¿˜æœ‰å‘¢ï¼š
```rust
impl PartialEq<IpAddr> for Ipv4Addr {
    #[inline]
    fn eq(&self, other: &IpAddr) -> bool {
        match other {
            IpAddr::V4(v4) => self == v4,
            IpAddr::V6(_) => false,
        }
    }
}

impl Eq for Ipv4Addr {}
```

ä»¥ä¸Šä»£ç æ¥è‡ª Rust æ ‡å‡†åº“ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œä¾ç„¶æ˜¯è¿™æ ·ä½¿ç”¨ï¼Œç±»ä¼¼çš„æƒ…å†µæ•°ä¸èƒœæ•°ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œæ˜¯å¦è¯´æ˜**å¦‚æœè¦ä¸ºæˆ‘ä»¬çš„ç±»å‹å¢åŠ ç›¸ç­‰æ€§æ¯”è¾ƒï¼Œåªè¦å®ç° `PartialEq` å³å¯ï¼Ÿ**

å…¶å®ï¼Œå…³é”®ç‚¹å°±åœ¨äº `partial` ä¸Šï¼Œ**å¦‚æœæˆ‘ä»¬çš„ç±»å‹åªåœ¨éƒ¨åˆ†æƒ…å†µä¸‹å…·æœ‰ç›¸ç­‰æ€§**ï¼Œé‚£ä½ å°±åªèƒ½å®ç° `PartialEq`ï¼Œå¦åˆ™å¯ä»¥å®ç° `PartialEq` ç„¶åå†é»˜è®¤å®ç° `Eq`ã€‚

å¥½çš„ï¼Œé—®é¢˜é€æ­¥æ¸…æ™°èµ·æ¥ï¼Œç°åœ¨æˆ‘ä»¬åªéœ€è¦ææ¸…æ¥šä½•ä¸ºéƒ¨åˆ†ç›¸ç­‰ã€‚

### éƒ¨åˆ†ç›¸ç­‰æ€§
é¦–å…ˆæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªç±»å‹ï¼Œå®ƒå®ç°äº† `PartialEq` ä½†æ˜¯æ²¡æœ‰å®ç° `Eq`ï¼ˆä½ å¯èƒ½ä¼šæƒ³æœ‰æ²¡æœ‰åè¿‡æ¥çš„æƒ…å†µï¼Ÿå½“ç„¶æ²¡æœ‰å•¦ï¼Œéƒ¨åˆ†ç›¸ç­‰è‚¯å®šæ˜¯å…¨éƒ¨ç›¸ç­‰çš„å­é›†ï¼ï¼‰

åœ¨ `HashMap` ç« èŠ‚æåˆ°è¿‡ `HashMap` çš„ key è¦æ±‚å®ç° `Eq` ç‰¹å¾ï¼Œä¹Ÿå°±æ˜¯è¦èƒ½å®Œå…¨ç›¸ç­‰ï¼Œè€Œæµ®ç‚¹æ•°ç”±äºæ²¡æœ‰å®ç° `Eq` ï¼Œå› æ­¤ä¸èƒ½ç”¨äº `HashMap` çš„ keyã€‚

å½“æ—¶ç”±äºä¸€äº›çŸ¥è¯†ç‚¹è¿˜æ²¡æœ‰ä»‹ç»ï¼Œå› æ­¤å°±æ²¡æœ‰è¿›ä¸€æ­¥å±•å¼€ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬è€ƒè™‘æµ®ç‚¹æ•°æ—¢ç„¶æ²¡æœ‰å®ç° `Eq` ä¸ºä½•è¿˜èƒ½è¿›è¡Œæ¯”è¾ƒå‘¢ï¼Ÿ
```rust
fn main() {
   let f1 = 3.14;
   let f2 = 3.14;

   if f1 == f2 {
       println!("hello, world!");
   }
}
```

ä»¥ä¸Šä»£ç æ˜¯å¯ä»¥çœ‹åˆ°è¾“å‡ºå†…å®¹çš„ï¼Œæ—¢ç„¶æµ®ç‚¹æ•°æ²¡æœ‰å®ç° `Eq` é‚£è¯´æ˜å®ƒå®ç°äº† `PartialEq`ï¼Œä¸€èµ·å†™ä¸ªç®€å•ä»£ç éªŒè¯ä¸‹ï¼š
```rust
fn main() {
    let f1 = 3.14;
    is_eq(f1);
    is_partial_eq(f1)
}

fn is_eq<T: Eq>(f: T) {}
fn is_partial_eq<T: PartialEq>(f: T) {}
```

ä¸Šé¢çš„ä»£ç é€šè¿‡ç‰¹å¾çº¦æŸçš„æ–¹å¼éªŒè¯äº†æˆ‘ä»¬çš„ç»“è®º: 
```shell
3 |     is_eq(f1);
  |     ----- ^^ the trait `Eq` is not implemented for `{float}`
```

å¥½çš„ï¼Œæ—¢ç„¶æˆ‘ä»¬æˆåŠŸæ‰¾åˆ°äº†ä¸€ä¸ªç±»å‹å®ç°äº† `PartialEq` ä½†æ²¡æœ‰å®ç° `Eq`ï¼Œé‚£å°±é€šè¿‡å®ƒæ¥çœ‹çœ‹ä½•ä¸ºéƒ¨åˆ†ç›¸ç­‰æ€§ã€‚

å…¶å®ç­”æ¡ˆå¾ˆç®€å•ï¼Œæµ®ç‚¹æ•°æœ‰ä¸€ä¸ªç‰¹æ®Šçš„å€¼ `NaN`ï¼Œå®ƒæ˜¯æ— æ³•è¿›è¡Œç›¸ç­‰æ€§æ¯”è¾ƒçš„:
```rust
fn main() {
    let f1 = f32::NAN;
    let f2 = f32::NAN;

    if f1 == f2 {
        println!("NaN ç«Ÿç„¶å¯ä»¥æ¯”è¾ƒï¼Œè¿™å¾ˆä¸æ•°å­¦å•Šï¼")
    } else {
        println!("æœç„¶ï¼Œè™½ç„¶ä¸¤ä¸ªéƒ½æ˜¯ NaN ï¼Œä½†æ˜¯å®ƒä»¬å…¶å®å¹¶ä¸ç›¸ç­‰")
    }
}
```

å¤§å®¶çŒœçŒœå“ªä¸€è¡Œä¼šè¾“å‡º :) è‡³äº `NaN` ä¸ºä½•ä¸èƒ½æ¯”è¾ƒï¼Œè¿™ä¸ªåŸå› å°±æ¯”è¾ƒå¤æ‚äº†( æœ‰è¯»è€…ä¼šè¯´ï¼Œå…¶å®å°±æ˜¯ä½ ä¸çŸ¥é“ï¼Œæˆ‘åªèƒ½ä¹‰æ­£ä¸¥è¾çš„è¯´ï¼šå’¦ï¼Ÿä½ æ€ä¹ˆçŸ¥é“ :P )ã€‚

æ—¢ç„¶æµ®ç‚¹æ•°æœ‰ä¸€ä¸ªå€¼ä¸å¯ä»¥æ¯”è¾ƒç›¸ç­‰æ€§ï¼Œé‚£å®ƒè‡ªç„¶åªèƒ½å®ç° `PartialEq` è€Œä¸èƒ½å®ç° `Eq` äº†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå¦‚æœæˆ‘ä»¬çš„ç±»å‹ä¹Ÿæœ‰è¿™ç§ç‰¹æ®Šè¦æ±‚ï¼Œé‚£ä¹Ÿåº”è¯¥è¿™ä¹ˆåšã€‚

### Ord å’Œ PartialOrd
äº‹å®ä¸Šï¼Œè¿˜æœ‰ä¸€å¯¹ä¸ `Eq/PartialEq` éå¸¸ç±»ä¼¼çš„ç‰¹å¾ï¼Œå®ƒä»¬å¯ä»¥ç”¨äº `<`ã€`<=`ã€`>` å’Œ `>=` æ¯”è¾ƒï¼Œè‡³äºå“ªä¸ªç±»å‹å®ç°äº† `PartialOrd` å´æ²¡æœ‰å®ç° `Ord` å°±äº¤ç»™å¤§å®¶è‡ªå·±æ¥æ€è€ƒäº†ï¼šï¼‰


> å°æç¤ºï¼šOrd æ„å‘³ç€ä¸€ä¸ªç±»å‹çš„æ‰€æœ‰å€¼éƒ½å¯ä»¥è¿›è¡Œæ’åºï¼Œè€Œ PartialOrd åˆ™ä¸ç„¶



================================================
FILE: src/difficulties/intro.md
================================================
# Rust éš¾ç‚¹æ”»å…³

å½“å¤§å®¶ä¸€è·¯çœ‹åˆ°è¿™é‡Œæ—¶ï¼Œæˆ‘æ•¢è¯´ 90% çš„äººè¿˜æ˜¯äº‘é‡Œé›¾é‡Œçš„ï¼Œä¾‹å¦‚ä½ èƒ½è¯´æ¸…æ¥š:

- åˆ‡ç‰‡å’Œåˆ‡ç‰‡å¼•ç”¨çš„åŒºåˆ«å—ï¼Ÿ
- å„ç§å­—ç¬¦ä¸²ä¹‹é—´çš„åŒºåˆ«å—ï¼Ÿ
- å„ç§æŒ‡é’ˆã€å¼•ç”¨çš„åŒºåˆ«å—ï¼Ÿ
- æ‰€æœ‰æƒè½¬ç§»ã€æ‹·è´ã€å…‹éš†çš„åŒºåˆ«å—ï¼Ÿ

ä»¥åŠåˆ°åº•è¯¥ç”¨å®ƒä»¬ä¹‹ä¸­å“ªä¸€ä¸ªå—ï¼Ÿ

å¦‚æœä¸è¡Œï¼Œå°±è·Ÿéšæˆ‘ä¸€èµ·æ¥çœ‹çœ‹å§ï¼Œæœ¬ç« çš„ç›®æ ‡å°±æ˜¯å¸®å¤§å®¶å½»åº•ç†æ¸…è¿™äº›æ¦‚å¿µï¼Œä¸ºåé¢çš„è¿›ä¸€æ­¥å­¦ä¹ å’Œå®æˆ˜æ‰“å¥½åšå®çš„åŸºç¡€ã€‚





================================================
FILE: src/difficulties/lifetime.md
================================================
# ä½œç”¨åŸŸã€ç”Ÿå‘½å‘¨æœŸå’Œ NLL todo



================================================
FILE: src/difficulties/move-copy.md
================================================
# moveã€Copyå’ŒClone todo



================================================
FILE: src/difficulties/pointer.md
================================================
# è£¸æŒ‡é’ˆã€å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆ todo

<!-- https://blog.csdn.net/kk3909/article/details/106743025 -->


================================================
FILE: src/difficulties/slice.md
================================================
# åˆ‡ç‰‡å’Œåˆ‡ç‰‡å¼•ç”¨

å…³äº `str` / `&str`ï¼Œ`[u8]` / `&[u8]` åŒºåˆ«ï¼Œä½ èƒ½æ¸…æ™°çš„è¯´å‡ºæ¥å˜›ï¼Ÿå¦‚æœç­”æ¡ˆæ˜¯ No ï¼Œé‚£å°±è·Ÿéšæˆ‘ä¸€èµ·æ¥çœ‹çœ‹åˆ‡ç‰‡å’Œåˆ‡ç‰‡å¼•ç”¨åˆ°åº•æœ‰ä½•åŒºåˆ«å§ã€‚

> åœ¨ç»§ç»­ä¹‹å‰ï¼ŒæŸ¥çœ‹[è¿™é‡Œ](https://course.rs/basic/compound-type/string-slice.html#åˆ‡ç‰‡slice)äº†è§£ä½•ä¸ºåˆ‡ç‰‡

åˆ‡ç‰‡å…è®¸æˆ‘ä»¬å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²åˆ‡ç‰‡å°±æ˜¯ä¸€ä¸ªå­å­—ç¬¦ä¸²ï¼Œæ•°ç»„åˆ‡ç‰‡å°±æ˜¯ä¸€ä¸ªå­æ•°ç»„ã€‚

## æ— æ³•è¢«ç›´æ¥ä½¿ç”¨çš„åˆ‡ç‰‡ç±»å‹

Rust è¯­è¨€ç‰¹æ€§å†…ç½®çš„ `str` å’Œ `[u8]` ç±»å‹éƒ½æ˜¯åˆ‡ç‰‡ï¼Œå‰è€…æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œåè€…æ˜¯æ•°ç»„åˆ‡ç‰‡ï¼Œä¸‹é¢æˆ‘ä»¬æ¥å°è¯•ä¸‹ä½¿ç”¨ `str` ï¼š

```rust
let string: str = "banana";
```

ä¸Šé¢ä»£ç åˆ›å»ºä¸€ä¸ª `str` ç±»å‹çš„å­—ç¬¦ä¸²ï¼Œçœ‹èµ·æ¥å¾ˆæ­£å¸¸ï¼Œä½†æ˜¯ç¼–è¯‘å°±ä¼šæŠ¥é”™ï¼š

```shell
error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> src/main.rs:4:9
  |
4 |     let string: str = "banana";
  |         ^^^^^^ doesn't have a size known at compile-time
```

ç¼–è¯‘å™¨å‡†ç¡®çš„å‘Šè¯‰äº†æˆ‘ä»¬åŸå› ï¼š`str` å­—ç¬¦ä¸²åˆ‡ç‰‡å®ƒæ˜¯ [`DST` åŠ¨æ€å¤§å°ç±»å‹](https://course.rs/advance/into-types/sized.html#åŠ¨æ€å¤§å°ç±»å‹-dst)ï¼Œè¿™æ„å‘³ç€ç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸçŸ¥é“ `str` ç±»å‹çš„å¤§å°ï¼Œåªæœ‰åˆ°äº†è¿è¡ŒæœŸæ‰èƒ½åŠ¨æ€è·çŸ¥ï¼Œè¿™å¯¹äºå¼ºç±»å‹ã€å¼ºå®‰å…¨çš„ Rust è¯­è¨€æ¥è¯´æ˜¯ä¸å¯æ¥å—çš„ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥ä½¿ç”¨ `str`ï¼Œè€Œå¯¹äº `[u8]` ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±åŠ¨æ‰‹è¯•è¯•ã€‚

æ€»ä¹‹ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºä¸€ä¸ªç»“è®ºï¼š**åœ¨ Rust ä¸­ï¼Œæ‰€æœ‰çš„åˆ‡ç‰‡éƒ½æ˜¯åŠ¨æ€å¤§å°ç±»å‹ï¼Œå®ƒä»¬éƒ½æ— æ³•ç›´æ¥è¢«ä½¿ç”¨**ã€‚

#### ä¸ºä½•åˆ‡ç‰‡æ˜¯åŠ¨æ€å¤§å°ç±»å‹

åŸå› åœ¨äºåº•å±‚çš„åˆ‡ç‰‡é•¿åº¦æ˜¯å¯ä»¥åŠ¨æ€å˜åŒ–çš„ï¼Œè€Œç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸå¾—çŸ¥å®ƒçš„å…·ä½“çš„é•¿åº¦ï¼Œå› æ­¤è¯¥ç±»å‹æ— æ³•è¢«åˆ†é…åœ¨æ ˆä¸Šï¼Œåªèƒ½åˆ†é…åœ¨å †ä¸Šã€‚

#### ä¸ºä½•åˆ‡ç‰‡åªèƒ½é€šè¿‡å¼•ç”¨æ¥ä½¿ç”¨

æ—¢ç„¶åˆ‡ç‰‡åªèƒ½åˆ†é…åˆ°å †ä¸Šï¼Œæˆ‘ä»¬å°±æ— æ³•ç›´æ¥ä½¿ç”¨å®ƒï¼Œå¤§å®¶å¯ä»¥æƒ³æƒ³ï¼Œæ‰€æœ‰åˆ†é…åœ¨å †ä¸Šçš„æ•°æ®ï¼Œæ˜¯ä¸æ˜¯éƒ½æ˜¯é€šè¿‡ä¸€ä¸ªåœ¨æ ˆä¸Šçš„å¼•ç”¨æ¥è®¿é—®çš„ï¼Ÿåˆ‡ç‰‡ä¹Ÿä¸ä¾‹å¤–ã€‚

#### ä¸ºä½•åˆ‡ç‰‡å¼•ç”¨å¯ä»¥å­˜å‚¨åœ¨æ ˆä¸Š

åˆ‡ç‰‡å¼•ç”¨æ˜¯ä¸€ä¸ªå®½æŒ‡é’ˆï¼Œå­˜å‚¨åœ¨æ ˆä¸Šï¼ŒæŒ‡å‘äº†å †ä¸Šçš„åˆ‡ç‰‡æ•°æ®ï¼Œè¯¥å¼•ç”¨åŒ…å«äº†åˆ‡ç‰‡çš„èµ·å§‹ä½ç½®å’Œé•¿åº¦ï¼Œè€Œä¸”æœ€é‡è¦çš„æ˜¯ï¼Œç±»ä¼¼äºæŒ‡é’ˆï¼Œå¼•ç”¨çš„å¤§å°æ˜¯å›ºå®šçš„(èµ·å§‹ä½ç½®å’Œé•¿åº¦éƒ½æ˜¯æ•´å½¢)ï¼Œå› æ­¤å®ƒæ‰å¯ä»¥å­˜å‚¨åœ¨æ ˆä¸Šã€‚

#### æœ‰æ²¡æœ‰å¯ä»¥å­˜å‚¨åœ¨æ ˆä¸Šçš„

æœ‰ï¼Œä½¿ç”¨å›ºå®šé•¿åº¦çš„æ•°ç»„: `let a: [i8;4] = [1,2,3,4];`ï¼Œæ³¨æ„çœ‹ï¼Œæ•°ç»„çš„ç±»å‹ä¸åˆ‡ç‰‡æ˜¯ä¸åŒçš„ï¼Œå‰è€…çš„ç±»å‹å¸¦æœ‰é•¿åº¦ï¼š`[i8;4]`ï¼Œè€Œåè€…ä»…ä»…æ˜¯ `[i8]`ã€‚

## åˆ‡ç‰‡å¼•ç”¨

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè¯¥å¦‚ä½•ä½¿ç”¨åˆ‡ç‰‡å‘¢ï¼Ÿ

ä½•ä»¥è§£å¿§ï¼Œå”¯æœ‰å¼•ç”¨ã€‚ç”±äºå¼•ç”¨ç±»å‹çš„å¤§å°åœ¨ç¼–è¯‘æœŸæ˜¯å·²çŸ¥çš„ï¼Œå› æ­¤åœ¨ Rust ä¸­ï¼Œå¦‚æœè¦ä½¿ç”¨åˆ‡ç‰‡ï¼Œå°±å¿…é¡»è¦ä½¿ç”¨å®ƒçš„å¼•ç”¨ã€‚

`str` åˆ‡ç‰‡çš„å¼•ç”¨ç±»å‹æ˜¯ `&str`ï¼Œè€Œ `[i32]` çš„å¼•ç”¨ç±»å‹æ˜¯ `&[i32]`ï¼Œç›¸ä¿¡èªæ˜çš„è¯»è€…å·²ç»çœ‹å‡ºæ¥äº†ï¼Œ`&str` å’Œ `&[i32]` éƒ½æ˜¯æˆ‘ä»¬éå¸¸å¸¸ç”¨çš„ç±»å‹ï¼Œä¾‹å¦‚:

```rust
let s1: &str = "banana";
let s2: &str = &String::from("banana");

let arr = [1, 2, 3, 4, 5];

let s3: &[i32] = &arr[1..3];
```

è¿™æ®µä»£ç å°±å¯ä»¥æ­£å¸¸é€šè¿‡ï¼ŒåŸå› åœ¨äºè¿™äº›åˆ‡ç‰‡å¼•ç”¨çš„å¤§å°åœ¨ç¼–è¯‘å™¨éƒ½æ˜¯å·²çŸ¥çš„ã€‚

## æ€»ç»“

æˆ‘ä»¬å¸¸å¸¸è¯´ä½¿ç”¨åˆ‡ç‰‡ï¼Œå®é™…ä¸Šæˆ‘ä»¬åœ¨ç”¨çš„æ˜¯åˆ‡ç‰‡çš„å¼•ç”¨ï¼Œæˆ‘ä»¬ä¹Ÿåœ¨é¢‘ç¹è¯´ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œå®é™…ä¸Šæˆ‘ä»¬åœ¨ä½¿ç”¨çš„ä¹Ÿæ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨ã€‚

æ€»ä¹‹ï¼Œåˆ‡ç‰‡åœ¨ Rust ä¸­æ˜¯åŠ¨æ€å¤§å°ç±»å‹ DSTï¼Œæ˜¯æ— æ³•è¢«æˆ‘ä»¬ç›´æ¥ä½¿ç”¨çš„ï¼Œè€Œæˆ‘ä»¬åœ¨ä½¿ç”¨çš„éƒ½æ˜¯åˆ‡ç‰‡çš„å¼•ç”¨ã€‚

| åˆ‡ç‰‡           | åˆ‡ç‰‡å¼•ç”¨              |
| -------------- | --------------------- |
| str å­—ç¬¦ä¸²åˆ‡ç‰‡ | &str å­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨ |
| [u8] æ•°ç»„åˆ‡ç‰‡  | &[u8] æ•°ç»„åˆ‡ç‰‡çš„å¼•ç”¨  |

**ä½†æ˜¯å‡ºäºæ–¹ä¾¿ï¼Œæˆ‘ä»¬å¾€å¾€ä¸ä¼šè¯´ä½¿ç”¨åˆ‡ç‰‡å¼•ç”¨ï¼Œè€Œæ˜¯ç›´æ¥è¯´ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡æˆ–æ•°ç»„åˆ‡ç‰‡ï¼Œå®é™…ä¸Šï¼Œè¿™æ—¶æŒ‡ä»£çš„éƒ½æ˜¯åˆ‡ç‰‡çš„å¼•ç”¨ï¼**




================================================
FILE: src/difficulties/string.md
================================================
[Binary file]


================================================
FILE: src/first-try/cargo.md
================================================
[Binary file]


================================================
FILE: src/first-try/editor.md
================================================
[Binary file]


================================================
FILE: src/first-try/hello-world.md
================================================
# ä¸ä»…ä»…æ˜¯ Hello world

å‡ ä¹æ‰€æœ‰æ•™ç¨‹ä¸­å®‰è£…çš„æœ€åä¸€ä¸ªç¯èŠ‚éƒ½æ˜¯ `hello world`ï¼Œæˆ‘ä»¬ä¹Ÿä¸èƒ½å…ä¿—ã€‚ä½†æ˜¯ï¼Œåœ¨ `hello world` ä¹‹åï¼Œè¿˜æœ‰ä¸€ä¸ªç›¸äº²ï¼Œå•Šå‘¸ï¼ŒRust åˆå°è±¡ç¯èŠ‚ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢ã€‚

## å¤šå›½è¯­è¨€çš„"ä¸–ç•Œï¼Œä½ å¥½"

è¿˜è®°å¾—å¤§æ˜æ¹–ç•”ç­‰ä½ çš„ [VSCode IDE](https://course.rs/first-try/editor.html) å’Œé€šè¿‡ `Cargo` åˆ›å»ºçš„ [ä¸–ç•Œï¼Œä½ å¥½](https://course.rs/first-try/cargo.html) å·¥ç¨‹å—ï¼Ÿ

ç°åœ¨ä½¿ç”¨ VSCode æ‰“å¼€ [ä¸Šä¸€èŠ‚](https://course.rs/first-try/cargo.html) ä¸­åˆ›å»ºçš„ `world_hello` å·¥ç¨‹ï¼Œç„¶åè¿›å…¥ `main.rs` æ–‡ä»¶ã€‚ï¼ˆæ­¤æ–‡ä»¶æ˜¯å½“å‰ Rust å·¥ç¨‹çš„å…¥å£æ–‡ä»¶ï¼Œå’Œå…¶å®ƒè¯­è¨€å‡ æ— åŒºåˆ«ã€‚ï¼‰

æ¥ä¸‹æ¥ï¼Œå¯¹ä¸–ç•Œå‹äººç»™äºˆçƒ­åˆ‡çš„é—®å€™ï¼š

```rust
fn greet_world() {
    let southern_germany = "GrÃ¼ÃŸ Gott!";
    let chinese = "ä¸–ç•Œï¼Œä½ å¥½";
    let english = "World, hello";
    let regions = [southern_germany, chinese, english];
    for region in regions.iter() {
        println!("{}", &region);
    }
}

fn main() {
    greet_world();
}
```

æ‰“å¼€ç»ˆç«¯ï¼Œè¿›å…¥ `world_hello` å·¥ç¨‹æ ¹ç›®å½•ï¼Œè¿è¡Œè¯¥ç¨‹åºã€‚ï¼ˆä½ ä¹Ÿå¯ä»¥åœ¨ VSCode ä¸­æ‰“å¼€ç»ˆç«¯ï¼Œæ–¹æ³•æ˜¯ç‚¹å‡» VSCode ä¸Šæ–¹èœå•æ ä¸­çš„ç»ˆç«¯->æ–°å»ºç»ˆç«¯ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨å¿«æ·é”®æ‰“å¼€ã€‚ï¼‰

```console
$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
     Running `target/debug/world_hello`
GrÃ¼ÃŸ Gott!
ä¸–ç•Œï¼Œä½ å¥½
World, hello
```

ä½ çš„çƒ­æƒ…ï¼Œå°±åƒä¸€æŠŠç«ï¼Œç‡ƒçƒ§äº†æ•´ä¸ªä¸–ç•Œ~ èŠ±ç‚¹æ—¶é—´æ¥çœ‹çœ‹ä¸Šé¢çš„ä»£ç ï¼š

é¦–å…ˆï¼ŒRust åŸç”Ÿæ”¯æŒ UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥å¾ˆå®¹æ˜“çš„ä½¿ç”¨ä¸–ç•Œå„å›½æ–‡å­—ä½œä¸ºå­—ç¬¦ä¸²å†…å®¹ã€‚

å…¶æ¬¡ï¼Œå…³æ³¨ä¸‹ `println` åé¢çš„ `!`ï¼Œå¦‚æœä½ æœ‰ Ruby ç¼–ç¨‹ç»éªŒï¼Œé‚£ä¹ˆä½ å¯èƒ½ä¼šè®¤ä¸ºè¿™æ˜¯è§£æ„æ“ä½œç¬¦ï¼Œä½†æ˜¯åœ¨ Rust ä¸­ï¼Œè¿™æ˜¯ `å®` æ“ä½œç¬¦ï¼Œä½ ç›®å‰å¯ä»¥è®¤ä¸ºå®æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹å‡½æ•°ã€‚

å¯¹äº `println` æ¥è¯´ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨å…¶å®ƒè¯­è¨€æƒ¯ç”¨çš„ `%s`ã€`%d` æ¥åšè¾“å‡ºå ä½ç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ `{}`ï¼Œå› ä¸º Rust åœ¨åº•å±‚å¸®æˆ‘ä»¬åšäº†å¤§é‡å·¥ä½œï¼Œä¼šè‡ªåŠ¨è¯†åˆ«è¾“å‡ºæ•°æ®çš„ç±»å‹ï¼Œä¾‹å¦‚å½“å‰ä¾‹å­ï¼Œä¼šè¯†åˆ«ä¸º `String` ç±»å‹ã€‚

æœ€åï¼Œå’Œå…¶å®ƒè¯­è¨€ä¸åŒï¼ŒRust çš„é›†åˆç±»å‹ä¸èƒ½ç›´æ¥è¿›è¡Œå¾ªç¯ï¼Œéœ€è¦å˜æˆè¿­ä»£å™¨ï¼ˆè¿™é‡Œæ˜¯é€šè¿‡ `.iter()` æ–¹æ³•ï¼‰ï¼Œæ‰èƒ½ç”¨äºè¿­ä»£å¾ªç¯ã€‚åœ¨ç›®å‰æ¥çœ‹ï¼Œä½ ä¼šè§‰å¾—è¿™ä¸€ç‚¹å¥½åƒæŒºéº»çƒ¦ï¼Œä¸æ€¥ï¼Œä»¥åå°±çŸ¥é“è¿™ä¹ˆåšçš„å¥½å¤„æ‰€åœ¨ã€‚

> å®é™…ä¸Šè¿™æ®µä»£ç å¯ä»¥ç®€å†™ï¼Œåœ¨ 2021 edition åŠä»¥åï¼Œæ”¯æŒç›´æ¥å†™ `for region in regions`ï¼ŒåŸå› ä¼šåœ¨è¿­ä»£å™¨ç« èŠ‚çš„å¼€å¤´æåˆ°ï¼Œæ˜¯å› ä¸º for éšå¼åœ°å°† regions è½¬æ¢æˆè¿­ä»£å™¨ã€‚

è‡³äºå‡½æ•°å£°æ˜ã€è°ƒç”¨ã€æ•°ç»„çš„ä½¿ç”¨ï¼Œå’Œå…¶å®ƒè¯­è¨€æ²¡ä»€ä¹ˆåŒºåˆ«ï¼ŒSo Easyï¼

## Rust è¯­è¨€åˆå°è±¡

Haskell å’Œ Java å¼€å‘è€…ä»¬å¯èƒ½ä¼šè§‰å¾—Rust è¿™é—¨è¯­è¨€å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒä»¬åœ¨é«˜é˜¶è¡¨è¾¾æ–¹é¢éƒ½å¾ˆä¼˜ç§€ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå°±æ˜¯å¯ä»¥å¾ˆç®€æ´çš„å†™å‡ºåŸæœ¬éœ€è¦ä¸€å¤§å †ä»£ç æ‰èƒ½è¡¨è¾¾çš„å«ä¹‰ã€‚ä½†æ˜¯ï¼ŒRust åˆæœ‰æ‰€ä¸åŒï¼šå®ƒçš„æ€§èƒ½æ˜¯åº•å±‚è¯­è¨€çº§åˆ«çš„æ€§èƒ½ï¼Œå¯ä»¥è·Ÿ C/C++ ç›¸åª²ç¾ã€‚

ä¸Šé¢çš„ `So Easy` çš„ä½™éŸ³ä»åœ¨ç»•æ¢ï¼Œæˆ‘å¸Œæœ›å®ƒèƒ½ç»§ç»­ä¸‹å»ï¼Œå¯æ˜¯â€¦ äººæ€»æ˜¯è¦é¢å¯¹ç°å®ï¼Œå› æ­¤è®©æˆ‘ä»¬æ¥ç‚¹ç‹ æ´»ï¼š

```rust
fn main() {
   let penguin_data = "\
   common name,length (cm)
   Little penguin,33
   Yellow-eyed penguin,65
   Fiordland penguin,60
   Invalid,data
   ";

   let records = penguin_data.lines();

   for (i, record) in records.enumerate() {
     if i == 0 || record.trim().len() == 0 {
       continue;
     }

     // å£°æ˜ä¸€ä¸ª fields å˜é‡ï¼Œç±»å‹æ˜¯ Vec
     // Vec æ˜¯ vector çš„ç¼©å†™ï¼Œæ˜¯ä¸€ä¸ªå¯ä¼¸ç¼©çš„é›†åˆç±»å‹ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªåŠ¨æ€æ•°ç»„
     // <_>è¡¨ç¤º Vec ä¸­çš„å…ƒç´ ç±»å‹ç”±ç¼–è¯‘å™¨è‡ªè¡Œæ¨æ–­ï¼Œåœ¨å¾ˆå¤šåœºæ™¯ä¸‹ï¼Œéƒ½ä¼šå¸®æˆ‘ä»¬çœå´ä¸å°‘åŠŸå¤«
     let fields: Vec<_> = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡º
       eprintln!("debug: {:?} -> {:?}",
              record, fields);
     }

     let name = fields[0];
     // 1. å°è¯•æŠŠ fields[1] çš„å€¼è½¬æ¢ä¸º f32 ç±»å‹çš„æµ®ç‚¹æ•°ï¼Œå¦‚æœæˆåŠŸï¼Œåˆ™æŠŠ f32 å€¼èµ‹ç»™ length å˜é‡
     //
     // 2. if let æ˜¯ä¸€ä¸ªåŒ¹é…è¡¨è¾¾å¼ï¼Œç”¨æ¥ä»=å³è¾¹çš„ç»“æœä¸­ï¼ŒåŒ¹é…å‡º length çš„å€¼ï¼š
     //   1ï¼‰å½“=å³è¾¹çš„è¡¨è¾¾å¼æ‰§è¡ŒæˆåŠŸï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ª Ok(f32) çš„ç±»å‹ï¼Œè‹¥å¤±è´¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ª Err(e) ç±»å‹ï¼Œif let çš„ä½œç”¨å°±æ˜¯ä»…åŒ¹é… Ok ä¹Ÿå°±æ˜¯æˆåŠŸçš„æƒ…å†µï¼Œå¦‚æœæ˜¯é”™è¯¯ï¼Œå°±ç›´æ¥å¿½ç•¥
     //   2ï¼‰åŒæ—¶ if let è¿˜ä¼šåšä¸€æ¬¡è§£æ„åŒ¹é…ï¼Œé€šè¿‡ Ok(length) å»åŒ¹é…å³è¾¹çš„ Ok(f32)ï¼Œæœ€ç»ˆæŠŠç›¸åº”çš„ f32 å€¼èµ‹ç»™ length
     //
     // 3. å½“ç„¶ä½ ä¹Ÿå¯ä»¥å¿½ç•¥æˆåŠŸçš„æƒ…å†µï¼Œç”¨ if let Err(e) = fields[1].parse::<f32>() {...}åŒ¹é…å‡ºé”™è¯¯ï¼Œç„¶åæ‰“å°å‡ºæ¥ï¼Œä½†æ˜¯æ²¡å•¥åµç”¨
     if let Ok(length) = fields[1].parse::<f32>() {
         // è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º
         println!("{}, {}cm", name, length);
     }
   }
 }
```

çœ‹å®Œè¿™æ®µä»£ç ï¼Œä¸çŸ¥é“ä½ çš„ä½™éŸ³æœ‰æ²¡æœ‰æˆ›ç„¶è€Œæ­¢ï¼Œåæ­£æˆ‘å·²ç»åœ¨é¢¤æŠ–äº†ã€‚è¿™å°±æ˜¯ä¼ è¯´ä¸­çš„ä¸‹é©¬å¨å—ï¼ŸğŸ˜µ

ä¸Šé¢ä»£ç ä¸­ï¼Œå€¼å¾—æ³¨æ„çš„ Rust ç‰¹æ€§æœ‰ï¼š

- æ§åˆ¶æµï¼š`for` å’Œ `continue` è¿åœ¨ä¸€èµ·ä½¿ç”¨ï¼Œå®ç°å¾ªç¯æ§åˆ¶ã€‚
- æ–¹æ³•è¯­æ³•ï¼šç”±äº Rust æ²¡æœ‰ç»§æ‰¿ï¼Œå› æ­¤ Rust ä¸æ˜¯ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„é¢å‘å¯¹è±¡è¯­è¨€ï¼Œä½†æ˜¯å®ƒå´ä» `OO` è¯­è¨€é‚£é‡Œå·å¸ˆäº†æ–¹æ³•çš„ä½¿ç”¨ `record.trim()`ï¼Œ`record.split(',')` ç­‰ã€‚
- é«˜é˜¶å‡½æ•°ç¼–ç¨‹ï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¹Ÿèƒ½ä½œä¸ºè¿”å›å€¼ï¼Œä¾‹å¦‚ `.map(|field| field.trim())`ï¼Œè¿™é‡Œ `map` æ–¹æ³•ä¸­ä½¿ç”¨é—­åŒ…å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œä¹Ÿå¯ä»¥ç§°å‘¼ä¸º `åŒ¿åå‡½æ•°`ã€`lambda å‡½æ•°`ã€‚
- ç±»å‹æ ‡æ³¨ï¼š`if let Ok(length) = fields[1].parse::<f32>()`ï¼Œé€šè¿‡ `::<f32>` çš„ä½¿ç”¨ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨ `length` æ˜¯ä¸€ä¸ª `f32` ç±»å‹çš„æµ®ç‚¹æ•°ã€‚è¿™ç§ç±»å‹æ ‡æ³¨ä¸æ˜¯å¾ˆå¸¸ç”¨ï¼Œä½†æ˜¯åœ¨ç¼–è¯‘å™¨æ— æ³•æ¨æ–­å‡ºä½ çš„æ•°æ®ç±»å‹æ—¶ï¼Œå°±å¾ˆæœ‰ç”¨äº†ã€‚
- æ¡ä»¶ç¼–è¯‘ï¼š`if cfg!(debug_assertions)`ï¼Œè¯´æ˜ç´§è·Ÿå…¶åçš„è¾“å‡ºï¼ˆæ‰“å°ï¼‰åªåœ¨ `debug` æ¨¡å¼ä¸‹ç”Ÿæ•ˆã€‚
- éšå¼è¿”å›ï¼šRust æä¾›äº† `return` å…³é”®å­—ç”¨äºå‡½æ•°è¿”å›ï¼Œä½†æ˜¯åœ¨å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥çœç•¥å®ƒã€‚å› ä¸º Rust æ˜¯ [**åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€**](https://course.rs/basic/base-type/statement-expression.html)ã€‚

åœ¨ç»ˆç«¯ä¸­è¿è¡Œä¸Šè¿°ä»£ç æ—¶ï¼Œä¼šçœ‹åˆ°å¾ˆå¤š `debug: ...` çš„è¾“å‡ºï¼Œä¸Šé¢æœ‰è®²ï¼Œè¿™äº›éƒ½æ˜¯ `æ¡ä»¶ç¼–è¯‘` çš„è¾“å‡ºï¼Œé‚£ä¹ˆè¯¥æ€ä¹ˆæ¶ˆé™¤æ‰è¿™äº›è¾“å‡ºå‘¢ï¼Ÿ

è¯»è€…å¤§å¤§æ™®éå†°é›ªèªæ˜ï¼Œè‚¯å®šå·²ç»æƒ³åˆ°ï¼šæ˜¯çš„ï¼Œåœ¨ [è®¤è¯† Cargo](https://course.rs/first-try/cargo.html#æ‰‹åŠ¨ç¼–è¯‘å’Œè¿è¡Œé¡¹ç›®) ä¸­ï¼Œæ›¾ç»ä»‹ç»è¿‡ `--release` å‚æ•°ï¼Œå› ä¸º `cargo run` é»˜è®¤æ˜¯è¿è¡Œ `debug` æ¨¡å¼ã€‚å› æ­¤æƒ³è¦æ¶ˆç­é‚£äº› `debug:` è¾“å‡ºï¼Œéœ€è¦æ›´æ”¹ä¸ºå…¶å®ƒæ¨¡å¼ï¼Œå…¶ä¸­æœ€å¸¸ç”¨çš„æ¨¡å¼å°±æ˜¯ `--release` ä¹Ÿå°±æ˜¯ç”Ÿäº§å‘å¸ƒçš„æ¨¡å¼ã€‚

å…·ä½“è¿è¡Œä»£ç å°±ä¸ç»™äº†ï¼Œç•™ç»™å¤§å®¶ä½œä¸ºä¸€ä¸ªå°ç»ƒä¹ ï¼Œå»ºè®®äº²è‡ªåŠ¨æ‰‹å°è¯•ä¸‹ã€‚

è‡³æ­¤ï¼ŒRust å®‰è£…å…¥é—¨å°±å·²ç»ç»“æŸã€‚ç›¸ä¿¡çœ‹åˆ°è¿™é‡Œï¼Œä½ å·²ç»å‘ç°äº†æœ¬ä¹¦ä¸å…¶å®ƒä¹¦çš„åŒºåˆ«ï¼Œå…¶ä¸­æœ€å¤§çš„åŒºåˆ«å°±æ˜¯ï¼š**è¿™æœ¬ä¹¦å°±åƒä¼˜ç§€çš„å›½å¤–è¯¾æœ¬ä¸€æ ·ï¼Œä¸å¤ªæ¯ç‡¥ã€‚ä¹Ÿå¸Œæœ›è¿™æœ¬ä¸å¤ªæ¯ç‡¥çš„ä¹¦ï¼Œèƒ½ä¼´ä½ é•¿è¡Œï¼ŒçŠ¹å¦‚ä¸€æ¯å¥¶èŒ¶ï¼Œç»†ç»†å“ä¹‹ï¼Œå”‡é½¿ç•™é¦™ã€‚**



================================================
FILE: src/first-try/installation.md
================================================
# å®‰è£… Rust

`rustup` æ˜¯ Rust çš„å®‰è£…ç¨‹åºï¼Œä¹Ÿæ˜¯å®ƒçš„ç‰ˆæœ¬ç®¡ç†ç¨‹åºã€‚
å¼ºçƒˆå»ºè®®ä½¿ç”¨ `rustup` æ¥å®‰è£… Rustï¼Œå½“ç„¶å¦‚æœä½ æœ‰å¼‚å¿ƒï¼Œè¯·å¯»æ‰¾å…¶å®ƒå®‰è£…æ–¹å¼ï¼Œç„¶åå†ä»ä¸‹ä¸€èŠ‚å¼€å§‹é˜…è¯»ã€‚

> hahaï¼Œå¼€ä¸ªç©ç¬‘ã€‚è¯»è€…ä¹ƒå¤§å¤§ï¼Œæ€ä¹ˆèƒ½å¼ƒä¹‹ä¸é¡¾ã€‚
>
> æ³¨æ„ï¼šå¦‚æœä½ ä¸æƒ³ç”¨æˆ–è€…ä¸èƒ½ç”¨ rustupï¼Œè¯·å‚è§ [Rust å…¶å®ƒå®‰è£…æ–¹æ³•](https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods)ã€‚

è‡³äºç‰ˆæœ¬ï¼Œç°åœ¨ Rust ç¨³å®šç‰ˆç‰¹æ€§è¶Šæ¥è¶Šå…¨äº†ï¼Œå› æ­¤ä¸‹è½½æœ€æ–°ç¨³å®šç‰ˆæœ¬å³å¯ã€‚ç”±äºä½ ç”¨çš„ Rust ç‰ˆæœ¬å¯èƒ½è·Ÿæœ¬ä¹¦å†™ä½œæ—¶ä¸ä¸€æ ·ï¼Œä¸€äº›ç¼–è¯‘é”™è¯¯å’Œè­¦å‘Šå¯èƒ½ä¹Ÿä¼šæœ‰æ‰€ä¸åŒã€‚

## åœ¨ Linux æˆ– macOS ä¸Šå®‰è£… `rustup`

æ‰“å¼€ç»ˆç«¯å¹¶è¾“å…¥ä¸‹é¢å‘½ä»¤ï¼š

```console
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

è¿™ä¸ªå‘½ä»¤å°†ä¸‹è½½ä¸€ä¸ªè„šæœ¬å¹¶å¼€å§‹å®‰è£… `rustup` å·¥å…·ï¼Œæ­¤å·¥å…·å°†å®‰è£… Rust çš„æœ€æ–°ç¨³å®šç‰ˆæœ¬ã€‚å¯èƒ½ä¼šæç¤ºä½ è¾“å…¥ç®¡ç†å‘˜å¯†ç ã€‚

å¦‚æœå®‰è£…æˆåŠŸï¼Œå°†å‡ºç°ä¸‹é¢è¿™è¡Œï¼š

```text
Rust is installed now. Great!
```

OKï¼Œè¿™æ ·å°±å·²ç»å®Œæˆ Rust å®‰è£…å•¦ã€‚

### å®‰è£… C è¯­è¨€ç¼–è¯‘å™¨ï¼šï¼ˆéå¿…éœ€ï¼‰

Rust å¯¹è¿è¡Œç¯å¢ƒçš„ä¾èµ–å’Œ Go è¯­è¨€å¾ˆåƒï¼Œå‡ ä¹æ‰€æœ‰ç¯å¢ƒéƒ½å¯ä»¥æ— éœ€å®‰è£…ä»»ä½•ä¾èµ–ç›´æ¥è¿è¡Œã€‚ä½†æ˜¯ï¼ŒRust ä¼šä¾èµ– `libc` å’Œé“¾æ¥å™¨ `linker`ã€‚æ‰€ä»¥å¦‚æœé‡åˆ°äº†æç¤ºé“¾æ¥å™¨æ— æ³•æ‰§è¡Œçš„é”™è¯¯ï¼Œä½ éœ€è¦å†æ‰‹åŠ¨å®‰è£…ä¸€ä¸ª C è¯­è¨€ç¼–è¯‘å™¨ï¼š

**macOS ä¸‹ï¼š**

```console
$ xcode-select --install
```

**Linux ä¸‹ï¼š**

Linux ç”¨æˆ·ä¸€èˆ¬åº”æŒ‰ç…§ç›¸åº”å‘è¡Œç‰ˆçš„æ–‡æ¡£æ¥å®‰è£… `GCC` æˆ– `Clang`ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨ Ubuntuï¼Œåˆ™å¯å®‰è£… `build-essential`ã€‚

## åœ¨ FreeBSD ä¸Šå®‰è£… `rustup`

- ä½¿ç”¨ pkg å®‰è£…ï¼š

```sh
# pkg install rustup-init
```

- ä½¿ç”¨ Ports å®‰è£…ï¼š

```sh
# cd /usr/ports/devel/rustup-init/ 
# make install clean
```

## åœ¨ Windows ä¸Šå®‰è£… `rustup`

Windows ä¸Šå®‰è£… Rust éœ€è¦æœ‰ `C++` ç¯å¢ƒï¼Œä»¥ä¸‹ä¸ºå®‰è£…çš„ä¸¤ç§æ–¹å¼ï¼š

**1. `x86_64-pc-windows-msvc`ï¼ˆå®˜æ–¹æ¨èï¼‰**

å…ˆå®‰è£… [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/)ï¼Œå‹¾é€‰å®‰è£… C++ ç¯å¢ƒå³å¯ã€‚å®‰è£…æ—¶å¯è‡ªè¡Œä¿®æ”¹ç¼“å­˜è·¯å¾„ä¸å®‰è£…è·¯å¾„ï¼Œé¿å…å ç”¨è¿‡å¤š C ç›˜ç©ºé—´ã€‚å®‰è£…å®Œæˆåï¼ŒRust æ‰€éœ€çš„ msvc å‘½ä»¤è¡Œç¨‹åºéœ€è¦æ‰‹åŠ¨æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ä¸­ï¼Œå¦åˆ™å®‰è£… Rust æ—¶ `rustup-init` ä¼šæç¤ºæœªå®‰è£… Microsoft C++ Build Toolsï¼Œå…¶ä½äºï¼š`%Visual Studio å®‰è£…ä½ç½®%\VC\Tools\MSVC\%version%\bin\Hostx64\x64`ï¼ˆè¯·è‡ªè¡Œæ›¿æ¢å…¶ä¸­çš„ %Visual Studio å®‰è£…ä½ç½®%ã€%version% å­—æ®µï¼‰ä¸‹ã€‚

å¦‚æœä½ ä¸æƒ³è¿™ä¹ˆåšï¼Œå¯ä»¥é€‰æ‹©å®‰è£… Microsoft C++ Build Tools æ–°å¢çš„â€œå®šåˆ¶â€ç»ˆç«¯ `Developer Command Prompt for %Visual Studio version%` æˆ– `Developer PowerShell for %Visual Studio version%`ï¼Œåœ¨å…¶ä¸­è¿è¡Œ `rustup-init.exe`ã€‚

å‡†å¤‡å¥½ C++ ç¯å¢ƒåå¼€å§‹å®‰è£… Rustï¼š

åœ¨ [RUSTUP-INIT](https://www.rust-lang.org/learn/get-started) ä¸‹è½½ç³»ç»Ÿç›¸å¯¹åº”çš„ Rust å®‰è£…ç¨‹åºï¼Œä¸€è·¯é»˜è®¤å³å¯ã€‚

```shell
PS C:\Users\Hehongyuan> rustup-init.exe
......
Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
```

**2ã€`x86_64-pc-windows-gnu`**

ç›¸æ¯”äº MSVC ç‰ˆæœ¬æ¥è¯´ï¼ŒGNU ç‰ˆæœ¬å…·æœ‰æ›´è½»é‡ï¼Œæ›´é è¿‘ Linux çš„ä¼˜åŠ¿ã€‚

é¦–å…ˆï¼Œæ ¹æ® [MSYS2 å®˜ç½‘](https://www.msys2.org/) é…ç½® MSYSã€‚

è‹¥æ‚¨è§‰å¾—ä¸‹è½½å¤ªæ…¢ï¼Œå¯ä»¥è¯•è¯•ç”± [Caviar-X](https://github.com/Caviar-X) æä¾›çš„ [ä»£ç†](https://github.pigeons.icu/msys2/msys2-installer/releases/download/2021-11-30/msys2-x86_64-20211130.exe)ã€‚

åœ¨å®‰è£… `mingw-toolchain` åï¼Œè¯·å°† `%MSYS å®‰è£…è·¯å¾„%\mingw64\bin` æ·»åŠ åˆ°ç³»ç»Ÿå˜é‡ `PATH` ä¸­ã€‚

é…ç½®å¥½åï¼Œåœ¨ MSYS ä¸­è¾“å…¥ä¸‹é¢çš„å‘½ä»¤æ¥å®‰è£… rustupã€‚

```bash
$ curl https://sh.rustup.rs -sSf | sh
```

ä¹‹åï¼Œæ ¹æ®ä»¥ä¸‹è¾“å‡ºè¿›è¡Œé…ç½®ã€‚

```text
Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>2

I'm going to ask you the value of each of these installation options.
You may simply press the Enter key to leave unchanged.

Default host triple? [x86_64-pc-windows-msvc]
x86_64-pc-windows-gnu

Default toolchain? (stable/beta/nightly/none) [stable]
stable

Profile (which tools and data to install)? (minimal/default/complete) [default]
complete

Modify PATH variable? (Y/n)
Y

Current installation options:

   default host triple: x86_64-pc-windows-gnu
     default toolchain: stable
               profile: complete
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>
```

å†ä¹‹åï¼ŒæŒ‰ä¸‹ 1ï¼Œç­‰å¾…ã€‚å®Œæˆåï¼Œæ‚¨å°±å·²ç»å®‰è£…äº† Rust å’Œ `rustup`ã€‚

## æ›´æ–°
è¦æ›´æ–° Rustï¼Œåœ¨ç»ˆç«¯æ‰§è¡Œä»¥ä¸‹å‘½ä»¤å³å¯æ›´æ–°ï¼š

```bash
$ rustup update
```

## å¸è½½

è¦å¸è½½ Rust å’Œ `rustup`ï¼Œåœ¨ç»ˆç«¯æ‰§è¡Œä»¥ä¸‹å‘½ä»¤å³å¯å¸è½½ï¼š

```bash
$ rustup self uninstall
```

## æ£€æŸ¥å®‰è£…æ˜¯å¦æˆåŠŸ

æ£€æŸ¥æ˜¯å¦æ­£ç¡®å®‰è£…äº† Rustï¼Œå¯æ‰“å¼€ç»ˆç«¯å¹¶è¾“å…¥ä¸‹é¢è¿™è¡Œï¼Œæ­¤æ—¶èƒ½çœ‹åˆ°æœ€æ–°å‘å¸ƒçš„ç¨³å®šç‰ˆæœ¬çš„ç‰ˆæœ¬å·ã€æäº¤å“ˆå¸Œå€¼å’Œæäº¤æ—¥æœŸï¼š

```bash
$ rustc -V
rustc 1.56.1 (59eed8a2a 2021-11-01)

$ cargo -V
cargo 1.57.0 (b2e52d7ca 2021-10-21)
```

> æ³¨ï¼šè‹¥å‘ç°ç‰ˆæœ¬å·ä¸åŒï¼Œä»¥æ‚¨çš„ç‰ˆæœ¬å·ä¸ºå‡†

æ­å–œï¼Œä½ å·²æˆåŠŸå®‰è£… Rustï¼

å¦‚æœæ²¡çœ‹åˆ°æ­¤ä¿¡æ¯ï¼š

1. å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Windowsï¼Œè¯·æ£€æŸ¥ Rust æˆ– `%USERPROFILE%\.cargo\bin` æ˜¯å¦åœ¨ `%PATH%` ç³»ç»Ÿå˜é‡ä¸­ã€‚
2. å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Windows ä¸‹çš„ Linux å­ç³»ç»Ÿï¼Œè¯·å…³é—­å¹¶é‡æ–°æ‰“å¼€ç»ˆç«¯ï¼Œå†æ¬¡æ‰§è¡Œä»¥ä¸Šå‘½ä»¤ã€‚

å¦‚æœéƒ½æ­£ç¡®ï¼Œä½† Rust ä»ç„¶æ— æ³•æ­£å¸¸å·¥ä½œï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨å¾ˆå¤šåœ°æ–¹è·å¾—å¸®åŠ©ã€‚æœ€ç®€å•çš„æ˜¯**åŠ å…¥ Rust ç¼–ç¨‹å­¦é™¢è¿™ä¸ªå¤§å®¶åº­ï¼ŒQQ ç¾¤ï¼š1009730433**.

## æœ¬åœ°æ–‡æ¡£

å®‰è£… Rust çš„åŒæ—¶ä¹Ÿä¼šåœ¨æœ¬åœ°å®‰è£…ä¸€ä¸ªæ–‡æ¡£æœåŠ¡ï¼Œæ–¹ä¾¿æˆ‘ä»¬ç¦»çº¿é˜…è¯»ï¼šè¿è¡Œ `rustup doc` è®©æµè§ˆå™¨æ‰“å¼€æœ¬åœ°æ–‡æ¡£ã€‚

æ¯å½“é‡åˆ°æ ‡å‡†åº“æä¾›çš„ç±»å‹æˆ–å‡½æ•°ä¸çŸ¥é“æ€ä¹ˆç”¨æ—¶ï¼Œéƒ½å¯ä»¥åœ¨ API æ–‡æ¡£ä¸­æŸ¥æ‰¾åˆ°ï¼å…·ä½“å‚è§ [åœ¨æ ‡å‡†åº“å¯»æ‰¾ä½ æƒ³è¦çš„å†…å®¹](https://course.rs/std/search.html)ã€‚



================================================
FILE: src/first-try/intro.md
================================================
# å¯»æ‰¾ç‰›åˆ€ï¼Œä»¥ä¾¿å°è¯•

å…¶å®å¯¹äºå†™è¿™ç§ç« èŠ‚ï¼Œæˆ‘å†…å¿ƒæ˜¯æ‹’ç»çš„ï¼Œå› ä¸ºçœŸçš„å¾ˆæ— è¶£ã€‚å¯¹äºä¸€æœ¬ä¹¦è€Œè¨€ï¼Œè¿™ä¹Ÿæ›´åƒæ˜¯ä¸€ç§æµªè´¹çº¸å¼ çš„è¡Œä¸ºï¼ˆå¥½åœ¨å’±æ— çº¸åŒ– :-Dï¼‰ã€‚ä¸è¿‡æ²¡æœ‰åŠæ³•ï¼Œå¦‚æœä¸å®‰è£… Rust ç¯å¢ƒï¼Œæ€»ä¸èƒ½è®©å¤§å®¶ç”¨ç©ºæ°”è¿è¡Œå§ï¼Œsoï¼Œæˆ‘æ¶è¶£å‘³çš„èµ·äº†ä¸€ä¸ªè¿™æ ·çš„ç« èŠ‚åã€‚

åœ¨æœ¬ç« ä¸­ï¼Œä½ å°†å­¦ä¹ ä»¥ä¸‹å†…å®¹ï¼š

1. åœ¨ macOSã€Linuxã€Windows ä¸Šå®‰è£… Rust ä»¥åŠç›¸å…³å·¥å…·é“¾
2. æ­å»º VSCode æ‰€éœ€çš„ç¯å¢ƒ
3. ç®€å•ä»‹ç» Cargo
4. å®ç°ä¸€ä¸ªé…·ç‚«å¤šå›½è¯­è¨€ç‰ˆæœ¬çš„â€œä¸–ç•Œï¼Œä½ å¥½â€çš„ç¨‹åºï¼Œå¹¶ä¸”è°ˆè°ˆå¯¹ Rust è¯­è¨€çš„åˆå°è±¡



================================================
FILE: src/first-try/slowly-downloading.md
================================================
[Binary file]


================================================
FILE: src/first-try/sth-you-should-not-do.md
================================================
[Binary file]


================================================
FILE: src/libraries/intro.md
================================================
# å¸¸ç”¨ä¸‰æ–¹åº“



================================================
FILE: src/libraries/command/intro.md
================================================
# å‘½ä»¤è¡Œè§£æ



================================================
FILE: src/libraries/command/structopt.md
================================================
# structopt(todo)



================================================
FILE: src/libraries/http/intro.md
================================================
# Http



================================================
FILE: src/libraries/http/reqwest.md
================================================
# reqwest(todo)



================================================
FILE: src/libraries/json/intro.md
================================================
# Json



================================================
FILE: src/libraries/json/serde.md
================================================
# serde(todo)



================================================
FILE: src/logs/about-log.md
================================================
[Binary file]


================================================
FILE: src/logs/intro.md
================================================
# æ—¥å¿—å’Œç›‘æ§
è¿™å‡ å¹´ AIOps ç‰¹åˆ«ç«ï¼Œä½†æ˜¯ä½ è¦æ˜¯é€®ç€ä¸€ä¸ªè¿ç»´é—®ä¸€ä¸‹ï¼Œä»–ä¼°è®¡å¾ˆéš¾è¯´å‡ºä¸ªæ‰€ä»¥ç„¶æ¥ï¼Œæ¯•ç«Ÿæ¦‚å¿µå’Œç°å®å¾€å¾€æ˜¯è„±èŠ‚çš„ï¼Œå‰è€…çš„å‘å±•é€Ÿåº¦è‚¯å®šè¿œå¿«äºåè€…ã€‚

å¥½åœ¨æˆ‘å¤§æ¦‚äº†è§£è¿™å—å„¿é¢†åŸŸï¼Œå¯ä»¥è¯´æ™ºèƒ½åŒ–è¿ç»´çš„æ ¸å¿ƒå°±åœ¨äºæ—¥å¿—å’Œç›‘æ§ï¼Œæ¢è€Œè¨€ä¹‹ï¼Ÿä½•ä¸ºæ™ºèƒ½ï¼Œä¸å°±æ˜¯åŸºäºå·²æœ‰çš„æµ·é‡æ•°æ®åˆ†æåè¿›è¡Œå†³ç­–å—ï¼Ÿå½“ç„¶ï¼Œä½ è¦è¯´ä»¥å‰çš„çŸ¥è¯†åº“ç±»å‹çš„è¿ç»´å†³ç­–ä¹Ÿæ˜¯æ™ºèƒ½ï¼Œæˆ‘ä¹Ÿæ²¡åŠæ³•æ : D

æ€»ä¹‹ï¼Œä¸ä»…ä»…æ˜¯å¯¹äºå¼€å‘è€…ï¼Œå¯¹äºæ•´ä¸ªæŠ€æœ¯é“¾æ¡çš„å‚ä¸è€…ï¼Œç”šè‡³åŒ…æ‹¬è€æ¿ï¼Œ**æ—¥å¿—å’Œç›‘æ§éƒ½æ˜¯å¼€å‘å®è·µä¸­æœ€æœ€é‡è¦çš„ä¸€ç¯**ã€‚


================================================
FILE: src/logs/log.md
================================================
# æ—¥å¿—é—¨é¢ log

å°±å¦‚åŒ slf4j æ˜¯ Java çš„æ—¥å¿—é—¨é¢åº“ï¼Œ[log](https://github.com/rust-lang/log) ä¹Ÿæ˜¯ Rust çš„æ—¥å¿—é—¨é¢åº“( è¿™ä¸æ˜¯æˆ‘è‡ªå·±ç¼–çš„ï¼Œå®˜æ–¹ç”¨è¯­: logging facade )ï¼Œå®ƒç›®å‰ç”±å®˜æ–¹ç§¯æç»´æŠ¤ï¼Œå› æ­¤å¤§å®¶å¯ä»¥æ”¾å¿ƒä½¿ç”¨ã€‚

ä½¿ç”¨æ–¹å¼å¾ˆç®€å•ï¼Œåªè¦åœ¨ `Cargo.toml` ä¸­å¼•å…¥å³å¯ï¼š
```toml
[dependencies]
log = "0.4"
```

> æ—¥å¿—é—¨é¢ä¸æ˜¯è¯´æ’åœºå¾ˆå¤§çš„æ„æ€ï¼Œè€Œæ˜¯æŒ‡ç›¸åº”çš„æ—¥å¿— API å·²æˆä¸ºäº‹å®ä¸Šçš„æ ‡å‡†ï¼Œä¼šè¢«å…¶å®ƒæ—¥å¿—æ¡†æ¶æ‰€ä½¿ç”¨ã€‚é€šè¿‡è¿™ç§ç»Ÿä¸€çš„é—¨é¢ï¼Œå¼€å‘è€…å°±å¯ä»¥ä¸å¿…å†æ‹˜æ³¥äºæ—¥å¿—æ¡†æ¶çš„é€‰æ‹©ï¼Œæœªæ¥å¤§ä¸äº†å†æ¢ä¸€ä¸ªæ—¥å¿—æ¡†æ¶å°±æ˜¯

æ—¢ç„¶æ˜¯é—¨é¢ï¼Œ`log` è‡ªç„¶å®šä¹‰äº†ä¸€å¥—ç»Ÿä¸€çš„æ—¥å¿—ç‰¹å¾å’Œ APIï¼Œå°†æ—¥å¿—çš„æ“ä½œè¿›è¡Œäº†æŠ½è±¡ã€‚

## Log ç‰¹å¾

ä¾‹å¦‚ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ª `Log` ç‰¹å¾ï¼š
```rust
pub trait Log: Sync + Send {
    fn enabled(&self, metadata: &Metadata<'_>) -> bool;
    fn log(&self, record: &Record<'_>);
    fn flush(&self);
}
```

- `enabled` ç”¨äºåˆ¤æ–­æŸæ¡å¸¦æœ‰å…ƒæ•°æ®çš„æ—¥å¿—æ˜¯å¦èƒ½è¢«è®°å½•ï¼Œå®ƒå¯¹äº `log_enabled!` å®ç‰¹åˆ«æœ‰ç”¨
- `log` ä¼šè®°å½• `record` æ‰€ä»£è¡¨çš„æ—¥å¿—
- `flush` ä¼šå°†ç¼“å­˜ä¸­çš„æ—¥å¿—æ•°æ®åˆ·åˆ°è¾“å‡ºä¸­ï¼Œä¾‹å¦‚æ ‡å‡†è¾“å‡ºæˆ–è€…æ–‡ä»¶ä¸­

## æ—¥å¿—å®

`log` è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€æ•´å¥—æ ‡å‡†çš„å®ï¼Œç”¨äºæ–¹ä¾¿åœ°è®°å½•æ—¥å¿—ã€‚çœ‹åˆ° `trace!`ã€`debug!`ã€`info!`ã€`warn!`ã€`error!`ï¼Œå¤§å®¶æ˜¯å¦æ„Ÿè§‰çœ¼ç†Ÿå‘¢ï¼Ÿæ˜¯çš„ï¼Œå®ƒä»¬è·Ÿä¸Šä¸€ç« èŠ‚æåˆ°çš„æ—¥å¿—çº§åˆ«å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯è¿™é‡Œä¹±å…¥äº†ä¸€ä¸ª `trace!`ï¼Œå®ƒæ¯” `debug!` çš„æ—¥å¿—çº§åˆ«è¿˜è¦ä½ï¼Œè®°å½•çš„ä¿¡æ¯è¿˜è¦è¯¦ç»†ã€‚å¯ä»¥è¯´ï¼Œä½ å¦‚æœæƒ³å·¨ç»†æ— é—åœ°äº†è§£æŸä¸ªæµç¨‹çš„æ‰€æœ‰è¸ªè¿¹ï¼Œå®ƒå°±æ˜¯ä¸äºŒä¹‹é€‰ã€‚

```rust
use log::{info, trace, warn};

pub fn shave_the_yak(yak: &mut Yak) {
    trace!("Commencing yak shaving");

    loop {
        match find_a_razor() {
            Ok(razor) => {
                info!("Razor located: {}", razor);
                yak.shave(razor);
                break;
            }
            Err(err) => {
                warn!("Unable to locate a razor: {}, retrying", err);
            }
        }
    }
}
```

ä¸Šé¢çš„ä¾‹å­ä½¿ç”¨ `trace!` è®°å½•äº†ä¸€æ¡å¯æœ‰å¯æ— çš„ä¿¡æ¯ï¼šå‡†å¤‡å¼€å§‹å‰ƒé¡»ï¼Œç„¶åå¼€å§‹å¯»æ‰¾å‰ƒé¡»åˆ€ï¼Œæ‰¾åˆ°åå°±ç”¨ `info!` è®°å½•ä¸€æ¡å¯èƒ½äº‹åä¹Ÿæ²¡äººçœ‹çš„ä¿¡æ¯ï¼šæ‰¾åˆ°å‰ƒé¡»åˆ€ï¼›æ²¡æ‰¾åˆ°çš„è¯ï¼Œå°±è®°å½•ä¸€æ¡ `warn!` ä¿¡æ¯ï¼Œè¿™æ¡ä¿¡æ¯å°±æœ‰ä¸€å®šä»·å€¼äº†ï¼Œä¸ä»…å‘Šè¯‰æˆ‘ä»¬æ²¡æ‰¾åˆ°çš„åŸå› ï¼Œè¿˜è®°å½•äº†å‘ç”Ÿçš„æ¬¡æ•°ï¼Œæœ‰åŠ©äºäº‹åå®šä½é—®é¢˜ã€‚

å¯ä»¥çœ‹å‡ºï¼Œè¿™é‡Œä½¿ç”¨æ—¥å¿—çº§åˆ«çš„æ–¹å¼å’Œæˆ‘ä»¬ä¸Šä¸€ç« èŠ‚æ‰€è¿°åŸºæœ¬ç›¸ç¬¦ã€‚

é™¤äº†ä»¥ä¸Šå¸¸ç”¨çš„ï¼Œ`log` è¿˜æä¾›äº† `log!` å’Œ `log_enabled!` å®ï¼Œåè€…ç”¨äºç¡®å®šä¸€æ¡æ¶ˆæ¯åœ¨å½“å‰æ¨¡å—ä¸­ï¼Œå¯¹äºç»™å®šçš„æ—¥å¿—çº§åˆ«æ˜¯å¦èƒ½å¤Ÿè¢«è®°å½•

```rust
use log::Level::Debug;
use log::{debug, log_enabled};

// åˆ¤æ–­èƒ½å¦è®°å½• Debug æ¶ˆæ¯
if log_enabled!(Debug) {
    let data = expensive_call();
     // ä¸‹é¢çš„æ—¥å¿—è®°å½•è¾ƒä¸ºæ˜‚è´µï¼Œå› æ­¤æˆ‘ä»¬å…ˆåœ¨å‰é¢åˆ¤æ–­äº†æ˜¯å¦èƒ½å¤Ÿè®°å½•ï¼Œèƒ½ï¼Œæ‰ç»§ç»­è¿™é‡Œçš„é€»è¾‘
    debug!("expensive debug data: {} {}", data.x, data.y);
}
if log_enabled!(target: "Global", Debug) {
   let data = expensive_call();
   debug!(target: "Global", "expensive debug data: {} {}", data.x, data.y);
}
```

è€Œ `log!` å®å°±ç®€å•çš„å¤šï¼Œå®ƒæ˜¯ä¸€ä¸ªé€šç”¨çš„æ—¥å¿—è®°å½•æ–¹å¼ï¼Œå› æ­¤éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æŒ‡å®šæ—¥å¿—çº§åˆ«ï¼š
```rust
use log::{log, Level};

let data = (42, "Forty-two");
let private_data = "private";

log!(Level::Error, "Received errors: {}, {}", data.0, data.1);
log!(target: "app_events", Level::Warn, "App warning: {}, {}, {}",
    data.0, data.1, private_data);
```

## æ—¥å¿—è¾“å‡ºåœ¨å“ªé‡Œï¼Ÿ
æˆ‘ä¸çŸ¥é“æœ‰æ²¡æœ‰åŒå­¦å°è¯•è¿è¡Œè¿‡ä¸Šé¢çš„ä»£ç ï¼Œä½†æ˜¯æˆ‘çŸ¥é“ï¼Œå°±ç®—ä½ ä»¬è¿è¡Œäº†ï¼Œä¹Ÿçœ‹ä¸åˆ°ä»»ä½•è¾“å‡ºã€‚

ä¸ºä»€ä¹ˆï¼ŸåŸå› å¾ˆç®€å•ï¼Œ`log` ä»…ä»…æ˜¯æ—¥å¿—é—¨é¢åº“ï¼Œ**å®ƒå¹¶ä¸å…·å¤‡å®Œæ•´çš„æ—¥å¿—åº“åŠŸèƒ½ï¼**ï¼Œå› æ­¤ä½ æ— æ³•åœ¨æ§åˆ¶å°ä¸­çœ‹åˆ°ä»»ä½•æ—¥å¿—è¾“å‡ºï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œè¯´å®è¯ï¼Œè¿œä¸å¦‚ä¸€ä¸ª `println!` æœ‰ç”¨ï¼

ä½†æ˜¯åˆ«æ€¥ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹è¯¥å¦‚ä½•è®© `log` æœ‰ç”¨èµ·æ¥ã€‚


## ä½¿ç”¨å…·ä½“çš„æ—¥å¿—åº“
`log` åŒ…è¿™ä¹ˆè®¾è®¡ï¼Œå…¶å®æ˜¯æœ‰å¾ˆå¤šå¥½å¤„çš„ã€‚

### Rust åº“çš„å¼€å‘è€…
æœ€ç›´æ¥çš„å¥½å¤„å°±æ˜¯ï¼Œå¦‚æœä½ æ˜¯ä¸€ä¸ª Rust åº“å¼€å‘è€…ï¼Œé‚£ä½ è‡ªå·±æˆ–åº“çš„ç”¨æˆ·è‚¯å®šéƒ½ä¸å¸Œæœ›è¿™ä¸ªåº“ç»‘å®šä»»ä½•å…·ä½“çš„æ—¥å¿—åº“ï¼Œå¦åˆ™ç”¨æˆ·æƒ³ä½¿ç”¨ `log1` æ¥è®°å½•æ—¥å¿—ï¼Œä½ çš„åº“å´ä½¿ç”¨äº† `log2`ï¼Œè¿™å°±å­˜åœ¨å¾ˆå¤šé—®é¢˜äº†ï¼

å› æ­¤ï¼Œ**ä½œä¸ºåº“çš„å¼€å‘è€…ï¼Œä½ åªè¦åœ¨åº“ä¸­ä½¿ç”¨é—¨é¢åº“å³å¯**ï¼Œå°†å…·ä½“çš„æ—¥å¿—åº“äº¤ç»™ç”¨æˆ·å»é€‰æ‹©å’Œç»‘å®šã€‚
```rust
use log::{info, trace, warn};
pub fn deal_with_something() {
    // å¼€å§‹å¤„ç†

    // è®°å½•ä¸€äº›æ—¥å¿—
    trace!("a trace log");
    info!("a info long: {}", "abc");
    warn!("a warning log: {}, retrying", err);

    // ç»“æŸå¤„ç†
}
```

### åº”ç”¨å¼€å‘è€…
å¦‚æœæ˜¯åº”ç”¨å¼€å‘è€…ï¼Œé‚£ä½ çš„åº”ç”¨è¿è¡Œèµ·æ¥ï¼Œå´çœ‹ä¸åˆ°ä»»ä½•æ—¥å¿—è¾“å‡ºï¼Œè¿™ç§åœºæ™¯æƒ³æƒ³éƒ½æ‰æ€¥ã€‚æ­¤æ—¶å°±éœ€è¦å»é€‰æ‹©ä¸€ä¸ªå…·ä½“çš„æ—¥å¿—åº“äº†ã€‚

ç›®å‰æ¥è¯´ï¼Œå·²ç»æœ‰äº†ä¸å°‘æ—¥å¿—åº“å®ç°ï¼Œå®˜æ–¹ä¹Ÿ[æ¨èäº†ä¸€äº›](https://github.com/rust-lang/log#in-executables)
ï¼Œå¤§å®¶å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚æ¥é€‰æ‹©ï¼Œä¸è¿‡ [env_logger](https://docs.rs/env_logger/*/env_logger/) æ˜¯ä¸€ä¸ªç›¸å½“ä¸é”™çš„é€‰æ‹©ã€‚

`log` è¿˜æä¾›äº† [set_logger](https://docs.rs/log/0.4.8/log/fn.set_logger.html) å‡½æ•°ç”¨äºè®¾ç½®æ—¥å¿—åº“ï¼Œ[set_max_level](https://docs.rs/log/0.4.8/log/fn.set_max_level.html) ç”¨äºè®¾ç½®æœ€å¤§æ—¥å¿—çº§åˆ«ï¼Œä½†æ˜¯å¦‚æœä½ é€‰äº†å…·ä½“çš„æ—¥å¿—åº“ï¼Œå®ƒå¾€å¾€ä¼šæä¾›æ›´é«˜çº§çš„ APIï¼Œæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨è°ƒç”¨è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œä¾‹å¦‚ä¸‹é¢çš„ `env_logger` å°±æ˜¯å¦‚æ­¤ã€‚

#### env_logger

ä¿®æ”¹ `Cargo.toml` , æ·»åŠ ä»¥ä¸‹å†…å®¹:
```toml
# in Cargo.toml

[dependencies]
log = "0.4.0"
env_logger = "0.9"
```

åœ¨ `src/main.rs` ä¸­æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š
```rust
use log::{debug, error, log_enabled, info, Level};

fn main() {
    // æ³¨æ„ï¼Œenv_logger å¿…é¡»å°½å¯èƒ½æ—©çš„åˆå§‹åŒ–
    env_logger::init();

    debug!("this is a debug {}", "message");
    error!("this is printed by default");

    if log_enabled!(Level::Info) {
        let x = 3 * 4; // expensive computation
        info!("the answer was: {}", x);
    }
}
```

åœ¨è¿è¡Œç¨‹åºæ—¶ï¼Œå¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡æ¥è®¾å®šæ—¥å¿—çº§åˆ«:
```shell
$ RUST_LOG=error ./main
[2017-11-09T02:12:24Z ERROR main] this is printed by default
```

æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºå•ç‹¬ä¸€ä¸ªæ¨¡å—æŒ‡å®šæ—¥å¿—çº§åˆ«:
```shell
$ RUST_LOG=main=info ./main
[2017-11-09T02:12:24Z ERROR main] this is printed by default
[2017-11-09T02:12:24Z INFO main] the answer was: 12
```

è¿˜èƒ½ä¸ºæŸä¸ªæ¨¡å—å¼€å¯æ‰€æœ‰æ—¥å¿—çº§åˆ«ï¼š
```shell
$ RUST_LOG=main ./main
[2017-11-09T02:12:24Z DEBUG main] this is a debug message
[2017-11-09T02:12:24Z ERROR main] this is printed by default
[2017-11-09T02:12:24Z INFO main] the answer was: 12
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ–‡ä»¶ååŒ…å« `-`ï¼Œä½ éœ€è¦å°†å…¶æ›¿æ¢æˆä¸‹åˆ’çº¿æ¥ä½¿ç”¨ï¼ŒåŸå› æ˜¯ Rust çš„æ¨¡å—å’ŒåŒ…åä¸æ”¯æŒä½¿ç”¨ `-`ã€‚
```shell
$ RUST_LOG=my_app ./my-app
[2017-11-09T02:12:24Z DEBUG my_app] this is a debug message
[2017-11-09T02:12:24Z ERROR my_app] this is printed by default
[2017-11-09T02:12:24Z INFO my_app] the answer was: 12
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`env_logger` ä¼šè¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯ `stderr`ï¼Œå¦‚æœä½ æƒ³è¦è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º `stdout`ï¼Œå¯ä»¥ä½¿ç”¨ `Builder` æ¥æ”¹å˜æ—¥å¿—å¯¹è±¡( target ):
```rust
use std::env;
use env_logger::{Builder, Target};

let mut builder = Builder::from_default_env();
builder.target(Target::Stdout);

builder.init();
```

é»˜è®¤
```rust
   if cfg!(debug_assertions) {
       eprintln!("debug: {:?} -> {:?}",
              record, fields);
     }
```

### æ—¥å¿—åº“å¼€å‘è€…
å¯¹äºè¿™ç±»å¼€å‘è€…è€Œè¨€ï¼Œè‡ªç„¶è¦å®ç°è‡ªå·±çš„ `Log` ç‰¹å¾å’¯:

```rust
use log::{Record, Level, Metadata};
struct SimpleLogger;
impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &Metadata) -> bool {
        metadata.level() <= Level::Info
    }
    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            println!("{} - {}", record.level(), record.args());
        }
    }
    fn flush(&self) {}
}
```

é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åƒ `env_logger` ä¸€æ ·åŒ…è£…ä¸‹ `set_logger` å’Œ `set_max_level`:
```rust
use log::{SetLoggerError, LevelFilter};
static LOGGER: SimpleLogger = SimpleLogger;
pub fn init() -> Result<(), SetLoggerError> {
    log::set_logger(&LOGGER)
        .map(|()| log::set_max_level(LevelFilter::Info))
}
```


## æ›´å¤šç¤ºä¾‹
å…³äº `log` é—¨é¢åº“å’Œå…·ä½“çš„æ—¥å¿—åº“è¿˜æœ‰æ›´å¤šçš„ä½¿ç”¨æ–¹å¼ï¼Œè¯¦æƒ…è¯·å‚è§é”ˆä¹¦çš„[å¼€å‘è€…å·¥å…·](https://rusty.course.rs/devtools/log.html)ä¸€ç« ã€‚




================================================
FILE: src/logs/tracing-logger.md
================================================
[Binary file]


================================================
FILE: src/logs/tracing.md
================================================
[Binary file]


================================================
FILE: src/logs/observe/about-observe.md
================================================
[Binary file]


================================================
FILE: src/logs/observe/intro.md
================================================
# ç›‘æ§

ç›‘æ§æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„é¢†åŸŸï¼Œå¤§åˆ°è€æ¿ã€å‰ç«¯å¼€å‘ã€åç«¯å¼€å‘ç†è§£çš„ç›‘æ§å¯èƒ½éƒ½ä¸ç›¸åŒã€‚

- è€æ¿çœ¼ä¸­çš„ç›‘æ§ï¼šä¸šåŠ¡å¤§æ•°æ®å®æ—¶å±•ç¤º
- å‰ç«¯çœ¼ä¸­çš„ç›‘æ§ï¼šæ‰‹æœº APP æ”¶é›†ä¸Šæ¥çš„å¼‚å¸¸ã€å´©æºƒã€ç”¨æˆ·æ“ä½œæ—¥å¿—ç­‰
- åç«¯çœ¼ä¸­çš„ç›‘æ§ï¼šè¯·æ±‚é“¾è·¯è·Ÿè¸ªã€ä¸€æ®µæ—¶é—´å†…çš„è¯·æ±‚é”™è¯¯ç‡ã€QPS è¿‡é«˜ã€å¼‚å¸¸æ—¥å¿—ç­‰

æ­£æ˜¯å› ä¸ºè¿™äº›å¤æ‚æ€§ï¼Œå¯¼è‡´å¾ˆå¤šåŒå­¦éš¾ä»¥å‡†ç¡®çš„è¯´å‡ºç›‘æ§åˆ°åº•æ˜¯ä»€ä¹ˆã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬å°†è¯•å›¾è§£é‡Šæ¸…æ¥šç›‘æ§çš„æ¦‚å¿µï¼Œå¹¶å¼•å…¥ä¸€ä¸ªå…¨æ–°çš„æ¦‚å¿µï¼šå¯è§‚æµ‹æ€§ã€‚



================================================
FILE: src/logs/observe/trace.md
================================================
# åˆ†å¸ƒå¼è¿½è¸ª



================================================
FILE: src/practice/best-pratice.md
================================================
[Binary file]


================================================
FILE: src/practice/interview.md
================================================
# é¢è¯•ç»éªŒ doing

å…¶å®è¿™ä¸€ç« èŠ‚çš„å¤„å¢ƒæœ‰äº›å°´å°¬ï¼ŒRust è™½ç„¶åœ¨ä¸–ç•ŒèŒƒå›´æœ‰ç‚¹å°åæ°”ï¼Œä½†æ˜¯åœ¨å›½å†…ç›®å‰è¿˜å¤„äºå¼€è’é˜¶æ®µï¼Œå› æ­¤è‡³å°‘å°±å…¬å¼€æ‹›è˜è€Œè¨€ï¼Œå²—ä½å¹¶ä¸å¤šã€‚

ä½†æ˜¯æ—¢ç„¶å·ç§°æœ€ä½³å®è·µï¼Œå°‘äº†é¢è¯•ï¼Œæ€»è§‰å¾—ä¼šç¼ºå°‘äº›ä»€ä¹ˆï¼Œç”±äºç°åœ¨è¿˜æ²¡æœ‰å¤ªå¤šçš„ç»éªŒå¯ä»¥å‚è€ƒï¼Œæˆ‘ä»¬é€‰æ‹©å…ˆä»ç½‘ä¸Šæ‘˜é€‰äº›æ–‡ç« åˆ†äº«ç»™å¤§å®¶ï¼Œ**ä½†ä»…ä¾›å‚è€ƒï¼Œå…·ä½“è¿˜è¦å¤§å®¶è‡ªå·±æ¥è¾¨åˆ«**ã€‚

> æ„Ÿè°¢ [Kasper4649](https://github.com/Kasper4649) çš„ç« èŠ‚æè®®å’Œèµ„æºåˆ†äº«



- [è®°ä¸€æ¬¡ Rust æŠ€æœ¯é¢è¯•](https://zhuanlan.zhihu.com/p/411979704)
- [é£ä¹¦ Rust å®ä¹ ](https://blog.kuangjux.top/2021/10/22/é£ä¹¦Rustå®ä¹ é¢è¯•/)
- [å­—èŠ‚è·³åŠ¨ Rust/C++ å®ä¹ ](https://www.nowcoder.com/discuss/538078)
- [è®°ä¸€æ¬¡é¢è¯•](https://huangjj27.github.io/interview.html)
- [å­—èŠ‚è·³åŠ¨é¢è¯•ç»å†](https://blog.sbw.so/u/byte-dance-rust-cpp-interview-experience.html)


To be continued..


================================================
FILE: src/practice/intro.md
================================================
# Rustæœ€ä½³å®è·µ

å¯¹äºç”Ÿäº§çº§é¡¹ç›®è€Œè¨€ï¼Œè¿è¡Œç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§æ˜¯éå¸¸é‡è¦çš„ï¼Œæœ¬ç« å°±ä¸€èµ·æ¥çœ‹çœ‹ Rust é¡¹ç›®æœ‰å“ªäº›æœ€ä½³å®è·µå‡†åˆ™ã€‚


================================================
FILE: src/practice/naming.md
================================================
# å‘½åè§„èŒƒ

åŸºæœ¬çš„ Rust å‘½åè§„èŒƒåœ¨ [RFC 430] ä¸­æœ‰æè¿°ã€‚

é€šå¸¸ï¼Œå¯¹äº **type-level** çš„æ„é€  Rust å€¾å‘äºä½¿ç”¨**é©¼å³°å‘½åæ³•**ï¼Œè€Œå¯¹äº **value-level** çš„æ„é€ ä½¿ç”¨**è›‡å½¢å‘½åæ³•**ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š

| æ¡ç›® | æƒ¯ä¾‹ |
| ---- | ---------- |
| åŒ… Crates | [unclear](https://github.com/rust-lang/api-guidelines/issues/29) |
| æ¨¡å— Modules | `snake_case` |
| ç±»å‹ Types | `UpperCamelCase` |
| ç‰¹å¾ Traits | `UpperCamelCase` |
| æšä¸¾ Enumerations | `UpperCamelCase` |
| ç»“æ„ä½“ Structs | `UpperCamelCase` |
| å‡½æ•° Functions | `snake_case` |
| æ–¹æ³• Methods | `snake_case` |
| é€šç”¨æ„é€ å™¨ General constructors | `new` or `with_more_details` |
| è½¬æ¢æ„é€ å™¨ Conversion constructors | `from_some_other_type` |
| å® Macros | `snake_case!` |
| å±€éƒ¨å˜é‡ Local variables | `snake_case` |
| é™æ€ç±»å‹ Statics | `SCREAMING_SNAKE_CASE` |
| å¸¸é‡ Constants | `SCREAMING_SNAKE_CASE` |
| ç±»å‹å‚æ•° Type parameters | `UpperCamelCase`ï¼Œé€šå¸¸ä½¿ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯: `T` |
| ç”Ÿå‘½å‘¨æœŸ Lifetimes | é€šå¸¸ä½¿ç”¨å°å†™å­—æ¯: `'a`ï¼Œ`'de`ï¼Œ`'src` |
| Features | [unclear](https://github.com/rust-lang/api-guidelines/issues/101) but see [C-FEATURE] |

å¯¹äº**é©¼å³°å‘½åæ³•**ï¼Œå¤åˆè¯çš„ç¼©ç•¥å½¢å¼æˆ‘ä»¬è®¤ä¸ºæ˜¯ä¸€ä¸ªå•ç‹¬çš„è¯è¯­ï¼Œæ‰€ä»¥**åªå¯¹é¦–å­—æ¯è¿›è¡Œå¤§å†™**ï¼šä½¿ç”¨ `Uuid` è€Œä¸æ˜¯ ~~`UUID`~~ï¼Œ`Usize` è€Œä¸æ˜¯ ~~`USize`~~ï¼Œ`Stdin` è€Œä¸æ˜¯ ~~`StdIn`~~ã€‚

å¯¹äº**è›‡å½¢å‘½åæ³•**ï¼Œç¼©ç•¥è¯ç”¨å…¨å°å†™ï¼š`is_xid_start`ã€‚

å¯¹äº**è›‡å½¢å‘½åæ³•**ï¼ˆåŒ…æ‹¬å…¨å¤§å†™çš„ `SCREAMING_SNAKE_CASE`ï¼‰ï¼Œé™¤äº†æœ€åä¸€éƒ¨åˆ†ï¼Œå…¶å®ƒéƒ¨åˆ†çš„è¯è¯­éƒ½ä¸èƒ½ç”±å•ä¸ªå­—æ¯ç»„æˆï¼š
`btree_map` è€Œä¸æ˜¯ ~~`b_tree_map`~~ï¼Œ`PI_2` è€Œä¸æ˜¯ ~~`PI2`~~.

åŒ…å**ä¸åº”è¯¥**ä½¿ç”¨ `-rs` æˆ–è€… `-rust` ä½œä¸ºåç¼€ï¼Œå› ä¸ºæ¯ä¸€ä¸ªåŒ…éƒ½æ˜¯ Rust å†™çš„ï¼Œå› æ­¤è¿™ç§å¤šä½™çš„æ³¨é‡Šå…¶å®æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚

[RFC 430]: https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md
[C-FEATURE]: #c-feature

## ç‰¹å¾å‘½å
ç‰¹å¾çš„åç§°åº”è¯¥ä½¿ç”¨åŠ¨è¯ï¼Œè€Œä¸æ˜¯å½¢å®¹è¯æˆ–è€…åè¯ï¼Œä¾‹å¦‚ `Print` å’Œ `Draw` æ˜æ˜¾å¥½äº `Printable` å’Œ `Drawable`ã€‚

## ç±»å‹è½¬æ¢è¦éµå®ˆ `as_`ï¼Œ`to_`ï¼Œ`into_` å‘½åæƒ¯ä¾‹(C-CONV)
ç±»å‹è½¬æ¢åº”è¯¥é€šè¿‡æ–¹æ³•è°ƒç”¨çš„æ–¹å¼å®ç°ï¼Œå…¶ä¸­çš„å‰ç¼€è§„åˆ™å¦‚ä¸‹ï¼š

| æ–¹æ³•å‰ç¼€ | æ€§èƒ½å¼€é”€ | æ‰€æœ‰æƒæ”¹å˜ |
| ------ | ---- | --------- |
| `as_` | Free | borrowed -\> borrowed |
| `to_` | Expensive | borrowed -\> borrowed<br>borrowed -\> owned (non-Copy types)<br>owned -\> owned (Copy types) |
| `into_` | Variable | owned -\> owned (non-Copy types) |

ä¾‹å¦‚ï¼š

- [`str::as_bytes()`] æŠŠ `str` å˜æˆ UTF-8 å­—èŠ‚æ•°ç»„ï¼Œæ€§èƒ½å¼€é”€æ˜¯ 0ã€‚è¾“å…¥æ˜¯ä¸€ä¸ªå€Ÿç”¨çš„ `&str`ï¼Œè¾“å‡ºä¹Ÿæ˜¯ä¸€ä¸ªå€Ÿç”¨çš„ `&str`
- [`Path::to_str`] ä¼šæ‰§è¡Œä¸€æ¬¡æ˜‚è´µçš„ UTF-8 å­—èŠ‚æ•°ç»„æ£€æŸ¥ï¼Œè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯å€Ÿç”¨çš„ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œå¦‚æœæŠŠæ–¹æ³•å‘½åä¸º `as_str` æ˜¯ä¸æ­£ç¡®çš„ï¼Œå› ä¸ºè¿™ä¸ªæ–¹æ³•çš„å¼€é”€è¿˜æŒºå¤§
- [`str::to_lowercase()`] åœ¨è°ƒç”¨è¿‡ç¨‹ä¸­ä¼šéå†å­—ç¬¦ä¸²çš„å­—ç¬¦ï¼Œä¸”å¯èƒ½ä¼šåˆ†é…æ–°çš„å†…å­˜å¯¹è±¡ã€‚è¾“å…¥æ˜¯ä¸€ä¸ªå€Ÿç”¨çš„ `str`ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ªæœ‰ç‹¬ç«‹æ‰€æœ‰æƒçš„ `String`
- [`String::into_bytes()`] è¿”å› `String` åº•å±‚çš„ `Vec<u8>` æ•°ç»„ï¼Œè½¬æ¢æœ¬èº«æ˜¯é›¶æ¶ˆè€—çš„ã€‚è¯¥æ–¹æ³•è·å– `String` çš„æ‰€æœ‰æƒï¼Œç„¶åè¿”å›ä¸€ä¸ªæ–°çš„æœ‰ç‹¬ç«‹æ‰€æœ‰æƒçš„ `Vec<u8>`


[`str::as_bytes()`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes
[`Path::to_str`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str
[`str::to_lowercase()`]: https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase
[`f64::to_radians()`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians
[`String::into_bytes()`]: https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes
[`BufReader::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`BufWriter::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner


å½“ä¸€ä¸ªå•ç‹¬çš„å€¼è¢«æŸä¸ªç±»å‹æ‰€åŒ…è£…æ—¶ï¼Œè®¿é—®è¯¥ç±»å‹çš„å†…éƒ¨å€¼åº”é€šè¿‡ `into_inner()` æ–¹æ³•æ¥è®¿é—®ã€‚ä¾‹å¦‚å°†ä¸€ä¸ªç¼“å†²åŒºå€¼åŒ…è£…ä¸º [`BufReader`] ç±»å‹ï¼Œè¿˜æœ‰ [`GzDecoder`]ã€[`AtomicBool`] ç­‰ï¼Œéƒ½æ˜¯è¿™ç§ç±»å‹ã€‚


[`BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`GzDecoder`]: https://starry-network.github.io/starry_node/flate2/write/struct.GzDecoder.html#method.into_inner
[`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner

å¦‚æœ `mut` é™å®šç¬¦åœ¨è¿”å›ç±»å‹ä¸­å‡ºç°ï¼Œé‚£ä¹ˆåœ¨å‘½åä¸Šä¹Ÿ**åº”è¯¥**ä½“ç°å‡ºæ¥ã€‚ä¾‹å¦‚ï¼Œ[`Vec::as_mut_slice`] å°±è¯´æ˜å®ƒè¿”å›äº†ä¸€ä¸ª `mut` åˆ‡ç‰‡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ `as_mut_slice` æ¯” `as_slice_mut` æ›´é€‚åˆã€‚

[`Vec::as_mut_slice`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice

```rust
// è¿”å›ç±»å‹æ˜¯ä¸€ä¸ª `mut` åˆ‡ç‰‡
fn as_mut_slice(&mut self) -> &mut [T];
```

### æ ‡å‡†åº“ä¸­çš„ä¸€äº›ä¾‹å­

- [`Result::as_ref`](https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref)
- [`RefCell::as_ptr`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr)
- [`slice::to_vec`](https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec)
- [`Option::into_iter`](https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter)


##  è¯»è®¿é—®å™¨(Getter)çš„åç§°éµå¾ª Rust çš„å‘½åè§„èŒƒ(C-GETTER)

é™¤äº†å°‘æ•°ä¾‹å¤–ï¼Œåœ¨ Rustä»£ç ä¸­ `get` å‰ç¼€ä¸ç”¨äº Getterã€‚

```rust
pub struct S {
    first: First,
    second: Second,
}

impl S {
    // è€Œä¸æ˜¯ get_first
    pub fn first(&self) -> &First {
        &self.first
    }

    // è€Œä¸æ˜¯ get_first_mutï¼Œget_mut_firstï¼Œor mut_first
    pub fn first_mut(&mut self) -> &mut First {
        &mut self.first
    }
}
```
è‡³äºä¸Šæ–‡æåˆ°çš„å°‘æ•°ä¾‹å¤–ï¼Œå¦‚ä¸‹ï¼š**å½“æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå€¼**èƒ½è¢« Getter æ‰€è·å–æ—¶ï¼Œæ‰ä½¿ç”¨ `get` å‰ç¼€ã€‚ä¾‹å¦‚ï¼Œ[`Cell::get`] èƒ½ç›´æ¥è®¿é—®åˆ° `Cell` ä¸­çš„å†…å®¹ã€‚

[`Cell::get`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get

æœ‰äº› Getter ä¼šåœ¨è¿‡ç¨‹ä¸­æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘æ·»åŠ  `_unchecked` Getter å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è™½ç„¶ä¸å®‰å…¨ï¼Œä½†æ˜¯å¾€å¾€å…·æœ‰æ›´é«˜çš„æ€§èƒ½ã€‚
å…¸å‹çš„ä¾‹å­å¦‚ä¸‹ï¼š

```rust
fn get(&self, index: K) -> Option<&V>;
fn get_mut(&mut self, index: K) -> Option<&mut V>;
unsafe fn get_unchecked(&self, index: K) -> &V;
unsafe fn get_unchecked_mut(&mut self, index: K) -> &mut V;
```

[`TempDir::path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.path
[`TempDir::into_path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.into_path

### æ ‡å‡†åº“ç¤ºä¾‹

- [`std::io::Cursor::get_mut`](https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut)
- [`std::ptr::Unique::get_mut`](https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut)
- [`std::sync::PoisonError::get_mut`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut)
- [`std::sync::atomic::AtomicBool::get_mut`](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut)
- [`std::collections::hash_map::OccupiedEntry::get_mut`](https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut)
- [`<[T]>::get_unchecked`](https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked)

## ä¸€ä¸ªé›†åˆä¸Šçš„æ–¹æ³•ï¼Œå¦‚æœè¿”å›è¿­ä»£å™¨ï¼Œéœ€éµå¾ªå‘½åè§„åˆ™ï¼š`iter`ï¼Œ`iter_mut`ï¼Œ`into_iter` (C-ITER)

```rust
fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>
fn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>
fn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>
```
ä¸Šé¢çš„è§„åˆ™é€‚ç”¨äºåŒæ„æ€§çš„æ•°æ®é›†åˆã€‚ä¸ä¹‹ç›¸åï¼Œ`str` ç±»å‹æ˜¯ä¸€ä¸ª UTF-8 å­—èŠ‚æ•°ç»„åˆ‡ç‰‡ï¼Œä¸åŒæ„æ€§é›†åˆæœ‰ä¸€ç‚¹å¾®å¦™çš„å·®åˆ«ï¼Œå®ƒå¯ä»¥è®¤ä¸ºæ˜¯å­—èŠ‚é›†åˆï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯å­—ç¬¦é›†åˆï¼Œå› æ­¤å®ƒæä¾›äº† [`str::bytes`] å»éå†å­—èŠ‚ï¼Œè¿˜æœ‰ [`str::chars`] å»éå†å­—ç¬¦ï¼Œè€Œå¹¶æ²¡æœ‰ç›´æ¥å®šä¹‰ `iter` ç­‰æ–¹æ³•ã€‚

[`str::bytes`]: https://doc.rust-lang.org/std/primitive.str.html#method.bytes
[`str::chars`]: https://doc.rust-lang.org/std/primitive.str.html#method.chars

ä¸Šè¿°è§„åˆ™åªé€‚ç”¨äºæ–¹æ³•ï¼Œå¹¶ä¸é€‚ç”¨äºå‡½æ•°ã€‚ä¾‹å¦‚ `url` åŒ…çš„ [`percent_encode`] å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ç”¨äºéå†ç™¾åˆ†æ¯”ç¼–ç ï¼ˆ[Percent encoding](https://en.wikipedia.org/wiki/Percent-encoding)ï¼‰çš„å­—ç¬¦ä¸²ç‰‡æ®µ. åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ `iter`/`iter_mut`/`into_iter` è¯¸å¦‚æ­¤ç±»çš„å‡½æ•°å‘½åæ— æ³•è¡¨è¾¾ä»»ä½•å…·ä½“çš„å«ä¹‰ã€‚

[`percent_encode`]: https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html
[RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md

### æ ‡å‡†åº“ç¤ºä¾‹

- [`Vec::iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)
- [`Vec::iter_mut`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut)
- [`Vec::into_iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter)
- [`BTreeMap::iter`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter)
- [`BTreeMap::iter_mut`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut)

## è¿­ä»£å™¨çš„ç±»å‹åº”è¯¥ä¸äº§ç”Ÿå®ƒçš„æ–¹æ³•åç›¸åŒ¹é…(C-ITER-TY)
ä¾‹å¦‚å½¢å¦‚ `into_iter()` çš„æ–¹æ³•åº”è¯¥è¿”å›ä¸€ä¸ª `IntoIter` ç±»å‹ï¼Œä¸ä¹‹ç›¸ä¼¼ï¼Œå…¶å®ƒä»»ä½•è¿”å›è¿­ä»£å™¨çš„æ–¹æ³•ä¹Ÿåº”è¯¥éµå¾ªè¿™ç§å‘½åæƒ¯ä¾‹ã€‚

ä¸Šè¿°è§„åˆ™ä¸»è¦åº”ç”¨äºæ–¹æ³•ï¼Œä½†æ˜¯ç»å¸¸å¯¹äºå‡½æ•°ä¹Ÿé€‚ç”¨ã€‚ä¾‹å¦‚ä¸Šæ–‡æåˆ°çš„ `url` åŒ…ä¸­çš„ [`percent_encode`] å‡½æ•°ï¼Œè¿”å›äº†ä¸€ä¸ª [`PercentEncode`] ç±»å‹ã€‚

[`PercentEncode`]: https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html

ç‰¹åˆ«æ˜¯ï¼Œå½“è¿™äº›ç±»å‹è·ŸåŒ…åå‰ç¼€ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå°†å…·å¤‡éå¸¸æ¸…æ™°çš„å«ä¹‰ï¼Œä¾‹å¦‚ [`vec::IntoIter`]ã€‚

[`vec::IntoIter`]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html

### æ ‡å‡†åº“ç¤ºä¾‹

* [`Vec::iter`] returns [`Iter`][slice::Iter]
* [`Vec::iter_mut`] returns [`IterMut`][slice::IterMut]
* [`Vec::into_iter`] returns [`IntoIter`][vec::IntoIter]
* [`BTreeMap::keys`] returns [`Keys`][btree_map::Keys]
* [`BTreeMap::values`] returns [`Values`][btree_map::Values]

[`Vec::iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter
[slice::Iter]: https://doc.rust-lang.org/std/slice/struct.Iter.html
[`Vec::iter_mut`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut
[slice::IterMut]: https://doc.rust-lang.org/std/slice/struct.IterMut.html
[`Vec::into_iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter
[vec::IntoIter]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html
[`BTreeMap::keys`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys
[btree_map::Keys]: https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html
[`BTreeMap::values`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values
[btree_map::Values]: https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html


<a id="c-feature"></a>
## Cargo Feature çš„åç§°ä¸åº”è¯¥åŒ…å«å ä½è¯(C-FEATURE)

ä¸è¦åœ¨ [Cargo feature] ä¸­åŒ…å«æ— æ³•ä¼ è¾¾ä»»ä½•æ„ä¹‰çš„è¯ï¼Œä¾‹å¦‚ `use-abc` æˆ– `with-abc`ï¼Œç›´æ¥å‘½åä¸º `abc` å³å¯ã€‚

[Cargo feature]: http://doc.crates.io/manifest.html#the-features-section

ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯ï¼šä¸€ä¸ªåŒ…å¯¹æ ‡å‡†åº“æœ‰å¯é€‰æ€§çš„ä¾èµ–ã€‚æ ‡å‡†çš„å†™æ³•å¦‚ä¸‹ï¼š

```toml
# åœ¨ Cargo.toml ä¸­

[features]
default = ["std"]
std = []
```

```rust
// åœ¨æˆ‘ä»¬è‡ªå®šä¹‰çš„ lib.rs ä¸­

#![cfg_attr(not(feature = "std"), no_std)]
```
é™¤äº† `std` ä¹‹å¤–ï¼Œä¸è¦ä½¿ç”¨ä»»ä½• `ust-std` æˆ–è€… `with-std` ç­‰è‡ªä»¥ä¸ºå¾ˆæœ‰åˆ›é€ æ€§çš„åç§°ã€‚

## å‘½åè¦ä½¿ç”¨ä¸€è‡´æ€§çš„è¯åº(C-WORD-ORDER)

è¿™æ˜¯ä¸€äº›æ ‡å‡†åº“ä¸­çš„é”™è¯¯ç±»å‹:

- [`JoinPathsError`](https://doc.rust-lang.org/std/env/struct.JoinPathsError.html)
- [`ParseBoolError`](https://doc.rust-lang.org/std/str/struct.ParseBoolError.html)
- [`ParseCharError`](https://doc.rust-lang.org/std/char/struct.ParseCharError.html)
- [`ParseFloatError`](https://doc.rust-lang.org/std/num/struct.ParseFloatError.html)
- [`ParseIntError`](https://doc.rust-lang.org/std/num/struct.ParseIntError.html)
- [`RecvTimeoutError`](https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html)
- [`StripPrefixError`](https://doc.rust-lang.org/std/path/struct.StripPrefixError.html)

å®ƒä»¬éƒ½ä½¿ç”¨äº† `è°“è¯­-å®¾è¯­-é”™è¯¯` çš„è¯åºï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è¡¨è¾¾ä¸€ä¸ªç½‘ç»œåœ°å€æ— æ³•åˆ†æçš„é”™è¯¯ï¼Œç”±äºè¯åºä¸€è‡´æ€§çš„åŸåˆ™ï¼Œå‘½ååº”è¯¥å¦‚ä¸‹ `ParseAddrError`ï¼Œè€Œä¸æ˜¯ `AddrParseError`ã€‚

è¯åºå’Œä¸ªäººä¹ æƒ¯æœ‰å¾ˆå¤§å…³ç³»ï¼Œæƒ³è¦æ³¨æ„çš„æ˜¯ï¼Œä½ å¯ä»¥é€‰æ‹©åˆé€‚çš„è¯åºï¼Œä½†æ˜¯è¦åœ¨åŒ…çš„èŒƒç•´å†…ä¿æŒä¸€è‡´æ€§ï¼Œå°±å¦‚æ ‡å‡†åº“ä¸­çš„åŒ…ä¸€æ ·ã€‚



================================================
FILE: src/practice/third-party-libs.md
================================================
[Binary file]


================================================
FILE: src/profiling/intro.md
================================================
# Rustæ€§èƒ½å‰–æ todo



================================================
FILE: src/profiling/compiler/attributes.md
================================================
# å¸¸è§å±æ€§æ ‡è®°

## å¼ºåˆ¶å†…å­˜å¯¹é½

```rust
#[repr(align(64))]
struct CachePadded(AtomicU64);
```

A data of alignment X is stored in memory at address multiple of X

https://doc.rust-lang.org/reference/attributes.html


================================================
FILE: src/profiling/compiler/intro.md
================================================
# å¯¹æŠ—ç¼–è¯‘æ£€æŸ¥



================================================
FILE: src/profiling/compiler/llvm.md
================================================
# LLVM todo
https://ttalk.im/2021/12/llvm-infrastructure-and-rust.html


================================================
FILE: src/profiling/compiler/phantom-data.md
================================================
# PhantomDataï¼ˆå¹½çµæ•°æ®ï¼‰

åœ¨ç¼–å†™éå®‰å…¨ä»£ç æ—¶ï¼Œæˆ‘ä»¬å¸¸å¸¸é‡è§è¿™ç§æƒ…å†µï¼šç±»å‹æˆ–ç”Ÿå‘½å‘¨æœŸé€»è¾‘ä¸Šä¸ä¸€ä¸ªç»“æ„ä½“å…³è”èµ·æ¥äº†ï¼Œä½†æ˜¯å´ä¸å±äºç»“æ„ä½“çš„ä»»ä½•ä¸€ä¸ªæˆå‘˜ã€‚è¿™ç§æƒ…å†µå¯¹äºç”Ÿå‘½å‘¨æœŸå°¤ä¸ºå¸¸è§ã€‚æ¯”å¦‚ï¼Œ`&'a [T]`çš„`Iter`å¤§æ¦‚æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š

``` Rust
struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
}
```

ä½†æ˜¯ï¼Œå› ä¸º`'a`æ²¡æœ‰åœ¨ç»“æ„ä½“å†…è¢«ä½¿ç”¨ï¼Œå®ƒæ˜¯æ— ç•Œçš„ã€‚ç”±äºä¸€äº›å†å²åŸå› ï¼Œæ— ç•Œç”Ÿå‘½å‘¨æœŸå’Œç±»å‹ç¦æ­¢å‡ºç°åœ¨ç»“æ„ä½“å®šä¹‰ä¸­ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»æƒ³åŠæ³•åœ¨ç»“æ„ä½“å†…ç”¨åˆ°è¿™äº›ç±»å‹ï¼Œè¿™ä¹Ÿæ˜¯æ­£ç¡®çš„å˜æ€§æ£€æŸ¥å’Œdropæ£€æŸ¥çš„å¿…è¦æ¡ä»¶ã€‚

æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„æ ‡å¿—ç±»å‹`PhantomData`åšåˆ°è¿™ä¸€ç‚¹ã€‚`PhantomData`ä¸æ¶ˆè€—å­˜å‚¨ç©ºé—´ï¼Œå®ƒåªæ˜¯æ¨¡æ‹Ÿäº†æŸç§ç±»å‹çš„æ•°æ®ï¼Œä»¥æ–¹ä¾¿é™æ€åˆ†æã€‚è¿™ä¹ˆåšæ¯”æ˜¾å¼åœ°å‘Šè¯‰ç±»å‹ç³»ç»Ÿä½ éœ€è¦çš„å˜æ€§æ›´ä¸å®¹æ˜“å‡ºé”™ï¼Œè€Œä¸”è¿˜èƒ½æä¾›dropæ£€æŸ¥éœ€è¦çš„ä¿¡æ¯ã€‚

`Iter`é€»è¾‘ä¸ŠåŒ…å«ä¸€ç³»åˆ—`&'a T`ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨`PhantomData`è¿™æ ·å»æ¨¡æ‹Ÿå®ƒï¼š

``` Rust
use std::marker;

struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData<&'a T>,
}
```

å°±æ˜¯è¿™æ ·ï¼Œç”Ÿå‘½å‘¨æœŸå˜å¾—æœ‰ç•Œäº†ï¼Œä½ çš„è¿­ä»£å™¨å¯¹äº`'a`å’Œ`T`ä¹Ÿå¯å˜äº†ã€‚ä¸€åˆ‡å°½å¦‚äººæ„ã€‚

å¦ä¸€ä¸ªé‡è¦çš„ä¾‹å­æ˜¯`Vec`ï¼Œå®ƒå·®ä¸å¤šæ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š

``` Rust
struct Vec<T> {
    data: *const T, // *constæ˜¯å¯å˜çš„ï¼
    len: usize,
    cap: usize,
}
```

å’Œä¹‹å‰çš„ä¾‹å­ä¸åŒï¼Œè¿™ä¸ªå®šä¹‰å·²ç»æ»¡è¶³æˆ‘ä»¬çš„å„ç§è¦æ±‚äº†ã€‚`Vec`çš„æ¯ä¸€ä¸ªæ³›å‹å‚æ•°éƒ½è¢«è‡³å°‘ä¸€ä¸ªæˆå‘˜ä½¿ç”¨è¿‡äº†ã€‚éå¸¸å®Œç¾ï¼

ä½ é«˜å…´çš„å¤ªæ—©äº†ã€‚

Dropæ£€æŸ¥å™¨ä¼šåˆ¤æ–­`Vec<T>`å¹¶ä¸æ‹¥æœ‰Tç±»å‹çš„å€¼ï¼Œç„¶åå®ƒè®¤ä¸ºæ— éœ€æ‹…å¿ƒVecåœ¨ææ„å‡½æ•°é‡Œèƒ½ä¸èƒ½å®‰å…¨åœ°é”€æ¯Tï¼Œå†ç„¶åå®ƒä¼šå…è®¸äººä»¬åˆ›å»ºä¸å®‰å…¨çš„Vecææ„å‡½æ•°ã€‚

ä¸ºäº†è®©dropæ£€æŸ¥å™¨çŸ¥é“æˆ‘ä»¬ç¡®å®æ‹¥æœ‰Tç±»å‹çš„å€¼ï¼Œä¹Ÿå°±æ˜¯éœ€è¦åœ¨é”€æ¯Vecçš„æ—¶å€™åŒæ—¶é”€æ¯Tï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ªé¢å¤–çš„PhantomDataï¼š

``` Rust
use std::marker:

struct Vec<T> {
    data: *const T, // *constæ˜¯å¯å˜çš„ï¼
    len: usize,
    cap: usize,
    _marker: marker::PhantomData<T>,
}
```

è®©è£¸æŒ‡é’ˆæ‹¥æœ‰æ•°æ®æ˜¯ä¸€ä¸ªå¾ˆæ™®éçš„è®¾è®¡ï¼Œä»¥è‡³äºæ ‡å‡†åº“ä¸ºå®ƒè‡ªå·±åˆ›é€ äº†ä¸€ä¸ªå«`Unique<T>`çš„ç»„ä»¶ï¼Œå®ƒå¯ä»¥ï¼š

- å°è£…ä¸€ä¸ª`*const T`å¤„ç†å˜æ€§
- åŒ…å«ä¸€ä¸ª `PhantomData<T>`
- è‡ªåŠ¨å®ç°`Send`/`Sync`ï¼Œæ¨¡æ‹Ÿå’ŒåŒ…å«Tæ—¶ä¸€æ ·çš„è¡Œä¸º
- å°†æŒ‡é’ˆæ ‡è®°ä¸º`NonZero`ä»¥ä¾¿ç©ºæŒ‡é’ˆä¼˜åŒ–

## `PhantomData`æ¨¡å¼è¡¨

ä¸‹è¡¨å±•ç¤ºäº†å„ç§ç‰›Xé—ªé—ªçš„`PhantomData`ç”¨æ³•ï¼š

| Phantom ç±»å‹ | `'a` | `'T` |
|----|----|----|
|`PhantomData<T>`|-|åå˜ï¼ˆå¯è§¦å‘dropæ£€æŸ¥ï¼‰|
|`PhantomData<&'a T>`|åå˜|åå˜|
|`PhantomData<&'a mut T>`|åå˜|ä¸å˜|
|`PhantomData<*const T>`|-|åå˜|
|`PhantomData<*mut T>`|-|ä¸å˜|
|`PhantomData<fn(T)>`|-|é€†å˜(*)|
|`PhantomData<fn() -> T>`|-|åå˜|
|`PhantomData<fn(T) -> T>`|-|ä¸å˜|
|`PhantomData<Cell<&'a ()>>`|ä¸å˜|-|

(*)å¦‚æœå‘ç”Ÿå˜æ€§çš„å†²çªï¼Œè¿™ä¸ªæ˜¯ä¸å˜çš„


================================================
FILE: src/profiling/compiler/speed-up.md
================================================
# ä¼˜åŒ–ç¼–è¯‘é€Ÿåº¦
<!-- 
https://www.reddit.com/r/rust/comments/rnkyc0/why_does_my_code_compile_faster_on_nightly/

https://www.reddit.com/r/rust/comments/rv8126/speedup_compilation_time/

https://www.reddit.com/r/rust/comments/rsfcgb/why_is_my_rust_build_so_slow/

https://www.reddit.com/r/rust/comments/sqi1ba/is_it_just_me_or_rustanalyzer_is_unreliableslow/ -->


================================================
FILE: src/profiling/compiler/optimization/intro.md
================================================
# ç¼–è¯‘å™¨ä¼˜åŒ–

åœ¨Rustä¸­ï¼Œä¸€æ®µå¾ˆä¸èµ·çœ¼çš„ä»£ç ä¸­å¯èƒ½ä¹Ÿéšè—ç€ç„æœºï¼Œç¼–è¯‘å™¨åœ¨ç»†æ— å£°çš„ä¸ºæˆ‘ä»¬åšç€å„ç§ä¼˜åŒ–ï¼Œæœ¬ç« å°†è®°å½•è¿™äº›ä¼˜åŒ–ï¼Œå¸®åŠ©å¤§å®¶æ›´å¥½çš„ç†è§£ç¨‹åºçš„æ€§èƒ½ã€‚


================================================
FILE: src/profiling/compiler/optimization/option.md
================================================
# Optionæšä¸¾

https://www.reddit.com/r/learnrust/comments/rz34ht/where_does_the_data_go_if_you_replace_some_with/



================================================
FILE: src/profiling/memory/allocation.md
================================================
# å†…å­˜åˆ†é…(todo)

https://www.reddit.com/r/rust/comments/s4pknf/investigating_memory_allocations_in_rust/


================================================
FILE: src/profiling/memory/intro.md
================================================
# æ·±å…¥å†…å­˜

éƒ¨åˆ†å†…å®¹å€Ÿé‰´äº†Rust in actionå’ŒRusté«˜çº§ç¼–ç¨‹


https://www.youtube.com/watch?v=rDoqT-a6UFg


================================================
FILE: src/profiling/memory/layout.md
================================================
# å†…å­˜å¸ƒå±€(todo)

https://www.reddit.com/r/rust/comments/rwta4h/why_arent_rust_structs_laid_out_in_memory_like_c/


================================================
FILE: src/profiling/memory/pointer-ref.md
================================================
# æŒ‡é’ˆå’Œå¼•ç”¨(todo)



================================================
FILE: src/profiling/memory/uninit.md
================================================
# æœªåˆå§‹åŒ–å†…å­˜

https://lucumr.pocoo.org/2022/1/30/unsafe-rust/


================================================
FILE: src/profiling/memory/virtual.md
================================================
# è™šæ‹Ÿå†…å­˜



================================================
FILE: src/profiling/performance/allocator.md
================================================
# å†…å­˜allocator todo

https://www.reddit.com/r/rust/comments/s28g4x/allocating_many_boxes_at_once/

https://www.reddit.com/r/rust/comments/szza43/memory_freed_but_not_immediately/


================================================
FILE: src/profiling/performance/calculate.md
================================================
# è®¡ç®—æ€§èƒ½ä¼˜åŒ–


https://www.reddit.com/r/rust/comments/rn7ozz/find_perfect_number_comparison_go_java_rust/


```go
package main

import (
	"fmt"
	"math"
	"time"
)

func main() {
	n := 320000
	nums := make(map[int][]int)
	start := time.Now()
	calPerfs(n, nums)
	fmt.Printf("runtime: %s\n", time.Since(start))
}

func calPerfs(n int, nums map[int][]int) {
	for i := 1; i <= n; i++ {
		d := divs(i)
		if sum(d) == i {
			nums[i] = all(d)
		}
	}
}

func divs(num int) map[int]struct{} {
	r := make(map[int]struct{})
	r[1] = struct{}{}
	mid := int(math.Sqrt(float64(num)))
	for i := 2; i <= mid; i++ {
		if num%i == 0 {
			r[i] = struct{}{}
			r[num/i] = struct{}{}
		}
	}
	return r
}

func sum(ds map[int]struct{}) int {
	var n int
	for k := range ds {
		n += k
	}
	return n
}

func all(ds map[int]struct{}) []int {
	var a []int
	for k := range ds {
		a = append(a, k)
	}
	return a
}
```

## 120ms

```rust
use std::time::Instant;

const N: usize = 320_000	;

fn is_perfect(n: usize) -> bool {
    //println!("{:?}", n);
    let mut sum = 1;
    let end = (n as f64).sqrt() as usize;
    for i in 2..end  + 1{
        if n % i == 0 {
            if i * i == n {
                sum += i;
            }
            else {
                sum += i + n / i;
            }
        }
    }
    sum == n
}

fn find_perfs(n: usize) -> Vec<usize> {
    let mut perfs:Vec<usize> = vec![];
    for i in 2..n + 1 {
        if is_perfect(i) {
            perfs.push(i)
        }
    }
    perfs
}

fn main() {
    let start = Instant::now();
    let perfects = find_perfs(N);
    println!("{:?}", start.elapsed());
    println!("{:?}, in {:?}", perfects, N);
}
```

## 90ms

```rust
use {
    std::{time::Instant},
};

const N: usize = 320000;

// Optimized, takes about 320ms on an Core i7 6700 @ 3.4GHz
fn cal_perfs2(n: usize) -> Vec<usize> {
    (1..=n)
        .into_iter()
        .filter(|i| cal2(*i) == *i)
        .collect::<Vec<_>>()
}

fn cal2(n: usize) -> usize {
    (2..=(n as f64).sqrt() as usize)
        .into_iter()
        .filter_map(|i| if n % i == 0 { Some([i, n / i]) } else { None })
        .map(|a| a[0] + a[1])
        .sum::<usize>()
        + 1
}


fn main() {
    let start = Instant::now();
    let perf2 = cal_perfs2(N);
    println!("{:?}",perf2);
    println!("Optimized: {:?}", start.elapsed());
}
```


================================================
FILE: src/profiling/performance/clone-copy.md
================================================
# Cloneå’ŒCopy



================================================
FILE: src/profiling/performance/cpu-cache.md
================================================
# CPUç¼“å­˜æ€§èƒ½ä¼˜åŒ–

https://github.com/TC5027/blog/blob/master/false_sharing.md


# On a use of the "repr" attribute in Rust

Consider we work with the following struct representing a counter,
```rust
struct Counter(u64);
```
and we want to increment it with random ``u8`` values with the help of a for loop : 
```rust
use rand::Rng;
fn main() {
	let mut counter = Counter(0);
	let mut rng = rand::thread_rng();
	
	for _ in 0..1_000_000 {
		counter.0 += rng.gen::<u8>() as u64;
	}
}
```
This takes 1.90ms to run on my laptop using ``cargo run --release``. Remember this timing as it will be our reference value :)
Now suppose we were given this struct, holding not 1 but 2 counters : 
```rust
struct Counters {
	c1 : u64,
	c2 : u64
}
```
Using the same approach, performing the increments for the 2 counters in a single-threaded fashion, we would expect to be twice slower (in fact it takes 3.71ms to execute).
Can we do better ? Well, as our 2 counters are independent, we could spawn 2 threads, assign them one counter and increment concurrently ! Given I have 4 CPUs on my laptop, I would expect to be just as fast as the first scenario. Let's see !

First thing, we could create a local variable in each thread which would be incremented and then we would set the counter value to this incremented one (spoiler : good idea). But we could also save these 2 variables and share the ``Counter`` between the 2 threads with an ``Arc`` (spoiler : definitely not worth). Let's do this second option ! ^^

Doing the following code, 

```rust
fn main() {
	let counters = Arc::new(Counters{c1:0, c2:0});
	let counters_clone = counters.clone();
	
	let handler1 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters.c1 += rng.gen::<u8>() as u64;
		}
	});
	let handler2 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters_clone.c2 += rng.gen::<u8>() as u64;
		}
	});
	handler1.join(); handler2.join();
}
```
we end up with an error : 

**cannot assign to data in an `Arc`**
**cannot assign**
**help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::sync::Arc<Counters>`rustc(E0594)**

Unlucky. Maybe we could use **atomic types**. These types provide operations that synchronize updates between threads. In fact, as an equivalent of ``+=`` we could use the ``fetch_add`` method which has the following signature : ``pub fn fetch_add(&self, val: u64, order: Ordering) -> u64``. What should be highlighted is the ``&self``. We could expect a ``&mut self`` given the modification we want to perform using it but thanks to the property that an atomic operation is performed without interruptions we don't need exclusive access to the variable to safely update it.
We can solve the error replacing the counter's type by ``AtomicU64`` as like that we only require ``Arc`` to implement the ``Deref`` trait (given the signature of ``fetch_add``) and it is the case !

We so have to change a bit our struct to : 
```rust
struct Counters {
	c1 : AtomicU64,
	c2 : AtomicU64,
}
```
and our code to :
```rust
fn main() {
    let counters = Arc::new(Counters{
        c1 :  AtomicU64::new(0),
        c2 : AtomicU64::new(0)
    });
    let counters_clone = counters.clone();
    let handler1 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters.c1.fetch_add(rng.gen::<u8>() as u64,Relaxed);
        }
    });
    let handler2 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters_clone.c2.fetch_add(rng.gen::<u8>() as u64,Relaxed);
        }
    });
    handler1.join();handler2.join();
}
```
We could naturally expect the operation on Atomics to be a bit slower than the ones on ``u64`` but let's see !
30.22ms .. ok... that's terrible ^^
Do Atomics operations explain all this ?
I ran a benchmark to compare ``+=`` and ``fetch_add( ,Relaxed)`` to figure it out : 

```rust
let mut sum = 0;
let start = Instant::now();
for _ in 0..10_000_000 {
	sum += rng.gen::<u8>() as u64;
}
println!("time spent u64 sum : {:?}", start.elapsed());
let atomic_sum = AtomicU64::new(0);
let start = Instant::now();
for _ in 0..10_000_000 {
	atomic_sum.fetch_add(rng.gen::<u8>() as u64, Relaxed);
}
println!("time spent AtomicU64 sum : {:?}", start.elapsed());
```

The ``u64`` sums takes 20.07ms while the ``AtomicU64`` one takes 70.28ms. So we should only be 3 times slower than 2ms but we are 15 times slower how can it be ???

Hint : CPU cache... but why should we care ?
CPU cache is a data storage, located close to CPU, offering a fast access to data.
In a computer, when the CPU needs to read or write a value, it checks if it is present inside the cache or not. If it is the case then the CPU directly uses the cached data. Otherwise, the cache allocates a new entry and copies data from main memory, an entry being of fixed size and called *cache line*.
CPU cache is relatively small compared to RAM but much faster, and that's why a program should be designed to use as much as possible data lying in cache, based on a locality principle, to avoid expensive access to RAM.

If we represent our current situation it looks like this :
 ![figure](https://github.com/TC5027/blog/blob/master/pngs/false_sharing.png)

The red square corresponds to the first counter and the green one to the second. They can potentially lie in the same cache line !

If data is modified through CPU 0 in its L1 cache we expect our computer to reflect the changes both in memory and in the other L1 cache. To ensure this coherency, there exists coherence protocols which can force the **whole cache line** impacted by the change to be propagated through the whole system, in order to update the copies of the value changed.

With that in mind, what is happening in our code comes from that : we suffer from coherency protocol due to our 2 counters lying on the same cache line. Updating first counter through CPU 0 involves an update in the system of the data stored in the cache line where the second counter (unchanged) potentially lies. During this update, CPU 1 cannot access the second counter whereas it is clearly independent from the change made by CPU 0, and that's why we are slow.
How can we solve then ? well by making sure that the counters lie on different cache lines and that's where we can use the ``repr`` attribute.

In Rust, we can specify the alignment we want for our type with the ``repr(align)`` attribute. We use it like this : 

```rust
#[repr(align(64))]
struct CachePadded(AtomicU64);
```

A data of alignment X is stored in memory at address multiple of X. Knowing this, giving to our counters an alignment equal to the size of a cache line, we ensure that the 2 counters won't be stored in the same cache line !

We can get the size of cache lines with command ``getconf LEVEL1_DCACHE_LINESIZE``. On my laptop the output value is 64.

With those changes we have now a timing of 7.16ms which seems decent given we work with Atomics. Mission succeeded ! 


Finally given my remark at the beginning, I wanted to share a potentially better solution, using local variables in the threads, and channels to communicate these local variables back to the main thread :

```rust
use std::sync::mpsc::channel;
fn main() {
    let (s1,t1) = channel();
    let (s2,t2) = channel();
    let h1 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::<u8>() as u64;
        }
        s1.send(local_counter)
    });
    let h2 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::<u8>() as u64;
        }
        s2.send(local_counter)
    });
    
    h1.join();
    h2.join();
    let counter = Counters{c1: t1.recv().unwrap(),c2: t2.recv().unwrap()};
}
```
It takes 2.03 ms to execute :)


## åŠ¨æ€å’Œé™æ€åˆ†å‘
https://www.reddit.com/r/rust/comments/ruavjm/is_there_a_difference_in_performance_between/


================================================
FILE: src/profiling/performance/deep-into-move.md
================================================
[Binary file]


================================================
FILE: src/profiling/performance/early-optimise.md
================================================
# ç³Ÿç³•çš„æå‰ä¼˜åŒ–


## å‡½æ•°è°ƒç”¨
ç”±äºRustçš„ç¼–è¯‘å™¨å’ŒLLVMå¾ˆå¼ºå¤§ï¼Œå› æ­¤å°±ç®—ä½ ä½¿ç”¨äº†å¤šå±‚å‡½æ•°è°ƒç”¨å»å®Œæˆä¸€ä»¶äº‹(åµŒå¥—å‡½æ•°è°ƒç”¨å¾€å¾€å‡ºäºè®¾è®¡ä¸Šçš„è€ƒè™‘)ï¼Œä¾ç„¶ä¸ä¼šæœ‰æ€§èƒ½ä¸Šçš„å½±å“ï¼Œå› ä¸ºæœ€ç»ˆç”Ÿæˆçš„æœºå™¨ç ä¼šæ¶ˆé™¤è¿™äº›å¤šä½™çš„å‡½æ•°è°ƒç”¨ã€‚

æ€»ä¹‹ç”¨Rustæ—¶ï¼Œä½ ä¸å¿…æ“å¿ƒå¤šä½™çš„å‡½æ•°è°ƒç”¨ï¼Œåªè¦å†™åˆç†çš„ä»£ç ï¼Œç„¶åRustä¼šå¸®åŠ©ä½ è¿è¡Œçš„æ›´å¿«!


================================================
FILE: src/profiling/performance/enum.md
================================================
# Enumå†…å­˜ä¼˜åŒ– todo

https://blog.zhuangty.com/rust-enum-layout/


================================================
FILE: src/profiling/performance/heap-stack.md
================================================
# å †å’Œæ ˆ

https://www.reddit.com/r/rust/comments/rkddg3/stackheap_question_regarding_performance/


================================================
FILE: src/profiling/performance/intro.md
================================================
# performance

https://nnethercote.github.io/perf-book/profiling.html

##  How do I profile a Rust web application in production?
https://www.reddit.com/r/rust/comments/rupcux/how_do_i_profile_a_rust_web_application_in/

https://zhuanlan.zhihu.com/p/191655266

## å†…å­˜å¯¹é½
https://www.reddit.com/r/rust/comments/s793x7/force_4byte_memory_alignment/

## riggrep ä¸ºå•¥è¿™ä¹ˆå¿«
https://www.reddit.com/r/rust/comments/sr02aj/what_makes_ripgrep_so_fast/

## æµ‹è¯•å †æ€§èƒ½
https://flakm.github.io/posts/heap_allocation/


================================================
FILE: src/profiling/performance/runtime-check.md
================================================
# å‡å°‘runtime check

https://www.reddit.com/r/rust/comments/sx8b7m/how_is_rust_able_to_elide_bounds_checks/

## å‡å°‘é›†åˆè®¿é—®çš„è¾¹ç•Œæ£€æŸ¥

ä»¥ä¸‹ä»£ç ï¼Œæˆ‘ä»¬å®ç°äº†ä¸¤ç§å¾ªç¯æ–¹å¼ï¼š
```rust
// ç¬¬ä¸€ç§
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// ç¬¬äºŒç§
for item in collection {

}
```

ç¬¬ä¸€ç§æ–¹å¼æ˜¯å¾ªç¯ç´¢å¼•ï¼Œç„¶åé€šè¿‡ç´¢å¼•ä¸‹æ ‡å»è®¿é—®é›†åˆï¼Œç¬¬äºŒç§æ–¹å¼æ˜¯ç›´æ¥å¾ªç¯è¿­ä»£é›†åˆä¸­çš„å…ƒç´ ï¼Œä¼˜åŠ£å¦‚ä¸‹ï¼š
- **æ€§èƒ½**ï¼šç¬¬ä¸€ç§ä½¿ç”¨æ–¹å¼ä¸­`collection[index]`çš„ç´¢å¼•è®¿é—®ï¼Œä¼šå› ä¸ºè¾¹ç•Œæ£€æŸ¥(bounds checking)å¯¼è‡´è¿è¡Œæ—¶çš„æ€§èƒ½æŸè€— - Rustä¼šæ£€æŸ¥å¹¶ç¡®è®¤`index`æ˜¯è½åœ¨é›†åˆå†…ä¹Ÿå°±æ˜¯åˆæ³•çš„ï¼Œä½†æ˜¯ç¬¬äºŒç§ç›´æ¥è¿­ä»£çš„æ–¹å¼å°±ä¸ä¼šè§¦å‘è¿™ç§æ£€æŸ¥,å› ä¸ºç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶å°±å®Œæˆåˆ†æå¹¶è¯æ˜è¿™ç§è®¿é—®æ˜¯åˆæ³•çš„`

## Box::leak
https://www.reddit.com/r/rust/comments/rntx7s/why_use_boxleak/


## bounds check
https://www.reddit.com/r/rust/comments/rnbubh/whats_the_big_deal_with_bounds_checking/

https://www.reddit.com/r/rust/comments/s6u65e/optimization_of_bubble_sort_fails_without_hinting/

## ä½¿ç”¨assert ä¼˜åŒ–æ£€æŸ¥æ€§èƒ½
https://www.reddit.com/r/rust/comments/rui1zz/write_assertions_that_clarify_code_to_both_the/



================================================
FILE: src/profiling/performance/string.md
================================================
https://www.reddit.com/r/rust/comments/t06hk7/string_concatenations_benchmarks_updated/


================================================
FILE: src/profiling/performance/tools.md
================================================
# å¸¸ç”¨æ€§èƒ½æµ‹è¯•å·¥å…·


https://era.co/blog/unbuffered-io-slows-rust-programs

# profiling
https://www.reddit.com/r/rust/comments/rxj81f/rust_profiling/


================================================
FILE: src/profiling/profiling/performance/benchmark.md
================================================
# Benchmarkæ€§èƒ½æµ‹è¯•(todo)



================================================
FILE: src/std/hashmap.md
================================================
# HashMap



================================================
FILE: src/std/intro.md
================================================
# æ ‡å‡†åº“è§£æ



================================================
FILE: src/std/iterator.md
================================================
# Iteratorå¸¸ç”¨æ–¹æ³•



================================================
FILE: src/std/search.md
================================================
# æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ

## å¯»æ‰¾ä½ æƒ³è¦çš„å†…å®¹

https://www.reddit.com/r/rust/comments/rk8lf6/how_do_you_find_all_the_functions_available_for_a/

## å¦‚ä½•é˜…è¯»å’Œä½¿ç”¨æ ‡å‡†åº“





================================================
FILE: src/std/vector.md
================================================
# Vectorå¸¸ç”¨æ–¹æ³•



================================================
FILE: src/templates/intro.md
================================================
# åœºæ™¯æ¨¡ç‰ˆ



================================================
FILE: src/templates/files/dir.md
================================================
# ç›®å½•



================================================
FILE: src/templates/files/intro.md
================================================
# æ–‡ä»¶æ“ä½œ



================================================
FILE: src/templates/http/intro.md
================================================
# Httpè¯·æ±‚



================================================
FILE: src/test/assertion.md
================================================
[Binary file]


================================================
FILE: src/test/benchmark.md
================================================
# åŸºå‡†æµ‹è¯• benchmark

å‡ ä¹æ‰€æœ‰å¼€å‘éƒ½çŸ¥é“ï¼Œå¦‚æœè¦æµ‹é‡ç¨‹åºçš„æ€§èƒ½ï¼Œå°±éœ€è¦æ€§èƒ½æµ‹è¯•ã€‚

æ€§èƒ½æµ‹è¯•åŒ…å«äº†ä¸¤ç§ï¼šå‹åŠ›æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•ã€‚å‰è€…æ˜¯é’ˆå¯¹æ¥å£ APIï¼Œæ¨¡æ‹Ÿå¤§é‡ç”¨æˆ·å»è®¿é—®æ¥å£ç„¶åç”Ÿæˆæ¥å£çº§åˆ«çš„æ€§èƒ½æ•°æ®ï¼›è€Œåè€…æ˜¯é’ˆå¯¹ä»£ç ï¼Œå¯ä»¥ç”¨æ¥æµ‹è¯•æŸä¸€æ®µä»£ç çš„è¿è¡Œé€Ÿåº¦ï¼Œä¾‹å¦‚ä¸€ä¸ªæ’åºç®—æ³•ã€‚

è€Œæœ¬æ–‡å°†è¦ä»‹ç»çš„å°±æ˜¯åŸºå‡†æµ‹è¯• `benchmark`ï¼Œåœ¨ Rust ä¸­ï¼Œæœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å®ç°ï¼š

- å®˜æ–¹æä¾›çš„ `benchmark`
- ç¤¾åŒºå®ç°ï¼Œä¾‹å¦‚ `criterion.rs`

äº‹å®ä¸Šæˆ‘ä»¬æ›´æ¨èåè€…ï¼ŒåŸå› åœ¨åæ–‡ä¼šè¯¦ç»†ä»‹ç»ï¼Œä¸‹é¢å…ˆä»å®˜æ–¹æä¾›çš„å·¥å…·å¼€å§‹ã€‚

## å®˜æ–¹ benchmark

å®˜æ–¹æä¾›çš„æµ‹è¯•å·¥å…·ï¼Œç›®å‰æœ€å¤§çš„é—®é¢˜å°±æ˜¯åªèƒ½åœ¨é `stable` ä¸‹ä½¿ç”¨ï¼ŒåŸå› æ˜¯éœ€è¦åœ¨ä»£ç ä¸­å¼•å…¥ `test` ç‰¹æ€§: `#![feature(test)]`ã€‚

#### è®¾ç½® Rust ç‰ˆæœ¬

å› æ­¤åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå°†å½“å‰ä»“åº“ä¸­çš„ [`Rust ç‰ˆæœ¬`](https://course.rs/appendix/rust-version.html#ä¸ç¨³å®šåŠŸèƒ½)ä» `stable` åˆ‡æ¢ä¸º `nightly`:

1. å®‰è£… `nightly` ç‰ˆæœ¬ï¼š`$ rustup install nightly`
2. ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç¡®è®¤ç‰ˆæœ¬å·²ç»å®‰è£…æˆåŠŸ

```shell
$ rustup toolchain list
stable-aarch64-apple-darwin (default)
nightly-aarch64-apple-darwin (override)
```

3. è¿›å…¥ `adder` é¡¹ç›®(ä¹‹å‰ä¸ºäº†å­¦ä¹ æµ‹è¯•ä¸“é—¨åˆ›å»ºçš„é¡¹ç›®)çš„æ ¹ç›®å½•ï¼Œç„¶åè¿è¡Œ `rustup override set nightly`ï¼Œå°†è¯¥é¡¹ç›®ä½¿ç”¨çš„ `rust` è®¾ç½®ä¸º `nightly`

å¾ˆç®€å•å§ï¼Œå…¶å®åªè¦ä¸€ä¸ªå‘½ä»¤å°±å¯ä»¥åˆ‡æ¢æŒ‡å®šé¡¹ç›®çš„ Rust ç‰ˆæœ¬ï¼Œä¾‹å¦‚ä½ è¿˜èƒ½åœ¨åŸºå‡†æµ‹è¯•åå†ä½¿ç”¨ `rustup override set stable` åˆ‡æ¢å› `stable` ç‰ˆæœ¬ã€‚

#### ä½¿ç”¨ benchmark

å½“å®Œæˆç‰ˆæœ¬åˆ‡æ¢åï¼Œå°±å¯ä»¥å¼€å§‹æ­£å¼ç¼–å†™ `benchmark` ä»£ç äº†ã€‚é¦–å…ˆï¼Œå°† `src/lib.rs` ä¸­çš„å†…å®¹æ›¿æ¢æˆå¦‚ä¸‹ä»£ç ï¼š

```rust
#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &mut Bencher) {
        b.iter(|| add_two(2));
    }
}
```

å¯ä»¥çœ‹å‡ºï¼Œ`benchmark` è·Ÿå•å…ƒæµ‹è¯•åŒºåˆ«ä¸å¤§ï¼Œæœ€å¤§çš„åŒºåˆ«åœ¨äºå®ƒæ˜¯é€šè¿‡ `#[bench]` æ ‡æ³¨ï¼Œè€Œå•å…ƒæµ‹è¯•æ˜¯é€šè¿‡ `#[test]` è¿›è¡Œæ ‡æ³¨ï¼Œè¿™æ„å‘³ç€ `cargo test` å°†ä¸ä¼šè¿è¡Œ `benchmark` ä»£ç ï¼š

```shell
$ cargo test
running 2 tests
test tests::bench_add_two ... ok
test tests::it_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

`cargo test` ç›´æ¥æŠŠæˆ‘ä»¬çš„ `benchmark` ä»£ç å½“ä½œå•å…ƒæµ‹è¯•å¤„ç†äº†ï¼Œå› æ­¤æ²¡æœ‰ä»»ä½•æ€§èƒ½æµ‹è¯•çš„ç»“æœäº§ç”Ÿã€‚

å¯¹æ­¤ï¼Œéœ€è¦ä½¿ç”¨ `cargo bench` å‘½ä»¤ï¼š

```shell
$ cargo bench
running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:           0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured; 0 filtered out; finished in 0.29s
```

çœ‹åˆ°æ²¡ï¼Œä¸€ä¸ªæˆªç„¶ä¸åŒçš„ç»“æœï¼Œé™¤æ­¤ä¹‹å¤–è¿˜èƒ½çœ‹å‡ºå‡ ç‚¹:

- å•å…ƒæµ‹è¯• `it_works` è¢«å¿½ç•¥ï¼Œå¹¶æ²¡æœ‰æ‰§è¡Œ: `tests::it_works ... ignored`
- benchmark çš„ç»“æœæ˜¯ `0 ns/iter`ï¼Œè¡¨ç¤ºæ¯æ¬¡è¿­ä»£( `b.iter` )è€—æ—¶ `0 ns`ï¼Œå¥‡æ€ªï¼Œæ€ä¹ˆæ˜¯ `0` çº³ç§’å‘¢ï¼Ÿåˆ«æ€¥ï¼ŒåŸå› åé¢ä¼šè®²

#### ä¸€äº›ä½¿ç”¨å»ºè®®

å…³äº `benchmark`ï¼Œè¿™é‡Œæœ‰ä¸€äº›ä½¿ç”¨å»ºè®®å€¼å¾—å¤§å®¶å…³æ³¨:

- å°†åˆå§‹åŒ–ä»£ç ç§»åŠ¨åˆ° `b.iter` å¾ªç¯ä¹‹å¤–ï¼Œå¦åˆ™æ¯æ¬¡å¾ªç¯è¿­ä»£éƒ½ä¼šåˆå§‹åŒ–ä¸€æ¬¡ï¼Œè¿™é‡Œåªåº”è¯¥å­˜æ”¾éœ€è¦ç²¾å‡†æµ‹è¯•çš„ä»£ç 
- è®©ä»£ç æ¯æ¬¡éƒ½åšä¸€æ ·çš„äº‹æƒ…ï¼Œä¾‹å¦‚ä¸è¦å»åšç´¯åŠ æˆ–çŠ¶æ€æ›´æ”¹çš„æ“ä½œ
- æœ€å¥½è®© `iter` ä¹‹å¤–çš„ä»£ç ä¹Ÿå…·æœ‰å¹‚ç­‰æ€§ï¼Œå› ä¸ºå®ƒä¹Ÿå¯èƒ½è¢« `benchmark` è¿è¡Œå¤šæ¬¡
- å¾ªç¯å†…çš„ä»£ç åº”è¯¥å°½é‡çš„çŸ­å°å¿«é€Ÿï¼Œå› ä¸ºè¿™æ ·å¾ªç¯æ‰èƒ½è¢«å°½å¯èƒ½å¤šçš„æ‰§è¡Œï¼Œç»“æœä¹Ÿä¼šæ›´åŠ å‡†ç¡®

#### è°œä¸€èˆ¬çš„æ€§èƒ½ç»“æœ

åœ¨å†™ `benchmark` æ—¶ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°ä¸€äº›å¾ˆçº³é—·çš„æ£˜æ‰‹é—®é¢˜ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç :

```rust
#![feature(test)]

extern crate test;

fn fibonacci_u64(number: u64) -> u64 {
    let mut last: u64 = 1;
    let mut current: u64 = 0;
    let mut buffer: u64;
    let mut position: u64 = 1;

    return loop {
        if position == number {
            break current;
        }

        buffer = last;
        last = current;
        current = buffer + current;
        position += 1;
    };
}
#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
       assert_eq!(fibonacci_u64(1), 0);
       assert_eq!(fibonacci_u64(2), 1);
       assert_eq!(fibonacci_u64(12), 89);
       assert_eq!(fibonacci_u64(30), 514229);
    }

    #[bench]
    fn bench_u64(b: &mut Bencher) {
        b.iter(|| {
            for i in 100..200 {
                fibonacci_u64(i);
            }
        });
    }
}
```

é€šè¿‡`cargo bench`è¿è¡Œåï¼Œå¾—åˆ°ä¸€ä¸ªéš¾ä»¥ç½®ä¿¡çš„ç»“æœï¼š`test tests::bench_u64 ... bench: 0 ns/iter (+/- 0)`, éš¾é“ Rust å·²ç»åˆ°è¾¾é‡å­è®¡ç®—æœºçº§åˆ«äº†ï¼Ÿ

å…¶å®ï¼ŒåŸå› è—åœ¨`LLVM`ä¸­: `LLVM`è®¤ä¸º`fibonacci_u64`å‡½æ•°è°ƒç”¨çš„ç»“æœæ²¡æœ‰ä½¿ç”¨ï¼ŒåŒæ—¶ä¹Ÿè®¤ä¸ºè¯¥å‡½æ•°æ²¡æœ‰ä»»ä½•å‰¯ä½œç”¨(é€ æˆå…¶å®ƒçš„å½±å“ï¼Œä¾‹å¦‚ä¿®æ”¹å¤–éƒ¨å˜é‡ã€è®¿é—®ç½‘ç»œç­‰), å› æ­¤å®ƒæœ‰ç†ç”±æŠŠè¿™ä¸ªå‡½æ•°è°ƒç”¨ä¼˜åŒ–æ‰ï¼

è§£å†³å¾ˆç®€å•ï¼Œä½¿ç”¨ Rust æ ‡å‡†åº“ä¸­çš„ `black_box` å‡½æ•°:

```rust
 for i in 100..200 {
    test::black_box(fibonacci_u64(test::black_box(i)));
}
```

é€šè¿‡è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè®©å®ƒå°½é‡å°‘åšä¼˜åŒ–ï¼Œæ­¤æ—¶ LLVM å°±ä¸ä¼šå†è‡ªä½œä¸»å¼ äº†:)

```shell
$ cargo bench
running 2 tests
test tests::it_works ... ignored
test tests::bench_u64 ... bench:       5,626 ns/iter (+/- 267)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured; 0 filtered out; finished in 0.67s
```

å—¯ï¼Œè¿™æ¬¡ç»“æœå°±æ˜æ˜¾æ­£å¸¸äº†ã€‚

## criterion.rs

å®˜æ–¹ `benchmark` æœ‰ä¸¤ä¸ªé—®é¢˜ï¼Œé¦–å…ˆå°±æ˜¯ä¸æ”¯æŒ `stable` ç‰ˆæœ¬çš„ Rustï¼Œå…¶æ¬¡æ˜¯ç»“æœæœ‰äº›ç®€å•ï¼Œç¼ºå°‘æ›´è¯¦ç»†çš„ç»Ÿè®¡åˆ†å¸ƒã€‚

å› æ­¤ç¤¾åŒº `benchmark` å°±åº”è¿è€Œç”Ÿï¼Œå…¶ä¸­æœ€æœ‰åçš„å°±æ˜¯ [`criterion.rs`](https://github.com/bheisler/criterion.rs)ï¼Œå®ƒæœ‰å‡ ä¸ªé‡è¦ç‰¹æ€§:

- ç»Ÿè®¡åˆ†æï¼Œä¾‹å¦‚å¯ä»¥è·Ÿä¸Šä¸€æ¬¡è¿è¡Œçš„ç»“æœè¿›è¡Œå·®å¼‚æ¯”å¯¹
- å›¾è¡¨ï¼Œä½¿ç”¨ [`gnuplots`](http://www.gnuplot.info) å±•ç¤ºè¯¦ç»†çš„ç»“æœå›¾è¡¨

é¦–å…ˆï¼Œå¦‚æœä½ éœ€è¦å›¾è¡¨ï¼Œéœ€è¦å…ˆå®‰è£… `gnuplots`ï¼Œå…¶æ¬¡ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥ç›¸å…³çš„åŒ…ï¼Œåœ¨ `Cargo.toml` æ–‡ä»¶ä¸­æ–°å¢ :

```toml
[dev-dependencies]
criterion = "0.3"

[[bench]]
name = "my_benchmark"
harness = false
```

æ¥ç€ï¼Œåœ¨é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶: `$PROJECT/benches/my_benchmark.rs`ï¼Œç„¶ååŠ å…¥ä»¥ä¸‹å†…å®¹ï¼š

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

æœ€åï¼Œä½¿ç”¨ `cargo bench` è¿è¡Œå¹¶è§‚å¯Ÿç»“æœï¼š

```shell
     Running target/release/deps/example-423eedc43b2b3a93
Benchmarking fib 20
Benchmarking fib 20: Warming up for 3.0000 s
Benchmarking fib 20: Collecting 100 samples in estimated 5.0658 s (188100 iterations)
Benchmarking fib 20: Analyzing
fib 20                  time:   [26.029 us 26.251 us 26.505 us]
Found 11 outliers among 99 measurements (11.11%)
  6 (6.06%) high mild
  5 (5.05%) high severe
slope  [26.029 us 26.505 us] R^2            [0.8745662 0.8728027]
mean   [26.106 us 26.561 us] std. dev.      [808.98 ns 1.4722 us]
median [25.733 us 25.988 us] med. abs. dev. [234.09 ns 544.07 ns]
```

å¯ä»¥çœ‹å‡ºï¼Œè¿™ä¸ªç»“æœæ˜¯æ˜æ˜¾æ¯”å®˜æ–¹çš„æ›´è¯¦å°½çš„ï¼Œå¦‚æœå¤§å®¶å¸Œæœ›æ›´æ·±å…¥çš„å­¦ä¹ å®ƒçš„ä½¿ç”¨ï¼Œå¯ä»¥å‚è§[å®˜æ–¹æ–‡æ¡£](https://bheisler.github.io/criterion.rs/book/getting_started.html)ã€‚



================================================
FILE: src/test/ci.md
================================================
[Binary file]


================================================
FILE: src/test/intro.md
================================================
[Binary file]


================================================
FILE: src/test/unit-integration-test.md
================================================
# å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•

åœ¨äº†è§£äº†å¦‚ä½•åœ¨ Rust ä¸­å†™æµ‹è¯•ç”¨ä¾‹åï¼Œæœ¬ç« èŠ‚æˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å®ç°å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ï¼Œå…¶å®å®ƒä»¬ç”¨åˆ°çš„æŠ€æœ¯è¿˜æ˜¯[ä¸Šä¸€ç« èŠ‚](https://course.rs/test/write-tests.html)ä¸­çš„æµ‹è¯•æŠ€æœ¯ï¼Œåªä¸è¿‡å¯¹å¦‚ä½•ç»„ç»‡æµ‹è¯•ä»£ç æå‡ºäº†æ–°çš„è¦æ±‚ã€‚

## å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•ç›®æ ‡æ˜¯æµ‹è¯•æŸä¸€ä¸ªä»£ç å•å…ƒ(ä¸€èˆ¬éƒ½æ˜¯å‡½æ•°)ï¼ŒéªŒè¯è¯¥å•å…ƒæ˜¯å¦èƒ½æŒ‰ç…§é¢„æœŸè¿›è¡Œå·¥ä½œï¼Œä¾‹å¦‚æµ‹è¯•ä¸€ä¸ª `add` å‡½æ•°ï¼ŒéªŒè¯å½“ç»™äºˆä¸¤ä¸ªè¾“å…¥æ—¶ï¼Œæœ€ç»ˆè¿”å›çš„å’Œæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚

åœ¨ Rust ä¸­ï¼Œå•å…ƒæµ‹è¯•çš„æƒ¯ä¾‹æ˜¯å°†æµ‹è¯•ä»£ç çš„æ¨¡å—è·Ÿå¾…æµ‹è¯•çš„æ­£å¸¸ä»£ç æ”¾å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œä¾‹å¦‚ `src/lib.rs` æ–‡ä»¶ä¸­æœ‰å¦‚ä¸‹ä»£ç :

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(add_two(2), 4);
    }
}
```

`add_two` æ˜¯æˆ‘ä»¬çš„é¡¹ç›®ä»£ç ï¼Œä¸ºäº†å¯¹å®ƒè¿›è¡Œæµ‹è¯•ï¼Œæˆ‘ä»¬åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­ç¼–å†™äº†æµ‹è¯•æ¨¡å— `tests`ï¼Œå¹¶ä½¿ç”¨ `#[cfg(test)]` è¿›è¡Œäº†æ ‡æ³¨ã€‚

#### æ¡ä»¶ç¼–è¯‘ `#[cfg(test)]`

ä¸Šé¢ä»£ç ä¸­çš„ `#[cfg(test)]` æ ‡æ³¨å¯ä»¥å‘Šè¯‰ Rust åªæœ‰åœ¨ `cargo test` æ—¶æ‰ç¼–è¯‘å’Œè¿è¡Œæ¨¡å— `tests`ï¼Œå…¶å®ƒæ—¶å€™å½“è¿™æ®µä»£ç æ˜¯ç©ºæ°”å³å¯ï¼Œä¾‹å¦‚åœ¨ `cargo build` æ—¶ã€‚è¿™ä¹ˆåšæœ‰å‡ ä¸ªå¥½å¤„ï¼š

- èŠ‚çœæ„å»ºä»£ç æ—¶çš„ç¼–è¯‘æ—¶é—´
- å‡å°ç¼–è¯‘å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶çš„ä½“ç§¯

å…¶å®é›†æˆæµ‹è¯•å°±ä¸éœ€è¦è¿™ä¸ªæ ‡æ³¨ï¼Œå› ä¸ºå®ƒä»¬è¢«æ”¾å…¥å•ç‹¬çš„ç›®å½•æ–‡ä»¶ä¸­ï¼Œè€Œå•å…ƒæµ‹è¯•æ˜¯è·Ÿæ­£å¸¸çš„é€»è¾‘ä»£ç åœ¨åŒä¸€ä¸ªæ–‡ä»¶ï¼Œå› æ­¤å¿…é¡»å¯¹å…¶è¿›è¡Œç‰¹æ®Šçš„æ ‡æ³¨ï¼Œä»¥ä¾¿ Rust å¯ä»¥è¯†åˆ«ã€‚

åœ¨ `#[cfg(test)]` ä¸­ï¼Œ`cfg` æ˜¯é…ç½® `configuration` çš„ç¼©å†™ï¼Œå®ƒå‘Šè¯‰ Rust ï¼šå½“ `test` é…ç½®é¡¹å­˜åœ¨æ—¶ï¼Œæ‰è¿è¡Œä¸‹é¢çš„ä»£ç ï¼Œè€Œ `cargo test` åœ¨è¿è¡Œæ—¶ï¼Œå°±ä¼šå°† `test` è¿™ä¸ªé…ç½®é¡¹ä¼ å…¥è¿›æ¥ï¼Œå› æ­¤åé¢çš„ `tests` æ¨¡å—ä¼šè¢«åŒ…å«è¿›æ¥ã€‚

å¤§å®¶çœ‹å‡ºæ¥äº†å—ï¼Ÿè¿™æ˜¯å…¸å‹çš„æ¡ä»¶ç¼–è¯‘ï¼Œ`Cargo` ä¼šæ ¹æ®æŒ‡å®šçš„é…ç½®æ¥é€‰æ‹©æ˜¯å¦ç¼–è¯‘æŒ‡å®šçš„ä»£ç ï¼Œäº‹å®ä¸Šå…³äºæ¡ä»¶ç¼–è¯‘ Rust èƒ½åšçš„ä¸ä»…ä»…æ˜¯è¿™äº›ï¼Œåœ¨ [`Cargo` ä¸“é¢˜](https://course.rs/cargo/intro.html)ä¸­æˆ‘ä»¬ä¼šè¿›è¡Œæ›´ä¸ºè¯¦ç»†çš„ä»‹ç»ã€‚

#### æµ‹è¯•ç§æœ‰å‡½æ•°

å…³äºç§æœ‰å‡½æ•°èƒ½å¦è¢«ç›´æ¥æµ‹è¯•ï¼Œç¼–ç¨‹ç¤¾åŒºé‡Œä¸€ç›´äº‰è®ºä¸ä¼‘ï¼Œç”šè‡³äºéƒ¨åˆ†è¯­è¨€å¯èƒ½éƒ½ä¸æ”¯æŒå¯¹ç§æœ‰å‡½æ•°è¿›è¡Œæµ‹è¯•æˆ–è€…éš¾ä»¥æµ‹è¯•ã€‚æ— è®ºä½ çš„ç«‹åœºå¦‚ä½•ï¼Œåæ­£ Rust æ˜¯æ”¯æŒå¯¹ç§æœ‰å‡½æ•°è¿›è¡Œæµ‹è¯•çš„:

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

`internal_adder` å¹¶æ²¡æœ‰ä½¿ç”¨ `pub` è¿›è¡Œå£°æ˜ï¼Œå› æ­¤å®ƒæ˜¯ä¸€ä¸ªç§æœ‰å‡½æ•°ã€‚æ ¹æ®æˆ‘ä»¬ä¹‹å‰[å­¦è¿‡çš„å†…å®¹]()ï¼Œ`tests` ä½œä¸ºå¦ä¸€ä¸ªæ¨¡å—ï¼Œæ˜¯ç»å¯¹æ— æ³•å¯¹å®ƒè¿›è¡Œè°ƒç”¨çš„ï¼Œå› ä¸ºå®ƒä»¬æ ¹æœ¬ä¸åœ¨åŒä¸€ä¸ªæ¨¡å—ä¸­ï¼

ä½†æ˜¯åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `use super::*;` å°† `tests` çš„çˆ¶æ¨¡å—ä¸­çš„æ‰€æœ‰å†…å®¹å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œè¿™æ ·å°±å¯ä»¥éå¸¸ç®€å•çš„å®ç°å¯¹ç§æœ‰å‡½æ•°çš„æµ‹è¯•ã€‚

## é›†æˆæµ‹è¯•

ä¸å•å…ƒæµ‹è¯•çš„åŒåƒåŒä½ä¸åŒï¼Œé›†æˆæµ‹è¯•çš„ä»£ç æ˜¯åœ¨ä¸€ä¸ªå•ç‹¬çš„ç›®å½•ä¸‹çš„ã€‚ç”±äºå®ƒä»¬ä½¿ç”¨è·Ÿå…¶å®ƒæ¨¡å—ä¸€æ ·çš„æ–¹å¼å»è°ƒç”¨ä½ æƒ³è¦æµ‹è¯•çš„ä»£ç ï¼Œå› æ­¤åªèƒ½è°ƒç”¨é€šè¿‡ `pub` å®šä¹‰çš„ `API`ï¼Œè¿™ä¸€ç‚¹ä¸å•å…ƒæµ‹è¯•æœ‰å¾ˆå¤§çš„ä¸åŒã€‚

å¦‚æœè¯´å•å…ƒæµ‹è¯•æ˜¯å¯¹ä»£ç å•å…ƒè¿›è¡Œæµ‹è¯•ï¼Œé‚£é›†æˆæµ‹è¯•åˆ™æ˜¯å¯¹æŸä¸€ä¸ªåŠŸèƒ½æˆ–è€…æ¥å£è¿›è¡Œæµ‹è¯•ï¼Œå› æ­¤å•å…ƒæµ‹è¯•çš„é€šè¿‡ï¼Œå¹¶ä¸æ„å‘³ç€é›†æˆæµ‹è¯•å°±èƒ½é€šè¿‡ï¼šå±€éƒ¨ä¸Šåæ˜ ä¸å‡ºçš„é—®é¢˜ï¼Œåœ¨å…¨å±€ä¸Šå¾ˆå¯èƒ½ä¼šæš´éœ²å‡ºæ¥ã€‚

#### _tests_ ç›®å½•

ä¸€ä¸ªæ ‡å‡†çš„ Rust é¡¹ç›®ï¼Œåœ¨å®ƒçš„æ ¹ç›®å½•ä¸‹ä¼šæœ‰ä¸€ä¸ª `tests` ç›®å½•ï¼Œå¤§åé¼é¼çš„ [`ripgrep`](https://github.com/BurntSushi/ripgrep) ä¹Ÿä¸èƒ½å…ä¿—ã€‚

æ²¡é”™ï¼Œè¯¥ç›®å½•å°±æ˜¯ç”¨æ¥å­˜æ”¾é›†æˆæµ‹è¯•çš„ï¼ŒCargo ä¼šè‡ªåŠ¨æ¥æ­¤ç›®å½•ä¸‹å¯»æ‰¾é›†æˆæµ‹è¯•æ–‡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¯¥ç›®å½•ä¸‹åˆ›å»ºä»»ä½•æ–‡ä»¶ï¼ŒCargo ä¼šå¯¹æ¯ä¸ªæ–‡ä»¶éƒ½è¿›è¡Œè‡ªåŠ¨ç¼–è¯‘ï¼Œä½†å‹æƒ…æç¤ºä¸‹ï¼Œæœ€å¥½æŒ‰ç…§åˆé€‚çš„é€»è¾‘æ¥ç»„ç»‡ä½ çš„æµ‹è¯•ä»£ç ã€‚

é¦–å…ˆæ¥åˆ›å»ºä¸€ä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶ `tests/integration_test.rs` ï¼Œæ³¨æ„ï¼Œ`tests` ç›®å½•ä¸€èˆ¬æ¥è¯´éœ€è¦æ‰‹åŠ¨åˆ›å»ºï¼Œè¯¥ç›®å½•åœ¨é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹ï¼Œè·Ÿ `src` ç›®å½•åŒçº§ã€‚ç„¶ååœ¨æ–‡ä»¶ä¸­å¡«å…¥å¦‚ä¸‹æµ‹è¯•ä»£ç ï¼š

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
```

è¿™æ®µæµ‹è¯•ä»£ç æ˜¯å¯¹ä¹‹å‰**ç§æœ‰å‡½æ•°**ä¸­çš„ç¤ºä¾‹è¿›è¡Œæµ‹è¯•ï¼Œè¯¥ç¤ºä¾‹ä»£ç åœ¨ `src/lib.rs` ä¸­ã€‚

é¦–å…ˆä¸å•å…ƒæµ‹è¯•æœ‰æ‰€ä¸åŒï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰åˆ›å»ºæµ‹è¯•æ¨¡å—ã€‚å…¶æ¬¡ï¼Œ`tests` ç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„åŒ…ï¼Œæˆ‘ä»¬éœ€è¦å°†å¾…æµ‹è¯•çš„åŒ…å¼•å…¥åˆ°å½“å‰åŒ…çš„ä½œç”¨åŸŸå: `use adder`ï¼Œæ‰èƒ½è¿›è¡Œæµ‹è¯• ã€‚å¤§å®¶åº”è¯¥è¿˜è®°å¾—[åŒ…å’Œæ¨¡å—ç« èŠ‚](https://course.rs/advance/crate-module/crate.html)ä¸­è®²è¿‡çš„å†…å®¹å§ï¼Ÿåœ¨åˆ›å»ºé¡¹ç›®åï¼Œ`src/lib.rs` è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªä¸é¡¹ç›®åŒåçš„ `lib` ç±»å‹çš„åŒ…ï¼Œç”±äºæˆ‘ä»¬çš„é¡¹ç›®åæ˜¯ `adder`ï¼Œå› æ­¤åŒ…åä¹Ÿæ˜¯ `adder`ã€‚

å› ä¸º `tests` ç›®å½•æœ¬èº«å°±è¯´æ˜äº†å®ƒçš„ç‰¹æ®Šç”¨é€”ï¼Œå› æ­¤æˆ‘ä»¬æ— éœ€å†ä½¿ç”¨ `#[cfg(test)]` æ¥å–æ‚¦ Cargoã€‚åè€…ä¼šåœ¨è¿è¡Œ `cargo test` æ—¶ï¼Œå¯¹ `tests` ç›®å½•ä¸­çš„æ¯ä¸ªæ–‡ä»¶éƒ½è¿›è¡Œç¼–è¯‘è¿è¡Œã€‚

```shell
$ cargo test
     Running unittests (target/debug/deps/adder-8a400aa2b5212836)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-2d3aeee6f15d1f20)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

è¿è¡Œ `cargo test` ï¼Œå¯ä»¥çœ‹åˆ°ä¸Šè¿°è¾“å‡ºã€‚æµ‹è¯•å†…å®¹æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼šå•å…ƒæµ‹è¯•ï¼Œé›†æˆæµ‹è¯•å’Œæ–‡æ¡£æµ‹è¯•ã€‚

é¦–å…ˆæ˜¯å•å…ƒæµ‹è¯•è¢«è¿è¡Œ `Running unittests` ï¼Œå…¶æ¬¡å°±æ˜¯æˆ‘ä»¬çš„ä¸»è§’é›†æˆæµ‹è¯•çš„è¿è¡Œ `Running tests/integration_test.rs`ï¼Œå¯ä»¥çœ‹å‡ºï¼Œé›†æˆæµ‹è¯•çš„è¾“å‡ºå†…å®¹ä¸å•å…ƒæµ‹è¯•å¹¶æ²¡æœ‰å¤§çš„åŒºåˆ«ã€‚æœ€åè¿è¡Œçš„æ˜¯æ–‡æ¡£æµ‹è¯• `Doc-tests adder`ã€‚

ä¸å•å…ƒæµ‹è¯•ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡[æŒ‡å®šåç§°çš„æ–¹å¼](https://course.rs/test/write-tests.html#æŒ‡å®šè¿è¡Œä¸€éƒ¨åˆ†æµ‹è¯•)æ¥è¿è¡Œç‰¹å®šçš„é›†æˆæµ‹è¯•ç”¨ä¾‹:

```shell
$ cargo test --test integration_test
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

è¿™æ¬¡ï¼Œå•å…ƒæµ‹è¯•ã€æ–‡æ¡£æµ‹è¯•å•¥çš„éƒ½æ²¡æœ‰è¿è¡Œï¼Œåªæœ‰é›†æˆæµ‹è¯•ç›®å½•ä¸‹çš„ `integration_test` æ–‡ä»¶è¢«é¡ºåˆ©æ‰§è¡Œã€‚

å¤§å®¶å¯ä»¥å°è¯•ä¸‹åœ¨åŒä¸€ä¸ªæµ‹è¯•æ–‡ä»¶ä¸­æ·»åŠ æ›´å¤šçš„æµ‹è¯•ç”¨ä¾‹æˆ–è€…æ·»åŠ æ›´å¤šçš„æµ‹è¯•æ–‡ä»¶ï¼Œå¹¶è§‚å¯Ÿæµ‹è¯•è¾“å‡ºä¼šå¦‚ä½•å˜åŒ–ã€‚

#### å…±äº«æ¨¡å—

åœ¨é›†æˆæµ‹è¯•çš„ `tests` ç›®å½•ä¸‹ï¼Œæ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŒ…ï¼Œè¿™ç§ç»„ç»‡æ–¹å¼å¯ä»¥å¾ˆå¥½çš„å¸®åŠ©æˆ‘ä»¬ç†æ¸…æµ‹è¯•ä»£ç çš„å…³ç³»ï¼Œä½†æ˜¯å¦‚æœå¤§å®¶æƒ³è¦åœ¨å¤šä¸ªæ–‡ä»¶ä¸­å…±äº«åŒä¸€ä¸ªåŠŸèƒ½è¯¥æ€ä¹ˆåšï¼Ÿä¾‹å¦‚å‡½æ•° `setup` å¯ä»¥ç”¨äºçŠ¶æ€åˆå§‹åŒ–ï¼Œç„¶åå¤šä¸ªæµ‹è¯•åŒ…éƒ½éœ€è¦ä½¿ç”¨è¯¥å‡½æ•°è¿›è¡ŒçŠ¶æ€çš„åˆå§‹åŒ–ã€‚

ä¹Ÿè®¸ä½ ä¼šæƒ³è¦åˆ›å»ºä¸€ä¸ª `tests/common.rs` æ–‡ä»¶ï¼Œç„¶åå°† `setup` å‡½æ•°æ”¾å…¥å…¶ä¸­ï¼š

```rust
pub fn setup() {
    // åˆå§‹åŒ–ä¸€äº›æµ‹è¯•çŠ¶æ€
    // ...
}
```

ä½†æ˜¯å½“æˆ‘ä»¬è¿è¡Œ `cargo test` åï¼Œä¼šå‘ç°è¯¥å‡½æ•°è¢«å½“ä½œé›†æˆæµ‹è¯•å‡½æ•°è¿è¡Œäº†ï¼Œå³ä½¿å®ƒå¹¶æ²¡æœ‰åŒ…å«ä»»ä½•æµ‹è¯•åŠŸèƒ½ï¼Œä¹Ÿæ²¡æœ‰è¢«å…¶å®ƒæµ‹è¯•æ–‡ä»¶æ‰€è°ƒç”¨:

```shell
$ cargo test
     Running tests/common.rs (target/debug/deps/common-5c21f4f2c87696fb)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

æ˜¾ç„¶ï¼Œè¿™ä¸ªç»“æœå¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚**ä¸ºäº†é¿å…è¿™ç§è¾“å‡ºï¼Œæˆ‘ä»¬ä¸èƒ½åˆ›å»º `tests/common.rs`ï¼Œè€Œæ˜¯è¦åˆ›å»º `tests/common/mod.rs`ã€‚**ï¼Œæ­¤æ—¶å†è¿è¡Œ `cargo test` å°±ä¸ä¼šå†çœ‹åˆ°ç›¸åº”çš„è¾“å‡ºã€‚ åŸå› æ˜¯**é€šè¿‡è¿™ç§æ–‡ä»¶ç»„ç»‡å’Œå‘½åæ–¹å¼ï¼Œ Rust ä¸å†å°† `common` æ¨¡å—çœ‹ä½œæ˜¯é›†æˆæµ‹è¯•æ–‡ä»¶ã€‚**

æ€»ç»“æ¥è¯´ï¼Œ**`tests` ç›®å½•ä¸‹çš„å­ç›®å½•ä¸­çš„æ–‡ä»¶ä¸ä¼šè¢«å½“ä½œç‹¬ç«‹çš„åŒ…ï¼Œä¹Ÿä¸ä¼šæœ‰æµ‹è¯•è¾“å‡º**ã€‚

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```

æ­¤æ—¶ï¼Œå°±å¯ä»¥åœ¨æµ‹è¯•ä¸­è°ƒç”¨ `common` ä¸­çš„å…±äº«å‡½æ•°äº†ï¼Œä¸è¿‡è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„ï¼Œä¸ºäº†ä½¿ç”¨ `common`ï¼Œè¿™é‡Œä½¿ç”¨äº† `mod common` çš„æ–¹å¼æ¥å£°æ˜è¯¥æ¨¡å—ã€‚

#### äºŒè¿›åˆ¶åŒ…çš„é›†æˆæµ‹è¯•

ç›®å‰æ¥è¯´ï¼ŒRust åªæ”¯æŒå¯¹ `lib` ç±»å‹çš„åŒ…è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œå¯¹äºäºŒè¿›åˆ¶åŒ…ä¾‹å¦‚ `src/main.rs` æ˜¯æ— èƒ½ä¸ºåŠ›çš„ã€‚åŸå› åœ¨äºï¼Œæˆ‘ä»¬æ— æ³•åœ¨å…¶å®ƒåŒ…ä¸­ä½¿ç”¨ `use` å¼•å…¥äºŒè¿›åˆ¶åŒ…ï¼Œè€Œåªæœ‰ `lib` ç±»å‹çš„åŒ…æ‰èƒ½è¢«å¼•å…¥ï¼Œä¾‹å¦‚ `src/lib.rs`ã€‚

è¿™å°±æ˜¯ä¸ºä½•æˆ‘ä»¬éœ€è¦å°†ä»£ç é€»è¾‘ä» `src/main.rs` å‰¥ç¦»å‡ºå»æ”¾å…¥ `lib` åŒ…ä¸­ï¼Œä¾‹å¦‚å¾ˆå¤š Rust é¡¹ç›®ä¸­éƒ½åŒæ—¶æœ‰ `src/main.rs` å’Œ `src/lib.rs` ï¼Œå‰è€…ä¸­åªä¿ç•™ä»£ç çš„ä¸»ä½“è„‰ç»œéƒ¨åˆ†ï¼Œè€Œå…·ä½“çš„å®ç°é€šé€šæ”¾åœ¨ç±»ä¼¼åè€…çš„ `lib` åŒ…ä¸­ã€‚

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¯¹ `lib` åŒ…ä¸­çš„å…·ä½“å®ç°è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œç”±äº `main.rs` ä¸­çš„ä¸»ä½“è„‰ç»œè¶³å¤Ÿç®€å•ï¼Œå½“é›†æˆæµ‹è¯•é€šè¿‡æ—¶ï¼Œæ„å‘³ç€ `main.rs` ä¸­ç›¸åº”çš„è°ƒç”¨ä»£ç ä¹Ÿå°†æ­£å¸¸è¿è¡Œã€‚

## æ€»ç»“

Rust æä¾›äº†å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ä¸¤ç§æ–¹å¼æ¥å¸®åŠ©æˆ‘ä»¬ç»„ç»‡æµ‹è¯•ä»£ç ä»¥è§£å†³ä»£ç æ­£ç¡®æ€§é—®é¢˜ã€‚

å•å…ƒæµ‹è¯•é’ˆå¯¹çš„æ˜¯å…·ä½“çš„ä»£ç å•å…ƒï¼Œä¾‹å¦‚å‡½æ•°ï¼Œè€Œé›†æˆæµ‹è¯•å¾€å¾€é’ˆå¯¹çš„æ˜¯ä¸€ä¸ªåŠŸèƒ½æˆ–æ¥å£ APIï¼Œæ­£å› ä¸ºç›®æ ‡ä¸Šçš„ä¸åŒï¼Œå¯¼è‡´äº†ä¸¤è€…åœ¨ç»„ç»‡æ–¹å¼ä¸Šçš„ä¸åŒï¼š

- å•å…ƒæµ‹è¯•çš„æ¨¡å—å’Œå¾…æµ‹è¯•çš„ä»£ç åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œä¸”å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å¯¹ç§æœ‰å‡½æ•°è¿›è¡Œæµ‹è¯•
- é›†æˆæµ‹è¯•æ–‡ä»¶æ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ `tests` ç›®å½•ä¸­ï¼Œç”±äºè¯¥ç›®å½•ä¸‹æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªåŒ…ï¼Œæˆ‘ä»¬å¿…é¡»è¦å¼•å…¥å¾…æµ‹è¯•çš„ä»£ç åˆ°å½“å‰åŒ…çš„ä½œç”¨åŸŸä¸­ï¼Œæ‰èƒ½è¿›è¡Œæµ‹è¯•ï¼Œæ­£å› ä¸ºæ­¤ï¼Œé›†æˆæµ‹è¯•åªèƒ½å¯¹å£°æ˜ä¸º `pub` çš„ API è¿›è¡Œæµ‹è¯•

ä¸‹ä¸ªç« èŠ‚ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹è¯¥å¦‚ä½•ä½¿ç”¨ `GitHub Actions` å¯¹ Rust é¡¹ç›®è¿›è¡ŒæŒç»­é›†æˆã€‚



================================================
FILE: src/test/write-tests.md
================================================
# ç¼–å†™æµ‹è¯•åŠæ§åˆ¶æ‰§è¡Œ

åœ¨ Rust ä¸­ï¼Œæµ‹è¯•æ˜¯é€šè¿‡å‡½æ•°çš„æ–¹å¼å®ç°çš„ï¼Œå®ƒå¯ä»¥ç”¨äºéªŒè¯è¢«æµ‹è¯•ä»£ç çš„æ­£ç¡®æ€§ã€‚æµ‹è¯•å‡½æ•°å¾€å¾€ä¾æ¬¡æ‰§è¡Œä»¥ä¸‹ä¸‰ç§è¡Œä¸ºï¼š

1. è®¾ç½®æ‰€éœ€çš„æ•°æ®æˆ–çŠ¶æ€
2. è¿è¡Œæƒ³è¦æµ‹è¯•çš„ä»£ç 
3. åˆ¤æ–­( assert )è¿”å›çš„ç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸ

è®©æˆ‘ä»¬æ¥çœ‹çœ‹è¯¥å¦‚ä½•ä½¿ç”¨ Rust æä¾›çš„ç‰¹æ€§æ¥æŒ‰ç…§ä¸Šè¿°æ­¥éª¤ç¼–å†™æµ‹è¯•ç”¨ä¾‹ã€‚

## æµ‹è¯•å‡½æ•°

å½“ä½¿ç”¨ `Cargo` åˆ›å»ºä¸€ä¸ª `lib` ç±»å‹çš„åŒ…æ—¶ï¼Œå®ƒä¼šä¸ºæˆ‘ä»¬è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªæµ‹è¯•æ¨¡å—ã€‚å…ˆæ¥åˆ›å»ºä¸€ä¸ª `lib` ç±»å‹çš„ `adder` åŒ…ï¼š

```shell
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

åˆ›å»ºæˆåŠŸåï¼Œåœ¨ _src/lib.rs_ æ–‡ä»¶ä¸­å¯ä»¥å‘ç°å¦‚ä¸‹ä»£ç :

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

å…¶ä¸­ï¼Œ`tests` å°±æ˜¯ä¸€ä¸ªæµ‹è¯•æ¨¡å—ï¼Œ`it_works` åˆ™æ˜¯æˆ‘ä»¬çš„ä¸»è§’ï¼šæµ‹è¯•å‡½æ•°ã€‚

å¯ä»¥çœ‹å‡ºï¼Œæµ‹è¯•å‡½æ•°éœ€è¦ä½¿ç”¨ `test` å±æ€§è¿›è¡Œæ ‡æ³¨ã€‚å…³äºå±æ€§( `attribute` )ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„ç« èŠ‚å·²ç»è§è¿‡ç±»ä¼¼çš„ `derive`ï¼Œä½¿ç”¨å®ƒå¯ä»¥æ´¾ç”Ÿè‡ªåŠ¨å®ç°çš„ `Debug` ã€`Copy` ç­‰ç‰¹å¾ï¼ŒåŒæ ·çš„ï¼Œä½¿ç”¨ `test` å±æ€§ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è·å– Rust æä¾›çš„æµ‹è¯•ç‰¹æ€§ã€‚

ç»è¿‡ `test` æ ‡è®°çš„å‡½æ•°å°±å¯ä»¥è¢«æµ‹è¯•æ‰§è¡Œå™¨å‘ç°ï¼Œå¹¶è¿›è¡Œè¿è¡Œã€‚å½“ç„¶ï¼Œåœ¨æµ‹è¯•æ¨¡å— `tests` ä¸­ï¼Œè¿˜å¯ä»¥å®šä¹‰éæµ‹è¯•å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å¯ä»¥ç”¨äºè®¾ç½®ç¯å¢ƒæˆ–æ‰§è¡Œä¸€äº›é€šç”¨æ“ä½œï¼šä¾‹å¦‚ä¸ºéƒ¨åˆ†æµ‹è¯•å‡½æ•°æä¾›æŸä¸ªé€šç”¨çš„åŠŸèƒ½ï¼Œè¿™ç§åŠŸèƒ½å°±å¯ä»¥æŠ½è±¡ä¸ºä¸€ä¸ªéæµ‹è¯•å‡½æ•°ã€‚

æ¢è€Œè¨€ä¹‹ï¼Œæ­£æ˜¯å› ä¸ºæµ‹è¯•æ¨¡å—æ—¢å¯ä»¥å®šä¹‰æµ‹è¯•å‡½æ•°åˆå¯ä»¥å®šä¹‰éæµ‹è¯•å‡½æ•°ï¼Œå¯¼è‡´äº†æˆ‘ä»¬å¿…é¡»æä¾›ä¸€ä¸ªç‰¹æ®Šçš„æ ‡è®° `test`ï¼Œç”¨äºå‘ŠçŸ¥å“ªä¸ªå‡½æ•°æ‰æ˜¯æµ‹è¯•å‡½æ•°ã€‚

#### assert_eq

åœ¨æµ‹è¯•å‡½æ•°ä¸­ï¼Œè¿˜ä½¿ç”¨åˆ°äº†ä¸€ä¸ªå†…ç½®çš„æ–­è¨€ï¼š`assert_eq`ï¼Œè¯¥å®ç”¨äºå¯¹ç»“æœè¿›è¡Œæ–­è¨€ï¼š`2 + 2` æ˜¯å¦ç­‰äº `4`ã€‚ä¸ä¹‹ç±»ä¼¼ï¼ŒRust è¿˜å†…ç½®äº†å…¶å®ƒä¸€äº›å®ç”¨çš„æ–­è¨€ï¼Œå…·ä½“å‚è§[åç»­ç« èŠ‚](https://course.rs/test/assertion.html)ã€‚

## cargo test

ä¸‹é¢ä½¿ç”¨ `cargo test` å‘½ä»¤æ¥è¿è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰æµ‹è¯•:

```shell
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

ä¸Šé¢æµ‹è¯•è¾“å‡ºä¸­ï¼Œæœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„:

- æµ‹è¯•ç”¨ä¾‹æ˜¯åˆ†æ‰¹æ‰§è¡Œçš„ï¼Œ`running 1 test` è¡¨ç¤ºä¸‹é¢çš„è¾“å‡º `test result` æ¥è‡ªä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¿è¡Œç»“æœã€‚
- `test tests::it_works` ä¸­åŒ…å«äº†æµ‹è¯•ç”¨ä¾‹çš„åç§°
- `test result: ok` ä¸­çš„ `ok` è¡¨ç¤ºæµ‹è¯•æˆåŠŸé€šè¿‡
- `1 passed` ä»£è¡¨æˆåŠŸé€šè¿‡ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹(å› ä¸ºåªæœ‰ä¸€ä¸ª)ï¼Œ`0 failed` : æ²¡æœ‰æµ‹è¯•ç”¨ä¾‹å¤±è´¥ï¼Œ`0 ignored` è¯´æ˜æˆ‘ä»¬æ²¡æœ‰å°†ä»»ä½•æµ‹è¯•å‡½æ•°æ ‡è®°ä¸ºè¿è¡Œæ—¶å¯å¿½ç•¥ï¼Œ`0 filtered` æ„å‘³ç€æ²¡æœ‰å¯¹æµ‹è¯•ç»“æœåšä»»ä½•è¿‡æ»¤ï¼Œ`0 measured` ä»£è¡¨[åŸºå‡†æµ‹è¯•(benchmark)](https://course.rs/test/benchmark.html)çš„ç»“æœ

å…³äº `filtered` å’Œ `ignored` çš„ä½¿ç”¨ï¼Œåœ¨æœ¬ç« èŠ‚çš„åç»­å†…å®¹æˆ‘ä»¬ä¼šè®²åˆ°ï¼Œè¿™é‡Œæš‚ä¸”ç•¥è¿‡ã€‚

è¿˜æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ç‚¹ï¼Œè¾“å‡ºä¸­çš„ `Doc-tests adder` ä»£è¡¨äº†æ–‡æ¡£æµ‹è¯•ï¼Œç”±äºæˆ‘ä»¬çš„ä»£ç ä¸­æ²¡æœ‰ä»»ä½•æ–‡æ¡£æµ‹è¯•çš„å†…å®¹ï¼Œå› æ­¤è¿™é‡Œçš„æµ‹è¯•ç”¨ä¾‹æ•°ä¸º `0`ï¼Œå…³äºæ–‡æ¡£æµ‹è¯•çš„è¯¦ç»†ä»‹ç»è¯·å‚è§[è¿™é‡Œ](https://course.rs/basic/comment.html#æ–‡æ¡£æ³¨é‡Š)ã€‚

å¤§å®¶è¿˜å¯ä»¥å°è¯•ä¿®æ”¹ä¸‹æµ‹è¯•å‡½æ•°çš„åç§°ï¼Œä¾‹å¦‚ä¿®æ”¹ä¸º `exploration`ï¼Œçœ‹çœ‹è¿è¡Œç»“æœå°†å¦‚ä½•å˜åŒ–ã€‚

#### å¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹

æ˜¯æ—¶å€™å¼€å§‹å†™è‡ªå·±çš„æµ‹è¯•å‡½æ•°äº†ï¼Œä¸ºäº†æ¼”ç¤ºï¼Œè¿™æ¬¡æˆ‘ä»¬æ¥å†™ä¸€ä¸ªä¼šè¿è¡Œå¤±è´¥çš„:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
```

æ–°çš„æµ‹è¯•å‡½æ•° `another` ç›¸å½“ç®€å•ç²—æš´ï¼Œç›´æ¥ä½¿ç”¨ `panic` æ¥æŠ¥é”™ï¼Œä½¿ç”¨ `cargo test` è¿è¡Œçœ‹çœ‹ç»“æœï¼š

```shell
running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```

ä»ç»“æœçœ‹ï¼Œä¸¤ä¸ªæµ‹è¯•å‡½æ•°ï¼Œä¸€ä¸ªæˆåŠŸï¼Œä¸€ä¸ªå¤±è´¥ï¼ŒåŒæ—¶åœ¨è¾“å‡ºä¸­å‡†ç¡®çš„å‘ŠçŸ¥äº†å¤±è´¥çš„å‡½æ•°å: `failures: tests::another`ï¼ŒåŒæ—¶è¿˜ç»™å‡ºäº†å…·ä½“çš„å¤±è´¥åŸå› ï¼š `tests::another stdout`ã€‚è¿™ä¸¤è€…è™½ç„¶çœ‹èµ·æ¥å­˜åœ¨é‡å¤ï¼Œä½†æ˜¯å‰è€…ç”¨äºè¯´æ˜æ¯ä¸ªå¤±è´¥çš„å…·ä½“åŸå› ï¼Œåè€…ç”¨äºç»™å‡ºä¸€çœ¼å¯å¾—ç»“è®ºçš„æ±‡æ€»ä¿¡æ¯ã€‚

æœ‰åŒå­¦å¯èƒ½ä¼šå¥½å¥‡ï¼Œè¿™ä¸¤ä¸ªæµ‹è¯•å‡½æ•°ä»¥ä»€ä¹ˆæ–¹å¼è¿è¡Œï¼Ÿ å®ƒä»¬ä¼šè¿è¡Œåœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­å—ï¼Ÿç­”æ¡ˆæ˜¯å¦å®šçš„ï¼ŒRust åœ¨é»˜è®¤æƒ…å†µä¸‹ä¼šä¸ºæ¯ä¸€ä¸ªæµ‹è¯•å‡½æ•°å¯åŠ¨å•ç‹¬çš„çº¿ç¨‹å»å¤„ç†ï¼Œå½“ä¸»çº¿ç¨‹ `main` å‘ç°æœ‰ä¸€ä¸ªæµ‹è¯•çº¿ç¨‹æ­»æ‰æ—¶ï¼Œ`main` ä¼šå°†ç›¸åº”çš„æµ‹è¯•æ ‡è®°ä¸ºå¤±è´¥ã€‚

äº‹å®ä¸Šï¼Œå¤šçº¿ç¨‹è¿è¡Œæµ‹è¯•è™½ç„¶æ€§èƒ½é«˜ï¼Œä½†æ˜¯å­˜åœ¨æ•°æ®ç«äº‰çš„é£é™©ï¼Œåœ¨åæ–‡æˆ‘ä»¬ä¼šå¯¹å…¶è¿›è¡Œè¯¦ç»†ä»‹ç»å¹¶ç»™å‡ºè§£å†³æ–¹æ¡ˆã€‚

## è‡ªå®šä¹‰å¤±è´¥ä¿¡æ¯

é»˜è®¤çš„å¤±è´¥ä¿¡æ¯åœ¨æœ‰æ—¶å€™å¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œæ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Sunface");
        assert!(result.contains("å­™é£"));
    }
}
```

ä½¿ç”¨ `cargo test` è¿è¡Œåï¼Œé”™è¯¯å¦‚ä¸‹ï¼š

```shell
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'assertion failed: result.contains(\"å­™é£\")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name
```

å¯ä»¥çœ‹å‡ºï¼Œè¿™æ®µæŠ¥é”™é™¤äº†å‘Šè¯‰æˆ‘ä»¬é”™è¯¯å‘ç”Ÿçš„åœ°æ–¹ï¼Œå¹¶æ²¡æœ‰æ›´å¤šçš„ä¿¡æ¯ï¼Œé‚£å†æ¥çœ‹çœ‹è¯¥å¦‚ä½•æä¾›ä¸€äº›æ›´æœ‰ç”¨çš„ä¿¡æ¯ï¼š

```rust
fn greeting_contains_name() {
    let result = greeting("Sunface");
    let target = "å­™é£";
    assert!(
        result.contains(target),
        "ä½ çš„é—®å€™ä¸­å¹¶æ²¡æœ‰åŒ…å«ç›®æ ‡å§“å {} ï¼Œä½ çš„é—®å€™æ˜¯ `{}`",
        target,
        result
    );
}
```

è¿™æ®µä»£ç è·Ÿä¹‹å‰å¹¶æ— ä¸åŒï¼Œåªæ˜¯ä¸º `assert!` æ–°å¢äº†å‡ ä¸ªæ ¼å¼åŒ–å‚æ•°ï¼Œè¿™ç§ä½¿ç”¨æ–¹å¼ä¸ `format!` å¹¶æ— åŒºåˆ«ã€‚å†æ¬¡è¿è¡Œåï¼Œè¾“å‡ºå¦‚ä¸‹ï¼š

```shell
---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'ä½ çš„é—®å€™ä¸­å¹¶æ²¡æœ‰åŒ…å«ç›®æ ‡å§“å å­™é£ ï¼Œä½ çš„é—®å€™æ˜¯ `Hello Sunface!`', src/lib.rs:14:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

è¿™æ¬¡çš„æŠ¥é”™å°±æ¸…æ™°å¤ªå¤šäº†ï¼ŒçœŸæ£’ï¼åœ¨æµ‹è¯•ç”¨ä¾‹å°‘çš„æ—¶å€™ï¼Œä¹Ÿè®¸è¿™ç§ä¿¡æ¯è¿˜æ— æ³•ä½“ç°æœ€å¤§çš„ä»·å€¼ï¼Œä½†æ˜¯ä¸€æ—¦æµ‹è¯•å¤šäº†åï¼Œè¯¦å°½çš„æŠ¥é”™ä¿¡æ¯å°†å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„è¿›è¡Œ Debugã€‚

## æµ‹è¯• panic

åœ¨ä¹‹å‰çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ `panic` æ¥è§¦å‘æŠ¥é”™ï¼Œä½†æ˜¯å¦‚æœä¸€ä¸ªå‡½æ•°æœ¬æ¥å°±ä¼š `panic` ï¼Œè€Œæˆ‘ä»¬æƒ³è¦æ£€æŸ¥è¿™ç§ç»“æœå‘¢ï¼Ÿ

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŠæ³•æ¥æµ‹è¯•ä¸€ä¸ªå‡½æ•°æ˜¯å¦ä¼š `panic`ï¼Œå¯¹æ­¤ï¼Œ Rust æä¾›äº† `should_panic` å±æ€§æ³¨è§£ï¼Œå’Œ `test` æ³¨è§£ä¸€æ ·ï¼Œå¯¹ç›®æ ‡æµ‹è¯•å‡½æ•°è¿›è¡Œæ ‡æ³¨å³å¯ï¼š

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

ä¸Šé¢æ˜¯ä¸€ä¸ªç®€å•çš„çŒœæ•°å­—æ¸¸æˆï¼Œ`Guess` ç»“æ„ä½“çš„ `new` æ–¹æ³•åœ¨ä¼ å…¥çš„å€¼ä¸åœ¨ [1,100] ä¹‹é—´æ—¶ï¼Œä¼šç›´æ¥ `panic`ï¼Œè€Œåœ¨æµ‹è¯•å‡½æ•° `greater_than_100` ä¸­ï¼Œæˆ‘ä»¬ä¼ å…¥çš„å€¼ `200` æ˜¾ç„¶æ²¡æœ‰è½å…¥è¯¥åŒºé—´ï¼Œå› æ­¤ `new` æ–¹æ³•ä¼šç›´æ¥ `panic`ï¼Œä¸ºäº†æµ‹è¯•è¿™ä¸ªé¢„æœŸçš„ `panic` è¡Œä¸ºï¼Œæˆ‘ä»¬ä½¿ç”¨ `#[should_panic]` å¯¹å…¶è¿›è¡Œäº†æ ‡æ³¨ã€‚

```shell
running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

ä»è¾“å‡ºå¯ä»¥çœ‹å‡ºï¼Œ `panic` çš„ç»“æœè¢«å‡†ç¡®çš„è¿›è¡Œäº†æµ‹è¯•ï¼Œé‚£å¦‚æœæµ‹è¯•å‡½æ•°ä¸­çš„ä»£ç ä¸å† `panic` å‘¢ï¼Ÿä¾‹å¦‚ï¼š

```rust
fn greater_than_100() {
    Guess::new(50);
}
```

æ­¤æ—¶æ˜¾ç„¶ä¼šæµ‹è¯•å¤±è´¥ï¼Œå› ä¸ºæˆ‘ä»¬é¢„æœŸä¸€ä¸ª `panic`ï¼Œä½†æ˜¯ `new` å‡½æ•°é¡ºåˆ©çš„è¿”å›äº†ä¸€ä¸ª `Guess` å®ä¾‹:

```shell
running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected // æµ‹è¯•å¹¶æ²¡æœ‰æŒ‰ç…§é¢„æœŸå‘ç”Ÿ panic
```

#### expected

è™½ç„¶ `panic` è¢«æˆåŠŸæµ‹è¯•åˆ°ï¼Œä½†æ˜¯å¦‚æœä»£ç å‘ç”Ÿçš„ `panic` å’Œæˆ‘ä»¬é¢„æœŸçš„ `panic` ä¸ç¬¦åˆå‘¢ï¼Ÿå› ä¸ºä¸€æ®µç³Ÿç³•çš„ä»£ç å¯èƒ½ä¼šåœ¨ä¸åŒçš„ä»£ç è¡Œç”Ÿæˆä¸åŒçš„ `panic`ã€‚

é‰´äºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¯é€‰çš„å‚æ•° `expected` æ¥è¯´æ˜é¢„æœŸçš„ `panic` é•¿å•¥æ ·ï¼š

```rust
// --snip--
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

è¿™æ®µä»£ç ä¼šé€šè¿‡æµ‹è¯•ï¼Œå› ä¸ºé€šè¿‡å¢åŠ äº† `expected` ï¼Œæˆ‘ä»¬æˆåŠŸæŒ‡å®šäº†æœŸæœ›çš„ `panic` ä¿¡æ¯ï¼Œå¤§å®¶å¯ä»¥é¡ºç€ä»£ç æ¨æµ‹ä¸‹ï¼šæŠŠ `200` å¸¦å…¥åˆ° `new` å‡½æ•°ä¸­çœ‹çœ‹ä¼šè§¦å‘å“ªä¸ª `panic`ã€‚

å¦‚æœæ³¨æ„çœ‹ï¼Œä½ ä¼šå‘ç° `expected` çš„å­—ç¬¦ä¸²å’Œå®é™… `panic` çš„å­—ç¬¦ä¸²å¯ä»¥ä¸åŒï¼Œå‰è€…åªéœ€è¦æ˜¯åè€…çš„å­—ç¬¦ä¸²å‰ç¼€å³å¯ï¼Œå¦‚æœæ”¹æˆ ` #[should_panic(expected = "Guess value must be less than")]`ï¼Œä¸€æ ·å¯ä»¥é€šè¿‡æµ‹è¯•ã€‚

è¿™é‡Œç”±äºç¯‡å¹…æœ‰é™ï¼Œæˆ‘ä»¬å°±ä¸å†å±•ç¤ºæµ‹è¯•å¤±è´¥çš„æŠ¥é”™ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±ä¿®æ”¹ä¸‹ `expected` çš„ä¿¡æ¯ï¼Œç„¶åçœ‹çœ‹æŠ¥é”™åçš„è¾“å‡ºé•¿å•¥æ ·ã€‚

## ä½¿ç”¨ `Result<T, E>`

åœ¨ä¹‹å‰çš„ä¾‹å­ä¸­ï¼Œ`panic` æ‰«æ¸…ä¸€åˆ‡éšœç¢ï¼Œä½†æ˜¯å®ƒä¹Ÿä¸æ˜¯ä¸‡èƒ½çš„ï¼Œä¾‹å¦‚ä½ æƒ³åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ `?` æ“ä½œç¬¦è¿›è¡Œé“¾å¼è°ƒç”¨è¯¥æ€ä¹ˆåŠï¼Ÿé‚£å°±å¾—è¯·å‡º `Result<T, E>` äº†ï¼š

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæµ‹è¯•å‡½æ•°ä¸ä¼šå†ä½¿ç”¨ `assert_eq!` å¯¼è‡´ `panic`ï¼Œè€Œæ˜¯æ‰‹åŠ¨è¿›è¡Œäº†é€»è¾‘åˆ¤æ–­ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Result`ã€‚å½“ç„¶ï¼Œå½“è¿™ä¹ˆå®ç°æ—¶ï¼Œ`#[should_panic]` å°†æ— æ³•å†è¢«ä½¿ç”¨ã€‚

è‡³æ­¤ï¼Œå…³äºå¦‚ä½•å†™æµ‹è¯•çš„åŸºæœ¬çŸ¥è¯†ï¼Œå¤§å®¶å·²ç»äº†è§£çš„å·®ä¸å¤šäº†ï¼Œä¸‹é¢æ¥çœ‹çœ‹è¯¥å¦‚ä½•æ§åˆ¶æµ‹è¯•çš„æ‰§è¡Œã€‚

## ä½¿ç”¨ `--` åˆ†å‰²å‘½ä»¤è¡Œå‚æ•°

å¤§å®¶åº”è¯¥éƒ½çŸ¥é“ `cargo build` å¯ä»¥å°†ä»£ç ç¼–è¯‘æˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œé‚£ä½ çŸ¥é“ `cargo run` å’Œ `cargo test` æ˜¯å¦‚ä½•è¿è¡Œçš„å—ï¼Ÿå…¶å®é“ç†éƒ½ä¸€æ ·ï¼Œè¿™ä¸¤ä¸ªä¹Ÿæ˜¯å°†ä»£ç ç¼–è¯‘æˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œç„¶åè¿›è¡Œè¿è¡Œï¼Œå”¯ä¸€çš„åŒºåˆ«å°±åœ¨äºè¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶éšåä¼šè¢«åˆ é™¤ã€‚

æ­£å› ä¸ºå¦‚æ­¤ï¼Œ`cargo test` ä¹Ÿå¯ä»¥é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æ¥æ§åˆ¶æµ‹è¯•çš„æ‰§è¡Œï¼Œä¾‹å¦‚ä½ å¯ä»¥é€šè¿‡å‚æ•°æ¥è®©é»˜è®¤çš„å¤šçº¿ç¨‹æµ‹è¯•å˜æˆå•çº¿ç¨‹ä¸‹çš„æµ‹è¯•ã€‚éœ€è¦æ³¨æ„çš„æ˜¯å‘½ä»¤è¡Œå‚æ•°æœ‰ä¸¤ç§ï¼Œè¿™ä¸¤ç§é€šè¿‡ `--` è¿›è¡Œåˆ†å‰²ï¼š

- ç¬¬ä¸€ç§æ˜¯æä¾›ç»™ `cargo test` å‘½ä»¤æœ¬èº«çš„ï¼Œè¿™äº›å‚æ•°åœ¨ `--` ä¹‹å‰æŒ‡å®š
- ç¬¬äºŒç§æ˜¯æä¾›ç»™ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œåœ¨ `--` ä¹‹åæŒ‡å®š

ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `cargo test --help` æ¥æŸ¥çœ‹ç¬¬ä¸€ç§å‚æ•°çš„å¸®åŠ©åˆ—è¡¨ï¼Œè¿˜å¯ä»¥é€šè¿‡ `cargo test -- --help` æ¥æŸ¥çœ‹ç¬¬äºŒç§çš„å¸®åŠ©åˆ—è¡¨ã€‚

å…ˆæ¥çœ‹çœ‹ç¬¬äºŒç§å‚æ•°ä¸­çš„å…¶ä¸­ä¸€ä¸ªï¼Œå®ƒå¯ä»¥æ§åˆ¶æµ‹è¯•æ˜¯å¹¶è¡Œè¿è¡Œè¿˜æ˜¯é¡ºåºè¿è¡Œã€‚

## æµ‹è¯•ç”¨ä¾‹çš„å¹¶è¡Œæˆ–é¡ºåºæ‰§è¡Œ

å½“è¿è¡Œå¤šä¸ªæµ‹è¯•å‡½æ•°æ—¶ï¼Œé»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸ºæ¯ä¸ªæµ‹è¯•éƒ½ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åé€šè¿‡ä¸»çº¿ç¨‹æ¥ç­‰å¾…å®ƒä»¬çš„å®Œæˆå’Œç»“æœã€‚è¿™ç§æ¨¡å¼çš„ä¼˜ç‚¹å¾ˆæ˜æ˜¾ï¼Œé‚£å°±æ˜¯å¹¶è¡Œè¿è¡Œä¼šè®©æ•´ä½“æµ‹è¯•æ—¶é—´å˜çŸ­å¾ˆå¤šï¼Œè¿è¡Œè¿‡å¤§é‡æµ‹è¯•ç”¨ä¾‹çš„åŒå­¦éƒ½æ˜ç™½å¹¶è¡Œæµ‹è¯•çš„é‡è¦æ€§ï¼šç”Ÿå‘½è‹¦çŸ­ï¼Œæˆ‘ç”¨å¹¶è¡Œã€‚

ä½†æ˜¯æœ‰åˆ©å°±æœ‰å¼Šï¼Œå¹¶è¡Œæµ‹è¯•æœ€å¤§çš„é—®é¢˜å°±åœ¨äºå…±äº«çŠ¶æ€çš„ä¿®æ”¹ï¼Œå› ä¸ºä½ éš¾ä»¥æ§åˆ¶æµ‹è¯•çš„è¿è¡Œé¡ºåºï¼Œå› æ­¤å¦‚æœå¤šä¸ªæµ‹è¯•å…±äº«ä¸€ä¸ªæ•°æ®ï¼Œé‚£ä¹ˆå¯¹è¯¥æ•°æ®çš„ä½¿ç”¨ä¹Ÿå°†å˜å¾—ä¸å¯æ§åˆ¶ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬æœ‰å¤šä¸ªæµ‹è¯•ï¼Œå®ƒä»¬æ¯ä¸ªéƒ½ä¼šå¾€è¯¥æ–‡ä»¶ä¸­å†™å…¥ä¸€äº›**è‡ªå·±çš„æ•°æ®**ï¼Œæœ€åå†ä»æ–‡ä»¶ä¸­è¯»å–è¿™äº›æ•°æ®è¿›è¡Œå¯¹æ¯”ã€‚ç”±äºæ‰€æœ‰æµ‹è¯•éƒ½æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œå½“æµ‹è¯• `A` å†™å…¥æ•°æ®å‡†å¤‡è¯»å–å¹¶å¯¹æ¯”æ—¶ï¼Œå¾ˆæœ‰å¯èƒ½ä¼šè¢«æµ‹è¯• `B` å†™å…¥æ–°çš„æ•°æ®ï¼Œå¯¼è‡´ `A` å†™å…¥çš„æ•°æ®è¢«è¦†ç›–ï¼Œç„¶å `A` å†è¯»å–åˆ°çš„å°±æ˜¯ `B` å†™å…¥çš„æ•°æ®ã€‚ç»“æœ `A` æµ‹è¯•å°±ä¼šå¤±è´¥ï¼Œè€Œä¸”è¿™ç§å¤±è´¥è¿˜ä¸æ˜¯å› ä¸ºæµ‹è¯•ä»£ç ä¸æ­£ç¡®å¯¼è‡´çš„ï¼

è§£å†³åŠæ³•ä¹Ÿæœ‰ï¼Œæˆ‘ä»¬å¯ä»¥è®©æ¯ä¸ªæµ‹è¯•å†™å…¥è‡ªå·±ç‹¬ç«‹çš„æ–‡ä»¶ä¸­ï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä»¥è®©æ‰€æœ‰æµ‹è¯•ä¸€ä¸ªæ¥ç€ä¸€ä¸ªé¡ºåºè¿è¡Œ:

```rust
$ cargo test -- --test-threads=1
```

é¦–å…ˆèƒ½æ³¨æ„åˆ°çš„æ˜¯è¯¥å‘½ä»¤è¡Œå‚æ•°æ˜¯ç¬¬äºŒç§ç±»å‹ï¼šæä¾›ç»™ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œå› ä¸ºå®ƒåœ¨ `--` ä¹‹åè¿›è¡Œä¼ é€’ã€‚å…¶æ¬¡ï¼Œç»†å¿ƒçš„åŒå­¦å¯èƒ½ä¼šæƒ³åˆ°ï¼Œçº¿ç¨‹æ•°ä¸ä»…ä»…å¯ä»¥æŒ‡å®šä¸º `1`ï¼Œè¿˜å¯ä»¥æŒ‡å®šä¸º `4`ã€`8`ï¼Œå½“ç„¶ï¼Œæƒ³è¦é¡ºåºè¿è¡Œï¼Œå°±å¿…é¡»æ˜¯ `1`ã€‚

## æµ‹è¯•å‡½æ•°ä¸­çš„ `println!`

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœæµ‹è¯•é€šè¿‡ï¼Œé‚£å†™å…¥æ ‡å‡†è¾“å‡ºçš„å†…å®¹æ˜¯ä¸ä¼šæ˜¾ç¤ºåœ¨æµ‹è¯•ç»“æœä¸­çš„:

```rust
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
```

ä¸Šé¢ä»£ç ä½¿ç”¨ `println!` è¾“å‡ºæ”¶åˆ°çš„å‚æ•°å€¼ï¼Œæ¥çœ‹çœ‹æµ‹è¯•ç»“æœ:

```shell
running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

å¤§å®¶æ³¨æ„çœ‹ï¼Œ`I got the value 4` å¹¶æ²¡æœ‰è¢«è¾“å‡ºï¼Œå› ä¸ºè¯¥æµ‹è¯•é¡ºåˆ©é€šè¿‡äº†ï¼Œå¦‚æœå°±æ˜¯æƒ³è¦çœ‹æ‰€æœ‰çš„è¾“å‡ºï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

```rust
$ cargo test -- --show-output
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œåªéœ€è¦å¢åŠ ä¸€ä¸ªå‚æ•°ï¼Œå…·ä½“çš„è¾“å‡ºå°±ä¸å†å±•ç¤ºï¼Œæ€»ä¹‹è¿™æ¬¡å¤§å®¶ä¸€å®šå¯ä»¥é¡ºåˆ©çœ‹åˆ° `I got the value 4` çš„èº«å½±ã€‚

## æŒ‡å®šè¿è¡Œä¸€éƒ¨åˆ†æµ‹è¯•

åœ¨ Mysql ä¸­æœ‰ä¸Šç™¾ä¸‡çš„å•å…ƒæµ‹è¯•ï¼Œå¦‚æœä½¿ç”¨ç±»ä¼¼ `cargo test` çš„å‘½ä»¤æ¥è¿è¡Œå…¨éƒ¨çš„æµ‹è¯•ï¼Œé‚£å¼€å‘çœŸçš„å·¥ä½œååˆ†é’Ÿï¼Œå¹ç‰›å…«å°æ—¶äº†ã€‚å¯¹äº Rust çš„ä¸­å¤§å‹é¡¹ç›®ä¹Ÿä¸€æ ·ï¼Œæ¯æ¬¡éƒ½è¿è¡Œå…¨éƒ¨æµ‹è¯•æ˜¯ä¸å¯æ¥å—çš„ï¼Œç‰¹åˆ«æ˜¯ä½ çš„å·¥ä½œä»…ä»…æ˜¯é¡¹ç›®ä¸­çš„ä¸€éƒ¨åˆ†æ—¶ã€‚

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
```

å¦‚æœç›´æ¥ä½¿ç”¨ `cargo test` è¿è¡Œï¼Œé‚£ä¸‰ä¸ªæµ‹è¯•å‡½æ•°ä¼šåŒæ—¶å¹¶è¡Œçš„è¿è¡Œï¼š

```shell
running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

å°±ä¸è¯´ä¸Šç™¾ä¸‡æµ‹è¯•ï¼Œå°±è¯´å‡ ç™¾ä¸ªï¼Œæƒ³è±¡ä¸€ä¸‹ç»“æœä¼šæ˜¯æ€ä¹ˆæ ·ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹è¯¥å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

#### è¿è¡Œå•ä¸ªæµ‹è¯•

è¿™ä¸ªå¾ˆç®€å•ï¼Œåªéœ€è¦å°†æŒ‡å®šçš„æµ‹è¯•å‡½æ•°åä½œä¸ºå‚æ•°å³å¯ï¼š

```shell
$ cargo test one_hundred
running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
```

æ­¤æ—¶ï¼Œåªæœ‰æµ‹è¯•å‡½æ•° `one_hundred` ä¼šè¢«è¿è¡Œï¼Œå…¶å®ƒä¸¤ä¸ªç”±äºåç§°ä¸åŒ¹é…ï¼Œä¼šè¢«ç›´æ¥å¿½ç•¥ã€‚åŒæ—¶ï¼Œåœ¨ä¸Šé¢çš„è¾“å‡ºä¸­ï¼ŒRust ä¹Ÿé€šè¿‡ `2 filtered out` æç¤ºæˆ‘ä»¬ï¼šæœ‰ä¸¤ä¸ªæµ‹è¯•å‡½æ•°è¢«è¿‡æ»¤äº†ã€‚

ä½†æ˜¯ï¼Œå¦‚æœä½ è¯•å›¾åŒæ—¶æŒ‡å®šå¤šä¸ªåç§°ï¼Œé‚£æŠ±æ­‰:

```shell
$ cargo test one_hundred,add_two_and_two
$ cargo test one_hundred add_two_and_two
```

è¿™ä¸¤ç§æ–¹å¼ç»Ÿç»Ÿä¸è¡Œï¼Œæ­¤æ—¶å°±éœ€è¦ä½¿ç”¨åç§°è¿‡æ»¤çš„æ–¹å¼æ¥å®ç°äº†ã€‚

#### é€šè¿‡åç§°æ¥è¿‡æ»¤æµ‹è¯•

æˆ‘ä»¬å¯ä»¥é€šè¿‡æŒ‡å®šéƒ¨åˆ†åç§°çš„æ–¹å¼æ¥è¿‡æ»¤è¿è¡Œç›¸åº”çš„æµ‹è¯•:

```shell
$ cargo test add
running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

äº‹å®ä¸Šï¼Œä½ ä¸ä»…å¯ä»¥ä½¿ç”¨å‰ç¼€ï¼Œè¿˜èƒ½ä½¿ç”¨åç§°ä¸­é—´çš„ä¸€éƒ¨åˆ†ï¼š

```shell
$ cargo test and
running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

å…¶ä¸­è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„ï¼Œé‚£å°±æ˜¯æµ‹è¯•æ¨¡å— `tests` çš„åç§°ä¹Ÿå‡ºç°åœ¨äº†æœ€ç»ˆç»“æœä¸­ï¼š`tests::add_two_and_two`ï¼Œè¿™æ˜¯éå¸¸è´´å¿ƒçš„ç»†èŠ‚ï¼Œä¹Ÿæ„å‘³ç€æˆ‘ä»¬å¯ä»¥é€šè¿‡**æ¨¡å—åç§°æ¥è¿‡æ»¤æµ‹è¯•**ï¼š

```shell
$ cargo test tests

running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### å¿½ç•¥éƒ¨åˆ†æµ‹è¯•

æœ‰æ—¶å€™ï¼Œä¸€äº›æµ‹è¯•ä¼šéå¸¸è€—æ—¶é—´ï¼Œå› æ­¤æˆ‘ä»¬å¸Œæœ›åœ¨ `cargo test` ä¸­å¯¹å®ƒè¿›è¡Œå¿½ç•¥ï¼Œå¦‚æœä½¿ç”¨ä¹‹å‰çš„æ–¹å¼ï¼Œæˆ‘ä»¬éœ€è¦å°†æ‰€æœ‰éœ€è¦è¿è¡Œçš„åç§°æŒ‡å®šä¸€éï¼Œè¿™éå¸¸éº»çƒ¦ï¼Œå¥½åœ¨ Rust å…è®¸é€šè¿‡ `ignore` å…³é”®å­—æ¥å¿½ç•¥ç‰¹å®šçš„æµ‹è¯•ç”¨ä¾‹:

```rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // è¿™é‡Œçš„ä»£ç éœ€è¦å‡ åç§’ç”šè‡³å‡ åˆ†é’Ÿæ‰èƒ½å®Œæˆ
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ `#[ignore]` å¯¹ `expensive_test` å‡½æ•°è¿›è¡Œäº†æ ‡æ³¨ï¼Œçœ‹çœ‹ç»“æœï¼š

```shell
$ cargo test
running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

è¾“å‡ºä¸­çš„ `test expensive_test ... ignored` æ„å‘³ç€è¯¥æµ‹è¯•å‡½æ•°è¢«å¿½ç•¥äº†ï¼Œå› æ­¤å¹¶æ²¡æœ‰è¢«æ‰§è¡Œã€‚

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼è¿è¡Œè¢«å¿½ç•¥çš„æµ‹è¯•å‡½æ•°ï¼š

```shell
$ cargo test -- --ignored
running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### ç»„åˆè¿‡æ»¤

ä¸Šé¢çš„æ–¹å¼è™½ç„¶å¾ˆå¼ºå¤§ï¼Œä½†æ˜¯å•ç‹¬ä½¿ç”¨ä¾ç„¶å­˜åœ¨å±€é™æ€§ã€‚å¥½åœ¨å®ƒä»¬è¿˜èƒ½ç»„åˆä½¿ç”¨ï¼Œä¾‹å¦‚è¿˜æ˜¯ä¹‹å‰çš„ä»£ç ï¼š

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // è¿™é‡Œçš„ä»£ç éœ€è¦å‡ åç§’ç”šè‡³å‡ åˆ†é’Ÿæ‰èƒ½å®Œæˆ
    }

    #[test]
    #[ignore]
    fn expensive_run() {
        // è¿™é‡Œçš„ä»£ç éœ€è¦å‡ åç§’ç”šè‡³å‡ åˆ†é’Ÿæ‰èƒ½å®Œæˆ
    }
}
```

ç„¶åè¿è¡Œ `tests` æ¨¡å—ä¸­çš„è¢«å¿½ç•¥çš„æµ‹è¯•å‡½æ•°

```shell
$ cargo test tests -- --ignored
running 2 tests
test tests::expensive_test ... ok
test tests::expensive_run ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

è¿è¡Œåç§°ä¸­å¸¦ `run` ä¸”è¢«å¿½ç•¥çš„æµ‹è¯•å‡½æ•°ï¼š

```shell
$ cargo test run -- --ignored
running 1 test
test tests::expensive_run ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
```

ç±»ä¼¼çš„è¿˜æœ‰å¾ˆå¤šï¼Œå¤§å®¶å¯ä»¥è‡ªå·±æ‘¸ç´¢ç ”ç©¶ä¸‹ï¼Œæ€»ä¹‹ï¼Œç†Ÿç»ƒæŒæ¡æµ‹è¯•çš„ä½¿ç”¨æ˜¯éå¸¸é‡è¦çš„ï¼Œè™½ç„¶åŒ…æ‹¬æˆ‘åœ¨å†…çš„å¾ˆå¤šå¼€å‘å¹¶ä¸å–œæ¬¢å†™æµ‹è¯• :)

## `[dev-dependencies]`

ä¸ `package.json`( Nodejs )æ–‡ä»¶ä¸­çš„ `devDependencies` ä¸€æ ·ï¼Œ Rust ä¹Ÿèƒ½å¼•å…¥åªåœ¨å¼€å‘æµ‹è¯•åœºæ™¯ä½¿ç”¨çš„å¤–éƒ¨ä¾èµ–ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­å°±æ˜¯ [`pretty_assertions`](https://docs.rs/pretty_assertions/1.0.0/pretty_assertions/index.html)ï¼Œå®ƒå¯ä»¥ç”¨æ¥æ‰©å±•æ ‡å‡†åº“ä¸­çš„ `assert_eq!` å’Œ `assert_ne!`ï¼Œä¾‹å¦‚æä¾›å½©è‰²å­—ä½“çš„ç»“æœå¯¹æ¯”ã€‚

åœ¨ `Cargo.toml` æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹æ¥å¼•å…¥ `pretty_assertions`ï¼š

```toml
# standard crate data is left out
[dev-dependencies]
pretty_assertions = "1"
```

ç„¶ååœ¨ `src/lib.rs` ä¸­æ·»åŠ :

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // è¯¥åŒ…ä»…èƒ½ç”¨äºæµ‹è¯•

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```

åœ¨ `tests` æ¨¡å—ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ `use pretty_assertions::assert_eq;` æˆåŠŸçš„å¼•å…¥ä¹‹å‰æ·»åŠ çš„åŒ…ï¼Œç”±äº `tests` æ¨¡å—æ˜ç¡®çš„ç”¨äºæµ‹è¯•ç›®çš„ï¼Œè¿™ç§å¼•å…¥å¹¶ä¸ä¼šæŠ¥é”™ã€‚ å¤§å®¶å¯ä»¥è¯•è¯•åœ¨æ­£å¸¸ä»£ç (éæµ‹è¯•ä»£ç )ä¸­å¼•å…¥è¯¥åŒ…ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

## ç”Ÿæˆæµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶

åœ¨æœ‰äº›æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›å°†æµ‹è¯•ä¸åˆ«äººåˆ†äº«ï¼Œè¿™ç§æƒ…å†µä¸‹ç”Ÿæˆä¸€ä¸ªç±»ä¼¼ `cargo build` çš„å¯æ‰§è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶æ˜¯å¾ˆå¥½çš„é€‰æ‹©ã€‚

äº‹å®ä¸Šï¼Œåœ¨ `cargo test` è¿è¡Œçš„æ—¶å€™ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªå¯è¿è¡Œæµ‹è¯•çš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶:

```shell
$ cargo test
 Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (target/debug/deps/study_cargo-0d693f72a0f49166)
```

è¿™é‡Œçš„ `target/debug/deps/study_cargo-0d693f72a0f49166` å°±æ˜¯å¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„å’Œåç§°ï¼Œæˆ‘ä»¬ç›´æ¥è¿è¡Œè¯¥æ–‡ä»¶æ¥æ‰§è¡Œç¼–è¯‘å¥½çš„æµ‹è¯•:

```shell
$ target/debug/deps/study_cargo-0d693f72a0f49166

running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

å¦‚æœä½ åªæƒ³ç”Ÿæˆç¼–è¯‘ç”Ÿæˆæ–‡ä»¶ï¼Œä¸æƒ³çœ‹ `cargo test` çš„è¾“å‡ºç»“æœï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `cargo test --no-run`.




================================================
FILE: src/too-many-lists/do-we-need-it.md
================================================
## æˆ‘ä»¬åˆ°åº•éœ€ä¸éœ€è¦é“¾è¡¨
ç»å¸¸æœ‰è¯»è€…è¯¢é—®è¯¥å¦‚ä½•å®ç°ä¸€ä¸ªé“¾è¡¨ï¼Œæ€ä¹ˆè¯´å‘¢ï¼Œè¿™ä¸ªç­”æ¡ˆä¸»è¦å–å†³äºä½ çš„éœ€æ±‚ï¼Œå› æ­¤å¹¶ä¸æ˜¯å¾ˆå¥½å›ç­”ã€‚é‰´äºæ­¤ï¼Œæˆ‘å†³å®šé€šè¿‡è¿™æœ¬ä¹¦æ¥è¯¦å°½çš„ä»‹ç»è¯¥å¦‚ä½•å®ç°ä¸€ä¸ªé“¾è¡¨ï¼Œå¤§å®¶åº”è¯¥éƒ½èƒ½ä»è¿™æœ¬ä¹¦ä¸­æ‰¾åˆ°ç­”æ¡ˆã€‚

ä¹¦ä¸­æˆ‘ä»¬å°†é€šè¿‡å®ç° 6 ç§é“¾è¡¨æ¥å­¦ä¹ åŸºæœ¬å’Œè¿›é˜¶ Rust ç¼–ç¨‹çŸ¥è¯†ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œä½ èƒ½å­¦åˆ°ï¼š

- æŒ‡é’ˆç±»å‹: `&`, `&mut`, `Box`, `Rc`, `Arc`, `*const`, `*mut`, `NonNull`
- æ‰€æœ‰æƒã€å€Ÿç”¨ã€ç»§æ‰¿å¯å˜æ€§ã€å†…éƒ¨å¯å˜æ€§ã€Copy
- æ‰€æœ‰çš„å…³é”®å­—ï¼šstructã€enumã€fnã€pubã€implã€use, ...
- æ¨¡å¼åŒ¹é…ã€æ³›å‹ã€è§£æ„
- æµ‹è¯•ã€å®‰è£…æ–°çš„å·¥å…·é“¾ã€ä½¿ç”¨ `miri`
- Unsafe: è£¸æŒ‡é’ˆã€åˆ«åã€æ ˆå€Ÿç”¨ã€`UnsafeCell`ã€å˜ä½“ variance

æ˜¯çš„ï¼Œé“¾è¡¨å°±æ˜¯è¿™ä¹ˆå¯æ€•ï¼Œåªæœ‰å°†è¿™äº›çŸ¥è¯†èä¼šè´¯é€šåï¼Œä½ æ‰èƒ½æŒæ¡ :( 


> äº‹å®ä¸Šè¿™æœ¬ä¹¦ä¸­å…³äº Rust è¯­è¨€çš„ç»å¤§éƒ¨åˆ†çŸ¥è¯†éƒ½åœ¨ `Rustè¯­è¨€åœ£ç»`ä¸­æœ‰è®²ï¼Œå› æ­¤é™¤éç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬å°†ç›´æ¥æä¾›é“¾æ¥ä¾›å¤§å®¶å­¦ä¹ ï¼Œé‡ç‚¹è¿˜æ˜¯æ”¾åœ¨é“¾è¡¨å®ç°ä¸Š

#### åˆ›å»ºä¸€ä¸ªé¡¹ç›®
åœ¨å¼€å§‹å‰ï¼Œå…ˆæ¥åˆ›å»ºä¸€ä¸ªé¡¹ç›®ä¸“é—¨ç”¨äºé“¾è¡¨å­¦ä¹ ï¼š
```shell
$ cargo new --lib lists
$ cd lists
```

ä¹‹åï¼Œæˆ‘ä»¬ä¼šå°†æ¯ä¸ªä¸€ä¸ªé“¾è¡¨æ”¾å…¥å•ç‹¬çš„æ–‡ä»¶ä¸­ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æˆ‘ä»¬ä¼šå°½é‡æ¨¡æ‹ŸçœŸå®çš„ Rust å¼€å‘åœºæ™¯ï¼šä½ å†™äº†ä¸€æ®µä»£ç ï¼Œç„¶åç¼–è¯‘å™¨å¼€å§‹è·³å‡ºè¯•å›¾æ•™ä½ åšäº‹ï¼Œåªæœ‰è¿™æ ·æ‰èƒ½çœŸæ­£å­¦ä¼š Rustï¼Œæ¸©å®¤ç¯å¢ƒæ˜¯æ— æ³•åŸ¹å…»å‡ºå¼ºå¤§çš„ Rustacean çš„ã€‚

#### ä¹‰åŠ¡å‘ŠçŸ¥
é¦–å…ˆï¼Œæœ¬ä¹¦ä¸æ˜¯ä¿å§†å¼æ•™ç¨‹ï¼Œè€Œä¸”æˆ‘ä¸ªäººè®¤ä¸ºç¼–ç¨‹åº”è¯¥æ˜¯å¿«ä¹ï¼Œè¿™ç§å¿«ä¹å¾€å¾€éœ€è¦ä½ è‡ªå·±å‘ç°è€Œä¸æ˜¯åˆ«äººçš„äº‹æ— å·¨ç»†çš„è®²è§£ã€‚

å…¶æ¬¡ï¼Œæˆ‘è®¨åŒé“¾è¡¨ã€‚é“¾è¡¨çœŸçš„æ˜¯ä¸€ç§ç³Ÿç³•çš„æ•°æ®ç»“æ„ï¼Œå°½ç®¡å®ƒåœ¨éƒ¨åˆ†åœºæ™¯ä¸‹ç¡®å®å¾ˆæœ‰ç”¨ï¼š

- å¯¹åˆ—è¡¨è¿›è¡Œå¤§é‡çš„åˆ†å‰²å’Œåˆå¹¶æ“ä½œ
- æ— é”å¹¶å‘
- è¦å®ç°å†…æ ¸æˆ–åµŒå…¥å¼çš„æœåŠ¡
- ä½ åœ¨ä½¿ç”¨ä¸€ä¸ªçº¯å‡½æ•°å¼è¯­è¨€ï¼Œç”±äºå—é™çš„è¯­æ³•å’Œç¼ºå°‘å¯å˜æ€§ï¼Œå› æ­¤ä½ éœ€è¦ä½¿ç”¨é“¾è¡¨æ¥è§£å†³è¿™äº›é—®é¢˜

ä½†æ˜¯å®äº‹æ±‚æ˜¯çš„è¯´ï¼Œè¿™äº›åœºæ™¯å¯¹äºå‡ ä¹ä»»ä½• Rust å¼€å‘éƒ½æ˜¯å¾ˆå°‘é‡åˆ°çš„ï¼Œ99% çš„åœºæ™¯ä½ å¯ä»¥ä½¿ç”¨ `Vec` æ¥æ›¿ä»£ï¼Œç„¶å 1% ä¸­çš„ 99% å¯ä»¥ä½¿ç”¨ `VecDeque`ã€‚ ç”±äºå®ƒä»¬å…·æœ‰æ›´å°‘çš„å†…å­˜åˆ†é…æ¬¡æ•°ã€æ›´ä½çš„å†…å­˜å ç”¨ã€éšæœºè®¿é—®å’Œç¼“å­˜äº²å’Œç‰¹æ€§ï¼Œå› æ­¤èƒ½å¤Ÿé€‚ç”¨äºç»å¤§å¤šæ•°å·¥ä½œåœºæ™¯ã€‚æ€»ä¹‹ï¼Œç±»ä¼¼äº `trie` æ ‘ï¼Œé“¾è¡¨ä¹Ÿæ˜¯ä¸€ç§éå¸¸å°ä¼—çš„æ•°æ®ç»“æ„ï¼Œç‰¹åˆ«æ˜¯å¯¹äº Rust å¼€å‘è€Œè¨€ã€‚

> æœ¬ä¹¦åªæ˜¯ä¸ºäº†å­¦ä¹ é“¾è¡¨è¯¥å¦‚ä½•å®ç°ï¼Œå¦‚æœå¤§å®¶åªæ˜¯ä¸ºäº†ä½¿ç”¨é“¾è¡¨ï¼Œå¼ºçƒˆæ¨èç›´æ¥ä½¿ç”¨æ ‡å‡†åº“æˆ–è€…ç¤¾åŒºæä¾›çš„ç°æˆå®ç°ï¼Œä¾‹å¦‚ [std::collections::LinkedList](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)

#### é“¾è¡¨æœ‰ O(1) çš„åˆ†å‰²ã€åˆå¹¶ã€æ’å…¥ã€ç§»é™¤æ€§èƒ½
æ˜¯çš„ï¼Œä½†æ˜¯ä½ é¦–å…ˆè¦è€ƒè™‘çš„æ˜¯ï¼Œè¿™äº›ä»£ç è¢«è°ƒç”¨çš„é¢‘ç‡æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿæ˜¯å¦åœ¨çƒ­ç‚¹è·¯å¾„ï¼Ÿ ç­”æ¡ˆå¦‚æœæ˜¯å¦å®šçš„ï¼Œé‚£ä¹ˆè¿˜æ˜¯å¼ºçƒˆå»ºè®®ä½¿ç”¨ `Vec` ç­‰ä¼ ç»Ÿæ•°æ®ç»“æ„ï¼Œå†µä¸”æ•´ä¸ªæ•°ç»„çš„æ‹·è´ä¹Ÿæ˜¯ç›¸å½“å¿«çš„ï¼

å†µä¸”ï¼Œ`Vec` ä¸Šçš„ `push` å’Œ `pop` æ“ä½œæ˜¯ `O(1)` çš„ï¼Œå®ƒä»¬æ¯”é“¾è¡¨æä¾›çš„ `push` å’Œ `pop` è¦æ›´å¿«ï¼æˆ‘ä»¬åªéœ€è¦é€šè¿‡ä¸€ä¸ªæŒ‡é’ˆ + å†…å­˜åç§»å°±å¯ä»¥è®¿é—®äº†ã€‚

> å…³äºæ˜¯å¦ä½¿ç”¨é“¾è¡¨è¿™ä¸ªé—®é¢˜ï¼ŒBjarne Stroustrup æœ‰è¿‡éå¸¸æ·±å…¥çš„[è®²è§£](https://www.youtube.com/watch?v=YQs6IC-vgmo)

ä½†æ˜¯å¦‚æœä½ çš„æ•´ä½“é¡¹ç›®ç¡®å®å› ä¸ºæŸä¸€æ®µåˆ†å‰²ã€åˆå¹¶çš„ä»£ç å¯¼è‡´äº†æ€§èƒ½ä½ä¸‹ï¼Œé‚£ä¹ˆå°±æ”¾å¿ƒå¤§èƒ†çš„ä½¿ç”¨é“¾è¡¨å§ã€‚


#### æˆ‘æ— æ³•æ¥å—å†…å­˜é‡æ–°åˆ†é…çš„ä»£ä»·
æ˜¯çš„ï¼Œ`Vec` å½“ [`capacity`](https://practice-zh.course.rs/collections/vector.html#capacity) ä¸å¤Ÿæ—¶ï¼Œä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ï¼Œç„¶åå°†ä¹‹å‰çš„ `Vec` å…¨éƒ¨æ‹·è´è¿‡å»ï¼Œä½†æ˜¯å¯¹äºç»å¤§å¤šæ•°ä½¿ç”¨åœºæ™¯ï¼Œè¦ä¹ˆ `Vec` ä¸åœ¨çƒ­ç‚¹è·¯å¾„ä¸­ï¼Œè¦ä¹ˆ `Vec` çš„å®¹é‡å¯ä»¥æå‰é¢„æµ‹ã€‚

å¯¹äºå‰è€…ï¼Œé‚£æ€§èƒ½å¦‚ä½•è‡ªç„¶æ— å…³ç´§è¦ã€‚è€Œå¯¹äºåè€…ï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ `Vec::with_capacity` æå‰åˆ†é…è¶³å¤Ÿçš„ç©ºé—´å³å¯ï¼ŒåŒæ—¶ï¼ŒRust ä¸­æ‰€æœ‰çš„è¿­ä»£å™¨è¿˜æä¾›äº† `size_hint` ä¹Ÿå¯ä»¥è§£å†³è¿™ç§é—®é¢˜ã€‚


å½“ç„¶ï¼Œå¦‚æœè¿™æ®µä»£ç åœ¨çƒ­ç‚¹è·¯å¾„ï¼Œä¸”ä½ æ— æ³•æå‰é¢„æµ‹æ‰€éœ€çš„å®¹é‡ï¼Œé‚£ä¹ˆé“¾è¡¨ç¡®å®ä¼šæ›´æå‡æ€§èƒ½ã€‚

#### é“¾è¡¨æ›´èŠ‚çœå†…å­˜ç©ºé—´
é¦–å…ˆï¼Œè¿™ä¸ªé—®é¢˜è¾ƒä¸ºå¤æ‚ã€‚ä¸€ä¸ªæ ‡å‡†çš„æ•°ç»„è°ƒæ•´ç­–ç•¥æ˜¯ï¼šå¢åŠ æˆ–å‡å°‘æ•°ç»„çš„é•¿åº¦ä½¿æ•°ç»„æœ€å¤šæœ‰ä¸€åŠä¸ºç©ºï¼Œä¾‹å¦‚ capacity å¢é•¿æ˜¯ç¿»å€çš„ç­–ç•¥ã€‚è¿™ç¡®å®ä¼šå¯¼è‡´å†…å­˜ç©ºé—´çš„æµªè´¹ï¼Œç‰¹åˆ«æ˜¯åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šè‡ªåŠ¨æ”¶ç¼©é›†åˆç±»å‹ã€‚

ä½†æ˜¯ä¸Šé¢è¯´çš„æ˜¯æœ€åçš„æƒ…å†µï¼Œå¦‚æœæ˜¯æœ€å¥½çš„æƒ…å†µï¼Œé‚£æ•´ä¸ªæ•°ç»„å…¶å®åªæœ‰ 3 ä¸ªæŒ‡é’ˆå¤§å°(æŒ‡é’ˆåœ¨ Rust ä¸­å ç”¨ä¸€ä¸ª word çš„ç©ºé—´ï¼Œä¾‹å¦‚ 64 ä½æœºå™¨å°±æ˜¯ 8 ä¸ªå­—èŠ‚çš„å¤§å°)çš„å†…å­˜æµªè´¹ï¼Œæˆ–è€…è¯´ï¼Œæ²¡æœ‰æµªè´¹ã€‚

è€Œä¸”é“¾è¡¨å®é™…ä¸Šä¹Ÿæœ‰å†…å­˜æµªè´¹ï¼Œä¾‹å¦‚é“¾è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä¼šå ç”¨é¢å¤–çš„å†…å­˜ï¼šå•å‘é“¾è¡¨æµªè´¹ä¸€ä¸ªæŒ‡é’ˆï¼ŒåŒå‘é“¾è¡¨æµªè´¹ä¸¤ä¸ªæŒ‡é’ˆã€‚å½“ç„¶ï¼Œå¦‚æœä½ çš„é“¾è¡¨ä¸­æ¯ä¸ªå…ƒç´ éƒ½å¾ˆå¤§ï¼Œé‚£ç›¸å¯¹æ¥è¯´ï¼Œè¿™ç§æµªè´¹ä¹Ÿå¾®ä¸è¶³é“ï¼Œä½†æ˜¯å¦‚æœé“¾è¡¨çš„å…ƒç´ è¾ƒå°ä¸”æ•°é‡å¾ˆå¤šå‘¢ï¼Ÿé‚£æµªè´¹çš„ç©ºé—´å°±ç›¸å½“å¯è§‚äº†ï¼

å½“ç„¶ï¼Œè¿™ä¸ªä¹Ÿå’Œä½¿ç”¨çš„å†…å­˜åˆ†é…å™¨æœ‰å…³( allocator )ï¼šå¯¹é“¾è¡¨èŠ‚ç‚¹çš„åˆ†é…å’Œå›æ”¶ä¼šç»å¸¸å‘ç”Ÿï¼Œè¿™æ ·å°±ä¸ä¼šæµªè´¹å†…å­˜ã€‚

æ€»ä¹‹ï¼Œå¦‚æœé“¾è¡¨çš„å…ƒç´ è¾ƒå¤§ï¼Œä½ ä¹Ÿæ— æ³•é¢„æµ‹æ•°ç»„çš„ç©ºé—´ï¼ŒåŒæ—¶è¿˜æœ‰ä¸€ä¸ªä¸é”™çš„å†…å­˜åˆ†é…å™¨ï¼Œé‚£é“¾è¡¨ç¡®å®å¯ä»¥èŠ‚çœç©ºé—´ï¼

#### æˆ‘åœ¨å‡½æ•°è¯­è¨€ä¸­ä¸€ç›´ä½¿ç”¨é“¾è¡¨
å¯¹äºå‡½æ•°è¯­è¨€è€Œè¨€ï¼Œé“¾è¡¨ç¡®å®éå¸¸æ£’ï¼Œå› ä¸ºä½ å¯ä»¥è§£å†³å¯å˜æ€§é—®é¢˜ï¼Œè¿˜èƒ½é€’å½’åœ°å»ä½¿ç”¨ï¼Œå½“ç„¶ï¼Œå¯èƒ½è¿˜æœ‰ä¸€å®šçš„å›¾æ–¹ä¾¿çš„å› ç´ ï¼Œå› ä¸ºé“¾è¡¨ä¸ç”¨æ“å¿ƒé•¿åº¦ç­‰é—®é¢˜ã€‚

ä½†å½¼ä¹‹èœœç³–ä¸ç­‰äºå¾ä¹‹èœœç³–ï¼Œå‡½æ•°è¯­è¨€çš„ä¸€äº›ä½¿ç”¨ä¹ æƒ¯ä¸åº”è¯¥å¸¦å…¥åˆ°å…¶å®ƒè¯­è¨€ä¸­ï¼Œä¾‹å¦‚ Rustã€‚

- å‡½æ•°è¯­è¨€å¾€å¾€å°†é“¾è¡¨ç”¨äºè¿­ä»£ï¼Œä½†æ˜¯ Rust ä¸­æœ€é€‚åˆè¿­ä»£çš„æ•°æ®ç»“æ„æ˜¯è¿­ä»£å™¨ `Iterator`
- å‡½æ•°å¼è¯­è¨€çš„ä¸å¯å˜å¯¹äº Rust ä¹Ÿä¸æ˜¯é—®é¢˜
- Rust è¿˜æ”¯æŒå¯¹æ•°ç»„è¿›è¡Œåˆ‡ç‰‡ä»¥è·å–å…¶ä¸­ä¸€éƒ¨åˆ†è¿ç»­çš„å…ƒç´ ï¼Œè€Œåœ¨å‡½æ•°è¯­è¨€ä¸­ä½ å¯èƒ½å¾—é€šè¿‡é“¾è¡¨çš„ `head/tail` åˆ†å‰²æ¥å®Œæˆ


å…¶å®ï¼Œåœ¨å‡½æ•°è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„æ¥è§£å†³é€‚åˆçš„åœºæ™¯ï¼Œè€Œä¸æ˜¯*ä¸€æ ¹é“¾è¡¨æŒ‚è…°é—´ï¼Œæ½‡æ½‡æ´’æ´’èµ°å¤©ä¸‹*ã€‚


#### é“¾è¡¨é€‚åˆæ„å»ºå¹¶å‘æ•°æ®ç»“æ„
æ˜¯è¿™æ ·çš„ï¼Œå¦‚æœæœ‰è¿™æ ·çš„éœ€æ±‚ï¼Œé‚£ä¹ˆé“¾è¡¨ä¼šéå¸¸åˆé€‚ï¼ä½†æ˜¯åªæœ‰åœ¨ä½ ç¡®å®éœ€è¦å¹¶å‘æ•°æ®ç»“æ„ï¼Œä¸”æ²¡æœ‰å…¶å®ƒåŠæ³•æ—¶ï¼Œå†è€ƒè™‘é“¾è¡¨ï¼

#### é“¾è¡¨éå¸¸é€‚åˆæ•™å­¦ç›®çš„
é¢... è¿™ä¹ˆè¯´ä¹Ÿæ²¡é”™ï¼Œæ¯•ç«Ÿæ‰€æœ‰çš„ç¼–ç¨‹è¯­è¨€è¯¾ç¨‹éƒ½ä»¥é“¾è¡¨æ¥ä½œä¸ºæœ€å¸¸è§çš„ç»ƒæ‰‹é¡¹ç›®ï¼ŒåŒ…æ‹¬æœ¬ä¹¦ä¹Ÿæ˜¯æœåŠ¡äºè¿™ä¸ªç›®çš„çš„ã€‚






================================================
FILE: src/too-many-lists/intro.md
================================================
# æ‰‹æŠŠæ‰‹å¸¦ä½ å®ç°é“¾è¡¨

> å…¶å®ƒè¯­è¨€ï¼šå…„å¼Ÿï¼Œè¯­è¨€å­¦äº†å—ï¼Ÿæ¥å†™ä¸€ä¸ªé“¾è¡¨è¯æ˜ä½ åŸºæœ¬æŒæ¡äº†è¯­æ³•ã€‚
> 
> Rust è¯­è¨€: å…„å¼Ÿï¼Œè¯­è¨€ç²¾é€šäº†å—ï¼Ÿæ¥å†™ä¸€ä¸ªé“¾è¡¨è¯æ˜ä½ å·²ç»ç²¾é€šäº† Rustï¼


ä¸Šé¢çš„å¯¹è¯éå¸¸çœŸå®ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„ç« èŠ‚ä¹Ÿè®²è¿‡[é¿å…ä»å…¥é—¨åˆ°æ”¾å¼ƒ](https://course.rs/first-try/sth-you-should-not-do.html#åƒä¸‡åˆ«ä»é“¾è¡¨æˆ–å›¾å¼€å§‹ç»ƒæ‰‹)ï¼Œå…¶ä¸­æœ€é‡è¦çš„å°±æ˜¯ - ä¸è¦å†™é“¾è¡¨æˆ–è€…ç±»ä¼¼çš„æ•°æ®ç»“æ„ï¼

è€Œæœ¬ç« ï¼Œä½ å°±å°†è§è¯†åˆ°ä½•ä¸ºçœŸæ­£çš„æ·±å‘ï¼Œçœ‹å®Œåï¼Œå°±çŸ¥é“æ²¡æœ‰ææ—©è·³è¿›å»æ˜¯ä¸€ä¸ªå¤šä¹ˆå¹¸è¿çš„äº‹ã€‚æ€»ä¹‹ï¼Œåœ¨ä¸“é¢˜ä¸­ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•ä½¿ç”¨ Rust æ¥å®ç°é“¾è¡¨ã€‚


**ä¸“é¢˜å†…å®¹ç¿»è¯‘è‡ªè‹±æ–‡å¼€æºä¹¦ [Learning Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/)ï¼Œä½†æ˜¯åœ¨å†…å®¹ä¸Šåšäº†ä¸€äº›è°ƒæ•´(åŸä¹¦è™½ç„¶éå¸¸æ£’ï¼Œä½†æ˜¯åœ¨ä¸€äº›å†…å®¹ç»„ç»‡å’Œæ–‡å­—ç»†èŠ‚ä¸Šæˆ‘è§‰å¾—è¿˜æ˜¯å¯ä»¥ä¼˜åŒ–ä¸‹çš„ ï¼šD)ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢ã€‚**




================================================
FILE: src/too-many-lists/advanced-lists/double-singly.md
================================================
# åŒå•å‘é“¾è¡¨
åœ¨ä¹‹å‰çš„åŒå‘é“¾è¡¨ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸€åº¦éå¸¸çº ç»“ï¼ŒåŸå› æ¥è‡ªåŒæ ·çº ç»“æˆä¸€å›¢çš„æ‰€æœ‰æƒä¾èµ–ã€‚è¿˜æœ‰ä¸€ä¸ªé‡è¦åŸå› å°±æ˜¯ï¼šå…ˆå…¥ä¸ºä¸»çš„é“¾è¡¨å®šä¹‰ã€‚

è°è¯´æ‰€æœ‰çš„é“¾æ¥ä¸€å®šè¦ä¸€ä¸ªæ–¹å‘å‘¢ï¼Ÿè¿™é‡Œä¸€èµ·æ¥å°è¯•ä¸‹æ–°çš„ä¸œä¸œï¼šé“¾è¡¨çš„å…¶ä¸­ä¸€åŠæœå·¦ï¼Œå¦ä¸€åŠæœå³ã€‚

æ–°è§„çŸ©( è€è§„çŸ©æ˜¯åˆ›å»ºæ–‡ä»¶ )ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å—:
```rust
// lib.rs
// ...
pub mod silly1;     // NEW!
```

```rust
// silly1.rs
use crate::second::List as Stack;

struct List<T> {
    left: Stack<T>,
    right: Stack<T>,
}
```

è¿™é‡Œå°†ä¹‹å‰çš„ `List` å¼•å…¥è¿›æ¥ï¼Œå¹¶é‡å‘½åä¸º `Stack`ï¼Œæ¥ç€ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚ç°åœ¨æ—¢å¯ä»¥å‘å·¦å¢é•¿åˆå¯ä»¥å‘å³å¢é•¿ã€‚

```rust
pub struct Stack<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Stack { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| {
            &node.elem
        })
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| {
            &mut node.elem
        })
    }
}

impl<T> Drop for Stack<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

ç¨å¾®ä¿®æ”¹ä¸‹ `push` å’Œ `pop`ï¼š
```rust
pub fn push(&mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&mut self, mut node: Box<Node<T>>) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&mut self) -> Option<T> {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&mut self) -> Option<Box<Node<T>>> {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
```

ç°åœ¨å¯ä»¥å¼€å§‹æ„é€ æ–°çš„é“¾è¡¨:
```rust
pub struct List<T> {
    left: Stack<T>,
    right: Stack<T>,
}

impl<T> List<T> {
    fn new() -> Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
```

å½“ç„¶ï¼Œè¿˜æœ‰ä¸€å¤§å †å·¦å·¦å³å³ç±»å‹çš„æ“ä½œ:
```rust
pub fn push_left(&mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&mut self) -> Option<T> { self.left.pop() }
pub fn pop_right(&mut self) -> Option<T> { self.right.pop() }
pub fn peek_left(&self) -> Option<&T> { self.left.peek() }
pub fn peek_right(&self) -> Option<&T> { self.right.peek() }
pub fn peek_left_mut(&mut self) -> Option<&mut T> { self.left.peek_mut() }
pub fn peek_right_mut(&mut self) -> Option<&mut T> { self.right.peek_mut() }
```

å…¶ä¸­æœ€æœ‰è¶£çš„æ˜¯ï¼šè¿˜å¯ä»¥æ¥å›é—²é€›äº†ã€‚
```rust
pub fn go_left(&mut self) -> bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&mut self) -> bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
```

è¿™é‡Œè¿”å› `bool` æ˜¯ä¸ºäº†å‘Šè¯‰è°ƒç”¨è€…æˆ‘ä»¬æ˜¯å¦æˆåŠŸçš„ç§»åŠ¨ã€‚æœ€åï¼Œå†æ¥æµ‹è¯•ä¸‹ï¼š
```rust
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&0));
        assert_eq!(list.peek_right(), Some(&1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured
```

ä¸Šä¸Šä¸‹ä¸‹ï¼Œå·¦å·¦å³å³ï¼ŒBABAï¼Œå“¦è€¶ï¼Œè¿™ä¸ªé“¾è¡¨æ— æ•Œäº†ï¼

ä»¥ä¸Šæ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„<ruby>æ‰‹æŒ‡å‹æ•°æ®ç»“æ„<rt>finger data structure</rt></ruby>ï¼Œåœ¨å…¶ä¸­ç»´æŠ¤ä¸€ä¸ªæ‰‹æŒ‡ï¼Œç„¶åæ“ä½œæ‰€éœ€çš„æ—¶é—´ä¸æ‰‹æŒ‡çš„è·ç¦»æˆæ­£æ¯”ã€‚




================================================
FILE: src/too-many-lists/advanced-lists/intro.md
================================================
# ä½¿ç”¨é«˜çº§æŠ€å·§å®ç°é“¾è¡¨

è¯´å¥å®è¯ï¼Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„é“¾è¡¨éƒ½è¾¾ä¸åˆ°ç”Ÿäº§çº§å¯ç”¨çš„ç¨‹åº¦ï¼Œè€Œä¸”ä¹Ÿæ²¡æœ‰ç”¨åˆ°ä¸€äº›æ¯”è¾ƒæ—¶é«¦çš„æŠ€å·§ã€‚

æœ¬ç« æˆ‘ä»¬ä¸€èµ·æ¥çœ‹ä¸€äº›æ›´æ—¶é«¦çš„é“¾è¡¨å®ç°:

1. åŒé‡å•å‘é“¾è¡¨
2. æ ˆåˆ†é…çš„é“¾è¡¨
3. è‡ªå¼•ç”¨å’ŒArenaåˆ†é…å™¨å®ç°( åŸæ–‡ä½œè€…è¿˜æœªå®ç°ï¼Œæ‰€ä»¥... Todo )
4. GhostCell å®ç°( åŒä¸Š )



================================================
FILE: src/too-many-lists/advanced-lists/stack-allocated.md
================================================
# æ ˆä¸Šçš„é“¾è¡¨
åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œæ— ä¸€ä¾‹å¤–ï¼Œæˆ‘ä»¬åˆ›å»ºçš„éƒ½æ˜¯æ•°æ®å­˜å‚¨åœ¨å †ä¸Šçš„é“¾è¡¨ï¼Œè¿™ç§é“¾è¡¨æœ€å¸¸è§ä¹Ÿæœ€å®ç”¨ï¼šå †å†…å­˜åœ¨åŠ¨æ€åˆ†é…çš„åœºæ™¯éå¸¸å¥½ç”¨ã€‚

ä½†æ˜¯ï¼Œæ—¢ç„¶æ˜¯é«˜çº§æŠ€å·§ç« èŠ‚ï¼Œé‚£æ ˆé“¾è¡¨ä¹Ÿåº”è¯¥æ‹¥æœ‰ä¸€å¸­ä¹‹åœ°ã€‚ä½†ä¸å †å†…å­˜çš„ç®€å•åˆ†é…ç›¸æ¯”ï¼Œæ ˆå†…å­˜å°±æ²¡é‚£ä¹ˆå‹å¥½äº†ï¼Œä½ ä»¬çŒœå¤§åé¼é¼çš„ C è¯­è¨€çš„ `alloca` æ˜¯å› ä¸ºä»€ä¹ˆè€Œå‡ºåçš„ :)

é™äºç« èŠ‚ç¯‡å¹…ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç®€å•çš„æ ˆåˆ†é…æ–¹æ³•ï¼šè°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œè·å–ä¸€ä¸ªæ–°çš„ã€æ‹¥æœ‰æ›´å¤šç©ºé—´çš„æ ˆå¸§ã€‚è¯´å®è¯ï¼Œè¯¥è§£å†³æ–¹æ³•è¦å¤šæ„šè ¢æœ‰å¤šæ„šè ¢ï¼Œä½†æ˜¯å®ƒç¡®å®ç›¸å½“å®ç”¨ï¼Œç”šè‡³...æœ‰ç”¨ã€‚

ä»»ä½•æ—¶å€™ï¼Œå½“æˆ‘ä»¬åœ¨åšä¸€äº›é€’å½’çš„ä»»åŠ¡æ—¶ï¼Œéƒ½å¯ä»¥å°†å½“å‰æ­¥éª¤çŠ¶æ€çš„æŒ‡é’ˆä¼ é€’ç»™ä¸‹ä¸€ä¸ªæ­¥éª¤ã€‚å¦‚æœæŒ‡é’ˆæœ¬èº«å°±æ˜¯çŠ¶æ€çš„ä¸€éƒ¨åˆ†ï¼Œé‚£æ­å–œä½ ï¼šä½ åœ¨åˆ›å»ºä¸€ä¸ªæ ˆä¸Šåˆ†é…çš„é“¾è¡¨ï¼

æ–°çš„é“¾è¡¨ç±»å‹æœ¬èº«å°±æ˜¯ä¸€ä¸ª Nodeï¼Œå¹¶ä¸”åŒ…å«ä¸€ä¸ªå¼•ç”¨æŒ‡å‘å¦ä¸€ä¸ª Node:
```rust
pub struct List<'a, T> {
    pub data: T,
    pub prev: Option<&'a List<'a, T>>,
}
```

è¯¥é“¾è¡¨åªæœ‰ä¸€ä¸ªæ“ä½œ `push`ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè·Ÿå…¶å®ƒé“¾è¡¨ä¸åŒï¼Œè¿™é‡Œçš„ `push` æ˜¯é€šè¿‡å›è°ƒçš„æ–¹å¼æ¥å®Œæˆæ–°å…ƒç´ æ¨å…¥ï¼Œå¹¶å°†å›è°ƒè¿”å›çš„å€¼ç›´æ¥è¿”å›ç»™ `push` çš„è°ƒç”¨è€…:
```rust
impl<'a, T> List<'a, T> {
    pub fn push<U>(
        prev: Option<&'a List<'a, T>>, 
        data: T, 
        callback: impl FnOnce(&List<'a, T>) -> U,
    ) -> U {
        let list = List { data, prev };
        callback(&list)
    }
}
```

æå®šï¼Œæå‰é—®ä¸€å¥ï¼šä½ è§è¿‡å›è°ƒåœ°ç‹±å—ï¼Ÿ
```rust
List::push(None, 3, |list| {
    println!("{}", list.data);
    List::push(Some(list), 5, |list| {
        println!("{}", list.data);
        List::push(Some(list), 13, |list| {
            println!("{}", list.data);
        })
    })
})
```

ä¸ç¦è®©äººæ„Ÿå¹ï¼Œè¿™æ®µå›è°ƒä»£ç å¤šä¹ˆçš„ç¾ä¸½åŠ¨äººğŸ˜¿ã€‚

ç”¨æˆ·è¿˜å¯ä»¥ç®€å•åœ°ä½¿ç”¨ `while-let` çš„æ–¹å¼æ¥ç¼–è¯‘éå†é“¾è¡¨ï¼Œä½†æ˜¯ä¸ºäº†å¢åŠ ä¸€äº›è¶£å‘³ï¼Œå’±ä»¬è¿˜æ˜¯ç»§ç»­ä½¿ç”¨è¿­ä»£å™¨:
```rust
impl<'a, T> List<'a, T> {
    pub fn iter(&'a self) -> Iter<'a, T> {
        Iter { next: Some(self) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.prev;
            &node.data
        })
    }
}
```

æµ‹è¯•ä¸‹ï¼š
```rust
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn elegance() {
        List::push(None, 3, |list| {
            assert_eq!(list.iter().copied().sum::<i32>(), 3);
            List::push(Some(list), 5, |list| {
                assert_eq!(list.iter().copied().sum::<i32>(), 5 + 3);
                List::push(Some(list), 13, |list| {
                    assert_eq!(list.iter().copied().sum::<i32>(), 13 + 5 + 3);
                })
            })
        })
    }
}
```
```shell
$ cargo test

running 18 tests
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::basics ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test second::test::iter_mut ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test second::test::peek ... ok
test third::test::iter ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

éƒ¨åˆ†è¯»è€…æ­¤æ—¶å¯èƒ½ä¼šæœ‰ä¸€äº›å¤§èƒ†çš„æƒ³æ³•ï¼šå’¦ï¼Ÿæˆ‘èƒ½å¦ä¿®æ”¹ Node ä¸­çš„å€¼ï¼Ÿå¤§èƒ†ä½†è²Œä¼¼å¯è¡Œï¼Œä¸å¦¨æ¥è¯•è¯•ã€‚
```rust
pub struct List<'a, T> {
    pub data: T,
    pub prev: Option<&'a mut List<'a, T>>,
}

pub struct Iter<'a, T> {
    next: Option<&'a List<'a, T>>,
}

impl<'a, T> List<'a, T> {
    pub fn push<U>(
        prev: Option<&'a mut List<'a, T>>, 
        data: T, 
        callback: impl FnOnce(&mut List<'a, T>) -> U,
    ) -> U {
        let mut list = List { data, prev };
        callback(&mut list)
    }

    pub fn iter(&'a self) -> Iter<'a, T> {
        Iter { next: Some(self) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.prev.as_ref().map(|prev| &**prev);
            &node.data
        })
    }
}
```

```shell
$ cargo test

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:47:32
   |
46 |  List::push(Some(list), 13, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
47 |      assert_eq!(list.iter().copied().sum::<i32>(), 13 + 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:45:28
   |
44 |  List::push(Some(list), 5, |list| {
   |                             ----
   |                             |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |      assert_eq!(list.iter().copied().sum::<i32>(), 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here


<ad infinitum>
```

å—¯ï¼Œæ²¡æƒ³åˆ°æ˜¯æµ“çœ‰å¤§çœ¼çš„è¿­ä»£å™¨èƒŒå›äº†æˆ‘ä»¬ï¼Œä¸ºäº†éªŒè¯åˆ°åº•æ˜¯å“ªé‡Œå‡ºäº†é—®é¢˜ï¼Œæˆ‘ä»¬æ¥ä¿®æ”¹ä¸‹æµ‹è¯•:
```rust
#[test]
fn elegance() {
    List::push(None, 3, |list| {
        assert_eq!(list.data, 3);
        List::push(Some(list), 5, |list| {
            assert_eq!(list.data, 5);
            List::push(Some(list), 13, |list| {
                assert_eq!(list.data, 13);
            })
        })
    })
}
```

```shell
$ cargo test

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:46:17
   |
44 |   List::push(Some(list), 5, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |       assert_eq!(list.data, 5);
46 | /     List::push(Some(list), 13, |list| {
47 | |         assert_eq!(list.data, 13);
48 | |     })
   | |______^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:44:13
   |
42 |   List::push(None, 3, |list| {
   |                        ----
   |                        |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
43 |       assert_eq!(list.data, 3);
44 | /     List::push(Some(list), 5, |list| {
45 | |         assert_eq!(list.data, 5);
46 | |         List::push(Some(list), 13, |list| {
47 | |             assert_eq!(list.data, 13);
48 | |         })
49 | |     })
   | |______________^ `list` escapes the closure body here
```

åŸå› åœ¨äºæˆ‘ä»¬çš„é“¾è¡¨ä¸å°å¿ƒä¾èµ–äº†<ruby>å‹å˜<rt>variance</rt></ruby>ã€‚å‹å˜æ˜¯ä¸€ä¸ª[ç›¸å½“å¤æ‚çš„æ¦‚å¿µ](https://doc.rust-lang.org/nomicon/subtyping.html)ï¼Œä¸‹é¢æ¥ç®€å•äº†è§£ä¸‹ã€‚

æ¯ä¸€ä¸ªèŠ‚ç‚¹( Node )éƒ½åŒ…å«ä¸€ä¸ªå¼•ç”¨ï¼Œè¯¥å¼•ç”¨æŒ‡å‘å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ ä¸”è¿™ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚å¦‚æœä»æœ€é‡Œé¢çš„èŠ‚ç‚¹è§’åº¦æ¥çœ‹ï¼Œé‚£æ‰€æœ‰å¤–éƒ¨çš„èŠ‚ç‚¹éƒ½åœ¨ä½¿ç”¨å’Œå®ƒä¸€æ ·çš„ç”Ÿå‘½å‘¨æœŸï¼Œä½†è¿™ä¸ªæ˜¾ç„¶æ˜¯ä¸å¯¹çš„ï¼šé“¾è¡¨ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä¼šæ¯”å®ƒæŒ‡å‘çš„èŠ‚ç‚¹æ´»å¾—æ›´ä¹…ï¼Œå› ä¸ºå®ƒä»¬çš„ä½œç”¨åŸŸæ˜¯åµŒå¥—å­˜åœ¨çš„ã€‚

é‚£ä¹‹å‰çš„ä¸å¯å˜å¼•ç”¨ç‰ˆæœ¬ä¸ºä½•å¯ä»¥æ­£å¸¸å·¥ä½œå‘¢ï¼ŸåŸå› æ˜¯åœ¨å¤§å¤šæ•°æ—¶å€™ï¼Œç¼–è¯‘å™¨éƒ½èƒ½è‡ªå·±åˆ¤æ–­ï¼šè™½ç„¶æŸäº›ä¸œä¸œæ´»å¾—å¤ªä¹…äº†ï¼Œä½†æ˜¯è¿™æ˜¯å®‰å…¨çš„ã€‚å½“æˆ‘ä»¬æŠŠä¸€ä¸ª List å¡å…¥å¦ä¸€ä¸ªæ—¶ï¼Œç¼–è¯‘å™¨ä¼šè¿…é€Ÿå°†ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ”¶ç¼©ä»¥æ»¡è¶³æ–°çš„ List çš„éœ€æ±‚ï¼Œ**è¿™ç§ç”Ÿå‘½å‘¨æœŸæ”¶ç¼©å°±æ˜¯ä¸€ç§å‹å˜**ã€‚

å¦‚æœå¤§å®¶è¿˜æ˜¯è§‰å¾—ä¸å¤ªç†è§£ï¼Œæˆ‘ä»¬æ¥è€ƒè™‘ä¸‹å…¶å®ƒæ‹¥æœ‰ç»§æ‰¿ç‰¹æ€§çš„ç¼–ç¨‹è¯­è¨€ã€‚åœ¨è¯¥è¯­è¨€ä¸­ï¼Œå½“ä½ å°†ä¸€ä¸ª `Cat` ä¼ é€’ç»™éœ€è¦ `Animal` çš„åœ°æ–¹æ—¶( `Animal` æ˜¯ `Cat` çš„çˆ¶ç±»å‹)ï¼Œå‹å˜å°±å‘ç”Ÿäº†ã€‚ä»å­—é¢æ¥è¯´ï¼Œå°†ä¸€åªçŒ«ä¼ ç»™éœ€è¦åŠ¨ç‰©çš„åœ°æ–¹ï¼Œä¹Ÿæ˜¯åˆé€‚çš„ï¼Œæ¯•ç«ŸçŒ«ç¡®å®æ˜¯åŠ¨ç‰©çš„ä¸€ç§ã€‚

æ€»ä¹‹ï¼Œå¯ä»¥çœ‹å‡ºæ— è®ºæ˜¯ä»å¤§çš„ç”Ÿå‘½å‘¨æœŸæ”¶ç¼©ä¸ºå°çš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿˜æ˜¯ä» `Cat` åˆ° `Animal`ï¼Œå‹å˜çš„å…¸å‹ç‰¹å¾å°±æ˜¯ï¼šèŒƒå›´åœ¨å‡å°ï¼Œæ¯•ç«Ÿå­ç±»å‹çš„åŠŸèƒ½è‚¯å®šæ˜¯æ¯”çˆ¶ç±»å‹å¤šçš„ã€‚

æ—¢ç„¶æœ‰å‹å˜ï¼Œä¸ºä½•å¯å˜å¼•ç”¨çš„ç‰ˆæœ¬ä¼šæŠ¥é”™å‘¢ï¼Ÿå…¶å®åœ¨äºå‹å˜ä¸æ€»æ˜¯å®‰å…¨çš„ï¼Œå‡å¦‚ä¹‹å‰çš„ä»£ç å¯ä»¥ç¼–è¯‘ï¼Œé‚£æˆ‘ä»¬å¯ä»¥å†™å‡º<ruby>é‡Šæ”¾åå†ä½¿ç”¨<rt>use-after-free</rt></ruby> çš„ä»£ç :
```rust
List::push(None, 3, |list| {
    List::push(Some(list), 5, |list| {
        List::push(Some(list), 13, |list| {
            // å“ˆå“ˆï¼Œå¥½çˆ½ï¼Œç”±äºæ‰€æœ‰çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯ç›¸åŒçš„ï¼Œå› æ­¤ç¼–è¯‘å™¨å…è®¸æˆ‘é‡å†™çˆ¶èŠ‚ç‚¹ï¼Œå¹¶è®©å®ƒæŒæœ‰ä¸€ä¸ªå¯å˜æŒ‡é’ˆæŒ‡å‘æˆ‘è‡ªå·±ã€‚
            // æˆ‘å°†åˆ›å»ºæ‰€æœ‰çš„ use-after-free !
            *list.prev.as_mut().unwrap().prev = Some(list);
        })
    })
})
```

ä¸€æ—¦å¼•å…¥å¯å˜æ€§ï¼Œå‹å˜å°±ä¼šé€ æˆè¿™æ ·çš„éšæ‚£ï¼šæ„å¤–ä¿®æ”¹äº†ä¸è¯¥è¢«ä¿®æ”¹çš„ä»£ç ï¼Œä½†è¿™äº›ä»£ç çš„è°ƒç”¨è€…è¿˜åœ¨æœŸå¾…ç€å’Œå¾€å¸¸ä¸€æ ·çš„ç»“æœï¼ä¾‹å¦‚ä»¥ä¸‹ä¾‹å­ï¼š
```rust
let mut my_kitty = Cat;                  // Make a Cat (long lifetime)
let animal: &mut Animal = &mut my_kitty; // Forget it's a Cat (shorten lifetime)
*animal = Dog;                           // Write a Dog (short lifetime)
my_kitty.meow();                         // Meowing Dog! (Use After Free)
```

æˆ‘ä»¬å°†é•¿ç”Ÿå‘½å‘¨æœŸçš„çŒ«è½¬æ¢æˆçŸ­ç”Ÿå‘½å‘¨æœŸçš„åŠ¨ç‰©ï¼Œå¯å˜çš„ï¼ç„¶åé€šè¿‡çŸ­ç”Ÿå‘½å‘¨æœŸçš„åŠ¨ç‰©å°†æŒ‡é’ˆé‡æ–°æŒ‡å‘ä¸€åªç‹—ã€‚æ­¤æ—¶æˆ‘ä»¬æƒ³å»æ’¸è½¯èŒçŒ«çš„æ—¶å€™ï¼Œå°±å¬åˆ°ï¼š`æ—ºæ—º...å‘œå—·å—·å—·`ï¼Œå¯¹ï¼Œä½ æ²¡å¬é”™ï¼Œä¸ä»…æ²¡æœ‰äº†çŒ«å«ï¼Œç”šè‡³äºç‹—è¿˜æ²¡å«å®Œï¼Œå°±å¯èƒ½åœ¨æŸä¸ªåœ°æ–¹åˆè¢«ä¿®æ”¹æˆç‹¼äº†ã€‚

å› æ­¤ï¼Œ**è™½ç„¶ä½ å¯ä»¥ä¿®æ”¹å¯å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä½†æ˜¯ä¸€æ—¦å¼€å§‹åµŒå¥—ï¼Œå®ƒä»¬å°±å°†å¤±å»å‹å˜ï¼Œå˜æˆ`ä¸å˜( invariant )`**ã€‚æ­¤æ—¶ï¼Œå°±å†ä¹Ÿæ— æ³•å¯¹ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ”¶ç¼©äº†ã€‚

å…·ä½“æ¥è¯´: `&mut &'big mut T` æ— æ³•è¢«è½¬æ¢æˆ `&mut &'small mut T`ï¼Œè¿™é‡Œ `'big` ä»£è¡¨æ¯” `'small` æ›´å¤§çš„ç”Ÿå‘½å‘¨æœŸã€‚æˆ–è€…ç”¨æ›´æ­£å¼çš„è¯´æ³•ï¼š`&'a mut T` å¯¹äº `'a` æ¥è¯´æ˜¯åå˜( `covariant` )çš„ï¼Œä½†æ˜¯å¯¹äº `T` æ˜¯ä¸å˜çš„( `invariant` )ã€‚

---

è¯´äº†è¿™ä¹ˆå¤šé«˜æ·±çš„ç†è®ºï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•æ”¹å˜é“¾è¡¨çš„æ•°æ®å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯ï¼šä½¿ç”¨è€æœ¬è¡Œ - å†…éƒ¨å¯å˜æ€§ã€‚

ä¸‹é¢è®©æˆ‘ä»¬å›æ»šåˆ°ä¹‹å‰çš„ä¸å¯å˜ç‰ˆæœ¬ï¼Œç„¶åä½¿ç”¨ `Cell` æ¥æ›¿ä»£ `&mut`ã€‚
```rust
#[test]
fn cell() {
    use std::cell::Cell;

    List::push(None, Cell::new(3), |list| {
        List::push(Some(list), Cell::new(5), |list| {
            List::push(Some(list), Cell::new(13), |list| {
                // Multiply every value in the list by 10
                for val in list.iter() {
                    val.set(val.get() * 10)
                }

                let mut vals = list.iter();
                assert_eq!(vals.next().unwrap().get(), 130);
                assert_eq!(vals.next().unwrap().get(), 50);
                assert_eq!(vals.next().unwrap().get(), 30);
                assert_eq!(vals.next(), None);
                assert_eq!(vals.next(), None);
            })
        })
    })
}
```

```shell
$ cargo test

running 19 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter_mut ... ok
test fifth::test::iter ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test first::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fifth::test::miri_food ... ok
test silly2::test::cell ... ok
test third::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test third::test::basics ... ok
test second::test::iter ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

ç®€ç®€å•å•æå®šï¼Œè™½ç„¶ä¹‹å‰æˆ‘ä»¬å«Œå¼ƒå†…éƒ¨å¯å˜æ€§ï¼Œä½†æ˜¯åœ¨è¿™é‡Œï¼šçœŸé¦™ï¼


================================================
FILE: src/too-many-lists/advanced-lists/unsafe-deque.md
================================================
# ç”Ÿäº§çº§å¯ç”¨çš„åŒå‘é“¾è¡¨
æ‰“å¼€[åŸæ–‡](https://rust-unofficial.github.io/too-many-lists/sixth.html)ï¼Œå‘ç°è¿™ä¸€ç¯‡åªæœ‰ä¸¤è¡Œï¼Œæˆ‘ä»¥ä¸ºè‡ªå·±çœ‹èŠ±äº†çœ¼ï¼Œæ‰äº†æ‰çœ¼ï¼Œå®šç›ä¸€çœ‹ï¼Œè¿˜æ˜¯ä¸¤è¡Œã€‚

æ²¡é”™ï¼Œè²Œä¼¼ä½œè€…æƒ³è¦å·æ‡’ï¼Œè€Œä¸”ä¸ºäº†æ©é¥°ï¼Œä»–è¿˜æä¾›äº†æ ‡å‡†åº“çš„å®ç°:) å¦‚æœå¤§å®¶æƒ³è¦å­¦ä¹ ï¼Œçœ‹[æ ‡å‡†åº“](https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs)å§ :D

> ä¸ºäº†èƒ½æ›´å¥½çš„çœ‹æ‡‚æ ‡å‡†åº“å®ç°ï¼Œä½ å¯èƒ½è¿˜éœ€è¦è¿™æœ¬ä¹¦çš„è¾…åŠ©: [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/)


================================================
FILE: src/too-many-lists/bad-stack/basic-operations.md
================================================
# å®šä¹‰åŸºæœ¬æ“ä½œ
è¿™ä¸ªç« èŠ‚æˆ‘ä»¬ä¸€èµ·æ¥ä¸ºæ–°åˆ›å»ºçš„ `List` å®šä¹‰ä¸€äº›åŸºæœ¬æ“ä½œï¼Œé¦–å…ˆä»åˆ›å»ºé“¾è¡¨å¼€å§‹ã€‚

## New
ä¸ºäº†å°†å®é™…çš„ä»£ç è·Ÿç±»å‹å…³è”åœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ `impl` è¯­å¥å—ï¼š
```rust
impl List {
    // TODO
}
```

ä¸‹ä¸€æ­¥å°±æ˜¯åˆ›å»ºä¸€ä¸ªå…³è”å‡½æ•°ï¼Œç”¨äºæ„å»º `List` çš„æ–°å®ä¾‹ï¼Œè¯¥å‡½æ•°çš„ä½œç”¨ç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„æ„é€ å‡½æ•°ã€‚
```rust
impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }
}
```

> å­¦ä¹ é“¾æ¥: [implã€å…³è”å‡½æ•°](https://course.rs/basic/method.html#å…³è”å‡½æ•°)ã€[Self](https://course.rs/basic/trait/trait-object.html?highlight=Self#self-ä¸-self) 


## Push
åœ¨å¼€å§‹å®ç°ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆäº†è§£ [selfã€&selfã€&mut sef](https://course.rs/basic/method.html#selfself-å’Œ-mut-self) è¿™å‡ ä¸ªæ¦‚å¿µã€‚

åœ¨åˆ›å»ºé“¾è¡¨åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å¾€é“¾è¡¨ä¸­æ’å…¥æ–°çš„å…ƒç´ ï¼Œç”±äº `push` ä¼šæ”¹å˜é“¾è¡¨ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨ `&mut self` çš„æ–¹æ³•ç­¾å:
```rust
impl List {
    pub fn push(&mut self, elem: i32) {
        // TODO
    }
}
```

æ ¹æ®ä¹‹å‰çš„æ•°æ®å®šä¹‰ï¼Œé¦–å…ˆéœ€è¦åˆ›å»ºä¸€ä¸ª `Node` æ¥å­˜æ”¾è¯¥å…ƒç´ :
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Node {
        elem: elem,
        next: ?????
    };
}
```

ä¸‹ä¸€æ­¥éœ€è¦è®©è¯¥èŠ‚ç‚¹æŒ‡å‘ä¹‹å‰çš„æ—§ `List`:
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Node {
        elem: elem,
        next: self.head,
    };
}
```

```shell
error[E0507]: cannot move out of `self.head` which is behind a mutable reference
  --> src/first.rs:23:19
   |
23 |             next: self.head,
   |                   ^^^^^^^^^ move occurs because `self.head` has type `Link`, which does not implement the `Copy` trait
```


ä½†æ˜¯ï¼Œå¦‚ä¸Šæ‰€ç¤ºï¼Œè¿™æ®µä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸ºè¯•å›¾å°†å€Ÿç”¨çš„å€¼ `self` ä¸­çš„ `head` å­—æ®µçš„æ‰€æœ‰æƒè½¬ç§»ç»™ `next` ï¼Œåœ¨ Rust ä¸­è¿™æ˜¯ä¸è¢«å…è®¸çš„ã€‚é‚£å¦‚æœæˆ‘ä»¬è¯•å›¾å°†å€¼å†æ”¾å›å»å‘¢ï¼Ÿ
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
```

å…¶å®åœ¨å†™ä¹‹å‰ï¼Œåº”è¯¥å°±é¢„æ–™åˆ°ç»“æœäº†ï¼Œæ˜¾ç„¶è¿™ä¹Ÿæ˜¯ä¸è¡Œçš„ï¼Œè™½ç„¶ä»æˆ‘ä»¬çš„è§’åº¦æ¥çœ‹è¿˜æŒºæ­£å¸¸çš„ï¼Œä½†æ˜¯ Rust å¹¶ä¸ä¼šæ¥å—(æœ‰å¤šç§åŸå› ï¼Œå…¶ä¸­ä¸»è¦çš„æ˜¯[Exception safety](https://doc.rust-lang.org/nightly/nomicon/exception-safety.html))ã€‚

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŠæ³•ï¼Œè®© Rust ä¸å†é˜»æŒ æˆ‘ä»¬ï¼Œå…¶ä¸­ä¸€ä¸ªå¯è¡Œçš„åŠæ³•æ˜¯ä½¿ç”¨ `clone`:
```rust
pub struct List {
    head: Link,
}

#[derive(Clone)]
enum Link {
    Empty,
    More(Box<Node>),
}

#[derive(Clone)]
struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head.clone(),
        };
    }
}
```

`clone` ç”¨èµ·æ¥ç®€å•ï¼Œä¸”å¯è§£ä¸‡æ„ï¼Œä½†æ˜¯ã€‚ã€‚ã€‚æ—¢ç„¶æ˜¯é“¾è¡¨ï¼Œæ€§èƒ½é‚£è‡ªç„¶æ˜¯å¾ˆé‡è¦çš„ï¼Œç‰¹åˆ«æ˜¯è¦å°è£…æˆåº“ç»™å…¶ä»–ä»£ç ä½¿ç”¨æ—¶ï¼Œé‚£æ€§èƒ½æ›´æ˜¯é‡ä¸­ä¹‹é‡ã€‚

æ²¡åŠæ³•äº†ï¼Œæˆ‘ä»¬åªèƒ½å‘å¤§åé¼é¼çš„ Rust é»‘å®¢ Indiana Jonesæ±‚åŠ©äº†:
<img src="https://rust-unofficial.github.io/too-many-lists/img/indy.gif" />

ç»è¿‡ä¸€ç•ªè¯šå¿ƒç¥ˆæ„¿ï¼ŒIndy å»ºè®®æˆ‘ä»¬ä½¿ç”¨ `mem::replace` ç§˜æŠ€ã€‚è¿™ä¸ªéå¸¸æœ‰ç”¨çš„å‡½æ•°å…è®¸æˆ‘ä»¬ä»ä¸€ä¸ªå€Ÿç”¨ä¸­å·å‡ºä¸€ä¸ªå€¼çš„åŒæ—¶å†æ”¾å…¥ä¸€ä¸ªæ–°å€¼ã€‚
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: std::mem::replace(&mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
```

è¿™é‡Œï¼Œæˆ‘ä»¬ä»å€Ÿç”¨ `self` ä¸­å·å‡ºäº†å®ƒçš„å€¼ `head` å¹¶èµ‹äºˆç»™ `next` å­—æ®µï¼ŒåŒæ—¶å°†ä¸€ä¸ªæ–°å€¼ `Link::Empty` æ”¾å…¥åˆ° `head` ä¸­ï¼ŒæˆåŠŸå®Œæˆå·æ¢æ¢æŸ±ã€‚ä¸å¾—ä¸è¯´ï¼Œè¿™ä¸ªåšæ³•éå¸¸åˆºæ¿€ï¼Œä½†æ˜¯å¾ˆä¸å¹¸çš„æ˜¯ï¼Œç›®å‰ä¸ºæ­¢ï¼Œæœ€å¥½çš„åŠæ³•å¯èƒ½ä¹Ÿåªèƒ½æ˜¯å®ƒäº†ã€‚

ä½†æ˜¯ä¸ç®¡æ€æ ·ï¼Œæˆ‘ä»¬æˆåŠŸçš„å®Œæˆäº† `push` æ–¹æ³•ï¼Œä¸‹é¢å†æ¥çœ‹çœ‹ `pop`ã€‚

## Pop
`push` æ˜¯æ’å…¥å…ƒç´ ï¼Œé‚£ `pop` è‡ªç„¶å°±æ˜¯æ¨å‡ºä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤ä¹Ÿéœ€è¦ä½¿ç”¨ `&mut self`ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œæ¨å‡ºçš„å…ƒç´ éœ€è¦è¢«è¿”å›ï¼Œè¿™æ ·è°ƒç”¨è€…å°±å¯ä»¥è·å–è¯¥å…ƒç´ :
```rust
pub fn pop(&mut self) -> Option<i32> {
    // TODO
}
```

æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªåŠæ³•æ¥æ ¹æ® `Link` æ˜¯å¦æœ‰å€¼è¿›è¡Œä¸åŒçš„å¤„ç†ï¼Œè¿™ä¸ªå¯ä»¥ä½¿ç”¨ `match` æ¥è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼š
```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
}
```

ç›®å‰çš„ä»£ç æ˜¾ç„¶ä¼šæŠ¥é”™ï¼Œå› ä¸ºå‡½æ•°çš„è¿”å›å€¼æ˜¯ `Option<T>` æšä¸¾ï¼Œè€Œç›®å‰çš„è¿”å›å€¼æ˜¯ [`()`](https://course.rs/basic/base-type/function.html#æ— è¿”å›å€¼)ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›ä¸€ä¸ª`Option<T>` çš„æšä¸¾æˆå‘˜ `None`ï¼Œä½†æ˜¯ä¸€ä¸ªæ›´å¥½çš„åšæ³•æ˜¯ä½¿ç”¨ `unimplemented!()`ï¼Œè¯¥å®å¯ä»¥æ˜ç¡®åœ°è¯´æ˜ç›®å‰çš„ä»£ç è¿˜æ²¡æœ‰å®ç°ï¼Œä¸€æ—¦ä»£ç æ‰§è¡Œåˆ° `unimplemented!()` çš„ä½ç½®ï¼Œå°±ä¼šå‘ç”Ÿä¸€ä¸ª `panic`ã€‚

```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
    unimplemented!()
}
```
`panics` æ˜¯ä¸€ç§[å‘æ•£å‡½æ•°](https://course.rs/basic/base-type/function.html?search=#æ°¸ä¸è¿”å›çš„å‡½æ•°)ï¼Œè¯¥å‡½æ•°æ°¸ä¸è¿”å›ä»»ä½•å€¼ï¼Œå› æ­¤å¯ä»¥ç”¨äºéœ€è¦è¿”å›ä»»ä½•ç±»å‹çš„åœ°æ–¹ã€‚è¿™å¥è¯å¾ˆä¸å¥½ç†è§£ï¼Œä½†æ˜¯ä»ä¸Šé¢çš„ä»£ç ä¸­å¯ä»¥çœ‹å‡º `unimplemented!()` æ˜¯æ°¸ä¸è¿”å›çš„å‡½æ•°ï¼Œä½†æ˜¯å®ƒå´å¯ä»¥ç”¨äºä¸€ä¸ªè¿”å› `Option<i32>` çš„å‡½æ•°ä¸­æ¥æ›¿ä»£è¿”å›å€¼ã€‚

ä»¥ä¸Šä»£ç æœä¸å…¶ç„¶åˆæŠ¥é”™äº†:
```shell
$ cargo build

error[E0507]: cannot move out of borrowed content
  --> src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&self.head`
...
32 |             Link::More(node) => {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box<first::Node>`, which does not implement the `Copy` trait
```

å¥½åœ¨ç¼–è¯‘å™¨å·å·æç¤ºäº†æˆ‘ä»¬ä½¿ç”¨å€Ÿç”¨æ¥æ›¿ä»£æ‰€æœ‰æƒè½¬ç§»ï¼š `&self.head`ã€‚ä¿®æ”¹åï¼Œå¦‚ä¸‹ï¼š
```rust
pub fn pop(&mut self) -> Option<i32> {
    match &self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
    unimplemented!()
}
```

æ˜¯æ—¶å€™å¡«å†™ç›¸åº”çš„é€»è¾‘äº†:
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match &self.head {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

å½“é“¾è¡¨ä¸º `Empty` æ—¶ï¼Œè¿”å›ä¸€ä¸ª `None`ï¼Œè¡¨ç¤ºæˆ‘ä»¬æ²¡æœ‰ `pop` åˆ°ä»»ä½•å…ƒç´ ï¼›è‹¥ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶å°† `head` æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ `node.next`ã€‚ä½†æ˜¯è¿™æ®µä»£ç åˆæŠ¥é”™äº†ï¼š
```shell
error[E0507]: cannot move out of `node.next` which is behind a shared reference
  --> src/first.rs:37:29
   |
37 |                 self.head = node.next;
   |                             ^^^^^^^^^ move occurs because `node.next` has type `Link`, which does not implement the `Copy` trait
```


åŸå› æ˜¯è¯•å›¾è½¬ç§» `node` çš„æ‰€æœ‰æƒï¼Œä½†åªæœ‰å®ƒçš„å¼•ç”¨ã€‚å›å¤´ä»”ç»†çœ‹çœ‹ä»£ç ï¼Œä¼šå‘ç°è¿™é‡Œçš„å…³é”®æ˜¯æˆ‘ä»¬å¸Œæœ›ç§»é™¤ä¸€äº›ä¸œè¥¿ï¼Œè¿™æ„å‘³ç€éœ€è¦é€šè¿‡å€¼çš„æ–¹å¼è·å–é“¾è¡¨çš„ headã€‚çœ‹æ¥åªèƒ½æ•…æŠ€é‡æ–½äº†ï¼š
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match std::mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

æˆ‘ä»¬å°† `self.head` çš„å€¼å·å‡ºæ¥ï¼Œç„¶åå†å°† `Link::Empty` å¡«å›åˆ° `self.head` ä¸­ã€‚æ­¤æ—¶ç”¨äº `match` åŒ¹é…çš„å°±æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ç±»å‹ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„å¼•ç”¨ç±»å‹ã€‚

äº‹å®ä¸Šï¼Œä¸Šé¢çš„ä»£ç æœ‰äº›å•°å—¦ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨ `match` çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­é€šè¿‡è¡¨è¾¾å¼è¿›è¡Œè¿”å›:
```rust
pub fn pop(&mut self) -> Option<i32> {
    match std::mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => None,
        Link::More(node) => {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
```

è¿™æ ·ä¿®æ”¹åï¼Œä»£ç å°±æ›´åŠ ç®€æ´ï¼Œå¯è¯»æ€§ä¹Ÿæ›´å¥½äº†ï¼Œè‡³æ­¤é“¾è¡¨çš„åŸºæœ¬æ“ä½œå·²ç»å®Œæˆï¼Œä¸‹é¢è®©æˆ‘ä»¬å†™ä¸€ä¸ªæµ‹è¯•ä»£ç æ¥æµ‹è¯•ä¸‹å®ƒçš„åŠŸèƒ½å’Œæ­£ç¡®æ€§ã€‚


================================================
FILE: src/too-many-lists/bad-stack/final-code.md
================================================
# ä¸€äº›æ”¶å°¾å·¥ä½œä»¥åŠæœ€ç»ˆä»£ç 
åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å®Œæˆäº† Bad å•é“¾è¡¨æ ˆçš„æ•°æ®å®šä¹‰å’ŒåŸºæœ¬æ“ä½œï¼Œä¸‹é¢ä¸€èµ·æ¥å†™ä¸€äº›æµ‹è¯•ä»£ç ã€‚


## å•å…ƒæµ‹è¯•
> å…³äºå¦‚ä½•ç¼–å†™æµ‹è¯•ï¼Œè¯·å‚è§[è‡ªåŠ¨åŒ–æµ‹è¯•ç« èŠ‚](https://course.rs/test/write-tests.html)

é¦–å…ˆï¼Œå•å…ƒæµ‹è¯•ä»£ç è¦æ”¾åœ¨å¾…æµ‹è¯•çš„ç›®æ ‡ä»£ç æ—è¾¹ï¼Œä¹Ÿå°±æ˜¯åŒä¸€ä¸ªæ–‡ä»¶ä¸­:
```rust
// in first.rs
#[cfg(test)]
mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
```

åœ¨ `src/first.rs` ä¸­æ·»åŠ ä»¥ä¸Šæµ‹è¯•æ¨¡å—ï¼Œç„¶åä½¿ç”¨ `cargo test` è¿è¡Œç›¸å…³çš„æµ‹è¯•ç”¨ä¾‹ï¼š
```shell
$ cargo test

error[E0433]: failed to resolve: use of undeclared type or module `List`
  --> src/first.rs:43:24
   |
43 |         let mut list = List::new();
   |                        ^^^^ use of undeclared type or module `List`

```

Ooops! æŠ¥é”™äº†ï¼Œä»é”™è¯¯å†…å®¹æ¥çœ‹ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ä¸€ä¸ªä¸åŒçš„æ¨¡å— `test` ä¸­ï¼Œå¼•å…¥äº† `first` æ¨¡å—ä¸­çš„ä»£ç ï¼Œç”±äºå‰è€…æ˜¯åè€…çš„å­æ¨¡å—ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼å¼•å…¥ `first` æ¨¡å—ä¸­çš„ `List` å®šä¹‰:
```rust
#[cfg(test)]
mod test {
    use super::List;
    // å…¶å®ƒä»£ç ä¿æŒä¸å˜
}
```

å¤§å®¶å¯ä»¥å†æ¬¡å°è¯•ä½¿ç”¨ `cargo test` è¿è¡Œæµ‹è¯•ç”¨ä¾‹ï¼Œå…·ä½“çš„ç»“æœå°±ä¸å†å±•å¼€ï¼Œå…³äºç»“æœçš„è§£è¯»ï¼Œè¯·å‚çœ‹æ–‡ç« å¼€å¤´çš„é“¾æ¥ã€‚

## Drop
ç°åœ¨è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æ˜¯å¦éœ€è¦æ‰‹åŠ¨æ¥æ¸…ç†é‡Šæ”¾æˆ‘ä»¬çš„é“¾è¡¨ï¼Ÿç­”æ¡ˆæ˜¯ Noï¼Œå› ä¸º Rust ä¸ºæˆ‘ä»¬æä¾›äº† `Drop` ç‰¹å¾ï¼Œè‹¥å˜é‡å®ç°äº†è¯¥ç‰¹å¾ï¼Œåˆ™åœ¨å®ƒç¦»å¼€ä½œç”¨åŸŸæ—¶å°†è‡ªåŠ¨è°ƒç”¨è§£æ„å‡½æ•°ä»¥å®ç°èµ„æºæ¸…ç†é‡Šæ”¾å·¥ä½œï¼Œæœ€å¦™çš„æ˜¯ï¼Œè¿™ä¸€åˆ‡éƒ½å‘ç”Ÿåœ¨ç¼–è¯‘æœŸï¼Œå› æ­¤æ²¡æœ‰å¤šä½™çš„æ€§èƒ½å¼€é”€ã€‚

> å…³äº Drop ç‰¹å¾çš„è¯¦ç»†ä»‹ç»ï¼Œè¯·å‚è§[æ™ºèƒ½æŒ‡é’ˆ - Drop](https://course.rs/advance/smart-pointer/drop.html)

äº‹å®ä¸Šï¼Œæˆ‘ä»¬æ— éœ€æ‰‹åŠ¨ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° `Drop` ç‰¹å¾ï¼ŒåŸå› æ˜¯ Rust è‡ªåŠ¨ä¸ºå‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å®ç°äº† `Drop`ï¼Œä¾‹å¦‚æˆ‘ä»¬è‡ªå®šä¹‰çš„ç»“æ„ä½“ï¼Œåªè¦ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µéƒ½å®ç°äº† `Drop`ï¼Œé‚£ç»“æ„ä½“ä¹Ÿä¼šè‡ªåŠ¨å®ç° `Drop` !

ä½†æ˜¯ï¼Œæœ‰çš„æ—¶å€™è¿™ç§è‡ªåŠ¨å®ç°å¯èƒ½ä¸å¤Ÿä¼˜ç§€ï¼Œä¾‹å¦‚è€ƒè™‘ä»¥ä¸‹é“¾è¡¨:
```shell
list -> A -> B -> C
```

å½“ `List` è¢«è‡ªåŠ¨ `drop` åï¼Œæ¥ç€ä¼šå»å°è¯• `Drop` Aï¼Œç„¶åæ˜¯ `B`ï¼Œæœ€åæ˜¯ `C`ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†è¯»è€…å¯èƒ½ä¼šç´§å¼ èµ·æ¥ï¼Œå› æ­¤è¿™å…¶å®æ˜¯ä¸€æ®µé€’å½’ä»£ç ï¼Œå¯èƒ½ä¼šç›´æ¥æ’‘çˆ†æˆ‘ä»¬çš„ stack æ ˆã€‚

ä¾‹å¦‚ä»¥ä¸‹çš„æµ‹è¯•ä»£ç ä¼šè¯•å›¾åˆ›å»ºä¸€ä¸ªå¾ˆé•¿çš„é“¾è¡¨ï¼Œç„¶åä¼šå¯¼è‡´æ ˆæº¢å‡ºé”™è¯¯:
```rust
#[test]
fn long_list() {
    let mut list = List::new();
    for i in 0..100000 {
        list.push(i);
    }
    drop(list);
}
```


```shell
thread 'first::test::long_list' has overflowed its stack
```

å¯èƒ½å¦ä¸€éƒ¨åˆ†åŒå­¦ä¼šæƒ³ "è¿™æ˜¾ç„¶æ˜¯[å°¾é€’å½’](https://zh.wikipedia.org/wiki/å°¾è°ƒç”¨)ï¼Œä¸€ä¸ªé è°±çš„ç¼–ç¨‹è¯­è¨€æ˜¯ä¸ä¼šè®©å°¾é€’å½’æ’‘çˆ†æˆ‘ä»¬çš„ stack"ã€‚ç„¶åï¼Œè¿™ä¸ªæƒ³æ³•å¹¶ä¸æ­£ç¡®ï¼Œä¸‹é¢è®©æˆ‘ä»¬å°è¯•æ¨¡æ‹Ÿç¼–è¯‘å™¨æ¥çœ‹çœ‹ `Drop` ä¼šå¦‚ä½•å®ç°:
```rust
impl Drop for List {
    fn drop(&mut self) {
        // NOTE: åœ¨ Rust ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸èƒ½æ˜¾å¼çš„è°ƒç”¨ `drop` æ–¹æ³•ï¼Œåªèƒ½è°ƒç”¨ std::mem::drop å‡½æ•°
        // è¿™é‡Œåªæ˜¯åœ¨æ¨¡æ‹Ÿç¼–è¯‘å™¨!
        self.head.drop(); // å°¾é€’å½’ - good!
    }
}

impl Drop for Link {
    fn drop(&mut self) {
        match *self {
            Link::Empty => {} // Done!
            Link::More(ref mut boxed_node) => {
                boxed_node.drop(); // å°¾é€’å½’ - good!
            }
        }
    }
}

impl Drop for Box<Node> {
    fn drop(&mut self) {
        self.ptr.drop(); // ç³Ÿç³•ï¼Œè¿™é‡Œä¸æ˜¯å°¾é€’å½’!
        deallocate(self.ptr); // ä¸æ˜¯å°¾é€’å½’çš„åŸå› æ˜¯åœ¨ `drop` åï¼Œè¿˜æœ‰é¢å¤–çš„æ“ä½œ
    }
}

impl Drop for Node {
    fn drop(&mut self) {
        self.next.drop();
    }
}
```

ä»ä¸Šé¢çš„ä»£ç å’Œæ³¨é‡Šå¯ä»¥çœ‹å‡ºä¸º `Box<Node>` å®ç°çš„ `drop` æ–¹æ³•ä¸­ï¼Œåœ¨ `self.ptr.drop` åè°ƒç”¨çš„ `deallocate` ä¼šå¯¼è‡´éå°¾é€’å½’çš„æƒ…å†µå‘ç”Ÿã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨ä¸º `List` å®ç° `Drop` ç‰¹å¾:
```rust
impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, Link::Empty);
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, Link::Empty);
            // boxed_node åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸå¹¶è¢« drop,
            // ç”±äºå®ƒçš„ `next` å­—æ®µæ‹¥æœ‰çš„ `Node` è¢«è®¾ç½®ä¸º Link::Empty,
            // å› æ­¤è¿™é‡Œå¹¶ä¸ä¼šæœ‰æ— è¾¹ç•Œçš„é€’å½’å‘ç”Ÿ
        }
    }
}
```

æµ‹è¯•ä¸‹ä¸Šé¢çš„å®ç°ä»¥åŠä¹‹å‰çš„é•¿é“¾è¡¨ä¾‹å­:
```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test first::test::long_list ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

å®Œç¾ï¼

<span style="float:left"><img src="https://rust-unofficial.github.io/too-many-lists/img/profbee.gif" /></span>

#### ä¸ºä»€ä¹ˆè¦æå‰ä¼˜åŒ–ï¼Ÿ

äº‹å®ä¸Šï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œåšäº†æå‰ä¼˜åŒ–ï¼Œå¦åˆ™å¯ä»¥ä½¿ç”¨ `while let Some(_) = self.pop() { }`, è¿™ç§å®ç°æ˜¾ç„¶æ›´åŠ ç®€å•. é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼šå®ƒä»¬çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Œæœ‰å“ªäº›æ€§èƒ½ä¸Šçš„å¥½å¤„ï¼Ÿç‰¹åˆ«æ˜¯åœ¨é“¾è¡¨ä¸ä»…ä»…æ”¯æŒ `i32` æ—¶ã€‚

<details>
  <summary>ç‚¹å‡»è¿™é‡Œå±•å¼€ç­”æ¡ˆ</summary>

`self.pop()` çš„ä¼šè¿”å› `Option<i32>`, è€Œæˆ‘ä»¬ä¹‹å‰çš„å®ç°ä»…ä»…å¯¹æ™ºèƒ½æŒ‡é’ˆ `Box<Node>` è¿›è¡Œæ“ä½œã€‚å‰è€…ä¼šå¯¹å€¼è¿›è¡Œæ‹·è´ï¼Œè€Œåè€…ä»…ä»…ä½¿ç”¨çš„æ˜¯æŒ‡é’ˆç±»å‹ã€‚

å½“é“¾è¡¨ä¸­åŒ…å«çš„å€¼æ˜¯å…¶ä»–è¾ƒå¤§çš„ç±»å‹æ—¶ï¼Œé‚£è¿™ä¸ªæ‹·è´çš„å¼€é”€å°†å˜å¾—éå¸¸é«˜æ˜‚ã€‚
</details>

## æœ€ç»ˆä»£ç 
```rust
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match mem::replace(&mut self.head, Link::Empty) {
            Link::Empty => None,
            Link::More(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
```

ä»ä»£ç è¡Œæ•°ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬å®ç°çš„è‚¯å®šä¸æ˜¯ä¸€ä¸ªç²¾è‡´çš„é“¾è¡¨ï¼šæ€»å…±åªæœ‰ 80 è¡Œä»£ç ï¼Œå…¶ä¸­ä¸€åŠè¿˜æ˜¯æµ‹è¯•ï¼

ä½†æ˜¯ä¸‡äº‹å¼€å¤´éš¾ï¼Œæ—¢ç„¶å¼€äº†ä¸€ä¸ªå¥½å¤´ï¼Œé‚£æ¥ä¸‹æ¥æˆ‘ä»¬ä¸€é¼“ä½œæ°”ï¼Œç»§ç»­çœ‹çœ‹æ›´ç²¾è‡´çš„é“¾è¡¨é•¿ä»€ä¹ˆæ ·ã€‚



================================================
FILE: src/too-many-lists/bad-stack/intro.md
================================================
# ç³Ÿç³•çš„å•å‘é“¾è¡¨æ ˆ
æœ¬ç« ï¼Œè®©æˆ‘ä»¬ç”¨ä¸€ä¸ªä¸å’‹æ ·çš„å•å‘é“¾è¡¨æ¥å®ç°ä¸€ä¸ªæ ˆæ•°æ®ç»“æ„ï¼Œå› ä¸ºä¸å’‹æ ·ï¼Œå®ç°èµ·æ¥å€’æ˜¯å¾ˆç®€å•ã€‚

é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ `src/first.rs` ç”¨äºå­˜æ”¾æœ¬ç« èŠ‚çš„é“¾è¡¨ä»£ç ï¼Œè™½ç„¶ç³Ÿç³•ï¼Œä¹Ÿä¸èƒ½ç”¨å®Œå°±æ‰”ï¼Œå¤§å®¶è¯´æ˜¯ä¸ :P ç„¶ååœ¨ `lib.rs` ä¸­æ·»åŠ è¿™ä¸€è¡Œä»£ç ï¼š

```rust
// in lib.rs
pub mod first;
```



================================================
FILE: src/too-many-lists/bad-stack/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/deque/final-code.md
================================================
# æœ€ç»ˆä»£ç 
è¿™ä¸€ç« çœŸä¸å¥½å†™( ä¹Ÿå¾ˆéš¾ç¿»è¯‘... )ï¼Œæœ€ç»ˆæˆ‘ä»¬å®ç°äº†ä¸€ä¸ª 100% å®‰å…¨ä½†æ˜¯åŠŸèƒ½æ®‹ç¼ºçš„åŒå‘é“¾è¡¨ã€‚

åŒæ—¶åœ¨å®ç°ä¸­ï¼Œè¿˜æœ‰å¤§é‡ `Rc` å’Œ `RefCell` å¼•èµ·çš„è¿è¡Œæ—¶æ£€æŸ¥ï¼Œæœ€ç»ˆä¼šå½±å“é“¾è¡¨çš„æ€§èƒ½ã€‚æ•´ä¸ªåŒå‘é“¾è¡¨å®ç°å²å°±æ˜¯ä¸€éƒ¨åˆ«åå’Œæ‰€æœ‰æƒçš„å¥‹æ–—å²ã€‚

æ€»ä¹‹ï¼Œä¸ç®¡çˆ±ä¸ä¸çˆ±ï¼Œå®ƒå°±è¿™æ ·äº†ï¼Œç‰¹åˆ«æ˜¯å¦‚æœæˆ‘ä»¬ä¸åœ¨æ„å†…éƒ¨çš„ç»†èŠ‚æš´éœ²ç»™å¤–é¢ç”¨æˆ·æ—¶ã€‚

è€Œä»ä¸‹ä¸€ç« å¼€å§‹ï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªçœŸæ­£èƒ½å¤Ÿå…¨ç›˜æŒæ§çš„é“¾è¡¨ï¼Œå½“ç„¶...é€šè¿‡ unsafe ä»£ç å®ç°ï¼


```rust

#![allow(unused)]
fn main() {
use std::rc::Rc;
use std::cell::{Ref, RefMut, RefCell};

pub struct List<T> {
    head: Link<T>,
    tail: Link<T>,
}

type Link<T> = Option<Rc<RefCell<Node<T>>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
    prev: Link<T>,
}


impl<T> Node<T> {
    fn new(elem: T) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) => {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None => {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) => {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None => {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) => {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None => {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) => {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None => {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&self) -> Option<Ref<T>> {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &node.elem)
        })
    }

    pub fn peek_back(&self) -> Option<Ref<T>> {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &node.elem)
        })
    }

    pub fn peek_back_mut(&mut self) -> Option<RefMut<T>> {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &mut node.elem)
        })
    }

    pub fn peek_front_mut(&mut self) -> Option<RefMut<T>> {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &mut node.elem)
        })
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while self.pop_front().is_some() {}
    }
}

pub struct IntoIter<T>(List<T>);

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<T> {
        self.0.pop_front()
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- back -----

        // Check empty list behaves right
        assert_eq!(list.pop_back(), None);

        // Populate list
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_back(4);
        list.push_back(5);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&*list.peek_front().unwrap(), &3);
        assert_eq!(&mut *list.peek_front_mut().unwrap(), &mut 3);
        assert_eq!(&*list.peek_back().unwrap(), &1);
        assert_eq!(&mut *list.peek_back_mut().unwrap(), &mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
}
```


================================================
FILE: src/too-many-lists/deque/intro.md
================================================
# ä¸å¤ªä¼˜ç§€çš„åŒç«¯é˜Ÿåˆ—
åœ¨å®ç°äº†ä¹‹å‰çš„é˜Ÿåˆ—åï¼Œæˆ‘ä»¬ä¸ç¦æµ®æƒ³è”ç¿©ï¼Œå¦‚æœ `Rc` æ˜¯å¯å˜çš„ï¼Œé‚£æ˜¯ä¸æ˜¯å¯ä»¥å®ç°ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Ÿ

å¿ƒåŠ¨ä¸å¦‚è¡ŒåŠ¨ï¼Œå…ˆæ¥åˆ›å»ºæ–°çš„é“¾è¡¨æ–‡ä»¶ `fourth.rs`ï¼Œå¹¶åœ¨ `src/lib.rs` ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
```

ä¾ç„¶æ˜¯ç†Ÿæ‚‰çš„ä»é›¶å¼€å§‹ï¼Œå½“ç„¶ï¼Œä¹Ÿä¾ç„¶ä¼šç”¨åˆ°ç†Ÿæ‚‰çš„ CV é…æ–¹ã€‚

> å£°æ˜ï¼šå¤§å®¶çœ‹åˆ°ç›®å½•åæ—¶ï¼Œå¿ƒé‡Œå°±åº”è¯¥åœ¨å˜€å’•äº†å§ï¼Ÿå…¶å®ä½ çš„å˜€å’•æ˜¯å¯¹çš„ï¼Œæ˜¯çš„ï¼Œæœ¬ç« çš„ç›®çš„æ˜¯ä¸ºäº†è¯æ˜ä¹‹å‰çš„æƒ³æ³•æ˜¯ç³Ÿç³•çš„ï¼


================================================
FILE: src/too-many-lists/deque/iterator.md
================================================
# è¿­ä»£å™¨
åç”·å­©æœ€ä»¤äººå¤´ç–¼ï¼Œè€Œé“¾è¡¨å®ç°ä¸­ï¼Œè¿­ä»£å™¨å°±æ˜¯è¿™æ ·çš„åç”·å­©ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¾åœ¨æœ€åæ¥å¤„ç†ã€‚

## IntoIter
ç”±äºæ˜¯è½¬ç§»æ‰€æœ‰æƒï¼Œå› æ­¤ `IntoIter` ä¸€ç›´éƒ½æ˜¯æœ€å¥½å®ç°çš„:
```rust
pub struct IntoIter<T>(List<T>);

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<T> {
        self.0.pop_front()
    }
}
```

ä½†æ˜¯å…³äºåŒå‘é“¾è¡¨ï¼Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„äº‹å®ï¼Œå®ƒä¸ä»…å¯ä»¥ä»å‰å‘åè¿­ä»£ï¼Œè¿˜èƒ½åè¿‡æ¥ã€‚å‰é¢å®ç°çš„æ˜¯ä¼ ç»Ÿçš„ä»å‰åˆ°åï¼Œé‚£é—®é¢˜æ¥äº†ï¼Œåè¿‡æ¥è¯¥å¦‚ä½•å®ç°å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯: `DoubleEndedIterator`ï¼Œå®ƒç»§æ‰¿è‡ª `Iterator`( é€šè¿‡ [`supertrait`](https://course.rs/basic/trait/advance-trait.html?highlight=supertrait#ç‰¹å¾å®šä¹‰ä¸­çš„ç‰¹å¾çº¦æŸ) )ï¼Œå› æ­¤æ„å‘³ç€è¦å®ç°è¯¥ç‰¹å¾ï¼Œé¦–å…ˆéœ€è¦å®ç° `Iterator`ã€‚

è¿™æ ·åªè¦ä¸º `DoubleEndedIterator` å®ç° `next_back` æ–¹æ³•ï¼Œå°±å¯ä»¥æ”¯æŒåŒå‘è¿­ä»£äº†: `Iterator` çš„ `next` æ–¹æ³•ä»å‰å¾€åï¼Œè€Œ `next_back` ä»åå‘å‰ã€‚

```rust
impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}
```

æµ‹è¯•ä¸‹:
```rust
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured
```

## Iter
è¿™é‡Œåˆè¦ç”¨åˆ°ç³Ÿç³•çš„ `Ref`:
```rust
pub struct Iter<'a, T>(Option<Ref<'a, Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
```

```shell
$ cargo build
```

è¿„ä»Šä¸ºæ­¢ä¸€åˆ‡è¿è¡Œæ­£å¸¸ï¼Œæ¥ä¸‹æ¥çš„ `next` å®ç°èµ·æ¥ä¼šæœ‰äº›éº»çƒ¦:
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = Ref<'a, T>;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &node.elem)
        })
    }
}
```

```shell
$ cargo build

error[E0521]: borrowed data escapes outside of closure
   --> src/fourth.rs:155:13
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- `self` is declared here, outside of the closure body
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   -------- borrow is only valid in the closure body
    |             |
    |             reference to `node_ref` escapes the closure body here

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --> src/fourth.rs:156:22
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ------   -------- borrow of `node_ref` occurs here
    |             |
    |             assignment requires that `node_ref` is borrowed for `'1`
156 |             Ref::map(node_ref, |node| &node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here
```

æœç„¶ï¼Œè†ç›–åˆä¸­äº†ä¸€ç®­ã€‚

`node_ref` æ´»å¾—ä¸å¤Ÿä¹…ï¼Œè·Ÿä¸€èˆ¬çš„å¼•ç”¨ä¸åŒï¼ŒRust ä¸å…è®¸æˆ‘ä»¬è¿™æ ·åˆ†å‰² `Ref`ï¼Œä» `head.borrow()` ä¸­å–å‡ºçš„ `Ref` åªå…è®¸è·Ÿ `node_ref` æ´»å¾—ä¸€æ ·ä¹…ã€‚


è€Œæˆ‘ä»¬æƒ³è¦çš„å‡½æ•°æ˜¯å­˜åœ¨çš„:
```rust
pub fn map_split<U, V, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>) where
    F: FnOnce(&T) -> (&U, &V),
    U: ?Sized,
    V: ?Sized,
```

å–”ï¼Œè¿™ä¸ªå‡½æ•°å®šä¹‰çš„æ³›å‹ç›´æ¥æ™ƒçäº†æˆ‘çš„çœ¼ç›ã€‚ã€‚
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&node.next, &node.elem)
        });

        self.0 = next.as_ref().map(|head| head.borrow());

        elem
    })
}
```

```shell
$ cargo build

   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0521]: borrowed data escapes outside of closure
   --> src/fourth.rs:159:13
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- `self` is declared here, outside of the closure body
...
159 |             self.0 = next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   ---- borrow is only valid in the closure body
    |             |
    |             reference to `next` escapes the closure body here
```

é¢ï¼Œå€Ÿç”¨çš„å†…å®¹åªå…è®¸åœ¨é—­åŒ…ä½“ä¸­ä½¿ç”¨ï¼Œçœ‹èµ·æ¥æˆ‘ä»¬è¿˜æ˜¯å¾—ç”¨ `Ref::map` æ¥è§£å†³é—®é¢˜:
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&node.next, &node.elem)
        });

        self.0 = if next.is_some() {
            Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
        } else {
            None
        };

        elem
    })
}
```

```shell
error[E0308]: mismatched types
   --> src/fourth.rs:162:22
    |
162 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `fourth::Node`, found struct `std::cell::RefCell`
    |
    = note: expected type `std::cell::Ref<'_, fourth::Node<_>>`
               found type `std::cell::Ref<'_, std::cell::RefCell<fourth::Node<_>>>`
```

æ™•, å¤šäº†ä¸€ä¸ª `RefCell` ï¼Œéšç€æˆ‘ä»¬çš„å¯¹é“¾è¡¨çš„é€æ­¥æ·±å…¥ï¼Œ`RefCell` çš„ä»£ç åµŒå¥—å˜æˆäº†ä¸å¯å¿½è§†çš„é—®é¢˜ã€‚

çœ‹èµ·æ¥æˆ‘ä»¬å·²ç»æ— èƒ½ä¸ºåŠ›äº†ï¼Œåªèƒ½è¯•ç€å»æ‘†è„± `RefCell` äº†ã€‚`Rc` æ€ä¹ˆæ ·ï¼Ÿæˆ‘ä»¬å®Œå…¨å¯ä»¥å¯¹ `Rc` è¿›è¡Œå®Œæ•´çš„å…‹éš†:
```rust
pub struct Iter<T>(Option<Rc<Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl<T> Iterator for Iter<T> {
    type Item =
```

ç­‰ç­‰ï¼Œé‚£ç°åœ¨è¿”å›çš„æ˜¯ä»€ä¹ˆï¼Ÿ`&T` è¿˜æ˜¯ `Ref<T>` ?

ä¸¤è€…éƒ½ä¸æ˜¯ï¼Œç°åœ¨æˆ‘ä»¬çš„ `Iter` å·²ç»æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸäº†ï¼šæ— è®ºæ˜¯ `&T` è¿˜æ˜¯ `Ref<T>` éƒ½éœ€è¦æˆ‘ä»¬åœ¨ `next` ä¹‹å‰å£°æ˜å¥½ç”Ÿå‘½å‘¨æœŸã€‚ä½†æ˜¯æˆ‘ä»¬è¯•å›¾ä» `Rc` ä¸­å–å‡ºæ¥çš„å€¼å…¶å®æ˜¯è¿­ä»£å™¨çš„å¼•ç”¨ã€‚

ä¹Ÿå¯ä»¥é€šè¿‡å¯¹ `Rc` è¿›è¡Œ map è·å–åˆ° `Rc<T>`ï¼Ÿä½†æ˜¯æ ‡å‡†åº“å¹¶æ²¡æœ‰ç»™æˆ‘ä»¬æä¾›ç›¸åº”çš„åŠŸèƒ½ï¼Œç¬¬ä¸‰æ–¹å€’æ˜¯æœ‰[ä¸€ä¸ª](https://crates.io/crates/owning_ref)ã€‚

ä½†æ˜¯ï¼Œå³ä½¿è¿™ä¹ˆåšäº†ï¼Œè¿˜æœ‰ä¸€ä¸ªæ›´å¤§çš„å‘åœ¨ç­‰ç€ï¼šä¸€ä¸ªä¼šé€ æˆè¿­ä»£å™¨ä¸åˆæ³•çš„å¯æ€•å¹½çµã€‚äº‹å®ä¸Šï¼Œä¹‹å‰æˆ‘ä»¬å¯¹äºè¿­ä»£å™¨ä¸åˆæ³•æ˜¯å…ç–«çš„ï¼Œä½†æ˜¯ä¸€æ—¦è¿­ä»£å™¨äº§ç”Ÿ `Rc`ï¼Œé‚£å®ƒä»¬å°±ä¸å†ä¼šå€Ÿç”¨é“¾è¡¨ã€‚è¿™æ„å‘³ç€äººä»¬å¯ä»¥åœ¨æŒæœ‰æŒ‡å‘é“¾è¡¨å†…éƒ¨çš„æŒ‡é’ˆæ—¶ï¼Œè¿˜å¯ä»¥è¿›è¡Œ `push` å’Œ `pop` æ“ä½œã€‚

ä¸¥æ ¼æ¥è¯´ï¼Œ`push` é—®é¢˜ä¸å¤§ï¼Œå› ä¸ºé“¾è¡¨ä¸¤ç«¯çš„å¢é•¿ä¸ä¼šå¯¹æˆ‘ä»¬æ­£åœ¨å…³æ³¨çš„æŸä¸ªå­é“¾è¡¨é€ æˆå½±å“ã€‚

ä½†æ˜¯ `pop` å°±æ˜¯å¦ä¸€ä¸ªæ•…äº‹äº†ï¼Œå¦‚æœåœ¨æˆ‘ä»¬å…³æ³¨çš„å­é“¾è¡¨ä¹‹å¤– `pop`, é‚£é—®é¢˜ä¸å¤§ã€‚ä½†æ˜¯å¦‚æœæ˜¯ `pop` ä¸€ä¸ªæ­£åœ¨å¼•ç”¨çš„å­é“¾è¡¨ä¸­çš„èŠ‚ç‚¹å‘¢ï¼Ÿé‚£ä¸€åˆ‡å°±å®Œäº†ï¼Œç‰¹åˆ«æ˜¯ï¼Œå¦‚æœå¤§å®¶è¿˜è¯•å›¾å» unwrap `try_unwrap` è¿”å›çš„ `Result` ï¼Œä¼šç›´æ¥é€ æˆæ•´ä¸ªç¨‹åºçš„ `panic`ã€‚

ä»”ç»†æƒ³ä¸€æƒ³ï¼Œå¥½åƒä¹Ÿä¸é”™ï¼Œç¨‹åºä¸€åˆ‡æ­£å¸¸ï¼Œé™¤éå» `pop` æˆ‘ä»¬æ­£åœ¨å¼•ç”¨çš„èŠ‚ç‚¹ï¼Œæœ€ç¾çš„æ˜¯ï¼Œå°±ç®—é‡åˆ°è¿™ç§æƒ…å†µï¼Œç¨‹åºä¹Ÿä¼šç›´æ¥å´©æºƒï¼Œæç¤ºæˆ‘ä»¬é”™è¯¯çš„å‘ç”Ÿã€‚

å…¶å®æˆ‘ä»¬å¤§éƒ¨åˆ†çš„åŠªåŠ›éƒ½æ˜¯ä¸ºäº†å®ç°éšè—çš„ç»†èŠ‚å’Œä¼˜é›…çš„ APIï¼Œå…¸å‹çš„äºŒå…«åŸåˆ™ï¼Œå…«æˆæ—¶é—´èŠ±åœ¨äºŒæˆçš„ç»†èŠ‚ä¸Šã€‚ä½†æ˜¯å¦‚æœä¸å…³å¿ƒè¿™äº›ç»†èŠ‚ï¼Œå¯ä»¥æ¥å—è‡ªå·±çš„å¹³å‡¡çš„è¯ï¼Œé‚£æŠŠèŠ‚ç‚¹ç®€å•çš„åˆ°å¤„ä¼ é€’å°±è¡Œã€‚

æ€»ä¹‹ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå†…éƒ¨å¯å˜æ€§éå¸¸é€‚åˆå†™ä¸€ä¸ªå®‰å…¨æ€§çš„åº”ç”¨ç¨‹åºï¼Œä½†æ˜¯å¦‚æœæ˜¯å®‰å…¨æ€§é«˜çš„åº“ï¼Œé‚£å†…éƒ¨å¯å˜æ€§å°±æœ‰äº›æ‰è¥Ÿè§è‚˜äº†ã€‚

æœ€ç»ˆï¼Œæˆ‘é€‰æ‹©äº†æ”¾å¼ƒï¼Œä¸å†å®ç° `Iter` å’Œ `IterMut`ï¼Œä¹Ÿè®¸åŠªåŠ›ä¸‹ï¼Œå¯ä»¥å®ç°ï¼Œä½†æ˜¯ã€‚ã€‚ã€‚ä¸æ„‰å¿«ï¼Œç®—äº†ã€‚


================================================
FILE: src/too-many-lists/deque/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/deque/peek.md
================================================
# Peek
`push` å’Œ `pop` çš„é˜²ä¸èƒœé˜²çš„ç¼–è¯‘æŠ¥é”™ç€å®è®©äººå‡ºäº†äº›å†·æ±—ï¼Œä¸‹é¢æ¥çœ‹çœ‹è½»æ¾çš„ï¼Œè‡³å°‘åœ¨ä¹‹å‰çš„é“¾è¡¨ä¸­æ˜¯å¾ˆè½»æ¾çš„ :)

```rust
pub fn peek_front(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        &node.elem
    })
}
```

é¢...å¥½åƒè¢«äººå‘ç°æˆ‘æ˜¯å¤åˆ¶é»è´´çš„äº†ï¼Œèµ¶ç´§æ¢ä¸€ä¸ª:
```rust
pub fn peek_front(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        // BORROW!!!!
        &node.borrow().elem
    })
}
```

```shell
$ cargo build

error[E0515]: cannot return value referencing temporary value
  --> src/fourth.rs:66:13
   |
66 |             &node.borrow().elem
   |             ^   ----------^^^^^
   |             |   |
   |             |   temporary value created here
   |             |
   |             returns a value referencing data owned by the current function
```

ä»æŠ¥é”™å¯ä»¥çœ‹å‡ºï¼ŒåŸå› æ˜¯æˆ‘ä»¬å¼•ç”¨äº†å±€éƒ¨çš„å˜é‡å¹¶è¯•å›¾åœ¨å‡½æ•°ä¸­è¿”å›ã€‚ä¸ºäº†è§£é‡Šè¿™ä¸ªé—®é¢˜ï¼Œå…ˆæ¥çœ‹çœ‹ `borrow` çš„å®šä¹‰:
```rust
fn borrow<'a>(&'a self) -> Ref<'a, T>
fn borrow_mut<'a>(&'a self) -> RefMut<'a, T>
```

è¿™é‡Œè¿”å›çš„å¹¶ä¸æ˜¯ `&T` æˆ– `&mut T`ï¼Œè€Œæ˜¯ä¸€ä¸ª [`Ref`](https://doc.rust-lang.org/std/cell/struct.Ref.html) å’Œ [`RefMut`](https://doc.rust-lang.org/std/cell/struct.RefMut.html)ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¯ä»€ä¹ˆï¼Ÿè¯´ç™½äº†ï¼Œå®ƒä»¬å°±æ˜¯åœ¨å€Ÿç”¨åˆ°çš„å¼•ç”¨å¤–åŒ…è£¹äº†ä¸€å±‚ã€‚è€Œä¸” `Ref` å’Œ `RefMut` åˆ†åˆ«å®ç°äº† `Deref` å’Œ `DerefMut`ï¼Œåœ¨ç»å¤§å¤šæ•°åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åƒä½¿ç”¨ `&T` ä¸€æ ·å»ä½¿ç”¨å®ƒä»¬ã€‚


åªèƒ½è¯´æ˜¯æˆæ˜¯è´¥éƒ½èµ–è§ä½•ï¼Œæ°æ°å°±å› ä¸ºè¿™ä¸€å±‚åŒ…è£¹ï¼Œå¯¼è‡´ç”Ÿå‘½å‘¨æœŸæ”¹å˜äº†ï¼Œä¹Ÿå°±æ˜¯ `Ref` å’Œå†…éƒ¨å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸å†å’Œ `RefCell` ç›¸åŒï¼Œè€Œ `Ref` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä»€ä¹ˆï¼Œç›¸ä¿¡å¤§å®¶éƒ½èƒ½çœ‹å¾—å‡ºæ¥ï¼Œå› æ­¤å°±é€ æˆäº†å±€éƒ¨å¼•ç”¨çš„é—®é¢˜ã€‚

äº‹å®ä¸Šï¼Œè¿™æ˜¯å¿…é¡»çš„ï¼Œå¦‚æœå†…éƒ¨çš„å¼•ç”¨å’Œå¤–éƒ¨çš„ `Ref` ç”Ÿå‘½å‘¨æœŸä¸ä¸€è‡´ï¼Œé‚£è¯¥å¦‚ä½•ç®¡ç†ï¼Ÿå½“ `Ref` å› è¶…å‡ºä½œç”¨åŸŸè¢« `drop` æ—¶ï¼Œå†…éƒ¨çš„å¼•ç”¨æ€ä¹ˆåŠï¼Ÿ

ç°åœ¨è¯¥æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬åªæƒ³è¦ä¸€ä¸ªå¼•ç”¨ï¼Œç°åœ¨å´å¤šäº†ä¸€ä¸ª `Ref` æ‹¦è·¯è™ã€‚ç­‰ç­‰ï¼Œå¦‚æœæˆ‘ä»¬ä¸è¿”å› `&T` è€Œæ˜¯è¿”å› `Ref` å‘¢ï¼Ÿ
```rust
use std::cell::{Ref, RefCell};

pub fn peek_front(&self) -> Option<Ref<T>> {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
```

```shell
$ cargo build

error[E0308]: mismatched types
  --> src/fourth.rs:64:9
   |
64 | /         self.head.as_ref().map(|node| {
65 | |             node.borrow()
66 | |         })
   | |__________^ expected type parameter, found struct `fourth::Node`
   |
   = note: expected type `std::option::Option<std::cell::Ref<'_, T>>`
              found type `std::option::Option<std::cell::Ref<'_, fourth::Node<T>>>`
```

å—¯ï¼Œç±»å‹ä¸åŒ¹é…äº†ï¼Œè¦è¿”å›çš„æ˜¯ `Ref<T>` ä½†æ˜¯è·å–çš„å´æ˜¯ `Ref<Node<T>>`ï¼Œé‚£ä¹ˆç°åœ¨çœ‹ä¸Šå»æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼š

- æŠ›å¼ƒè¿™æ¡è·¯ï¼Œæ¢ä¸€æ¡é‡æ–°å¼€å§‹
- ä¸€æ¡è·¯èµ°åˆ°æ­»ï¼Œæœ€ç»ˆé€šè¿‡æ›´å¤æ‚çš„å®ç°æ¥è§£å†³

ä½†æ˜¯ï¼Œä»”ç»†æƒ³æƒ³ï¼Œè¿™ä¸¤ä¸ªé€‰æ‹©éƒ½ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œé‚£æ²¡åŠæ³•äº†ï¼Œåªèƒ½ç»§ç»­æ·±æŒ–ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰å…¶å®ƒè§£å†³åŠæ³•ã€‚å•Šå“¦ï¼Œè¿˜çœŸå‘ç°äº†ä¸€åªé‡å…½ï¼š
```rust
map<U, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>
    where F: FnOnce(&T) -> &U,
          U: ?Sized
```

å°±åƒåœ¨ `Result` å’Œ `Option` ä¸Šä½¿ç”¨ `map` ä¸€æ ·ï¼Œæˆ‘ä»¬è¿˜èƒ½åœ¨ `Ref` ä¸Šä½¿ç”¨ `map`:
```rust
pub fn peek_front(&self) -> Option<Ref<T>> {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &node.elem)
    })
}
```

```shell
$ cargo build
```

Gooood! æœ¬ç« èŠ‚çš„ç¼–è¯‘é”™è¯¯å¯ä»¥è¯´æ˜¯å¤šä¸ªé“¾è¡¨ä¸­æœ€éš¾è§£å†³çš„ä¹‹ä¸€ï¼Œä¾ç„¶è¢«æˆ‘ä»¬æˆåŠŸæå®šäº†ï¼


ä¸‹é¢æ¥å†™ä¸‹æµ‹è¯•ç”¨ä¾‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ `Ref` ä¸èƒ½è¢«ç›´æ¥æ¯”è¾ƒï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å…ˆåˆ©ç”¨ `Deref` è§£å¼•ç”¨å‡ºå…¶ä¸­çš„å€¼ï¼Œå†è¿›è¡Œæ¯”è¾ƒã€‚

```rust
#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&*list.peek_front().unwrap(), &3);
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured
```

ç»ˆäºå¯ä»¥æŠŠæ–‡ç« å¼€å¤´çš„å†·æ±—æ“¦æ‹­å¹²å‡€äº†ï¼Œå¿˜æ‰è¿™ä¸ªç« èŠ‚å§ï¼Œè®©æˆ‘æ¥å…»ä½ ...å“¦ä¸å¯¹ï¼Œè®©æˆ‘ä»¬å¼€å§‹ä¸€æ®µçœŸæ­£è½»æ¾çš„ç« èŠ‚ã€‚


================================================
FILE: src/too-many-lists/deque/symmetric.md
================================================
# åŸºæœ¬æ“ä½œçš„å¯¹ç§°é•œåƒ
ä¹‹å‰æˆ‘ä»¬ä»…å®ç°äº†å¤´éƒ¨çš„ `push`ã€`pop` ï¼Œç°åœ¨æ¥è¡¥å…¨ä¸€ä¸‹ï¼Œå¤§è‡ªç„¶çš„å¯¹ç§°ä¹‹ç¾å’±çš„åŒå‘é“¾è¡¨ä¹Ÿä¸èƒ½å°‘äº†ã€‚

```rust
tail <-> head
next <-> prev
front -> back
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œè¿˜æ–°å¢äº† `mut` ç±»å‹çš„ peek:
```rust
use std::cell::{Ref, RefCell, RefMut};

//..

pub fn push_back(&mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) => {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None => {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&mut self) -> Option<T> {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) => {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None => {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&self) -> Option<Ref<T>> {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &node.elem)
    })
}

pub fn peek_back_mut(&mut self) -> Option<RefMut<T>> {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &mut node.elem)
    })
}

pub fn peek_front_mut(&mut self) -> Option<RefMut<T>> {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &mut node.elem)
    })
}
```

å†æ›´æ–°æµ‹è¯•ç”¨ä¾‹:
```rust
#[test]
fn basics() {
    let mut list = List::new();

    // Check empty list behaves right
    assert_eq!(list.pop_front(), None);

    // Populate list
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_front(4);
    list.push_front(5);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- back -----

    // Check empty list behaves right
    assert_eq!(list.pop_back(), None);

    // Populate list
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_back(4);
    list.push_back(5);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&*list.peek_front().unwrap(), &3);
    assert_eq!(&mut *list.peek_front_mut().unwrap(), &mut 3);
    assert_eq!(&*list.peek_back().unwrap(), &1);
    assert_eq!(&mut *list.peek_back_mut().unwrap(), &mut 1);
}
```

ä»€ä¹ˆï¼Ÿä½ é—®æˆ‘è¿™é‡Œçš„æµ‹è¯•ç”¨ä¾‹å…¨å—ï¼Ÿåªèƒ½è¯´å¦‚æœæµ‹è¯•å…¨éƒ¨çš„ç»„åˆæƒ…å†µï¼Œè¿™ä¸€ç« èŠ‚ä¼šè¢«æ’‘çˆ†ã€‚è‡³äºç°åœ¨ï¼Œèƒ½ä¸å‡ºé”™å°±è°¢å¤©è°¢åœ°äº† :(

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured
```

æˆ‘æƒ³è¯´ï¼šCtrl CV æ˜¯æœ€å¥½çš„ç¼–ç¨‹å·¥å…·ï¼Œå¤§å®¶åŒæ„å—ï¼Ÿ


================================================
FILE: src/too-many-lists/ok-stack/intro.md
================================================
# è¿˜å¯ä»¥çš„å•å‘é“¾è¡¨
åœ¨ä¹‹å‰æˆ‘ä»¬å†™äº†ä¸€ä¸ªæœ€å°å¯ç”¨çš„å•å‘é“¾è¡¨ï¼Œä¸‹é¢ä¸€èµ·æ¥å®Œå–„ä¸‹ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ `src/second.rs`ï¼Œç„¶ååœ¨ `lib.rs` ä¸­å¼•å…¥ï¼š
```rust
// in lib.rs

pub mod first;
pub mod second;
```

å¹¶å°† `first.rs` ä¸­çš„æ‰€æœ‰å†…å®¹æ‹·è´åˆ° `second.rs` ä¸­ã€‚


================================================
FILE: src/too-many-lists/ok-stack/iter.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/ok-stack/itermut.md
================================================
# IterMutä»¥åŠå®Œæ•´ä»£ç 
ä¸Šä¸€ç« èŠ‚ä¸­æˆ‘ä»¬è®²åˆ°äº†è¦ä¸º `List` å®ç°ä¸‰ç§ç±»å‹çš„è¿­ä»£å™¨å¹¶å®ç°äº†å…¶ä¸­ä¸¤ç§: `IntoIter` å’Œ `Iter`ã€‚ä¸‹é¢å†æ¥çœ‹çœ‹æœ€åä¸€ç§ `IterMut`ã€‚

å†æ¥å›é¡¾ä¸‹ `Iter` çš„å®ç°ï¼š
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> { /* stuff */ }
}
```

è¿™æ®µä»£ç å¯ä»¥è¿›è¡Œä¸‹è„±ç³–( desugar ):
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next<'b>(&'b mut self) -> Option<&'a T> { /* stuff */ }
}
```

å¯ä»¥çœ‹å‡º `next` æ–¹æ³•çš„è¾“å…¥å’Œè¾“å‡ºä¹‹é—´çš„ç”Ÿå‘½å‘¨æœŸå¹¶æ²¡æœ‰å…³è”ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ— æ¡ä»¶çš„ä¸€éåˆä¸€éåœ°è°ƒç”¨ `next`:
```rust
let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
```

å¯¹äºä¸å¯å˜å€Ÿç”¨è€Œè¨€ï¼Œè¿™ç§æ–¹å¼æ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œå› ä¸ºä¸å¯å˜å€Ÿç”¨å¯ä»¥åŒæ—¶å­˜åœ¨å¤šä¸ªï¼Œä½†æ˜¯å¦‚æœæ˜¯å¯å˜å¼•ç”¨å‘¢ï¼Ÿå› æ­¤ï¼Œå¤§å®¶å¯èƒ½ä¼šä»¥ä¸ºä½¿ç”¨å®‰å…¨ä»£ç æ¥å†™ `IterMut` æ˜¯ä¸€ä»¶ç›¸å½“å›°éš¾çš„äº‹ã€‚ä½†æ˜¯ä»¤äººè¯§å¼‚çš„æ˜¯ï¼Œäº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®‰å…¨çš„ä»£ç æ¥ä¸ºå¾ˆå¤šæ•°æ®ç»“æ„å®ç° `IterMut`ã€‚

å…ˆå°†ä¹‹å‰çš„ä»£ç ä¿®æ”¹æˆå¯å˜çš„ï¼š
```rust
pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn iter_mut(&self) -> IterMut<'_, T> {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}
```

```shell
$ cargo build

error[E0596]: cannot borrow `self.head` as mutable, as it is behind a `&` reference
  --> src/second.rs:95:25
   |
94 |     pub fn iter_mut(&self) -> IterMut<'_, T> {
   |                     ----- help: consider changing this to be a mutable reference: `&mut self`
95 |         IterMut { next: self.head.as_deref_mut() }
   |                         ^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error[E0507]: cannot move out of borrowed content
   --> src/second.rs:103:9
    |
103 |         self.next.map(|node| {
    |         ^^^^^^^^^ cannot move out of borrowed content
```

æœä¸å…¶ç„¶ï¼Œä¸¤ä¸ªé”™è¯¯å‘ç”Ÿäº†ã€‚ç¬¬ä¸€é”™è¯¯çœ‹ä¸Šå»å¾ˆæ¸…æ™°ï¼Œç”šè‡³å‘Šè¯‰äº†æˆ‘ä»¬è¯¥å¦‚ä½•è§£å†³:
```rust
pub fn iter_mut(&mut self) -> IterMut<'_, T> {
    IterMut { next: self.head.as_deref_mut() }
}
```

ä½†æ˜¯å¦ä¸€ä¸ªå¥½åƒå°±æ²¡é‚£ä¹ˆå®¹æ˜“äº†ã€‚ä½†æ˜¯ä¹‹å‰çš„ä»£ç å°±å¯ä»¥å·¥ä½œå•Šï¼Œä¸ºä½•è¿™é‡Œå°±ä¸è¡Œäº†ï¼Ÿ

åŸå› åœ¨äºæœ‰äº›ç±»å‹å¯ä»¥ [Copy](https://course.rs/basic/ownership/ownership.html#æ‹·è´æµ…æ‹·è´)ï¼Œæœ‰äº›ä¸è¡Œã€‚è€Œ`Option` å’Œä¸å¯å˜å¼•ç”¨ `&T` æ°æ°æ˜¯å¯ä»¥ Copy çš„ï¼Œä½†å°´å°¬çš„æ˜¯ï¼Œå¯å˜å¼•ç”¨ `&mut T` ä¸å¯ä»¥ï¼Œå› æ­¤è¿™é‡ŒæŠ¥é”™äº†ã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ `take` æ–¹æ³•æ¥å¤„ç†è¿™ç§æƒ…å†µï¼š
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.next.take().map(|node| {
        self.next = node.next.as_deref_mut();
        &mut node.elem
    })
}
```

```shell
$ cargo build
```

è€è§„çŸ©ï¼Œæ¥æµ‹è¯•ä¸‹:
```rust
#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&mut 3));
    assert_eq!(iter.next(), Some(&mut 2));
    assert_eq!(iter.next(), Some(&mut 1));
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured
```

æœ€ç»ˆï¼Œæˆ‘ä»¬å®Œæˆäº†è¿­ä»£å™¨çš„åŠŸèƒ½ï¼Œä¸‹é¢æ˜¯å®Œæ•´çš„ä»£ç ã€‚

## å®Œæ•´ä»£ç 

```rust
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| {
            &node.elem
        })
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| {
            &mut node.elem
        })
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

pub struct IntoIter<T>(List<T>);

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&3));
        assert_eq!(list.peek_mut(), Some(&mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&42));
        assert_eq!(list.pop(), Some(42));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&mut 3));
        assert_eq!(iter.next(), Some(&mut 2));
        assert_eq!(iter.next(), Some(&mut 1));
    }
}
```


================================================
FILE: src/too-many-lists/ok-stack/peek.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/ok-stack/type-optimizing.md
================================================
# ä¼˜åŒ–ç±»å‹å®šä¹‰
é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¼˜åŒ–ä¸‹ç±»å‹çš„å®šä¹‰ï¼Œå¯èƒ½ä¸€éƒ¨åˆ†åŒå­¦å·²ç»è§‰å¾—ä¹‹å‰çš„ç±»å‹å®šä¹‰ç›¸å½“ä¸é”™äº†ï¼Œä½†æ˜¯å¦‚æœå¤§å®¶ä»”ç»†è§‚å¯Ÿä¸‹ `Link`:
```rust
enum Link {
    Empty,
    More(Box<Node>),
}
```

ä¼šå‘ç°ï¼Œå®ƒå…¶å®è·Ÿ `Option<Box<Node>>` éå¸¸ç±»ä¼¼ã€‚

## Option
ä½†æ˜¯ä¸ºäº†ä»£ç å¯è¯»æ€§ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æ¥ä½¿ç”¨è¿™ä¸ªå†—é•¿çš„ç±»å‹ï¼Œå¦åˆ™ä»£ç ä¸­å°†å……æ–¥ç€ `Option<Box<Node>>` è¿™ç§ä»¤äººéš¾å ªçš„ç±»å‹ï¼Œä¸ºæ­¤å¯ä»¥ä½¿ç”¨ç±»å‹åˆ«åã€‚é¦–å…ˆï¼Œå°†ä¹‹å‰çš„ä»£ç ä½¿ç”¨æ–°çš„ `Link` è¿›è¡Œä¿®æ”¹ï¼š
```rust
use std::mem;

pub struct List {
    head: Link,
}

// ç±»å‹åˆ«åï¼Œtype alias
type Link = Option<Box<Node>>;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match mem::replace(&mut self.head, None) {
            None => None,
            Some(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, None);
        }
    }
}
```

ä»£ç çœ‹ä¸Šå»ç¨å¾®å¥½äº†ä¸€äº›ï¼Œä½†æ˜¯ `Option` çš„å¥½å¤„è¿œä¸æ­¢è¿™äº›ã€‚

é¦–å…ˆï¼Œä¹‹å‰å’±ä»¬ç”¨åˆ°äº† `mem::replace` è¿™ä¸ªè®©äººèƒ†æˆ˜å¿ƒæƒŠä½†æ˜¯åˆéå¸¸æœ‰ç”¨çš„å‡½æ•°ï¼Œè€Œ `Option` ç›´æ¥æä¾›äº†ä¸€ä¸ªæ–¹æ³• `take` ç”¨äºæ›¿ä»£å®ƒ: 
```rust
pub struct List {
    head: Link,
}

type Link = Option<Box<Node>>;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match self.head.take() {
            None => None,
            Some(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

å…¶æ¬¡ï¼Œ`match option { None => None, Some(x) => Some(y) }` è¿™æ®µä»£ç å¯ä»¥ç›´æ¥ä½¿ç”¨ `map` æ–¹æ³•ä»£æ›¿ï¼Œ`map` ä¼šå¯¹ `Some(x)` ä¸­çš„å€¼è¿›è¡Œæ˜ å°„ï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ªæ–°çš„ `Some(y)` å€¼ã€‚

> æˆ‘ä»¬å¾€å¾€å°†é—­åŒ…ä½œä¸ºå‚æ•°ä¼ é€’ç»™ map æ–¹æ³•ï¼Œå…³äºé—­åŒ…å¯ä»¥å‚è§[æ­¤ç« ](https://course.rs/advance/functional-programing/closure.html)

```rust
pub fn pop(&mut self) -> Option<i32> {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
```

ä¸é”™ï¼Œçœ‹ä¸Šå»ç®€æ´äº†å¾ˆå¤šï¼Œä¸‹é¢è¿è¡Œä¸‹æµ‹è¯•ä»£ç ç¡®ä¿é“¾è¡¨ä¾ç„¶å¯ä»¥æ­£å¸¸è¿è¡Œ(è¿™å°±æ˜¯ TDD çš„ä¼˜ç‚¹ï¼) :
```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

å¾ˆæ£’ï¼Œæ¥ä¸‹æ¥è®©æˆ‘ä»¬æ¥è§£å†³ç›®å‰é“¾è¡¨æœ€å¤§çš„é—®é¢˜ï¼šåªæ”¯æŒ `i32` ç±»å‹çš„å…ƒç´ å€¼ã€‚

## æ³›å‹
ä¸ºäº†è®©é“¾è¡¨æ”¯æŒä»»ä½•ç±»å‹çš„å…ƒç´ ï¼Œæ³›å‹å°±æ˜¯ç»•ä¸è¿‡å»çš„åï¼Œé¦–å…ˆå°†æ‰€æœ‰çš„ç±»å‹å®šä¹‰ä¿®æ”¹ä¸ºæ³›å‹å®ç°ï¼š
```rust
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

å¤§å®¶åœ¨ä¿®æ”¹äº† `List` çš„å®šä¹‰åï¼Œåˆ«å¿˜äº†å°† `impl` ä¸­çš„ `List` ä¿®æ”¹ä¸º `List<T>`ï¼Œåˆ‡è®°**æ³›å‹å‚æ•°ä¹Ÿæ˜¯ç±»å‹å®šä¹‰çš„ä¸€éƒ¨åˆ†**ã€‚

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæˆªè‡³ç›®å‰ï¼Œæµ‹è¯•ç”¨ä¾‹ä¾ç„¶è¿è¡Œè‰¯å¥½ï¼Œå°½ç®¡æˆ‘ä»¬æŠŠä»£ç ä¿®æ”¹æˆäº†æ›´åŠ å¤æ‚çš„æ³›å‹ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç‚¹ç‰¹åˆ«å€¼å¾—æ³¨æ„ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä¿®æ”¹å…³è”å‡½æ•° `new` ï¼š
```rust
pub fn new() -> Self {
    List { head: None }
}
```

åŸå› æ˜¯ `Self` æ‰¿è½½äº†æˆ‘ä»¬æ‰€æœ‰çš„è£è€€ï¼Œ`List` æ—¶ï¼Œ`Self` å°±ä»£è¡¨ `List`ï¼Œå½“å˜æˆ `List<T>` æ—¶ï¼Œ`Self` ä¹Ÿéšä¹‹å˜åŒ–ï¼Œä»£è¡¨ `List<T>`ï¼Œå¯ä»¥çœ‹å‡ºä½¿ç”¨å®ƒå¯ä»¥è®©æœªæ¥çš„ä»£ç é‡æ„å˜å¾—æ›´åŠ ç®€å•ã€‚




================================================
FILE: src/too-many-lists/persistent-stack/drop-arc.md
================================================
# Dropã€Arc åŠå®Œæ•´ä»£ç 

## Drop
ä¸ä¹‹å‰é“¾è¡¨å­˜åœ¨çš„é—®é¢˜ç›¸ä¼¼ï¼Œæ–°çš„é“¾è¡¨ä¹Ÿæœ‰é€’å½’çš„é—®é¢˜ã€‚ä¸‹é¢æ˜¯ä¹‹å‰çš„è§£å†³æ–¹æ³•:
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

ä½†æ˜¯ `boxed_node.next.take()` çš„æ–¹å¼åœ¨æ–°çš„é“¾è¡¨ä¸­æ— æ³•ä½¿ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡åŠæ³•å»ä¿®æ”¹ `Rc` æŒæœ‰çš„å€¼ã€‚

è€ƒè™‘ä¸€ä¸‹ç›¸å…³çš„é€»è¾‘ï¼Œå¯ä»¥å‘ç°ï¼Œå¦‚æœå½“å‰çš„èŠ‚ç‚¹ä»…è¢«å½“å‰é“¾è¡¨æ‰€å¼•ç”¨(Rc çš„å¼•ç”¨è®¡æ•°ä¸º 1)ï¼Œé‚£è¯¥èŠ‚ç‚¹æ˜¯å¯ä»¥å®‰å…¨ `drop` çš„: 
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
```

è¿™é‡Œæœ‰ä¸€ä¸ªæ²¡è§è¿‡çš„æ–¹æ³• `Rc::Try_unwrap` ï¼Œè¯¥æ–¹æ³•ä¼šåˆ¤æ–­å½“å‰çš„ `Rc` æ˜¯å¦åªæœ‰ä¸€ä¸ªå¼ºå¼•ç”¨ï¼Œè‹¥æ˜¯ï¼Œåˆ™è¿”å› `Rc` æŒæœ‰çš„å€¼ï¼Œå¦åˆ™è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬ä¼šä¸€ç›´ drop åˆ°ç¬¬ä¸€ä¸ªè¢«å…¶å®ƒé“¾è¡¨æ‰€å¼•ç”¨çš„èŠ‚ç‚¹ï¼š
```shell
list1 -> A ---+
              |
              v
list2 ------> B -> C -> D
              ^
              |
list3 -> X ---+
```

ä¾‹å¦‚å¦‚æœè¦ drop `List2`ï¼Œé‚£ä¼šä»å¤´èŠ‚ç‚¹å¼€å§‹ä¸€ç›´ drop åˆ° `B` èŠ‚ç‚¹æ—¶åœæ­¢ï¼Œå‰©ä½™çš„ `B -> C -> D` ä¸‰ä¸ªèŠ‚ç‚¹ç”±äºå¼•ç”¨è®¡æ•°ä¸ä¸º 1 (åŒæ—¶è¢«å¤šä¸ªé“¾è¡¨å¼•ç”¨) ï¼Œå› æ­¤ä¸ä¼šè¢« dropã€‚


æµ‹è¯•ä¸‹æ–°çš„ä»£ç :
```shell
$ cargo test

   Compiling lists v0.1.0 (/Users/ABeingessner/dev/too-many-lists/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.10s
     Running /Users/ABeingessner/dev/too-many-lists/lists/target/debug/deps/lists-86544f1d97438f1f

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

å®Œç¾é€šè¿‡ï¼Œä¸‹é¢å†æ¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬çš„é“¾è¡¨è¦åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä½¿ç”¨è¯¥æ€ä¹ˆåŠï¼Ÿ

## Arc
ä¸å¯å˜é“¾è¡¨çš„ä¸€ä¸ªå¾ˆå¤§çš„å¥½å¤„å°±åœ¨äºå¤šçº¿ç¨‹è®¿é—®æ—¶è‡ªå¸¦å®‰å…¨æ€§ï¼Œæ¯•ç«Ÿå…±äº«å¯å˜æ€§æ˜¯å¤šçº¿ç¨‹å±é™©çš„æºæ³‰ï¼Œæœ€å¥½ä¹Ÿæ˜¯æœ€ç®€å•çš„è§£å†³åŠæ³•å°±æ˜¯ç›´æ¥å¹²æ‰å¯å˜æ€§ã€‚

ä½†æ˜¯ `Rc<T>` æœ¬èº«å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒåŸå› åœ¨ä¹‹å‰çš„ç« èŠ‚ä¹Ÿæœ‰è®²ï¼šå®ƒå†…éƒ¨çš„å¼•ç”¨è®¡æ•°å™¨å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé€šä¿—æ¥è®²ï¼Œè®¡æ•°å™¨æ²¡æœ‰åŠ é”ä¹Ÿæ²¡æœ‰å®ç°åŸå­æ€§ã€‚

å†ç»“åˆä¹‹å‰ç« èŠ‚å­¦è¿‡çš„å†…å®¹ï¼Œç»å¤§éƒ¨åˆ†åŒå­¦åº”è¯¥éƒ½èƒ½æƒ³åˆ°, `Arc<T>` å°±æ˜¯æˆ‘ä»¬çš„æœ€ç»ˆç­”æ¡ˆã€‚

é‚£ä¹ˆè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æ€ä¹ˆçŸ¥é“ä¸€ä¸ªç±»å‹æ˜¯ä¸æ˜¯ç±»å‹å®‰å…¨ï¼Ÿä¼šä¸ä¼šåœ¨å¤šçº¿ç¨‹è¯¯ç”¨äº†éçº¿ç¨‹å®‰å…¨çš„ç±»å‹å‘¢ï¼Ÿè¿™å°±æ˜¯ Rust å®‰å…¨æ€§çš„å¦ä¸€ä¸ªå¼ºå¤§ä¹‹å¤„ï¼šRust é€šè¿‡æä¾› `Send` å’Œ `Sync` ä¸¤ä¸ªç‰¹å¾æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚

> å…³äº `Send` å’Œ `Sync` çš„è¯¦ç»†ä»‹ç»ï¼Œè¯·å‚è§[æ­¤ç« èŠ‚](https://course.rs/advance/concurrency-with-threads/send-sync.html)

## å®Œæ•´ä»£ç 
åˆåˆ°äº†å–œé—»ä¹è§çš„ç¯èŠ‚ï¼Œæ–°é“¾è¡¨çš„ä»£ç ç›¸æ¯”ä¹‹å‰åè€Œè¿˜æ›´ç®€å•äº†ï¼Œä¸å¯å˜å°±æ˜¯é¦™ï¼

```rust
use std::rc::Rc;

pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Rc<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn prepend(&self, elem: T) -> List<T> {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&self) -> List<T> {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.elem)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.prepend(1).prepend(2).prepend(3);
        assert_eq!(list.head(), Some(&3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);
    }

    #[test]
    fn iter() {
        let list = List::new().prepend(1).prepend(2).prepend(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&1));
    }
}
```



================================================
FILE: src/too-many-lists/persistent-stack/intro.md
================================================
# æŒä¹…åŒ–å•å‘é“¾è¡¨
è¿„ä»Šä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº†å¦‚ä½•å®ç°ä¸€ä¸ªå¯å˜çš„å•å‘é“¾è¡¨ã€‚ä½†æ˜¯ä¹‹å‰çš„é“¾è¡¨éƒ½æ˜¯å•æ‰€æœ‰æƒçš„ï¼Œåœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œå…±äº«æ‰€æœ‰æƒæ‰æ˜¯æ›´å®ç”¨çš„æ–¹å¼ï¼Œä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹è¯¥å¦‚ä½•å®ç°ä¸€ä¸ªä¸å¯å˜çš„ã€å…±äº«æ‰€æœ‰æƒçš„æŒä¹…åŒ–é“¾è¡¨( persistent )ã€‚

å¼€å§‹ä¹‹å‰ï¼Œè¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ `third.rs` ï¼Œå¹¶åœ¨ `lib.rs` ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹:
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
```

ä¸ä¸Šä¸€ä¸ªé“¾è¡¨æœ‰æ‰€ä¸åŒï¼Œè¿™æ¬¡æˆ‘ä»¬æ— éœ€æ‹·è´ä¹‹å‰çš„ä»£ç ï¼Œè€Œæ˜¯ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚





================================================
FILE: src/too-many-lists/persistent-stack/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/basics.md
================================================
# Basics

å¥½äº†ï¼Œè¿™å°±æ˜¯æœ¬ä¹¦æœ€çƒ‚çš„éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯æˆ‘èŠ±äº† 7 å¹´æ—¶é—´æ‰å†™å®Œè¿™ä¸€ç« çš„åŸå› ï¼æ˜¯æ—¶å€™æŠŠæˆ‘ä»¬å·²ç»åšè¿‡ 5 æ¬¡çš„æ¯ç‡¥ä¹å‘³çš„ä¸œè¥¿å†å†™ä¸€éäº†ï¼Œä½†å› ä¸ºæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ `Option<NonNull<Node<T>>` æŠŠæ¯ä»¶äº‹éƒ½åšä¸¤éï¼Œæ‰€ä»¥æ˜¾å¾—æ ¼å¤–å†—é•¿ï¼

```rust
impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }
}
```

PhantomData æ˜¯ä¸€ç§å¥‡æ€ªçš„ç±»å‹ï¼Œæ²¡æœ‰å­—æ®µï¼Œæ‰€ä»¥ä½ åªéœ€è¯´å‡ºå®ƒçš„ç±»å‹åç§°å°±èƒ½åˆ›å»ºä¸€ä¸ªã€‚

```rust
pub fn push_front(&mut self, elem: T) {
    // SAFETY: it's a linked-list, what do you want?
    unsafe {
        let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
            front: None,
            back: None,
            elem,
        })));
        if let Some(old) = self.front {
            // Put the new front before the old one
            (*old).front = Some(new);
            (*new).back = Some(old);
        } else {
            // If there's no front, then we're the empty list and need 
            // to set the back too. Also here's some integrity checks
            // for testing, in case we mess up.
            debug_assert!(self.back.is_none());
            debug_assert!(self.front.is_none());
            debug_assert!(self.len == 0);
            self.back = Some(new);
        }
        self.front = Some(new);
        self.len += 1;
    }
}
error[E0614]: type `NonNull<Node<T>>` cannot be dereferenced
  --> src\lib.rs:39:17
   |
39 |                 (*old).front = Some(new);
   |                 ^^^^^^
```

æ˜¯çš„ï¼Œæˆ‘çœŸæ¨ `NonNull<Node<T>>`ã€‚æˆ‘ä»¬éœ€è¦æ˜ç¡®åœ°ä½¿ç”¨ `as_ptr` ä» NonNull ä¸­è·å–åŸå§‹æŒ‡é’ˆï¼Œå› ä¸º DerefMut æ˜¯ä»¥ `&mut` å®šä¹‰çš„ï¼Œæˆ‘ä»¬ä¸æƒ³åœ¨ä¸å®‰å…¨ä»£ç ä¸­éšæ„å¼•å…¥å®‰å…¨å¼•ç”¨ï¼

```rust
            (*old.as_ptr()).front = Some(new);
            (*new.as_ptr()).back = Some(old);
   Compiling linked-list v0.0.3
warning: field is never read: `elem`
  --> src\lib.rs:16:5
   |
16 |     elem: T,
   |     ^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: `linked-list` (lib) generated 1 warning (1 duplicate)
warning: `linked-list` (lib test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.33s
```

å¾ˆå¥½ï¼Œæ¥ä¸‹æ¥æ˜¯ `pop` å’Œ `len`ï¼š

```rust
pub fn pop_front(&mut self) -> Option<T> {
    unsafe {
        // Only have to do stuff if there is a front node to pop.
        // Note that we don't need to mess around with `take` anymore
        // because everything is Copy and there are no dtors that will
        // run if we mess up... right? :) Riiiight? :)))
        self.front.map(|node| {
            // Bring the Box back to life so we can move out its value and
            // Drop it (Box continues to magically understand this for us).
            let boxed_node = Box::from_raw(node.as_ptr());
            let result = boxed_node.elem;

            // Make the next node into the new front.
            self.front = boxed_node.back;
            if let Some(new) = self.front {
                // Cleanup its reference to the removed node
                (*new.as_ptr()).front = None;
            } else {
                // If the front is now null, then this list is now empty!
                debug_assert!(self.len == 1);
                self.back = None;
            }

            self.len -= 1;
            result
            // Box gets implicitly freed here, knows there is no T.
        })
    }
}

pub fn len(&self) -> usize {
    self.len
}
   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
```

åœ¨æˆ‘çœ‹æ¥æ˜¯åˆæ³•çš„ï¼Œæ˜¯æ—¶å€™å†™ä¸€ä¸ªæµ‹è¯•äº†ï¼

```rust
#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.40s
     Running unittests src\lib.rs

running 1 test
test test::test_basic_front ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

ä¸‡å¹¸ï¼Œæˆ‘ä»¬æ˜¯å®Œç¾çš„ï¼æ˜¯å—ï¼Ÿ



================================================
FILE: src/too-many-lists/production-unsafe-deque/boring-combinatorics.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/drop-and-panic-safety.md
================================================
# Drop and Panic Safety

å˜¿ï¼Œä½ æ³¨æ„åˆ°è¿™äº›æ³¨é‡Šäº†å—ï¼š

```rust
// Note that we don't need to mess around with `take` anymore
// because everything is Copy and there are no dtors that will
// run if we mess up... right? :) Riiiight? :)))
```

è¿™å¯¹å—ï¼Ÿ

ä½ å¿˜è®°ä½ æ­£åœ¨è¯»é‚£æœ¬ä¹¦äº†å—ï¼Ÿå½“ç„¶è¿™æ˜¯é”™è¯¯çš„ï¼ˆéƒ¨åˆ†ä¸Šæ˜¯ï¼‰ã€‚

è®©æˆ‘ä»¬å†æ¬¡çœ‹çœ‹ pop_front å†…éƒ¨:

```rust
// Bring the Box back to life so we can move out its value and
// Drop it (Box continues to magically understand this for us).
let boxed_node = Box::from_raw(node.as_ptr());
let result = boxed_node.elem;

// Make the next node into the new front.
self.front = boxed_node.back;
if let Some(new) = self.front {
    // Cleanup its reference to the removed node
    (*new.as_ptr()).front = None;
} else {
    // If the front is now null, then this list is now empty!
    debug_assert!(self.len == 1);
    self.back = None;
}

self.len -= 1;
result
// Box gets implicitly freed here, knows there is no T.
```

ä½ çœ‹åˆ° bug äº†å—? çœŸå¯æ€•, æ˜¯è¿™ä¸€è¡Œ:

```rust
debug_assert!(self.len == 1);
```

å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ ä¸éœ€è¦è€ƒè™‘æˆ–æ‹…å¿ƒææ…Œï¼Œä½†ä¸€æ—¦ä½ å¼€å§‹ç¼–å†™çœŸæ­£ä¸å®‰å…¨çš„ä»£ç ï¼Œå¹¶åœ¨ "invariants(ä¸å¯å˜æ€§) "ä¸Šå¤§åšæ–‡ç« ï¼Œä½ å°±éœ€è¦å¯¹ææ…Œä¿æŒé«˜åº¦è­¦æƒ•ï¼

æˆ‘ä»¬å¿…é¡»è°ˆè°ˆ [*å¼‚å¸¸å®‰å…¨*](https://doc.rust-lang.org/nightly/nomicon/exception-safety.html) ï¼ˆåˆåææ…Œå®‰å…¨ã€è§£é™¤å®‰å…¨......ï¼‰ã€‚

æƒ…å†µæ˜¯è¿™æ ·çš„ï¼šåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œææ…Œä¼šè¢« unwindingã€‚unwind åªæ˜¯ "è®©æ¯ä¸ªå‡½æ•°ç«‹å³è¿”å› "çš„ä¸€ç§èŠ±å“¨è¯´æ³•ã€‚ä½ å¯èƒ½ä¼šæƒ³ï¼š"å¥½å§ï¼Œå¦‚æœæ¯ä¸ªå‡½æ•°éƒ½è¿”å›ï¼Œé‚£ä¹ˆç¨‹åºå°±è¦ç»“æŸäº†ï¼Œä½•å¿…åœ¨ä¹å®ƒå‘¢ï¼Ÿ"ä½†ä½ é”™äº†ï¼

æˆ‘ä»¬å¿…é¡»å…³æ³¨æœ‰ä¸¤ä¸ªåŸå› ï¼šå½“å‡½æ•°è¿”å›æ—¶ï¼Œææ„å‡½æ•°ä¼šè¿è¡Œï¼Œè€Œä¸”å¯ä»¥æ•è· unwindã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œä»£ç éƒ½å¯èƒ½åœ¨ææ…Œå‘ç”Ÿåç»§ç»­è¿è¡Œï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»éå¸¸å°å¿ƒï¼Œç¡®ä¿æˆ‘ä»¬çš„ä¸å®‰å…¨çš„é›†åˆåœ¨ææ…Œå‘ç”Ÿæ—¶å§‹ç»ˆå¤„äºæŸç§ä¸€è‡´çš„çŠ¶æ€ï¼Œå› ä¸ºæ¯æ¬¡ææ…Œéƒ½æ˜¯éšå¼çš„æå‰è¿”å›ï¼

è®©æˆ‘ä»¬æƒ³ä¸€æƒ³ï¼Œåˆ°è¿™ä¸€è¡Œæ—¶ï¼Œæˆ‘ä»¬çš„é›†åˆå¤„äºä»€ä¹ˆçŠ¶æ€ï¼š

æˆ‘ä»¬å°† boxed_node æ”¾åœ¨æ ˆä¸Šï¼Œå¹¶ä»ä¸­æå–äº†å…ƒç´ ã€‚å¦‚æœæˆ‘ä»¬åœ¨æ­¤æ—¶è¿”å›ï¼ŒBox å°†è¢«ä¸¢å¼ƒï¼ŒèŠ‚ç‚¹å°†è¢«é‡Šæ”¾ã€‚self.back ä»ç„¶æŒ‡å‘é‚£ä¸ªè¢«é‡Šæ”¾çš„èŠ‚ç‚¹ï¼ä¸€æ—¦æˆ‘ä»¬ä½¿ç”¨ self.back æ¥å¤„ç†ä¸€äº›äº‹æƒ…ï¼Œè¿™å°±å¯èƒ½å¯¼è‡´é‡Šæ”¾åå†ä½¿ç”¨ï¼

æœ‰è¶£çš„æ˜¯ï¼Œè¿™è¡Œä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ï¼Œä½†å®ƒè¦å®‰å…¨å¾—å¤šï¼š

```rust
self.len -= 1;
```

é»˜è®¤æƒ…å†µä¸‹ï¼ŒRust ä¼šåœ¨è°ƒè¯•æ„å»ºæ—¶æ£€æŸ¥ä¸Šæº¢å’Œä¸‹æº¢ï¼Œå¹¶åœ¨å‘ç”Ÿæ—¶äº§ç”Ÿææ…Œã€‚æ˜¯çš„ï¼Œæ¯ä¸€æ¬¡ç®—æœ¯è¿ç®—éƒ½ä¼šå¸¦æ¥ææ…Œå®‰å…¨éšæ‚£ï¼è¿™è¡Œè¿˜å¥½ï¼Œä»–ä¸ä¼šå¯¼è‡´å†…å­˜é”™è¯¯ï¼Œå› ä¸ºä¹‹å‰å·²ç»å®Œæˆäº†è¯¥åšçš„æ‰€æœ‰æ“ä½œã€‚æ‰€ä»¥è°ƒè¯•æ–­è¨€å“ªè¡Œåœ¨æŸç§æ„ä¹‰ä¸Šæ›´ç³Ÿç³•ï¼Œå› ä¸ºå®ƒå¯èƒ½å°†ä¸€ä¸ªå°é—®é¢˜å‡çº§ä¸ºå…³é”®é—®é¢˜ï¼

åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œåªè¦æˆ‘ä»¬ç¡®ä¿åœ¨åˆ«äººæ³¨æ„åˆ°ä¹‹å‰ä¿®å¤å®ƒä»¬ï¼Œæˆ‘ä»¬å¯ä»¥ä¸´æ—¶æ€§çš„ç ´åinvariants(ä¸å¯å˜æ€§)ã€‚è¿™å®é™…ä¸Šæ˜¯ Rust çš„é›†åˆæ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿçš„ "æ€æ‰‹çº§åº”ç”¨ "ä¹‹ä¸€ï¼šå¦‚æœä¸€ä¸ªæ“ä½œéœ€è¦ä¸€ä¸ª `&mut Self`ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±èƒ½ä¿è¯å¯¹æˆ‘ä»¬çš„é›†åˆæ‹¥æœ‰ç‹¬å è®¿é—®æƒï¼Œè€Œä¸”æˆ‘ä»¬å¯ä»¥æš‚æ—¶ç ´åinvariants(ä¸å¯å˜æ€§)ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“æ²¡æœ‰äººèƒ½å·å·æ‘¸æ‘¸åœ°ç ´åå®ƒã€‚

æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è®©æˆ‘ä»¬çš„ä»£ç æ›´å¥å£®ï¼š

- æ›´ç§¯æåœ°ä½¿ç”¨ Option::take è¿™æ ·çš„æ“ä½œï¼Œå› ä¸ºå®ƒä»¬æ›´ "äº‹åŠ¡æ€§"ï¼Œæ›´å€¾å‘äºä¿ç•™invariants(ä¸å¯å˜æ€§)ã€‚
- æ”¾å¼ƒ debug_assertsï¼Œç›¸ä¿¡è‡ªå·±èƒ½å†™å‡ºæ›´å¥½çš„æµ‹è¯•ï¼Œå¹¶ä½¿ç”¨ä¸“ç”¨çš„ "å®Œæ•´æ€§æ£€æŸ¥ "å‡½æ•°ï¼Œè€Œè¿™äº›å‡½æ•°æ°¸è¿œä¸ä¼šåœ¨ç”¨æˆ·ä»£ç ä¸­è¿è¡Œã€‚

åŸåˆ™ä¸Šï¼Œæˆ‘å–œæ¬¢ç¬¬ä¸€ç§æ–¹æ¡ˆï¼Œä½†å®ƒå¯¹åŒé“¾è·¯åˆ—è¡¨çš„å®é™…æ•ˆæœå¹¶ä¸å¥½ï¼Œå› ä¸ºæ‰€æœ‰å†…å®¹éƒ½æ˜¯åŒå†—ä½™ç¼–ç çš„ã€‚Option::take å¹¶ä¸èƒ½è§£å†³è¿™é‡Œçš„é—®é¢˜ï¼Œä½†å°† debug_assert ä¸‹ç§»ä¸€è¡Œå´å¯ä»¥ã€‚ä¸è¿‡è¯´çœŸçš„ï¼Œä¸ºä»€ä¹ˆè¦ä¸ºéš¾æˆ‘ä»¬è‡ªå·±å‘¢ï¼Ÿè®©æˆ‘ä»¬ç§»é™¤é‚£äº› debug_assertsï¼Œå¹¶ç¡®ä¿ä»»ä½•å¯èƒ½å¼•èµ·ææ…Œçš„äº‹æƒ…éƒ½å‘ç”Ÿåœ¨æˆ‘ä»¬æ–¹æ³•çš„å¼€å¤´æˆ–ç»“å°¾ï¼Œè€Œæˆ‘ä»¬åœ¨è¿™äº›åœ°æ–¹ä¿æŒinvariants(ä¸å¯å˜æ€§)ã€‚

è¿™æ˜¯æˆ‘ä»¬çš„å…¨éƒ¨å®ç°ï¼š

```rust
use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn len(&self) -> usize {
        self.len
    }
}
```

è¿™è¿˜æœ‰ä»€ä¹ˆå¯ä»¥å¼•å‘ææ…Œï¼Ÿè€å®è¯´ï¼Œè¦çŸ¥é“è¿™äº›éœ€è¦ä½ æ˜¯ Rust ä¸“å®¶ï¼Œä¸è¿‡å¹¸å¥½æˆ‘æ˜¯ï¼

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘èƒ½çœ‹åˆ°çš„å”¯ä¸€å¯èƒ½å¼•èµ·ææ…Œçš„åœ°æ–¹æ˜¯ `Box::new`ï¼ˆç”¨äºå†…å­˜ä¸è¶³çš„æƒ…å†µï¼‰å’Œ `len` è¿ç®—ã€‚æ‰€æœ‰è¿™äº›éƒ½åœ¨æˆ‘ä»¬æ–¹æ³•çš„æœ€æœ«ç«¯æˆ–æœ€å¼€å§‹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬æ˜¯å®‰å…¨çš„ï¼



================================================
FILE: src/too-many-lists/production-unsafe-deque/filling-in-random-bits.md
================================================
# Filling In Random Bits

å˜¿ï¼Œä½ ä¸æ˜¯è¯´è¦åšæˆç²¾å“å—ï¼Ÿ

ä¸ºäº†æˆä¸ºä¸€ä¸ª "å¥½ "ç³»åˆ—ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€äº›ä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿ï¼š

```rust
impl<T> LinkedList<T> {
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }
}
```

ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€å¤§å †å¤§å®¶éƒ½æœŸå¾…çš„ç‰¹æ€§éœ€è¦å®ç°ï¼š

```rust
impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }

    fn ne(&self, other: &Self) -> bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> { }

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}
```

å¦ä¸€ä¸ªæœ‰è¶£çš„è¯é¢˜æ˜¯å“ˆå¸Œæœ¬èº«ã€‚ä½ çœ‹åˆ°æˆ‘ä»¬å¦‚ä½•å°† `len` å†™å…¥æ•£åˆ—çš„å—ï¼Ÿè¿™å…¶å®éå¸¸é‡è¦ï¼å¦‚æœé›†åˆä¸æŠŠ `len` åŠ å…¥æ•£åˆ—ï¼Œå¾ˆå¯èƒ½ä¼šæ„å¤–çš„é€ æˆå‰ç¼€ç¢°æ’ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªé›†åˆåŒ…å« `["he", "llo"]` å¦ä¸€ä¸ªé›†åˆåŒ…å« `["hello"]`ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•åŒºåˆ†ï¼Ÿå¦‚æœæ²¡æœ‰æŠŠé›†åˆé•¿åº¦æˆ–å…¶å®ƒ"åˆ†éš”ç¬¦"åŠ å…¥åˆ°æ•£åˆ— ï¼Œè¿™å°†æ¯«æ— æ„ä¹‰ï¼ä¼šè®©æ„å¤–å“ˆå¸Œç¢°æ’å‘ç”Ÿå˜å¾—å¤ªå®¹æ˜“ï¼Œä¼šå¯¼è‡´ä¸¥é‡çš„åæœï¼Œæ‰€ä»¥è¿˜æ˜¯ç…§åšå§ï¼

å¥½äº†ï¼Œè¿™æ˜¯æˆ‘ä»¬ç°åœ¨çš„ä»£ç ï¼š

```rust
use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}

pub struct Iter<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a T>,
}

pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}

pub struct IntoIter<T> {
    list: LinkedList<T>,
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need 
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&self) -> Option<&T> {
        unsafe {
            self.front.map(|node| &(*node.as_ptr()).elem)
        }
    }

    pub fn front_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.front.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn back(&self) -> Option<&T> {
        unsafe {
            self.back.map(|node| &(*node.as_ptr()).elem)
        }
    }

    pub fn back_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.back.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }

    pub fn iter(&self) -> Iter<T> {
        Iter { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter { 
            list: self
        }
    }
}

impl<T> Drop for LinkedList<T> {
    fn drop(&mut self) {
        // Pop until we have to stop
        while let Some(_) = self.pop_front() { }
    }
}

impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }

    fn ne(&self, other: &Self) -> bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> { }

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl<'a, T> IntoIterator for &'a LinkedList<T> {
    type IntoIter = Iter<'a, T>;
    type Item = &'a T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for Iter<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<'a, T> IntoIterator for &'a mut LinkedList<T> {
    type IntoIter = IterMut<'a, T>;
    type Item = &'a mut T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for IterMut<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<T> IntoIterator for LinkedList<T> {
    type IntoIter = IntoIter<T>;
    type Item = T;

    fn into_iter(self) -> Self::IntoIter {
        self.into_iter()
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.list.pop_front()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.list.len, Some(self.list.len))
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.list.pop_back()
    }
}

impl<T> ExactSizeIterator for IntoIter<T> {
    fn len(&self) -> usize {
        self.list.len
    }
}


#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
```



================================================
FILE: src/too-many-lists/production-unsafe-deque/final-code.md
================================================
# Final Code

æˆ‘çœŸä¸æ•¢ç›¸ä¿¡ï¼Œæˆ‘å±…ç„¶è®©ä½ ååœ¨é‚£é‡Œï¼Œå¬æˆ‘ä»å¤´å¼€å§‹é‡æ–°å®ç° std::collections::LinkedListï¼Œä¸€è·¯ä¸Šæˆ‘çŠ¯äº†å¾ˆå¤šç¹ççš„å°é”™è¯¯ã€‚

æˆ‘åšåˆ°äº†ï¼Œä¹¦å†™å®Œäº†ï¼Œæˆ‘ç»ˆäºå¯ä»¥ä¼‘æ¯äº†ã€‚

å¥½äº†ï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬å®Œæ•´é‡å†™çš„ 1200 è¡Œä»£ç çš„å…¨éƒ¨å†…å®¹ã€‚è¿™åº”è¯¥ä¸ [this commit](https://github.com/contain-rs/linked-list/commit/5b69cc29454595172a5167a09277660342b78092) çš„æ–‡æœ¬ç›¸åŒã€‚

```rust
use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::marker::PhantomData;
use std::ptr::NonNull;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T,
}

pub struct Iter<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a T>,
}

pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}

pub struct IntoIter<T> {
    list: LinkedList<T>,
}

pub struct CursorMut<'a, T> {
    list: &'a mut LinkedList<T>,
    cur: Link<T>,
    index: Option<usize>,
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&self) -> Option<&T> {
        unsafe { self.front.map(|node| &(*node.as_ptr()).elem) }
    }

    pub fn front_mut(&mut self) -> Option<&mut T> {
        unsafe { self.front.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn back(&self) -> Option<&T> {
        unsafe { self.back.map(|node| &(*node.as_ptr()).elem) }
    }

    pub fn back_mut(&mut self) -> Option<&mut T> {
        unsafe { self.back.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while self.pop_front().is_some() {}
    }

    pub fn iter(&self) -> Iter<T> {
        Iter {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn cursor_mut(&mut self) -> CursorMut<T> {
        CursorMut {
            list: self,
            cur: None,
            index: None,
        }
    }
}

impl<T> Drop for LinkedList<T> {
    fn drop(&mut self) {
        // Pop until we have to stop
        while self.pop_front().is_some() {}
    }
}

impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> {}

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl<'a, T> IntoIterator for &'a LinkedList<T> {
    type IntoIter = Iter<'a, T>;
    type Item = &'a T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for Iter<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<'a, T> IntoIterator for &'a mut LinkedList<T> {
    type IntoIter = IterMut<'a, T>;
    type Item = &'a mut T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for IterMut<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<T> IntoIterator for LinkedList<T> {
    type IntoIter = IntoIter<T>;
    type Item = T;

    fn into_iter(self) -> Self::IntoIter {
        IntoIter { list: self }
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.list.pop_front()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.list.len, Some(self.list.len))
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.list.pop_back()
    }
}

impl<T> ExactSizeIterator for IntoIter<T> {
    fn len(&self) -> usize {
        self.list.len
    }
}

impl<'a, T> CursorMut<'a, T> {
    pub fn index(&self) -> Option<usize> {
        self.index
    }

    pub fn move_next(&mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn move_prev(&mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its previous (front)
                self.cur = (*cur.as_ptr()).front;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() -= 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real back, so move to it!
            self.cur = self.list.back;
            self.index = Some(self.list.len - 1)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn current(&mut self) -> Option<&mut T> {
        unsafe { self.cur.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn peek_next(&mut self) -> Option<&mut T> {
        unsafe {
            let next = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's back pointer
                (*cur.as_ptr()).back
            } else {
                // Ghost case, try to use the list's front pointer
                self.list.front
            };

            // Yield the element if the next node exists
            next.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_prev(&mut self) -> Option<&mut T> {
        unsafe {
            let prev = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's front pointer
                (*cur.as_ptr()).front
            } else {
                // Ghost case, try to use the list's back pointer
                self.list.back
            };

            // Yield the element if the prev node exists
            prev.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn split_before(&mut self) -> LinkedList<T> {
        // We have this:
        //
        //     list.front -> A <-> B <-> C <-> D <- list.back
        //                               ^
        //                              cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -> C <-> D <- list.back
        //                   ^
        //                  cur
        //
        //
        //    return.front -> A <-> B <- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let prev = (*cur.as_ptr()).front;

                // What self will become
                let new_len = old_len - old_idx;
                let new_front = self.cur;
                let new_back = self.list.back;
                let new_idx = Some(0);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = self.list.front;
                let output_back = prev;

                // Break the links between cur and prev
                if let Some(prev) = prev {
                    (*cur.as_ptr()).front = None;
                    (*prev.as_ptr()).back = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn split_after(&mut self) -> LinkedList<T> {
        // We have this:
        //
        //     list.front -> A <-> B <-> C <-> D <- list.back
        //                         ^
        //                        cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -> A <-> B <- list.back
        //                         ^
        //                        cur
        //
        //
        //    return.front -> C <-> D <- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let next = (*cur.as_ptr()).back;

                // What self will become
                let new_len = old_idx + 1;
                let new_back = self.cur;
                let new_front = self.list.front;
                let new_idx = Some(old_idx);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = next;
                let output_back = self.list.back;

                // Break the links between cur and next
                if let Some(next) = next {
                    (*cur.as_ptr()).back = None;
                    (*next.as_ptr()).front = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn splice_before(&mut self, mut input: LinkedList<T>) {
        // We have this:
        //
        // input.front -> 1 <-> 2 <- input.back
        //
        // list.front -> A <-> B <-> C <- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -> A <-> 1 <-> 2 <-> B <-> C <- list.back
        //                                 ^
        //                                cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(prev) = (*cur.as_ptr()).front {
                    // General Case, no boundaries, just internal fixups
                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                } else {
                    // No prev, we're appending to the front
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                    self.list.front = Some(in_front);
                }
                // Index moves forward by input length
                *self.index.as_mut().unwrap() += input.len;
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*back.as_ptr()).back = Some(in_front);
                (*in_front.as_ptr()).front = Some(back);
                self.list.back = Some(in_back);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }

    pub fn splice_after(&mut self, mut input: LinkedList<T>) {
        // We have this:
        //
        // input.front -> 1 <-> 2 <- input.back
        //
        // list.front -> A <-> B <-> C <- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -> A <-> B <-> 1 <-> 2 <-> C <- list.back
        //                     ^
        //                    cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(next) = (*cur.as_ptr()).back {
                    // General Case, no boundaries, just internal fixups
                    (*next.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(next);
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                } else {
                    // No next, we're appending to the back
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                    self.list.back = Some(in_back);
                }
                // Index doesn't change
            } else if let Some(front) = self.list.front {
                // We're on the ghost but non-empty, append to the front
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*front.as_ptr()).front = Some(in_back);
                (*in_back.as_ptr()).back = Some(front);
                self.list.front = Some(in_front);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }
}

unsafe impl<T: Send> Send for LinkedList<T> {}
unsafe impl<T: Sync> Sync for LinkedList<T> {}

unsafe impl<'a, T: Send> Send for Iter<'a, T> {}
unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}

unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}
unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}

#[allow(dead_code)]
fn assert_properties() {
    fn is_send<T: Send>() {}
    fn is_sync<T: Sync>() {}

    is_send::<LinkedList<i32>>();
    is_sync::<LinkedList<i32>>();

    is_send::<IntoIter<i32>>();
    is_sync::<IntoIter<i32>>();

    is_send::<Iter<i32>>();
    is_sync::<Iter<i32>>();

    is_send::<IterMut<i32>>();
    is_sync::<IterMut<i32>>();

    fn linked_list_covariant<'a, T>(x: LinkedList<&'static T>) -> LinkedList<&'a T> {
        x
    }
    fn iter_covariant<'i, 'a, T>(x: Iter<'i, &'static T>) -> Iter<'i, &'a T> {
        x
    }
    fn into_iter_covariant<'a, T>(x: IntoIter<&'static T>) -> IntoIter<&'a T> {
        x
    }

    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    ///
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
}

#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -> LinkedList<i32> {
        list_from(&[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList<u8> = list_from(&[]);
        let mut m = list_from(&[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&[2, 3, 4]);
        let m = list_from(&[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&[]);
        let m = list_from(&[1, 2, 3]);
        assert!(n < m);
        assert!(m > n);
        assert!(n <= n);
        assert!(n >= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&[nan]);
        let m = list_from(&[nan]);
        assert!(!(n < m));
        assert!(!(n > m));
        assert!(!(n <= m));
        assert!(!(n >= m));

        let n = list_from(&[nan]);
        let one = list_from(&[1.0f64]);
        assert!(!(n < one));
        assert!(!(n > one));
        assert!(!(n <= one));
        assert!(!(n >= one));

        let u = list_from(&[1.0f64, 2.0, nan]);
        let v = list_from(&[1.0f64, 2.0, 3.0]);
        assert!(!(u < v));
        assert!(!(u > v));
        assert!(!(u <= v));
        assert!(!(u >= v));

        let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s < t));
        assert!(s > one);
        assert!(!(s <= one));
        assert!(s >= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList<i32> = (0..10).collect();
        assert_eq!(format!("{:?}", list), "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]");

        let list: LinkedList<&str> = vec!["just", "one", "test", "more"]
            .iter()
            .copied()
            .collect();
        assert_eq!(format!("{:?}", list), r#"["just", "one", "test", "more"]"#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList<i32> = (0..10).collect();
        let list2: LinkedList<i32> = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), "list1"), None);
        assert_eq!(map.insert(list2.clone(), "list2"), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&list1), Some(&"list1"));
        assert_eq!(map.get(&list2), Some(&"list2"));

        assert_eq!(map.remove(&list1), Some("list1"));
        assert_eq!(map.remove(&list2), Some("list2"));

        assert!(map.is_empty());
    }

    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 1));
        assert_eq!(cursor.peek_next(), Some(&mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 2));
        assert_eq!(cursor.peek_next(), Some(&mut 3));
        assert_eq!(cursor.peek_prev(), Some(&mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 5));
        assert_eq!(cursor.peek_next(), Some(&mut 6));
        assert_eq!(cursor.peek_prev(), Some(&mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[7, 1, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]
        );

        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);
        */

        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList<u32> = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList<u32> = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(
            tmp.into_iter().collect::<Vec<_>>(),
            &[102, 103, 8, 2, 3, 4, 5, 6]
        );
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101]
        );
    }

    fn check_links<T: Eq + std::fmt::Debug>(list: &LinkedList<T>) {
        let from_front: Vec<_> = list.iter().collect();
        let from_back: Vec<_> = list.iter().rev().collect();
        let re_reved: Vec<_> = from_back.into_iter().rev().collect();

        assert_eq!(from_front, re_reved);
    }
}
```



================================================
FILE: src/too-many-lists/production-unsafe-deque/implementing-cursors.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/intro.md
================================================
# A Production-Quality Unsafe Doubly-Linked Deque

æˆ‘ä»¬ç»ˆäºæˆåŠŸäº†ã€‚æˆ‘æœ€å¤§çš„å…‹æ˜Ÿï¼š**[std::collections::LinkedList](https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs)ï¼ŒåŒå‘é“¾æ¥çš„ Deque**ã€‚

æˆ‘å°è¯•è¿‡ä½†æœªèƒ½å‡»è´¥çš„é‚£ä¸ªã€‚

æ¥å§ï¼Œæˆ‘å°†å‘ä½ å±•ç¤ºä½ éœ€è¦çŸ¥é“çš„ä¸€åˆ‡ï¼Œå¸®åŠ©æˆ‘ä¸€åŠ³æ°¸é€¸åœ°æ‘§æ¯å®ƒ--å®ç°ä¸€ä¸ª **unsafe** çš„ç”Ÿäº§è´¨é‡åŒå‘é“¾æ¥ Deque æ‰€éœ€è¦çŸ¥é“çš„ä¸€åˆ‡ã€‚

æˆ‘ä»¬å°†å½»åº•é‡å†™æˆ‘é‚£å¤è€çš„ Rust 1.0 linked-list crateï¼Œé‚£ä¸ª linked-list å®¢è§‚ä¸Šæ¯” std è¦å¥½ï¼Œå®ƒä» 2015 å¹´å¼€å§‹ï¼Œå°±å­˜åœ¨ Cursors (æ¸¸æ ‡ï¼Œåé¢æ–‡ç« ä¼šä»‹ç»)ï¼è€Œæ ‡å‡†åº“2022å¹´äº†è¿˜æ²¡æœ‰çš„ä¸œè¥¿ï¼



================================================
FILE: src/too-many-lists/production-unsafe-deque/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/send-sync-and-compile-tests.md
================================================
# Send, Sync, and Compile Tests

å¥½å§ï¼Œå…¶å®æˆ‘ä»¬è¿˜æœ‰ä¸€å¯¹ç‰¹å¾éœ€è¦è€ƒè™‘ï¼Œä½†å®ƒä»¬å¾ˆç‰¹åˆ«ã€‚æˆ‘ä»¬å¿…é¡»å¯¹ä»˜ Rust çš„ç¥åœ£ç½—é©¬å¸å›½ï¼š unsafe çš„ Opt-in Built-out ç‰¹å¾ï¼ˆOIBITsï¼‰ï¼š Send å’Œ Syncï¼Œå®ƒä»¬å®é™…ä¸Šæ˜¯ï¼ˆopt-outï¼‰å’Œï¼ˆbuilt-outï¼‰ï¼ˆ3 ä¸ªä¸­æœ‰ 1 ä¸ªå·²ç»å¾ˆä¸é”™äº†ï¼ï¼‰ã€‚

ä¸ Copy ä¸€æ ·ï¼Œè¿™äº›ç‰¹å¾å®Œå…¨æ²¡æœ‰ç›¸å…³ä»£ç ï¼Œåªæ˜¯æ ‡è®°æ‚¨çš„ç±»å‹å…·æœ‰ç‰¹å®šå±æ€§ã€‚Send è¡¨ç¤ºä½ çš„ç±»å‹å¯ä»¥å®‰å…¨åœ°å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚Sync è¡¨ç¤ºä½ çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨å…±äº«ï¼ˆ&Self: Sendï¼‰ã€‚

å…³äº LinkedList *covariant(åå˜çš„)* è®ºç‚¹åœ¨è¿™é‡ŒåŒæ ·é€‚ç”¨ï¼šä¸€èˆ¬æ¥è¯´ï¼Œä¸ä½¿ç”¨èŠ±å“¨çš„å†…éƒ¨å¯å˜æŠ€å·§çš„æ™®é€šé›†åˆå¯ä»¥å®‰å…¨åœ°è¿›è¡Œ Send å’Œ Syncã€‚

But I said they're *opt out*. So actually, are we already? How would we know?

è®©æˆ‘ä»¬åœ¨ä»£ç ä¸­æ·»åŠ ä¸€äº›æ–°çš„é­”æ³•ï¼šéšæœºçš„ç§æœ‰åƒåœ¾ï¼Œé™¤éæˆ‘ä»¬çš„ç±»å‹å…·æœ‰æˆ‘ä»¬æ‰€æœŸæœ›çš„å±æ€§ï¼Œå¦åˆ™å°†æ— æ³•ç¼–è¯‘ï¼š

```rust
#[allow(dead_code)]
fn assert_properties() {
    fn is_send<T: Send>() {}
    fn is_sync<T: Sync>() {}

    is_send::<LinkedList<i32>>();
    is_sync::<LinkedList<i32>>();

    is_send::<IntoIter<i32>>();
    is_sync::<IntoIter<i32>>();

    is_send::<Iter<i32>>();
    is_sync::<Iter<i32>>();

    is_send::<IterMut<i32>>();
    is_sync::<IterMut<i32>>();

    is_send::<Cursor<i32>>();
    is_sync::<Cursor<i32>>();

    fn linked_list_covariant<'a, T>(x: LinkedList<&'static T>) -> LinkedList<&'a T> { x }
    fn iter_covariant<'i, 'a, T>(x: Iter<'i, &'static T>) -> Iter<'i, &'a T> { x }
    fn into_iter_covariant<'a, T>(x: IntoIter<&'static T>) -> IntoIter<&'a T> { x }
}
cargo build
   Compiling linked-list v0.0.3 
error[E0277]: `NonNull<Node<i32>>` cannot be sent between threads safely
   --> src\lib.rs:433:5
    |
433 |     is_send::<LinkedList<i32>>();
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `NonNull<Node<i32>>` cannot be sent between threads safely
    |
    = help: within `LinkedList<i32>`, the trait `Send` is not implemented for `NonNull<Node<i32>>`
    = note: required because it appears within the type `Option<NonNull<Node<i32>>>`
note: required because it appears within the type `LinkedList<i32>`
   --> src\lib.rs:8:12
    |
8   | pub struct LinkedList<T> {
    |            ^^^^^^^^^^
note: required by a bound in `is_send`
   --> src\lib.rs:430:19
    |
430 |     fn is_send<T: Send>() {}
    |                   ^^^^ required by this bound in `is_send`

<a million more errors>
```

æˆ‘éª—ä½ è¯´åŸå§‹æŒ‡é’ˆåªæœ‰ä¸€ä¸ªå®‰å…¨ä¿æŠ¤ï¼šè¿™æ˜¯å¦ä¸€ä¸ªã€‚ `*const` å’Œ `*mut` explicitly opt out of Send and Sync to be safe, so we do *actually* have to opt back in:

```rust
unsafe impl<T: Send> Send for LinkedList<T> {}
unsafe impl<T: Sync> Sync for LinkedList<T> {}

unsafe impl<'a, T: Send> Send for Iter<'a, T> {}
unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}

unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}
unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨è¿™é‡Œç¼–å†™ä¸å®‰å…¨çš„ implï¼šè¿™äº›æ˜¯ä¸å®‰å…¨çš„ç‰¹å¾ï¼ä¸å®‰å…¨ä»£ç ï¼ˆå¦‚å¹¶å‘åº“ï¼‰åªèƒ½ä¾é æˆ‘ä»¬æ­£ç¡®åœ°å®ç°è¿™äº›ç‰¹å¾ï¼ç”±äºæ²¡æœ‰å®é™…ä»£ç ï¼Œæˆ‘ä»¬æ‰€åšçš„ä¿è¯åªæ˜¯ï¼šæ˜¯çš„ï¼Œæˆ‘ä»¬åœ¨çº¿ç¨‹é—´å‘é€æˆ–å…±äº«ç¡®å®æ˜¯å®‰å…¨çš„ï¼

åˆ«ä»¥ä¸ºè¿™äº›éƒ½æ˜¯éšä¾¿è¯´è¯´çš„ï¼Œæˆ‘å¯æ˜¯ç»è¿‡è®¤è¯çš„ä¸“ä¸šäººå£«ï¼Œæˆ‘åœ¨è¿™é‡Œè¦è¯´ï¼šæ˜¯çš„ï¼Œè¿™äº›éƒ½æ˜¯å®Œå…¨æ²¡é—®é¢˜çš„ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦ä¸º IntoIter å®ç° Send å’Œ Syncï¼šå®ƒåªæ˜¯åŒ…å« LinkedListï¼Œæ‰€ä»¥ä¼šè‡ªåŠ¨ç”Ÿæˆ Send å’Œ Sync--æˆ‘å‘Šè¯‰è¿‡ä½ å®ƒä»¬å®é™…ä¸Šæ˜¯ opt outï¼

```text
cargo build
   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.18s
```

å¾ˆå¥½

IterMut ç»å¯¹ä¸åº”è¯¥æ˜¯åå˜çš„ï¼Œå› ä¸ºå®ƒ "å°±åƒ" `&mut T`ã€‚

ç”¨é­”æœ¯ï¼å…¶å®æ˜¯ç”¨ rustdocï¼å¥½å§ï¼Œæˆ‘ä»¬ä¸ä¸€å®šè¦ä½¿ç”¨ rustdocï¼Œä½†è¿™æ˜¯æœ€æœ‰è¶£çš„ç”¨æ³•ã€‚ä½ çœ‹ï¼Œå¦‚æœä½ å†™äº†ä¸€ä¸ª doccomment å¹¶åŒ…å«äº†ä¸€ä¸ªä»£ç å—ï¼Œé‚£ä¹ˆ rustdoc å°±ä¼šå°è¯•ç¼–è¯‘å¹¶è¿è¡Œå®ƒï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºæ–°çš„åŒ¿å "ç¨‹åº"ï¼Œè€Œè¿™äº›ç¨‹åºä¸ä¼šå½±å“ä¸»ç¨‹åºï¼š

```rust
    /// ```
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
error[E0308]: mismatched types
 --> src\lib.rs:461:86
  |
6 | fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
  |                                                                                      ^ lifetime mismatch
  |
  = note: expected struct `linked_list::IterMut<'_, &'a T>`
             found struct `linked_list::IterMut<'_, &'static T>`
```

å¥½å§ï¼Œæˆ‘ä»¬å·²ç»è¯æ˜äº†å®ƒæ˜¯ä¸å˜çš„ï¼Œä½†ç°åœ¨æˆ‘ä»¬çš„æµ‹è¯•å¤±è´¥äº†ã€‚ä¸ç”¨æ‹…å¿ƒï¼Œrustdoc ä¼šè®©ä½ åœ¨æ …æ ä¸Šæ³¨é‡Š compile_failï¼Œè¯´æ˜è¿™æ˜¯æ„æ–™ä¹‹ä¸­çš„ï¼

(å®é™…ä¸Šï¼Œæˆ‘ä»¬åªè¯æ˜äº†å®ƒ "ä¸æ˜¯*covariant(åå˜çš„)*"ï¼Œä½†è€å®è¯´ï¼Œå¦‚æœä½ èƒ½è®©ä¸€ä¸ªç±»å‹ "æ„å¤–åœ°ã€é”™è¯¯åœ°*contravariant(é€†å˜çš„)* "ï¼Œé‚£ä¹ˆï¼Œæ­å–œä½ ã€‚ï¼‰

```rust
    /// ```compile_fail
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.49s
     Running unittests src\lib.rs

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
```

æ˜¯çš„ï¼æˆ‘å»ºè®®åœ¨è¿›è¡Œæµ‹è¯•æ—¶ä¸è¦ä½¿ç”¨ compile_failï¼Œè¿™æ ·ä½ å¯ä»¥çœ‹åˆ°é”™è¯¯æ˜¯ä¸æ˜¯å’Œä½ é¢„æœŸçš„ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œä½ å¿˜è®°äº†ä½¿ç”¨ use å…³é”®å­—ï¼Œè¿™æ˜¯é”™è¯¯çš„ï¼Œä½†å› ä¸º compile_failé€šè¿‡äº†æµ‹è¯•ã€‚å¦‚æœä¸ä½¿ç”¨compile_failï¼Œæµ‹è¯•ä¼šå› ä¸ºæ²¡æœ‰ä½¿ç”¨ use å¤±è´¥ï¼Œè¿™ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œ æˆ‘ä»¬æƒ³è¦çš„æ˜¯ï¼šæµ‹è¯•å› ä¸º `mut` æ˜¯*covariant(åå˜çš„)*çš„è€Œå¤±è´¥ï¼

(å“¦ï¼Œç­‰ç­‰ï¼Œæˆ‘ä»¬å…¶å®å¯ä»¥åœ¨ compile_fail æ—è¾¹æŒ‡å®šæˆ‘ä»¬æƒ³è¦çš„é”™è¯¯ä»£ç ï¼Œä½†è¿™åªé€‚ç”¨äº nightlyï¼Œè€Œä¸”ç”±äºä¸Šè¿°åŸå› ï¼Œä¾èµ–å®ƒæ˜¯ä¸ªåä¸»æ„ã€‚åœ¨ not-nightly ç‰ˆæœ¬è¿è¡Œæ—¶ï¼Œå®ƒå°†è¢«é»˜é»˜å¿½ç•¥ï¼‰ã€‚

```rust
    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
```

......è¿˜æœ‰ï¼Œä½ æ³¨æ„åˆ°æˆ‘ä»¬å®é™…ä¸ŠæŠŠ IterMut å˜æˆ*invariant(ä¸å˜çš„)*çš„é‚£éƒ¨åˆ†äº†å—ï¼Ÿè¿™å¾ˆå®¹æ˜“è¢«å¿½ç•¥ï¼Œå› ä¸ºæˆ‘ "åªæ˜¯ "å¤åˆ¶ç²˜è´´äº† Iter å¹¶æŠŠå®ƒæ”¾åœ¨äº†æœ€åã€‚è¿™æ˜¯æœ€åä¸€è¡Œï¼š

```rust
pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}
```

æˆ‘ä»¬è¯•ç€å»æ‰ PhantomData:

```text
 cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
error[E0392]: parameter `'a` is never used
  --> src\lib.rs:30:20
   |
30 | pub struct IterMut<'a, T> {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, or using a marker such as `PhantomData`
```

å“ˆï¼ç¼–è¯‘å™¨åœ¨èƒŒåæ”¯æŒæˆ‘ä»¬ï¼Œæç¤ºæˆ‘ä»¬æœªä½¿ç”¨çš„ lifetimeã€‚è®©æˆ‘ä»¬è¯•ç€ç”¨ä¸€ä¸ªé”™è¯¯çš„ä¾‹å­æ¥ä»£æ›¿ï¼š

```rust
    _boo: PhantomData<&'a T>,
cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
```

å®ƒå¯ä»¥æ„å»ºï¼æˆ‘ä»¬çš„æµ‹è¯•å¯ä»¥å‘ç°é—®é¢˜å—ï¼Ÿ

```text
cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
Test compiled successfully, but it's marked `compile_fail`.

failures:
    src\lib.rs - assert_properties::iter_mut_invariant (line 458)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.15s
```

Eyyy!!.ï¼è¿™ä¸ªç³»ç»ŸçœŸç®¡ç”¨ï¼æˆ‘å–œæ¬¢é‚£äº›èƒ½çœŸæ­£å®Œæˆä»»åŠ¡çš„æµ‹è¯•ï¼Œè¿™æ ·æˆ‘å°±ä¸å¿…ä¸ºé‚£äº›è‹¥éšè‹¥ç°çš„é”™è¯¯è€Œæ„Ÿåˆ°ææƒ§äº†ï¼



================================================
FILE: src/too-many-lists/production-unsafe-deque/testing-cursors.md
================================================
# Testing Cursors

æ˜¯æ—¶å€™æ‰¾å‡ºæˆ‘åœ¨ä¸Šä¸€èŠ‚ä¸­çŠ¯äº†å¤šå°‘ä»¤äººå°´å°¬çš„é”™è¯¯äº†ï¼

å“¦ï¼Œå¤©å“ªï¼Œæˆ‘ä»¬çš„ API æ—¢ä¸åƒæ ‡å‡†ç‰ˆï¼Œä¹Ÿä¸åƒæ—§ç‰ˆã€‚å¥½å§ï¼Œé‚£æˆ‘æ‰“ç®—ä»è¿™ä¸¤ä¸ªåœ°æ–¹æ‹¼å‡‘ä¸€äº›ä¸œè¥¿å§ã€‚æ˜¯çš„ï¼Œè®©æˆ‘ä»¬ "å€Ÿç”¨ " æ ‡å‡†ç‰ˆä¸­çš„è¿™äº›æµ‹è¯•ï¼š

```rust
    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 1));
        assert_eq!(cursor.peek_next(), Some(&mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 2));
        assert_eq!(cursor.peek_next(), Some(&mut 3));
        assert_eq!(cursor.peek_prev(), Some(&mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 5));
        assert_eq!(cursor.peek_next(), Some(&mut 6));
        assert_eq!(cursor.peek_prev(), Some(&mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);
        
        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);
        */

       let mut m: LinkedList<u32> = LinkedList::new();
    m.extend([1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList<u32> = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList<u32> = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);
    }

    fn check_links<T>(_list: &LinkedList<T>) {
        // would be good to do this!
    }
```

è§è¯å¥‡è¿¹çš„æ—¶å€™ï¼

```text
cargo test

   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 1.03s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_debug ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord ... ok
test test::test_cursor_move_peek ... FAILED
test test::test_cursor_mut_insert ... FAILED
test test::test_iterator ... ok
test test::test_mut_iter ... ok
test test::test_eq ... ok
test test::test_rev_iter ... ok
test test::test_iterator_double_end ... ok
test test::test_hashmap ... ok
test test::test_ord_nan ... ok

failures:

---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `None`,
 right: `Some(1)`', src\lib.rs:1079:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- test::test_cursor_mut_insert stdout ----
thread 'test::test_cursor_mut_insert' panicked at 'assertion failed: `(left == right)`
  left: `[200, 201, 202, 203, 10, 100, 101, 102, 103, 7, 1, 8, 2, 3, 4, 5, 6, 9]`,
 right: `[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]`', src\lib.rs:1153:9


failures:
    test::test_cursor_move_peek
    test::test_cursor_mut_insert

test result: FAILED. 12 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

æˆ‘å¾—æ‰¿è®¤ï¼Œæˆ‘åœ¨è¿™é‡Œæœ‰äº›è‡ªè´Ÿï¼Œå¸Œæœ›è‡ªå·±èƒ½æˆåŠŸã€‚è¿™å°±æ˜¯æˆ‘ä»¬å†™æµ‹è¯•çš„åŸå› ï¼ˆä½†ä¹Ÿè®¸æˆ‘åªæ˜¯åœ¨ç§»æ¤æµ‹è¯•æ—¶åšå¾—ä¸å¥½ï¼Ÿï¼‰

ç¬¬ä¸€æ¬¡å¤±è´¥æ˜¯ä»€ä¹ˆï¼Ÿ

```rust
let mut m: LinkedList<u32> = LinkedList::new();
m.extend([1, 2, 3, 4, 5, 6]);
let mut cursor = m.cursor_mut();

cursor.move_next();
assert_eq!(cursor.current(), Some(&mut 1));
assert_eq!(cursor.peek_next(), Some(&mut 2));
assert_eq!(cursor.peek_prev(), None);
assert_eq!(cursor.index(), Some(0));

cursor.move_prev();
assert_eq!(cursor.current(), None);
assert_eq!(cursor.peek_next(), Some(&mut 1)); // DIES HERE
```

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

å°±æ˜¯è¿™é”™äº†ã€‚å¦‚æœ `self.cur` æ˜¯ None, æˆ‘ä»¬ä¸åº”è¯¥å°±è¿™æ ·æ”¾å¼ƒï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ£€æŸ¥ self.list.frontï¼Œå› ä¸ºæˆ‘ä»¬åœ¨å¹½çµèŠ‚ç‚¹ä¸Šï¼å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€åœ¨é“¾ä¸­æ·»åŠ ä¸€ä¸ª or_elseï¼š

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .or_else(|| self.list.front)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).front)
            .or_else(|| self.list.back)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

è¿™æ ·å°±ä¿®å¤å¥½äº†å—ï¼Ÿ

```text
---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `Some(6)`,
 right: `None`', src\lib.rs:1078:9
```

åˆé”™äº†ã€‚å¥½å§ï¼Œæ˜¾ç„¶è¿™æ¯”æˆ‘æƒ³è±¡çš„è¦éš¾å¾—å¤šã€‚ç›²ç›®åœ°æŠŠè¿™äº›æƒ…å†µä¸²è”èµ·æ¥ç®€ç›´æ˜¯ä¸€åœºç¾éš¾ï¼Œè®©æˆ‘ä»¬å¯¹å¹½çµèŠ‚ç‚¹ä¸éå¹½çµèŠ‚ç‚¹çš„æƒ…å†µåšä¸åŒçš„åˆ¤æ–­å§ï¼š

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        let next = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's back pointer
            (*cur.as_ptr()).back
        } else {
            // Ghost case, try to use the list's front pointer
            self.list.front
        };

        // Yield the element if the next node exists
        next.map(|node| &mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&mut self) -> Option<&mut T> {
    unsafe {
        let prev = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's front pointer
            (*cur.as_ptr()).front
        } else {
            // Ghost case, try to use the list's back pointer
            self.list.back
        };

        // Yield the element if the prev node exists
        prev.map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

æˆ‘å¯¹è¿™ä¸€æ¬¡å……æ»¡ä¿¡å¿ƒï¼

```rust

 cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.70s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_cursor_move_peek ... ok
test test::test_eq ... ok
test test::test_cursor_mut_insert ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_ord_nan ... ok
test test::test_mut_iter ... ok
test test::test_hashmap ... ok
test test::test_debug ... ok
test test::test_ord ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
```

å˜¿å˜¿ï¼Œçœ‹çœ‹è¿™ä¸ª......å¥½å§ï¼Œç°åœ¨æˆ‘å¼€å§‹ç–‘ç¥ç–‘é¬¼äº†ã€‚è®©æˆ‘ä»¬æ­£ç¡®å¡«å†™ check_linksï¼Œå¹¶åœ¨ miri ä¸‹è¿›è¡Œæµ‹è¯•ï¼š

```rust
fn check_links<T: Eq + std::fmt::Debug>(list: &LinkedList<T>) {
    let from_front: Vec<_> = list.iter().collect();
    let from_back: Vec<_> = list.iter().rev().collect();
    let re_reved: Vec<_> = from_back.into_iter().rev().collect();

    assert_eq!(from_front, re_reved);
}
```

```text
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_cursor_move_peek ... ok
test test::test_cursor_mut_insert ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.10s
```

å®Œæˆã€‚

æˆ‘ä»¬æˆåŠŸäº† æˆ‘ä»¬åšå‡ºäº†ä¸€ä¸ªå…·æœ‰ç”Ÿäº§è´¨é‡çš„ LinkedListï¼Œå…¶åŠŸèƒ½ä¸ std ä¸­çš„ LinkedList åŸºæœ¬ç›¸åŒã€‚æˆ‘ä»¬æ˜¯å¦åœ¨è¿™é‡Œæˆ–é‚£é‡Œç¼ºå°‘äº†ä¸€äº›å°çš„ä¾¿åˆ©æ–¹æ³•ï¼Ÿå½“ç„¶æœ‰ã€‚æˆ‘ä¼šæŠŠå®ƒä»¬æ·»åŠ åˆ°æœ€ç»ˆå‘å¸ƒçš„ç‰ˆæœ¬ä¸­å—ï¼Ÿä¹Ÿè®¸ä¼šï¼

ä½†æ˜¯ï¼Œæˆ‘å·²ç»éå¸¸ç´¯äº†ã€‚

æ‰€ä»¥ã€‚æˆ‘ä»¬èµ¢äº†

ç­‰ç­‰ æˆ‘ä»¬æ­£åœ¨ç”Ÿäº§è´¨é‡ã€‚å¥½å§ï¼Œæœ€åä¸€ä¸ªæ­¥éª¤ï¼š clippyã€‚

```text
cargo clippy

cargo clippy
    Checking linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
warning: redundant pattern matching, consider using `is_some()`
   --> src\lib.rs:189:19
    |
189 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: `#[warn(clippy::redundant_pattern_matching)]` on by default
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`
   --> src\lib.rs:210:5
    |
210 | /     pub fn into_iter(self) -> IntoIter<T> {
211 | |         IntoIter {
212 | |             list: self
213 | |         }
214 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::should_implement_trait)]` on by default
    = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait

warning: redundant pattern matching, consider using `is_some()`
   --> src\lib.rs:228:19
    |
228 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: re-implementing `PartialEq::ne` is unnecessary
   --> src\lib.rs:275:5
    |
275 | /     fn ne(&self, other: &Self) -> bool {
276 | |         self.len() != other.len() || self.iter().ne(other)
277 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::partialeq_ne_impl)]` on by default
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl

warning: `linked-list` (lib) generated 4 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
```

å¥½çš„ clippy, æŒ‰ç…§ä½ çš„è¦æ±‚ä¿®æ”¹ã€‚

å†æ¥ä¸€æ¬¡ï¼š

```text
cargo clippy
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
```

å¤ªæ£’äº†ï¼Œç§°ä¸ºç”Ÿäº§å“è´¨çš„æœ€åä¸€ä»¶äº‹: fmt.

```text
cargo fmt
```

**æˆ‘ä»¬ç°åœ¨ç»ˆäºçœŸæ­£çš„å®Œæˆå•¦!!!!!!!!!!!!!!!!!!!!!**



================================================
FILE: src/too-many-lists/production-unsafe-deque/testing.md
================================================
# Testing

å¥½å§ï¼Œæˆ‘æ¨è¿Ÿäº†ä¸€æ®µæ—¶é—´æµ‹è¯•ï¼Œå› ä¸ºæˆ‘ä»¬éƒ½çŸ¥é“ï¼Œæˆ‘ä»¬ç°åœ¨æ˜¯ Rust çš„ä¸»äººï¼Œä¸ä¼šå†çŠ¯é”™äº†ï¼å¦å¤–ï¼Œè¿™æ˜¯å¯¹ä¸€ä¸ªæ—§ crate çš„é‡å†™ï¼Œæ‰€ä»¥æˆ‘å·²ç»æœ‰äº†æ‰€æœ‰çš„æµ‹è¯•ã€‚ä½ å·²ç»çœ‹è¿‡å¾ˆå¤šæµ‹è¯•äº†ã€‚å®ƒä»¬å°±åœ¨è¿™é‡Œï¼š

```rust
#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -> LinkedList<i32> {
        list_from(&[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList<u8> = list_from(&[]);
        let mut m = list_from(&[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&[2, 3, 4]);
        let m = list_from(&[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&[]);
        let m = list_from(&[1, 2, 3]);
        assert!(n < m);
        assert!(m > n);
        assert!(n <= n);
        assert!(n >= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&[nan]);
        let m = list_from(&[nan]);
        assert!(!(n < m));
        assert!(!(n > m));
        assert!(!(n <= m));
        assert!(!(n >= m));

        let n = list_from(&[nan]);
        let one = list_from(&[1.0f64]);
        assert!(!(n < one));
        assert!(!(n > one));
        assert!(!(n <= one));
        assert!(!(n >= one));

        let u = list_from(&[1.0f64, 2.0, nan]);
        let v = list_from(&[1.0f64, 2.0, 3.0]);
        assert!(!(u < v));
        assert!(!(u > v));
        assert!(!(u <= v));
        assert!(!(u >= v));

        let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s < t));
        assert!(s > one);
        assert!(!(s <= one));
        assert!(s >= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList<i32> = (0..10).collect();
        assert_eq!(format!("{:?}", list), "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]");

        let list: LinkedList<&str> = vec!["just", "one", "test", "more"]
            .iter().copied()
            .collect();
        assert_eq!(format!("{:?}", list), r#"["just", "one", "test", "more"]"#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList<i32> = (0..10).collect();
        let list2: LinkedList<i32> = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), "list1"), None);
        assert_eq!(map.insert(list2.clone(), "list2"), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&list1), Some(&"list1"));
        assert_eq!(map.get(&list2), Some(&"list2"));

        assert_eq!(map.remove(&list1), Some("list1"));
        assert_eq!(map.remove(&list2), Some("list2"));

        assert!(map.is_empty());
    }
}
```

ç°åœ¨æ˜¯å…³é”®æ—¶åˆ»ï¼š

```text
cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_eq ... ok
test test::test_iterator ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord_nan ... ok
test test::test_iterator_double_end ... ok
test test::test_mut_iter ... ok
test test::test_rev_iter ... ok
test test::test_hashmap ... ok
test test::test_ord ... ok
test test::test_debug ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.35s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

ğŸ˜­

æˆ‘ä»¬åšåˆ°äº†ï¼Œæˆ‘ä»¬çœŸçš„æ²¡æœ‰æç ¸ã€‚è¿™ä¸æ˜¯å°æŠŠæˆï¼æˆ‘ä»¬æ‰€æœ‰çš„ç»ƒä¹ å’Œè®­ç»ƒç»ˆäºå€¼å¾—äº†ï¼æˆ‘ä»¬ç»ˆäºå†™å‡ºäº†å¥½ä»£ç 

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å›åˆ° "æœ‰è¶£çš„äº‹æƒ… "ä¸Šæ¥äº†ï¼



================================================
FILE: src/too-many-lists/production-unsafe-deque/variance-and-phantomData.md
================================================
# Variance and PhantomData

å¦‚æœç°åœ¨ä¸åšï¼Œç­‰ä»¥åå†ä¿®ï¼Œä¼šå¾ˆéº»çƒ¦ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨è¦åšçš„æ˜¯ç¡¬æ ¸å¸ƒå±€ã€‚

å»ºé€  Rust collections æ—¶ï¼Œæœ‰è¿™äº”ä¸ªå¯æ€•çš„éš¾é¢˜ï¼š

1. [Variance](https://doc.rust-lang.org/nightly/nomicon/subtyping.html)
2. [Drop Check](https://doc.rust-lang.org/nightly/nomicon/dropck.html)
3. [NonNull Optimizations](https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html)
4. [The isize::MAX Allocation Rule](https://doc.rust-lang.org/nightly/nomicon/vec/vec-alloc.html)
5. [Zero-Sized Types](https://doc.rust-lang.org/nightly/nomicon/vec/vec-zsts.html)

å¹¸å¥½ï¼Œåé¢2ä¸ªå¯¹æˆ‘ä»¬æ¥è¯´éƒ½ä¸æ˜¯é—®é¢˜ã€‚

æˆ‘ä»¬å¯ä»¥æŠŠç¬¬ä¸‰ä¸ªé—®é¢˜å˜æˆæˆ‘ä»¬çš„é—®é¢˜ï¼Œä½†è¿™å¸¦æ¥çš„éº»çƒ¦æ¯”å®ƒçš„ä»·å€¼æ›´å¤šã€‚

ç¬¬äºŒä¸ªé—®é¢˜æ˜¯æˆ‘ä»¥å‰ä¸€ç›´åšæŒè®¤ä¸ºéå¸¸é‡è¦çš„ï¼Œstd ä¹Ÿä¼šä¹±ç”¨å®ƒï¼Œä½†é»˜è®¤å€¼æ˜¯å®‰å…¨çš„ï¼Œè€Œä¸”ä½ éœ€è¦éå¸¸åŠªåŠ›æ‰èƒ½æ³¨æ„åˆ°é»˜è®¤å€¼çš„é™åˆ¶ï¼Œæ‰€ä»¥ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªé—®é¢˜ã€‚

æ‰€ä»¥åªå‰©ä¸‹äº† Variance(å‹å˜)ã€‚

Rust æœ‰å­ç±»å‹äº†ã€‚é€šå¸¸ï¼Œ`&'big T`  æ˜¯ `&'small T` çš„å­ç±»å‹ã€‚å› ä¸ºå¦‚æœæŸäº›ä»£ç éœ€è¦åœ¨ç¨‹åºçš„æŸä¸ªç‰¹å®šåŒºåŸŸå­˜æ´»çš„å¼•ç”¨ï¼Œé‚£ä¹ˆé€šå¸¸å®Œå…¨å¯ä»¥ç»™å®ƒä¸€ä¸ªå­˜åœ¨*æ—¶é—´æ›´é•¿çš„*å¼•ç”¨ã€‚ç›´è§‰ä¸Šè¿™æ˜¯æ­£ç¡®çš„ï¼Œå¯¹å§ï¼Ÿ

ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ï¼Ÿæƒ³è±¡ä¸€ä¸‹ï¼Œä¸€äº›ä»£ç é‡‡ç”¨ä¸¤ä¸ªå…·æœ‰ç›¸åŒç±»å‹çš„å€¼ï¼š

```rust
fn take_two<T>(_val1: T, _val2: T) { }
```

è¿™æ˜¯ä¸€äº›éå¸¸æ— èŠçš„ä»£ç ï¼Œå¹¶ä¸”æˆ‘ä»¬æœŸæœ›å®ƒèƒ½å¤Ÿå¾ˆå¥½åœ°ä¸ T=&u32 ä¸€èµ·ä½¿ç”¨ï¼Œå¯¹å§ï¼Ÿ

```rust
fn two_refs<'big: 'small, 'small>(
    big: &'big u32, 
    small: &'small u32,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
```

æ˜¯çš„ï¼Œç¼–è¯‘å¾—å¾ˆå¥½ï¼

ç°åœ¨è®©æˆ‘ä»¬æ‰¾ç‚¹ä¹å­ï¼ŒæŠŠå®ƒåŒ…èµ·æ¥ï¼š`std::cell::Cell`

```rust
use std::cell::Cell;

fn two_refs<'big: 'small, 'small>(
    // NOTE: these two lines changed
    big: Cell<&'big u32>, 
    small: Cell<&'small u32>,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
error[E0623]: lifetime mismatch
 --> src/main.rs:7:19
  |
4 |     big: Cell<&'big u32>, 
  |               ---------
5 |     small: Cell<&'small u32>,
  |                 ----------- these two types are declared with different lifetimes...
6 | ) {
7 |     take_two(big, small);
  |                   ^^^^^ ...but data from `small` flows into `big` here
```

å“¼ï¼Ÿï¼Ÿï¼Ÿæˆ‘ä»¬æ²¡æœ‰ç¢°è¿‡ç”Ÿå‘½å‘¨æœŸï¼Œä¸ºä»€ä¹ˆç¼–è¯‘å™¨ç°åœ¨ç”Ÿæ°”äº†ï¼ï¼Ÿ

å•Šï¼Œå¥½å§ï¼Œç”Ÿå‘½å‘¨æœŸçš„â€œå­ç±»å‹â€å¿…é¡»éå¸¸ç®€å•ï¼Œæ‰€ä»¥å¦‚æœä½ å°†å¼•ç”¨åŒ…è£…åœ¨ä»»ä½•ä¸œè¥¿ä¸­ï¼Œå®ƒå°±ä¼šè¢«ç ´åï¼Œçœ‹çœ‹ Vecï¼š

```rust
fn two_refs<'big: 'small, 'small>(
    big: Vec<&'big u32>, 
    small: Vec<&'small u32>,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
    Finished dev [unoptimized + debuginfo] target(s) in 1.07s
     Running `target/debug/playground`
```

çœ‹åˆ°å®ƒæ²¡æœ‰ç¼–è¯‘æˆåŠŸ â€”â€”ç­‰ç­‰???Vecæ˜¯é­”æœ¯??????

æ˜¯çš„ã€‚è¿™ç§é­”åŠ›å°±æ˜¯âœ¨*Variance*âœ¨ã€‚

å¦‚æœæ‚¨æƒ³è¦æ‰€æœ‰ç»†èŠ‚ï¼Œè¯·é˜…è¯» [nomicon å…³äºå­ç±»å‹çš„ç« èŠ‚](https://doc.rust-lang.org/nightly/nomicon/subtyping.html)ï¼Œä½†åŸºæœ¬ä¸Šå­ç±»å‹*å¹¶ä¸æ€»æ˜¯*å®‰å…¨çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œå½“æ¶‰åŠå¯å˜å¼•ç”¨æ—¶ï¼Œå®ƒå°±æ›´ä¸å®‰å…¨äº†ï¼Œã€‚å› ä¸ºä½ å¯èƒ½ä¼šä½¿ç”¨è¯¸å¦‚`mem::swap`çš„ä¸œè¥¿ï¼Œçªç„¶å“å‘€ï¼Œæ‚¬ç©ºæŒ‡é’ˆï¼

å¯å˜å¼•ç”¨æ˜¯ *invariant(ä¸å˜çš„)*ï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¼šé˜»æ­¢å¯¹æ³›å‹å‚æ•°å­ç±»å‹åŒ–ã€‚å› æ­¤ï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œ `&mut T` åœ¨ T ä¸Šæ˜¯ä¸å˜çš„ï¼Œå¹¶ä¸” `Cell<T>` åœ¨ T ä¸Šä¹Ÿæ˜¯ä¸å˜çš„ï¼ˆå› ä¸ºå†…éƒ¨å¯å˜æ€§ï¼‰ï¼Œå› ä¸º `&Cell<T>` æœ¬è´¨ä¸Šå°±åƒ `&mut T`ã€‚

å‡ ä¹æ‰€æœ‰ä¸æ˜¯ *invariant* çš„ä¸œè¥¿éƒ½æ˜¯ *covariant(åå˜çš„)* ï¼Œè¿™æ„å‘³ç€å­ç±»å‹å¯ä»¥æ­£å¸¸å·¥ä½œï¼ˆä¹Ÿæœ‰ *contravariant(é€†å˜çš„)* çš„ç±»å‹ä½¿å­ç±»å‹å€’é€€ï¼Œä½†å®ƒä»¬çœŸçš„å¾ˆå°‘è§ï¼Œæ²¡æœ‰äººå–œæ¬¢å®ƒä»¬ï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šå†æåˆ°å®ƒä»¬ï¼‰ã€‚

é›†åˆé€šå¸¸åŒ…å«æŒ‡å‘å…¶æ•°æ®çš„å¯å˜æŒ‡é’ˆï¼Œå› æ­¤ä½ å¯èƒ½å¸Œæœ›å®ƒä»¬ä¹Ÿæ˜¯ä¸å˜çš„ï¼Œä½†äº‹å®ä¸Šï¼Œå®ƒä»¬å¹¶ä¸éœ€è¦ä¸å˜ï¼ç”±äº Rust çš„æ‰€æœ‰æƒç³»ç»Ÿï¼Œ`Vec<T>` åœ¨è¯­ä¹‰ä¸Šç­‰åŒäº `T`ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥å®‰å…¨åœ°ä¿æŒ*covariant(åå˜çš„)* ï¼

ä¸å¹¸çš„çš„æ˜¯ï¼Œä¸‹é¢çš„å®šä¹‰æ˜¯ *invariant(ä¸å˜çš„)*:

```rust
pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
}

type Link<T> = *mut Node<T>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}
```

æ‰€ä»¥æˆ‘ä»¬çš„ç±»å‹å®šä¹‰ä¸­å“ªé‡Œæƒ¹ Rust ç¼–è¯‘å™¨ä¸é«˜å…´äº†? `*mut`ï¼

Rust ä¸­çš„è£¸æŒ‡é’ˆå…¶å®å°±æ˜¯è®©ä½ å¯ä»¥åšä»»ä½•äº‹æƒ…ï¼Œä½†å®ƒä»¬åªæœ‰ä¸€ä¸ªå®‰å…¨ç‰¹æ€§ï¼šå› ä¸ºå¤§å¤šæ•°äººéƒ½ä¸çŸ¥é“ Rust ä¸­è¿˜æœ‰ *Variance(å‹å˜)* å’Œå­ç±»å‹ï¼Œè€Œé”™è¯¯åœ°ä½¿ç”¨ *covariant(åå˜çš„)* ä¼šéå¸¸å±é™©ï¼Œæ‰€ä»¥ `*mut T` æ˜¯*invariant(ä¸å˜çš„)*ï¼Œå› ä¸ºå®ƒå¾ˆæœ‰å¯èƒ½è¢« "ä½œä¸º" `&mut T` ä½¿ç”¨ã€‚

ä½œä¸ºä¸€ä¸ªèŠ±äº†å¤§é‡æ—¶é—´åœ¨ Rust ä¸­ç¼–å†™é›†åˆçš„äººï¼Œè¿™è®©æˆ‘æ„Ÿåˆ°åŒçƒ¦ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘åœ¨åˆ¶ä½œ [std::ptr::NonNull](https://doc.rust-lang.org/std/ptr/struct.NonNull.html), æ—¶æ·»åŠ äº†è¿™ä¸ªå°é­”æ³•ï¼š

> ä¸ *mut T ä¸åŒï¼Œ`NonNull<T>` åœ¨ T ä¸Šæ˜¯ *covariant(åå˜çš„)*ã€‚è¿™ä½¿å¾—ä½¿ç”¨ `NonNull<T>` æ„å»º*covariant(åå˜çš„)*ç±»å‹æˆä¸ºå¯èƒ½ï¼Œä½†å¦‚æœåœ¨ä¸åº”è¯¥æ˜¯ *covariant(åå˜çš„)* çš„åœ°æ–¹ä¸­ä½¿ç”¨ï¼Œåˆ™ä¼šå¸¦æ¥ä¸å¥å…¨çš„é£é™©ã€‚

è¿™æ˜¯ä¸€ä¸ªå›´ç»•ç€ `*mut T` æ„å»ºçš„ç±»å‹ã€‚çœŸçš„æ˜¯é­”æ³•å—ï¼Ÿè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ï¼š

```rust
pub struct NonNull<T> {
    pointer: *const T,
}


impl<T> NonNull<T> {
    pub unsafe fn new_unchecked(ptr: *mut T) -> Self {
        // SAFETY: the caller must guarantee that `ptr` is non-null.
        unsafe { NonNull { pointer: ptr as *const T } }
    }
}
```

ä¸ï¼Œè¿™é‡Œæ²¡æœ‰é­”æ³•ï¼NonNull åªæ˜¯æ»¥ç”¨äº† *const T æ˜¯ *covariant(åå˜çš„)* è¿™ä¸€äº‹å®ï¼Œå¹¶å°†å…¶å­˜å‚¨èµ·æ¥ã€‚è¿™å°±æ˜¯ Rust ä¸­é›†åˆçš„åå˜æ–¹å¼ï¼è¿™å¯çœŸæ˜¯æƒ¨ä¸å¿ç¹ï¼æ‰€ä»¥æˆ‘ä¸ºä½ åšäº†è¿™ä¸ª Good Pointer Type ï¼ä¸å®¢æ°”å¥½å¥½äº«å—å­ç±»å‹å§

è§£å†³ä½ æ‰€æœ‰é—®é¢˜çš„åŠæ³•å°±æ˜¯ä½¿ç”¨ NonNullï¼Œç„¶åå¦‚æœä½ æƒ³å†æ¬¡ä½¿ç”¨å¯ç©ºæŒ‡é’ˆï¼Œå°±ä½¿ç”¨ `Option<NonNull<T>>`ã€‚æˆ‘ä»¬çœŸçš„è¦è¿™ä¹ˆåšå—ï¼Ÿ

æ˜¯çš„ï¼è¿™å¾ˆç³Ÿç³•ï¼Œä½†æˆ‘ä»¬è¦åšçš„æ˜¯ç”Ÿäº§çº§çš„é“¾è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦åƒå°½åƒè¾›ä¸‡è‹¦ï¼ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨è£¸*const Tï¼Œç„¶ååœ¨ä»»ä½•åœ°æ–¹éƒ½è¿›è¡Œè½¬æ¢ï¼Œä½†æˆ‘çœŸçš„æƒ³çœ‹çœ‹è¿™æ ·åšæœ‰å¤šç—›è‹¦......ä¸ºäº†äººä½“å·¥ç¨‹å­¦ç§‘å­¦ï¼‰ã€‚

ä¸‹é¢å°±æ˜¯æˆ‘ä»¬æœ€ç»ˆçš„ç±»å‹å®šä¹‰ï¼š

```rust
use std::ptr::NonNull;

// !!!This changed!!!
pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}
```

...ç­‰ç­‰ï¼Œä¸ï¼Œæœ€åä¸€ä»¶äº‹ã€‚æ¯å½“ä½ ä½¿ç”¨è£¸æŒ‡é’ˆæ—¶ï¼Œä½ éƒ½åº”è¯¥æ·»åŠ ä¸€ä¸ª Ghost æ¥ä¿æŠ¤ä½ çš„æŒ‡é’ˆï¼š

```rust
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    /// We semantically store values of T by-value.
    _boo: PhantomData<T>,
}
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘è®¤ä¸ºæˆ‘ä»¬*å®é™…ä¸Š*ä¸éœ€è¦ [PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)ï¼Œä½†æ¯å½“ä½ ä½¿ç”¨ NonNullï¼ˆæˆ–ä¸€èˆ¬çš„è£¸æŒ‡é’ˆï¼‰æ—¶ï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œä½ éƒ½åº”è¯¥å§‹ç»ˆæ·»åŠ å®ƒï¼Œå¹¶å‘ç¼–è¯‘å™¨å’Œå…¶ä»–äººæ¸…æ¥šåœ°è¡¨æ˜ä½ çš„æƒ³æ³•ï¼Œä½ åœ¨åšä»€ä¹ˆã€‚

PhantomData æ˜¯æˆ‘ä»¬ç»™ç¼–è¯‘å™¨æä¾›ä¸€ä¸ªé¢å¤–çš„ "ç¤ºä¾‹ "å­—æ®µçš„æ–¹æ³•ï¼Œè¿™ä¸ªå­—æ®µåœ¨æ¦‚å¿µä¸Šå­˜åœ¨äºä½ çš„ç±»å‹ä¸­ï¼Œä½†ç”±äºå„ç§åŸå› ï¼ˆé—´æ¥ã€ç±»å‹æ“¦é™¤......ï¼‰å¹¶ä¸å­˜åœ¨ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ NonNull æ˜¯å› ä¸ºæˆ‘ä»¬å£°ç§°æˆ‘ä»¬çš„ç±»å‹ "å¥½åƒ "å­˜å‚¨äº†ä¸€ä¸ªå€¼ Tï¼Œæ‰€ä»¥æˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ª PhantomData æ¥æ˜ç¡®è¿™ä¸€ç‚¹ã€‚

...å¥½å§ï¼Œæˆ‘ä»¬ç°åœ¨å·²ç»å®Œæˆäº†å¸ƒå±€ï¼è¿›å…¥å®é™…çš„åŸºæœ¬åŠŸèƒ½ï¼



================================================
FILE: src/too-many-lists/unsafe-queue/basics.md
================================================
# åŸºæœ¬æ“ä½œ

> æœ¬ç« èŠ‚çš„ä»£ç ä¸­æœ‰ä¸€ä¸ªéšè—çš„ bugï¼Œå› ä¸ºå®ƒè—èº«äº unsafe ä¸­ï¼Œå› æ­¤ä¸ä¼šå¯¼è‡´æŠ¥é”™ï¼Œæˆ‘ä»¬ä¼šåœ¨åç»­ç« èŠ‚è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥ï¼Œè¯·ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨æ­¤å¤„çš„ä»£ç 

åœ¨å¼€å§‹ä¹‹å‰ï¼Œå¤§å®¶éœ€è¦å…ˆäº†è§£ unsafe çš„[ç›¸å…³çŸ¥è¯†](https://course.rs/advance/unsafe/intro.html)ã€‚é‚£ä¹ˆï¼Œè¨€å½’æ­£ä¼ ï¼Œè¯¥å¦‚ä½•æ„å»ºä¸€ä¸ªé“¾è¡¨ï¼Ÿåœ¨ä¹‹å‰æˆ‘ä»¬æ˜¯è¿™ä¹ˆåšçš„ï¼š
```rust
impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }
}
```

ä½†æ˜¯æˆ‘ä»¬ä¸å†åœ¨ `tail` ä¸­ä½¿ç”¨ `Option`:
```shell
$ cargo build

error[E0308]: mismatched types
  --> src/fifth.rs:15:34
   |
15 |         List { head: None, tail: None }
   |                                  ^^^^ expected *-ptr, found 
   |                                       enum `std::option::Option`
   |
   = note: expected type `*mut fifth::Node<T>`
              found type `std::option::Option<_>`
```

æˆ‘ä»¬æ˜¯å¯ä»¥ä½¿ç”¨ `Option` åŒ…è£¹ä¸€å±‚ï¼Œä½†æ˜¯ `*mut` è£¸æŒ‡é’ˆä¹‹æ‰€ä»¥è£¸ï¼Œæ˜¯å› ä¸ºå®ƒç‹‚ï¼Œå®ƒå¯ä»¥æ˜¯ `null` ! å› æ­¤ `Option` å°±å˜å¾—æ²¡æœ‰æ„ä¹‰:
```rust
use std::ptr;

// defns...

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œé€šè¿‡ `std::ptr::null_mut` å‡½æ•°å¯ä»¥è·å–ä¸€ä¸ª `null`ï¼Œå½“ç„¶ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `0 as *mut _`ï¼Œä½†æ˜¯...å·²ç»è¿™ä¹ˆä¸å®‰å…¨äº†ï¼Œå¥½æ­¹æˆ‘ä»¬è¦ç•™ä¸€ç‚¹ä»£ç å¯è¯»æ€§ä¸Šçš„å°Šä¸¥å§ = , =

å¥½äº†ï¼Œç°åœ¨æ˜¯æ—¶å€™å»é‡æ–°å®ç° `push` ï¼Œä¹‹å‰è·å–çš„æ˜¯ `Option<&mut Node<T>>` æˆä¸ºæˆ‘ä»¬çš„æ‹¦è·¯è™ï¼Œè¿™æ¬¡æ¥çœ‹çœ‹å¦‚æœæ˜¯è·å– `*mut Node<T>` è¿˜ä¼šä¸ä¼šæœ‰ç±»ä¼¼çš„é—®é¢˜ã€‚

é¦–å…ˆï¼Œè¯¥å¦‚ä½•å°†ä¸€ä¸ªæ™®é€šçš„å¼•ç”¨å˜æˆè£¸æŒ‡é’ˆï¼Ÿç­”æ¡ˆæ˜¯ï¼šå¼ºåˆ¶è½¬æ¢ Coercionsã€‚

```rust
let raw_tail: *mut _ = &mut *new_tail;
```

æ¥çœ‹çœ‹ `push` çš„å®ç°:
```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &mut *new_tail;

    // .is_null ä¼šæ£€æŸ¥æ˜¯å¦ä¸º null, åœ¨åŠŸèƒ½ä¸Šç­‰ä»·äº `None` çš„æ£€æŸ¥
    if !self.tail.is_null() {
        // å¦‚æœ old tail å­˜åœ¨ï¼Œé‚£å°†å…¶æŒ‡å‘æ–°çš„ tail
        self.tail.next = Some(new_tail);
    } else {
        // å¦åˆ™è®© head æŒ‡å‘æ–°çš„ tail
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
```

```shell
$ cargo build

error[E0609]: no field `next` on type `*mut fifth::Node<T>`
  --> src/fifth.rs:31:23
   |
31 |             self.tail.next = Some(new_tail);
   |             ----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
```

å½“ä½¿ç”¨è£¸æŒ‡é’ˆæ—¶ï¼Œä¸€äº› Rust æä¾›çš„ä¾¿åˆ©æ¡ä»¶ä¹Ÿå°†ä¸å¤å­˜åœ¨ï¼Œä¾‹å¦‚ç”±äºä¸å®‰å…¨æ€§çš„å­˜åœ¨ï¼Œè£¸æŒ‡é’ˆéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å»è§£å¼•ç”¨( deref ):
```rust
*self.tail.next = Some(new_tail);
```

```shell
$ cargo build

error[E0609]: no field `next` on type `*mut fifth::Node<T>`
  --> src/fifth.rs:31:23
   |
31 |             *self.tail.next = Some(new_tail);
   |             -----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
```

å“¦å“¦ï¼Œè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§é—®é¢˜:
```rust
(*self.tail).next = Some(new_tail);
```

```shell
$ cargo build

error[E0133]: dereference of raw pointer is unsafe and requires 
              unsafe function or block

  --> src/fifth.rs:31:13
   |
31 |             (*self.tail).next = Some(new_tail);
   |             ^^^^^^^^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be NULL, dangling or unaligned; 
     they can violate aliasing rules and cause data races: 
     all of these are undefined behavior
```

å“...å¤ªéš¾äº†ï¼Œé”™è¯¯ä¸€ä¸ªè¿ä¸€ä¸ªï¼Œå¥½åœ¨ç¼–è¯‘å™¨ç»™å‡ºäº†æç¤ºï¼šç”±äºæˆ‘ä»¬åœ¨è¿›è¡Œä¸å®‰å…¨çš„æ“ä½œï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ `unsafe` è¯­å¥å—ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæ˜¯å°†æŸå‡ è¡Œä»£ç åŒ…åœ¨ `unsafe` ä¸­è¿˜æ˜¯å°†æ•´ä¸ªå‡½æ•°åŒ…åœ¨ `unsafe` ä¸­å‘¢ï¼Ÿå¦‚æœå¤§å®¶ä¸çŸ¥é“å“ªä¸ªæ˜¯æ­£ç¡®ç­”æ¡ˆçš„è¯ï¼Œè¯æ˜[ä¹‹å‰çš„ç« èŠ‚](https://course.rs/advance/unsafe/intro.html#æ§åˆ¶-unsafe-çš„ä½¿ç”¨è¾¹ç•Œ)è¿˜æ˜¯æ²¡æœ‰ä»”ç»†å­¦ï¼Œè¯·å›å»å†çœ‹ä¸€ä¸‹ï¼Œå·©å›ºå·©å›º:) 

```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &mut *new_tail;

    if !self.tail.is_null() {
        // ä½ å¥½ç¼–è¯‘å™¨ï¼Œæˆ‘çŸ¥é“æˆ‘åœ¨åšå±é™©çš„äº‹æƒ…ï¼Œæˆ‘å‘ä½ ä¿è¯ï¼šå°±ç®—çŠ¯é”™äº†ï¼Œä¹Ÿå’Œä½ æ²¡æœ‰å…³ç³»ï¼Œéƒ½æ˜¯æˆ‘è¿™ä¸ªä¸ä¼˜ç§€çš„ç¨‹åºå‘˜çš„è´£ä»»
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
```

```shell
$ cargo build
warning: field is never used: `elem`
  --> src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
```

ç»†å¿ƒçš„åŒå­¦å¯èƒ½ä¼šå‘ç°:ä¸æ˜¯æ‰€æœ‰çš„è£¸æŒ‡é’ˆä»£ç éƒ½æœ‰ unsafe çš„èº«å½±ã€‚åŸå› åœ¨äºï¼š**åˆ›å»ºåŸç”ŸæŒ‡é’ˆæ˜¯å®‰å…¨çš„è¡Œä¸ºï¼Œè€Œè§£å¼•ç”¨åŸç”ŸæŒ‡é’ˆæ‰æ˜¯ä¸å®‰å…¨çš„è¡Œä¸º**

å‘¼ï¼Œé•¿å‡ºäº†ä¸€å£æ°”ï¼Œç»ˆäºæˆåŠŸå®ç°äº† `push` ï¼Œä¸‹é¢æ¥çœ‹çœ‹ `pop`:
```rust
pub fn pop(&mut self) -> Option<T> {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
```

æµ‹è¯•ä¸‹:
```rust
#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
```

æ‘Šç‰Œäº†ï¼Œæˆ‘ä»¬å·æ‡’äº†ï¼Œè¿™äº›æµ‹è¯•å°±æ˜¯ä»ä¹‹å‰çš„æ ˆé“¾è¡¨èµ‹å€¼è¿‡æ¥çš„ï¼Œä½†æ˜¯ä¾ç„¶åšäº†äº›æ”¹å˜ï¼Œä¾‹å¦‚åœ¨æœ«å°¾å¢åŠ äº†å‡ ä¸ªæ­¥éª¤ä»¥ç¡®ä¿åœ¨ `pop` ä¸­ä¸ä¼šå‘ç”Ÿå°¾æŒ‡é’ˆæŸå( tail-pointer corruption  )çš„æƒ…å†µã€‚

```shell
$ cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```




================================================
FILE: src/too-many-lists/unsafe-queue/extra-junk.md
================================================
# é¢å¤–çš„æ“ä½œ
åœ¨æå®š `push`ã€`pop` åï¼Œå‰©ä¸‹çš„åŸºæœ¬è·Ÿæ ˆé“¾è¡¨çš„å®ç°æ²¡æœ‰å•¥åŒºåˆ«ã€‚åªæœ‰ä¼šæ”¹å˜é“¾è¡¨é•¿åº¦çš„æ“ä½œæ‰ä¼šä½¿ç”¨<ruby>å°¾<rt>tail</rt></ruby>æŒ‡é’ˆã€‚

å½“ç„¶ï¼Œç°åœ¨ä¸€åˆ‡éƒ½æ˜¯è£¸æŒ‡é’ˆï¼Œå› æ­¤æˆ‘ä»¬è¦é‡å†™ä»£ç æ¥ä½¿ç”¨å®ƒä»¬ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­å¿…é¡»è¦ç¡®ä¿æ²¡æœ‰é—æ¼åœ°ä¿®æ”¹æ‰€æœ‰åœ°æ–¹ã€‚

é¦–å…ˆï¼Œå…ˆä»æ ˆé“¾è¡¨å®ç°ä¸­æ‹·è´ä»¥ä¸‹ä»£ç :
```rust
// ...

pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}
```

è¿™é‡Œçš„ `Iter` å’Œ `IterMut` å¹¶æ²¡æœ‰å®ç°è£¸æŒ‡é’ˆï¼Œå…ˆæ¥ä¿®æ”¹ä¸‹ï¼š
```rust
pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: *mut Node<T>,
}

pub struct IterMut<'a, T> {
    next: *mut Node<T>,
}

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut { next: self.head }
    }
}
```

çœ‹èµ·æ¥ä¸é”™!
```text
error[E0392]: parameter `'a` is never used
  --> src\fifth.rs:17:17
   |
17 | pub struct Iter<'a, T> {
   |                 ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`

error[E0392]: parameter `'a` is never used
  --> src\fifth.rs:21:20
   |
21 | pub struct IterMut<'a, T> {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`
```

å’¦ï¼Ÿè¿™é‡Œçš„ [PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html) æ˜¯ä»€ä¹ˆ?

> PhantomData æ˜¯<ruby>é›¶å¤§å°<rt>zero sized</rt></ruby>çš„ç±»å‹
>
> åœ¨ä½ çš„ç±»å‹ä¸­æ·»åŠ ä¸€ä¸ª `PhantomData<T>` å­—æ®µï¼Œå¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ä½ çš„ç±»å‹å¯¹ `T` è¿›è¡Œäº†ä½¿ç”¨ï¼Œè™½ç„¶å¹¶æ²¡æœ‰ã€‚è¯´ç™½äº†ï¼Œå°±æ˜¯è®©ç¼–è¯‘å™¨ä¸å†ç»™å‡º `T` æœªè¢«ä½¿ç”¨çš„è­¦å‘Šæˆ–è€…é”™è¯¯ã€‚
>
> å¦‚æœæƒ³è¦æ›´æ·±å…¥çš„äº†è§£ï¼Œå¯ä»¥çœ‹ä¸‹ [Nomicon](https://doc.rust-lang.org/nightly/nomicon/)

å¤§æ¦‚æœ€é€‚ç”¨äº PhantomData çš„åœºæ™¯å°±æ˜¯ä¸€ä¸ªç»“æ„ä½“æ‹¥æœ‰æœªä½¿ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œå…¸å‹çš„å°±æ˜¯åœ¨ unsafe ä¸­ä½¿ç”¨ã€‚

æ€»ä¹‹ï¼Œä¹‹å‰çš„é”™è¯¯æ˜¯å¯ä»¥é€šè¿‡ PhantomData æ¥è§£å†³çš„ï¼Œä½†æ˜¯æˆ‘æƒ³å°†è¿™ä¸ªç§˜å¯†æ­¦å™¨ç•™åˆ°ä¸‹ä¸€ç« ä¸­çš„åŒå‘é“¾è¡¨ï¼Œå®ƒæ‰æ˜¯çœŸæ­£çš„éœ€è¦ã€‚

é‚£ç°åœ¨åªèƒ½ç ´åæˆ‘ä»¬ä¹‹å‰çš„è±ªè¨€å£®è¯­äº†ï¼Œç°æºœæºœçš„ç»§ç»­ä½¿ç”¨å¼•ç”¨è²Œä¼¼ä¹Ÿæ˜¯ä¸é”™çš„é€‰æ‹©ã€‚èƒ½ä½¿ç”¨å¼•ç”¨çš„åŸå› æ˜¯ï¼šæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œåœ¨å…¶ä¸­ä½¿ç”¨å®‰å…¨å¼•ç”¨ï¼Œç„¶åå†ä¸¢å¼ƒè¿­ä»£å™¨ã€‚ä¸€æ—¦è¿­ä»£å™¨è¢«ä¸¢å¼ƒåï¼Œå°±å¯ä»¥ç»§ç»­ä½¿ç”¨ `push` å’Œ `pop` äº†ã€‚

äº‹å®ä¸Šï¼Œåœ¨è¿­ä»£æœŸé—´ï¼Œæˆ‘ä»¬è¿˜æ˜¯éœ€è¦è§£å¼•ç”¨å¤§é‡çš„è£¸æŒ‡é’ˆï¼Œä½†æ˜¯å¯ä»¥æŠŠå¼•ç”¨çœ‹ä½œè£¸æŒ‡é’ˆçš„å†å€Ÿç”¨ã€‚

å·å·çš„è¯´ä¸€å¥ï¼šå¯¹äºè¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä¸æ•¢ä¿è¯ä¸€å®šèƒ½æˆåŠŸï¼Œå…ˆæ¥è¯•è¯•å§..
```rust
pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}
```

ä¸ºäº†å­˜å‚¨å¼•ç”¨ï¼Œè¿™é‡Œä½¿ç”¨ `Option` æ¥åŒ…è£¹ï¼Œå¹¶é€šè¿‡ [`ptr::as_ref`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref-1) å’Œ [`ptr::as_mut`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_mut) æ¥å°†è£¸æŒ‡é’ˆè½¬æ¢æˆå¼•ç”¨ã€‚

é€šå¸¸ï¼Œæˆ‘ä¼šå°½é‡é¿å…ä½¿ç”¨ `as_ref` è¿™ç±»æ–¹æ³•ï¼Œå› ä¸ºå®ƒä»¬åœ¨åšä¸€äº›ä¸å¯æ€è®®çš„è½¬æ¢ï¼ä½†æ˜¯ä¸Šé¢å´æ˜¯æå°‘æ•°å¯ä»¥ä½¿ç”¨çš„åœºæ™¯ä¹‹ä¸€ã€‚

è¿™ä¸¤ä¸ªæ–¹æ³•çš„ä½¿ç”¨å¾€å¾€ä¼šä¼´éšå¾ˆå¤šè­¦å‘Šï¼Œå…¶ä¸­æœ€æœ‰è¶£çš„æ˜¯ï¼š

> ä½ å¿…é¡»è¦éµå¾ªæ··å (Aliasing)çš„è§„åˆ™ï¼ŒåŸå› æ˜¯è¿”å›çš„ç”Ÿå‘½å‘¨æœŸ `'a` åªæ˜¯ä»»æ„é€‰æ‹©çš„ï¼Œå¹¶ä¸èƒ½ä»£è¡¨æ•°æ®çœŸå®çš„ç”Ÿå‘½å‘¨æœŸã€‚ç‰¹åˆ«çš„ï¼Œåœ¨è¿™æ®µç”Ÿå‘½å‘¨æœŸçš„è¿‡ç¨‹ä¸­ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜åŒºåŸŸç»ä¸èƒ½è¢«å…¶å®ƒæŒ‡é’ˆæ‰€è®¿é—®ã€‚

å¥½æ¶ˆæ¯æ˜¯ï¼Œæˆ‘ä»¬è²Œä¼¼ä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºæ··å æ˜¯æˆ‘ä»¬ä¸€ç›´åœ¨è®¨è®ºå’Œé¿å…çš„é—®é¢˜ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªæ¶é­”ï¼š
```rust
pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T>
```

å¤§å®¶æ³¨æ„åˆ°è¿™ä¸ªå‡­ç©ºå‡ºç°çš„ `'a` å—ï¼Ÿè¿™é‡Œ `self` æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼ŒæŒ‰ç…§ç”Ÿå‘½å‘¨æœŸçš„è§„åˆ™ï¼Œ`'a` æ— æ ¹ä¹‹æœ¨ï¼Œå®ƒå°±æ˜¯[æ— ç•Œç”Ÿå‘½å‘¨æœŸ](https://course.rs/advance/lifetime/advance.html#æ— ç•Œç”Ÿå‘½å‘¨æœŸ)ã€‚

å…„å¼Ÿä»¬ï¼Œæˆ‘å¾ˆç´§å¼ ï¼Œä½†æ˜¯è¯¥ç»§ç»­çš„è¿˜æ˜¯å¾—ç»§ç»­ï¼Œè®©æˆ‘ä»¬ä»æ ˆé“¾è¡¨ä¸­å†å¤åˆ¶ä¸€äº›ä»£ç è¿‡æ¥ï¼š
```rust
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &node.elem
            })
        }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &mut node.elem
            })
        }
    }
}
```

éªŒè¯ä¸‹æµ‹è¯•ç”¨ä¾‹ï¼š
```rust
cargo test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test third::test::basics ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

è¿˜æœ‰ miri:
```text
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

å—¯ï¼Œè¿˜æœ‰ `peek` å’Œ `peek_mut` çš„å®ç°ï¼š
```rust
pub fn peek(&self) -> Option<&T> {
    unsafe {
        self.head.as_ref()
    }
}

pub fn peek_mut(&mut self) -> Option<&mut T> {
    unsafe {
        self.head.as_mut()
    }
}
```

å®ç°è¿™ä¹ˆç®€å•ï¼Œè¿è¡Œèµ·æ¥è‚¯å®šæ²¡é—®é¢˜ï¼š
```text
$ cargo build
error[E0308]: mismatched types
  --> src\fifth.rs:66:13
   |
25 | impl<T> List<T> {
   |      - this type parameter
...
64 |     pub fn peek(&self) -> Option<&T> {
   |                           ---------- expected `Option<&T>` 
   |                                      because of return type
65 |         unsafe {
66 |             self.head.as_ref()
   |             ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, 
   |                                found struct `fifth::Node`
   |
   = note: expected enum `Option<&T>`
              found enum `Option<&fifth::Node<T>>`
```

å“¦ï¼Œè¿™ä¸ªç®€å•ï¼Œmap ä»¥ä¸‹å°±å¯ä»¥äº†:
```rust
pub fn peek(&self) -> Option<&T> {
    unsafe {
        self.head.as_ref().map(|node| &node.elem)
    }
}

pub fn peek_mut(&mut self) -> Option<&mut T> {
    unsafe {
        self.head.as_mut().map(|node| &mut node.elem)
    }
}
```

æˆ‘æ„Ÿè§‰æœ‰å¾ˆå¤šé”™è¯¯æ­£åœ¨èµ¶æ¥çš„è·¯ä¸Šï¼Œå› æ­¤å¤§å®¶éœ€è¦æé«˜è­¦æƒ•ï¼Œè¦ä¹ˆå…ˆå†™ä¸€ä¸ªæµ‹è¯•å§ï¼šæŠŠæˆ‘ä»¬çš„ API éƒ½æ··åˆåœ¨ä¸€èµ·ï¼Œè®© miri æ¥äº«ç”¨ - miri food!
```rust
#[test]
fn miri_food() {
    let mut list = List::new();

    list.push(1);
    list.push(2);
    list.push(3);

    assert!(list.pop() == Some(1));
    list.push(4);
    assert!(list.pop() == Some(2));
    list.push(5);

    assert!(list.peek() == Some(&3));
    list.push(6);
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&30));
    assert!(list.pop() == Some(30));

    for elem in list.iter_mut() {
        *elem *= 100;
    }

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&400));
    assert_eq!(iter.next(), Some(&500));
    assert_eq!(iter.next(), Some(&600));
    assert_eq!(iter.next(), None);
    assert_eq!(iter.next(), None);

    assert!(list.pop() == Some(400));
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&5000));
    list.push(7);

    // Drop it on the ground and let the dtor exercise itself
}
```

```text
cargo test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out



MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

å®Œç¾ã€‚


================================================
FILE: src/too-many-lists/unsafe-queue/final-code.md
================================================
# æœ€ç»ˆä»£ç 
å¾—ç›Šäºä¸å®‰å…¨ä»£ç çš„å¼•å…¥ï¼Œæ–°çš„å®ç°å¯ä»¥è·å¾—çº¿æ€§çš„æ€§èƒ½æå‡ï¼ŒåŒæ—¶æˆ‘ä»¬è¿˜è®¾æ³•å¤ç”¨äº†æ ˆé“¾è¡¨çš„å¾ˆå¤šä»£ç ã€‚

å½“ç„¶ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è¿˜å¼•å…¥äº†æ–°çš„æ¦‚å¿µï¼Œä¾‹å¦‚å€Ÿç”¨æ ˆï¼Œç›¸ä¿¡ç›´åˆ°ç°åœ¨æœ‰äº›åŒå­¦è¿˜æ™•ä¹ä¹çš„ã€‚ä¸ç®¡å¦‚ä½•ï¼Œæˆ‘ä»¬ä¸ç”¨å†å»å†™ä¸€å¤§å †åµŒå¥—æ¥åµŒå¥—å»çš„ `Rc` å’Œ `RefCell`ã€‚

ä¸‹é¢æ¥çœ‹çœ‹å’±ä»¬è¿™ä¸ªä¸å®‰å…¨é“¾è¡¨çš„å…¨è²Œå§ã€‚

```rust
use std::ptr;

pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>,
}

type Link<T> = *mut Node<T>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
    pub fn push(&mut self, elem: T) {
        unsafe {
            let new_tail = Box::into_raw(Box::new(Node {
                elem: elem,
                next: ptr::null_mut(),
            }));

            if !self.tail.is_null() {
                (*self.tail).next = new_tail;
            } else {
                self.head = new_tail;
            }

            self.tail = new_tail;
        }
    }
    pub fn pop(&mut self) -> Option<T> {
        unsafe {
            if self.head.is_null() {
                None
            } else {
                let head = Box::from_raw(self.head);
                self.head = head.next;

                if self.head.is_null() {
                    self.tail = ptr::null_mut();
                }

                Some(head.elem)
            }
        }
    }

    pub fn peek(&self) -> Option<&T> {
        unsafe {
            self.head.as_ref().map(|node| &node.elem)
        }
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.head.as_mut().map(|node| &mut node.elem)
        }
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() { }
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &node.elem
            })
        }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &mut node.elem
            })
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&1));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&mut 1));
        assert_eq!(iter.next(), Some(&mut 2));
        assert_eq!(iter.next(), Some(&mut 3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn miri_food() {
        let mut list = List::new();

        list.push(1);
        list.push(2);
        list.push(3);

        assert!(list.pop() == Some(1));
        list.push(4);
        assert!(list.pop() == Some(2));
        list.push(5);

        assert!(list.peek() == Some(&3));
        list.push(6);
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&30));
        assert!(list.pop() == Some(30));

        for elem in list.iter_mut() {
            *elem *= 100;
        }

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&400));
        assert_eq!(iter.next(), Some(&500));
        assert_eq!(iter.next(), Some(&600));
        assert_eq!(iter.next(), None);
        assert_eq!(iter.next(), None);

        assert!(list.pop() == Some(400));
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&5000));
        list.push(7);

        // Drop it on the ground and let the dtor exercise itself
    }
}
```


================================================
FILE: src/too-many-lists/unsafe-queue/intro.md
================================================
# ä¸é”™çš„unsafeé˜Ÿåˆ—
åœ¨ä¹‹å‰ç« èŠ‚ä¸­ï¼ŒåŸºäºå†…éƒ¨å¯å˜æ€§å’Œå¼•ç”¨è®¡æ•°çš„åŒå‘é“¾è¡¨æœ‰äº›å¤±æ§äº†ï¼ŒåŸå› åœ¨äº `Rc` å’Œ `RefCell` å¯¹äºç®€å•çš„ä»»åŠ¡è€Œè¨€ï¼Œå®ƒä»¬æ˜¯éå¸¸ç§°èŒçš„ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„ä»»åŠ¡ï¼Œå®ƒä»¬å¯èƒ½ä¼šå˜å¾—ç›¸å½“ç¬¨æ‹™ï¼Œç‰¹åˆ«æ˜¯å½“æˆ‘ä»¬è¯•å›¾éšè—ä¸€äº›ç»†èŠ‚æ—¶ã€‚

æ€»ä¹‹ï¼Œä¸€å®šæœ‰æ›´å¥½çš„åŠæ³•ï¼ä¸‹é¢æ¥çœ‹çœ‹è¯¥å¦‚ä½•ä½¿ç”¨è£¸æŒ‡é’ˆå’Œ unsafe ä»£ç å®ç°ä¸€ä¸ªå•å‘é“¾è¡¨ã€‚

> å¤§å®¶å¯èƒ½æƒ³ç­‰ç€çœ‹æˆ‘çŠ¯é”™è¯¯ï¼Œunsafe å˜›ï¼Œä¸çŠ¯é”™è¯¯ä¸å¯èƒ½çš„ï¼Œä½†æ˜¯å‘¢ï¼Œä¿ºåå°±ä¸çŠ¯é”™è¯¯ï¼šï¼‰

å›½é™…æƒ¯ä¾‹ï¼Œæ·»åŠ ç¬¬äº”ä¸ªé“¾è¡¨æ‰€éœ€çš„æ–‡ä»¶ `fifth.rs`:
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
```

è™½ç„¶æˆ‘ä»¬ä¾ç„¶ä¼šä»é›¶å¼€å§‹æ’¸ä»£ç ï¼Œä½†æ˜¯ `fifth.rs` çš„ä»£ç ä¼šè·Ÿ `second.rs` å­˜åœ¨ä¸€å®šçš„é‡å ï¼Œå› ä¸ºå¯¹äºé“¾è¡¨è€Œè¨€ï¼Œé˜Ÿåˆ—å…¶å®å°±æ˜¯æ ˆçš„å¢å¼ºã€‚




================================================
FILE: src/too-many-lists/unsafe-queue/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/unsafe-queue/layout2.md
================================================
# æ•°æ®å¸ƒå±€2: å†è£¸ä¸€äº›å§

> TL;DR åœ¨ä¹‹å‰éƒ¨åˆ†ä¸­ï¼Œå°†å®‰å…¨çš„æŒ‡é’ˆ `&` ã€`&mut` å’Œ `Box` è·Ÿä¸å®‰å…¨çš„è£¸æŒ‡é’ˆ `*mut` å’Œ `*const` æ··ç”¨æ˜¯ UB çš„æ ¹æºä¹‹ä¸€ï¼ŒåŸå› æ˜¯å®‰å…¨æŒ‡é’ˆä¼šå¼•å…¥é¢å¤–çš„çº¦æŸï¼Œä½†æ˜¯è£¸æŒ‡é’ˆå¹¶ä¸ä¼šéµå®ˆè¿™äº›çº¦æŸã€‚

ä¸€ä¸ªå¥½æ¶ˆæ¯ï¼Œä¸€ä¸ªåæ¶ˆæ¯ã€‚åæ¶ˆæ¯æ˜¯æˆ‘ä»¬åˆè¦å¼€å§‹å†™é“¾è¡¨äº†ï¼Œæ‚²å‰§ = , = å¥½æ¶ˆæ¯å‘¢æ˜¯ä¹‹å‰æˆ‘ä»¬å·²ç»è®¨è®ºè¿‡è¯¥å¦‚ä½•è®¾è®¡äº†ï¼Œä¹‹å‰åšçš„å·¥ä½œåŸºæœ¬éƒ½æ˜¯æ­£ç¡®çš„ï¼Œé™¤äº†æ··ç”¨å®‰å…¨æŒ‡é’ˆå’Œä¸å®‰å…¨æŒ‡é’ˆçš„éƒ¨åˆ†ã€‚

## å¸ƒå±€
åœ¨æ–°çš„å¸ƒå±€ä¸­æˆ‘ä»¬å°†åªä½¿ç”¨è£¸æŒ‡é’ˆï¼Œç„¶åå¤§å®¶å°±ç­‰ç€å¥½æ¶ˆæ¯å§ï¼

ä¸‹é¢æ˜¯ä¹‹å‰çš„"ç ´ä»£ç " ï¼š
```rust
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>, // å¥½äººä¸€æš
}

type Link<T> = Option<Box<Node<T>>>; // æ¶é­”ä¸€åª

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

ç°åœ¨åˆ é™¤æ¶é­”:
```rust
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>,
}

type Link<T> = *mut Node<T>; // å˜€ï¼Œæ–°çš„å¥½äººå¡ï¼Œè¯·æŸ¥æ”¶

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

è¯·å¤§å®¶ç‰¢è®°ï¼šå½“ä½¿ç”¨è£¸æŒ‡é’ˆæ—¶ï¼Œ`Option` å¯¹æˆ‘ä»¬æ˜¯ç›¸å½“ä¸å‹å¥½çš„ï¼Œæ‰€ä»¥è¿™é‡Œä¸å†ä½¿ç”¨ã€‚åœ¨åé¢è¿˜å°†å¼•å…¥ `NonNull` ç±»å‹ï¼Œä½†æ˜¯ç°åœ¨è¿˜æ— éœ€æ“å¿ƒã€‚

## åŸºæœ¬æ“ä½œ
`List::new` ä¸ä¹‹å‰å‡ ä¹æ²¡æœ‰åŒºåˆ«ï¼š
```rust
use ptr;

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
}
```

`Push` ä¹Ÿå‡ ä¹æ²¡åŒº...
```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(
```

ç­‰ç­‰ï¼Œæˆ‘ä»¬ä¸å†ä½¿ç”¨ `Box` äº†ï¼Œæ—¢ç„¶å¦‚æ­¤ï¼Œè¯¥æ€ä¹ˆåˆ†é…å†…å­˜å‘¢ï¼Ÿ

ä¹Ÿè®¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `std::alloc::alloc`ï¼Œä½†æ˜¯å¤§å®¶æƒ³è±¡ä¸€ä¸‹æ‹¿ç€æ­¦å£«åˆ€è¿›å¨æˆ¿åˆ‡èœçš„åœºæ™¯ï¼Œæ‰€ä»¥ï¼Œè¿˜æ˜¯ç®—äº†å§ã€‚

æˆ‘ä»¬æƒ³è¦ `Box` åˆä¸æƒ³è¦ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªä¹Ÿè®¸å¾ˆé‡ä½†æ˜¯ç®¡ç”¨çš„æ–¹æ³•:
```rust
struct Node<T> {
    elem: T,
    real_next: Option<Box<Node<T>>>,
    next: *mut Node<T>,
}
```

å…ˆåˆ›å»ºä¸€ä¸ª `Box` ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªè£¸æŒ‡é’ˆæŒ‡å‘ `Box` ä¸­çš„ `Node`ï¼Œç„¶åå°±ä¸€ç›´ä½¿ç”¨è¯¥è£¸æŒ‡é’ˆç›´åˆ°æˆ‘ä»¬å¤„ç†å®Œ `Node` ä¸”å¯ä»¥é”€æ¯å®ƒä¹‹æ—¶ã€‚æœ€åï¼Œå¯ä»¥å°† `Box` ä» `real_next` ä¸­ `take` å‡ºæ¥ï¼Œå¹¶ `drop` æ‰ã€‚

ä»ä¸Šé¢æ¥çœ‹ï¼Œè¿™ä¸ªéå¸¸ç¬¦åˆæˆ‘ä»¬ä¹‹å‰çš„ç®€åŒ–ç‰ˆå€Ÿç”¨æ ˆæ¨¡å‹ï¼Ÿå€Ÿç”¨ `Box`ï¼Œå†å€Ÿç”¨ä¸€ä¸ªè£¸æŒ‡é’ˆï¼Œç„¶åå…ˆå¼¹å‡ºè¯¥è£¸æŒ‡é’ˆï¼Œå†å¼¹å‡º `Box`ï¼Œå—¯ï¼Œæœç„¶å¾ˆç¬¦åˆã€‚

ä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œè¿™æ ·åšçœ‹ä¸Šå»æœ‰è¶£ï¼Œä½†æ˜¯ä½ èƒ½ä¿è¯è¿™ä¸ªç®€åŒ–ç‰ˆå€Ÿç”¨æ ˆé¡ºåˆ©çš„å·¥ä½œå—ï¼Ÿæ‰€ä»¥ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä½¿ç”¨ [Box::into_raw](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw) å‡½æ•°å§ï¼

> `pub fn into_raw(b: Box<T>) -> *mut T`
>
> æ¶ˆè´¹æ‰ `Box` (æ‹¿èµ°æ‰€æœ‰æƒ)ï¼Œè¿”å›ä¸€ä¸ªè£¸æŒ‡é’ˆã€‚è¯¥æŒ‡é’ˆä¼šè¢«æ­£ç¡®çš„å¯¹é½ä¸”ä¸ä¸º null
> 
> åœ¨è°ƒç”¨è¯¥å‡½æ•°åï¼Œè°ƒç”¨è€…éœ€è¦å¯¹ä¹‹å‰è¢« Box æ‰€ç®¡ç†çš„å†…å­˜è´Ÿè´£ï¼Œç‰¹åˆ«åœ°ï¼Œè°ƒç”¨è€…éœ€è¦æ­£ç¡®çš„æ¸…ç† `T` å¹¶é‡Šæ”¾ç›¸åº”çš„å†…å­˜ã€‚æœ€ç®€å•çš„æ–¹å¼æ˜¯é€šè¿‡ `Box::from_raw` å‡½æ•°å°†è£¸æŒ‡é’ˆå†è½¬å›åˆ° `Box`ï¼Œç„¶å `Box` çš„ææ„å™¨å°±å¯ä»¥è‡ªåŠ¨æ‰§è¡Œæ¸…ç†äº†ã€‚
>
> æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œå› æ­¤ `b.into_raw()` æ˜¯ä¸æ­£ç¡®çš„ï¼Œæˆ‘ä»¬å¾—ä½¿ç”¨ `Box::into_raw(b)`ã€‚å› æ­¤è¯¥å‡½æ•°ä¸ä¼šè·Ÿå†…éƒ¨ç±»å‹çš„åŒåæ–¹æ³•å†²çªã€‚
>
> ### ç¤ºä¾‹
>
> å°†è£¸æŒ‡é’ˆè½¬æ¢æˆ `Box` ä»¥å®ç°è‡ªåŠ¨çš„æ¸…ç†:
>
> ```rust
>
> let x = Box::new(String::from("Hello"));
> let ptr = Box::into_raw(x);
> let x = unsafe { Box::from_raw(ptr) };

å¤ªæ£’äº†ï¼Œç®€ç›´ä¸ºæˆ‘ä»¬é‡èº«å®šåˆ¶ã€‚è€Œä¸”å®ƒè¿˜å¾ˆç¬¦åˆæˆ‘ä»¬è¯•å›¾éµå¾ªçš„è§„åˆ™ï¼š ä»å®‰å…¨çš„ä¸œä¸œå¼€å§‹ï¼Œå°†å…¶è½¬æ¢æˆè£¸æŒ‡é’ˆï¼Œæœ€åå†å°†è£¸æŒ‡é’ˆè½¬å›å®‰å…¨çš„ä¸œä¸œä»¥å®ç°å®‰å…¨çš„ dropã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ°å¤„ä½¿ç”¨è£¸æŒ‡é’ˆï¼Œä¹Ÿæ— éœ€å†æ³¨æ„ unsafe çš„èŒƒå›´ï¼Œåæ­£ç°åœ¨éƒ½æ˜¯ unsafe äº†ï¼Œæ— æ‰€è°“ã€‚
```rust
pub fn push(&mut self, elem: T) {
    unsafe {
        // ä¸€å¼€å§‹å°±å°† Box è½¬æ¢æˆè£¸æŒ‡é’ˆ
        let new_tail = Box::into_raw(Box::new(Node {
            elem: elem,
            next: ptr::null_mut(),
        }));

        if !self.tail.is_null() {
            (*self.tail).next = new_tail;
        } else {
            self.head = new_tail;
        }

        self.tail = new_tail;
    }
}
```

å˜¿ï¼Œéƒ½è¯´ unsafe ä¸åº”è¯¥ä½¿ç”¨ï¼Œä½†æ²¡æƒ³åˆ° unsafe çœŸçš„æ˜¯å¥½ï¼ç°åœ¨ä»£ç æ•´ä½“çœ‹èµ·æ¥ç®€æ´å¤šäº†ã€‚

ç»§ç»­å®ç° `pop`ï¼Œå®ƒè·Ÿä¹‹å‰åŒºåˆ«ä¸å¤§ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸è¦å¿˜äº†ä½¿ç”¨ `Box::from_raw` æ¥æ¸…ç†å†…å­˜:
```rust
pub fn pop(&mut self) -> Option<T> {
    unsafe {
        if self.head.is_null() {
            None
        } else {
            let head = Box::from_raw(self.head);
            self.head = head.next;

            if self.head.is_null() {
                self.tail = ptr::null_mut();
            }

            Some(head.elem)
        }
    }
}
```

çºªå¿µä¸‹æ­»å»çš„ `take` å’Œ `map`ï¼Œç°åœ¨æˆ‘ä»¬å¾—æ‰‹åŠ¨æ£€æŸ¥å’Œè®¾ç½® `null` äº†ã€‚

ç„¶åå†å®ç°ä¸‹ææ„å™¨ï¼Œç›´æ¥å¾ªç¯ `pop` å³å¯ï¼Œæ€ä¹ˆè¯´ï¼Œç®€å•å¯çˆ±ï¼Œè°ä¸çˆ±å‘¢?
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() { }
    }
}
```

ç°åœ¨åˆ°äº†æ£€éªŒæ­£ç¡®æ€§çš„æ—¶å€™:
```rust
#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
```

```shell
$ cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```

æµ‹è¯•æ²¡é—®é¢˜ï¼Œè¿˜æœ‰ä¸€ä¸ªæ‹¦è·¯è™ `miri` å‘¢ã€‚
```rust
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```

è‹¦å°½ç”˜æ¥ï¼Œè‹¦å°½ç”˜æ¥å•Šï¼æˆ‘ä»¬è¿™äº›ç« èŠ‚çš„åŠªåŠ›æ²¡æœ‰ç™½è´¹ï¼Œå®ƒç»ˆäºæˆåŠŸçš„å·¥ä½œäº†ã€‚


================================================
FILE: src/too-many-lists/unsafe-queue/miri.md
================================================
# Miri
çœ‹åˆ°è¿™é‡Œï¼Œå¤§å®¶æ˜¯ä¸æ˜¯æš—ä¸­æ¾äº†å£æ°”ï¼Ÿunsafe ä¸è¿‡å¦‚æ­¤å˜›ï¼Œä¸çŸ¥é“ä¸ºä½•å…¶å®ƒäººéƒ½è°ˆä¹‹è‰²å˜ã€‚

æ€ä¹ˆè¯´å‘¢ï¼Ÿä½ ä»¥ä¸ºçš„ç¼–è¯‘å™¨å·²ç»ä¸æ˜¯ä»¥å‰çš„ç¼–è¯‘å™¨äº†ï¼Œå®ƒä¸æŠ¥é”™ä¸ä»£è¡¨æ²¡æœ‰é”™è¯¯ã€‚åŒ…æ‹¬æµ‹è¯•ç”¨ä¾‹ä¹Ÿæ˜¯ï¼Œæ­£å¸¸åœ°è¿è¡Œä¸èƒ½æ„å‘³ç€ä»£ç æ²¡æœ‰ä»»ä½•é”™è¯¯ã€‚

åœ¨å‘¨æ˜Ÿé©°ç”µå½±åŠŸå¤«ä¸­ï¼Œè¿˜æœ‰ä¸€ä¸ªå¥‡æ€ªå¤§å” 10 å…ƒä¸€æœ¬ä¸»åŠ¨ä¸Šé—¨å–å¦‚æ¥ç¥æŒï¼Œé‚£ä¹ˆæœ‰æ²¡æœ‰ 10 å…ƒä¸€æœ¬çš„ Rust ç§˜ç¬ˆå‘¢ï¼Ÿ( å–‚ï¼ŒRustè¯­è¨€åœ£ç»éƒ½å…è´¹è®©ä½ è¯»äº†ï¼Œæœ‰äº†æ‘©æ‰˜è½¦ï¼Œè¿˜è¦ä»€ä¹ˆæ‹–æ‹‰æœº... å“ˆå“ˆï¼Œå¼€ä¸ªç©ç¬‘ )

æœ‰çš„ï¼Œå¥‡æ€ªå¤§å”æ­£åœ¨èµ¶æ¥ï¼Œä»–å‘Šè¯‰æˆ‘ä»¬å…ˆæ¥å®‰è£…ä¸€ä¸ªå‘½ä»¤:
```shell
rustup +nightly-2022-01-21 component add miri
info: syncing channel updates for 'nightly-2022-01-21-x86_64-pc-windows-msvc'
info: latest update on 2022-01-21, rust version 1.60.0-nightly (777bb86bc 2022-01-20)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'
info: downloading component 'rustc'
info: downloading component 'rustfmt'
info: installing component 'cargo'
info: installing component 'clippy'
info: installing component 'rust-docs'
info: installing component 'rust-std'
info: installing component 'rustc'
info: installing component 'rustfmt'
info: downloading component 'miri'
info: installing component 'miri'
```

ç­‰ç­‰ï¼Œä½ åœ¨æˆ‘ç”µè„‘ä¸Šè£…äº†ä»€ä¹ˆå¥‡æ€ªçš„ä¸œè¥¿ï¼Ÿï¼  "å¥½ä¸œè¥¿"


> miri ç›®å‰åªèƒ½åœ¨ nightly Rust ä¸Šå®‰è£…ï¼Œ`+nightly-2022-01-21` å‘Šè¯‰ `rustup` æˆ‘ä»¬æƒ³è¦å®‰è£…çš„ `nightly` ç‰ˆæœ¬ï¼Œäº‹å®ä¸Šï¼Œä½ å¯ä»¥ç›´æ¥é€šè¿‡ `rustup +nightly component add miri` å®‰è£…ï¼Œè¿™é‡ŒæŒ‡å®šç‰ˆæœ¬ä¸»è¦å› ä¸º `miri` æœ‰æ—¶å€™ä¼šå› ä¸ºæŸäº›ç‰ˆæœ¬è€Œå‡ºé”™ã€‚
>
> 2022-01-21 æ˜¯æˆ‘æ‰€çŸ¥çš„ miri å¯ä»¥æˆåŠŸè¿è¡Œçš„ç‰ˆæœ¬ï¼Œä½ å¯ä»¥æ£€æŸ¥[è¿™ä¸ªç½‘å€](https://rust-lang.github.io/rustup-components-history/)è·å–æ›´å¤šä¿¡æ¯
>
> + æ˜¯ä¸€ç§ä¸´æ—¶æ€§çš„è§„åˆ™è¿ç”¨ï¼Œå¦‚æœä½ ä¸æƒ³æ¯æ¬¡éƒ½ä½¿ç”¨ `+nightly-2022-01-21`ï¼Œå¯ä»¥ä½¿ç”¨ [`rustup override set`](https://course.rs/appendix/rust-version.html#rustup-å’Œ-rust-nightly-çš„èŒè´£) å‘½ä»¤å¯¹å½“å‰é¡¹ç›®çš„ Rust ç‰ˆæœ¬è¿›è¡Œè¦†ç›–

```shell
$ cargo +nightly-2022-01-21 miri test

I will run `"cargo.exe" "install" "xargo"` to install
a recent enough xargo. Proceed? [Y/n]
```

é¢ï¼Œ`xargo` æ˜¯ä»€ä¹ˆä¸œä¸œï¼Ÿ"ä¸è¦æ‹…å¿ƒï¼Œé€‰æ‹© y å°±è¡Œï¼Œæˆ‘åƒæ˜¯ä¼šå‘ä½ çš„äººå—ï¼Ÿ"

```shell
> y

    Updating crates.io index
  Installing xargo v0.3.24
...
    Finished release [optimized] target(s) in 10.65s
  Installing C:\Users\ninte\.cargo\bin\xargo-check.exe
  Installing C:\Users\ninte\.cargo\bin\xargo.exe
   Installed package `xargo v0.3.24` (executables `xargo-check.exe`, `xargo.exe`)

I will run `"rustup" "component" "add" "rust-src"` to install 
the `rust-src` component for the selected toolchain. Proceed? [Y/n]
```

é¢ï¼Ÿ "ä¸è¦æ€•ï¼Œå¤šç»™ä½ ä¸€ä»½ Rust æºä»£ç ï¼Œä¸å¼€å¿ƒå˜›ï¼Ÿ"

```shell
> y

info: downloading component 'rust-src'
info: installing component 'rust-src'
```

"çœ‹å§ï¼Œæˆ‘å°±è¯´æˆ‘ä¸ä¼šéª—ä½ çš„ï¼Œä¸ç›¸ä¿¡æˆ‘ï¼Œç­‰ç€é”™è¯¯ç ¸è„¸å§!" çœŸæ˜¯ä¸€ä¸ªå¥‡æ€ªçš„å¤§å”...
```shell
 Compiling lists v0.1.0 (C:\Users\ninte\dev\tmp\lists)
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests (lists-5cc11d9ee5c3e924.exe)

error: Undefined Behavior: trying to reborrow for Unique at alloc84055, 
       but parent tag <209678> does not have an appropriate item in 
       the borrow stack

   --> \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) => Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag <209678> does not have an 
    |                    appropriate item in the borrow stack
    |
    = help: this indicates a potential bug in the program: 
      it performed an invalid operation, but the rules it 
      violated are still experimental
    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information

    = note: inside `std::option::Option::<std::boxed::Box<fifth::Node<i32>>>::map::<i32, [closure@src\fifth.rs:31:30: 40:10]>` at \lib\rustlib\src\rust\library\core\src\option.rs:846:18

note: inside `fifth::List::<i32>::pop` at src\fifth.rs:31:9
   --> src\fifth.rs:31:9
    |
31  | /         self.head.take().map(|head| {
32  | |             let head = *head;
33  | |             self.head = head.next;
34  | |
...   |
39  | |             head.elem
40  | |         })
    | |__________^
note: inside `fifth::test::basics` at src\fifth.rs:74:20
   --> src\fifth.rs:74:20
    |
74  |         assert_eq!(list.pop(), Some(1));
    |                    ^^^^^^^^^^
note: inside closure at src\fifth.rs:62:5
   --> src\fifth.rs:62:5
    |
61  |       #[test]
    |       ------- in this procedural macro expansion
62  | /     fn basics() {
63  | |         let mut list = List::new();
64  | |
65  | |         // Check empty list behaves right
...   |
96  | |         assert_eq!(list.pop(), None);
97  | |     }
    | |_____^
 ...
error: aborting due to previous error
```

å’¦è¿˜çœŸæœ‰é”™è¯¯ï¼Œå¤§å”ï¼Œè¿™æ˜¯ä»€ä¹ˆé”™è¯¯ï¼Ÿå¤§å”ï¼Ÿ...å¥‡æ€ªçš„å¤§å”é»˜é»˜ç¦»å¼€äº†ï¼Œç•™ä¸‹æˆ‘åœ¨é£ä¸­å‡Œä¹±ã€‚

æœç„¶ä¸é è°±...è¿˜æ˜¯å¾—é è‡ªå·±ï¼Œé¦–å…ˆå¾—äº†è§£ä¸‹ä½•ä¸º `miri`ã€‚


[`miri`](https://github.com/rust-lang/miri) å¯ä»¥ç”Ÿæˆ Rust çš„ä¸­é—´å±‚è¡¨ç¤º MIRï¼Œå¯¹äºç¼–è¯‘å™¨æ¥è¯´ï¼Œæˆ‘ä»¬çš„ Rust ä»£ç é¦–å…ˆä¼šè¢«ç¼–è¯‘ä¸º MIR ï¼Œç„¶åå†æäº¤ç»™ LLVM è¿›è¡Œå¤„ç†ã€‚

å¯ä»¥é€šè¿‡ `rustup component add miri` æ¥å®‰è£…å®ƒï¼Œå¹¶é€šè¿‡ `cargo miri` æ¥ä½¿ç”¨ï¼ŒåŒæ—¶è¿˜å¯ä»¥ä½¿ç”¨ `cargo miri test` æ¥è¿è¡Œæµ‹è¯•ä»£ç ã€‚

`miri` å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ£€æŸ¥å¸¸è§çš„æœªå®šä¹‰è¡Œä¸º(UB = Undefined Behavior)ï¼Œä»¥ä¸‹åˆ—å‡ºäº†ä¸€éƒ¨åˆ†:

- å†…å­˜è¶Šç•Œæ£€æŸ¥å’Œå†…å­˜é‡Šæ”¾åå†ä½¿ç”¨(use-after-free)
- ä½¿ç”¨æœªåˆå§‹åŒ–çš„æ•°æ®
- æ•°æ®ç«äº‰
- å†…å­˜å¯¹é½é—®é¢˜

UB æ£€æµ‹æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºå®ƒå‘ç”Ÿåœ¨è¿è¡Œæ—¶ï¼Œå› æ­¤å¾ˆéš¾å‘ç°ï¼Œå¦‚æœ `miri` èƒ½åœ¨ç¼–è¯‘æœŸæ£€æµ‹å‡ºæ¥ï¼Œé‚£è‡ªç„¶æ˜¯æœ€å¥½ä¸è¿‡çš„ã€‚

æ€»ä¹‹ï¼Œ`miri` çš„ä½¿ç”¨å¾ˆç®€å•:
```shell
$ cargo +nightly-2022-01-21 miri test
```

ä¸‹é¢æ¥çœ‹çœ‹å…·ä½“çš„é”™è¯¯ï¼š
```shell
error: Undefined Behavior: trying to reborrow for Unique at alloc84055, but parent tag <209678> does not have an appropriate item in the borrow stack

   --> \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) => Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag <209678> does not have an 
    |                    appropriate item in the borrow stack
    |

    = help: this indicates a potential bug in the program: it 
      performed an invalid operation, but the rules it 
      violated are still experimental
    
    = help: see 
      https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information
```

å—¯ï¼Œåªèƒ½çœ‹å‡ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œå…¶å®ƒå®Œå…¨çœ‹ä¸æ‡‚äº†ï¼Œä¾‹å¦‚ä»€ä¹ˆæ˜¯ `borrow stack`ï¼Ÿ





================================================
FILE: src/too-many-lists/unsafe-queue/stacked-borrow.md
================================================
# æ ˆå€Ÿç”¨( Stacked Borrorw)
ä¸Šä¸€ç« èŠ‚ä¸­æˆ‘ä»¬è¿è¡Œ miri æ—¶é‡åˆ°äº†ä¸€ä¸ªæ ˆå€Ÿç”¨é”™è¯¯ï¼Œè¿˜ç»™äº†æ–‡æ¡£é“¾æ¥ï¼Œä½†è¿™äº›æ–‡æ¡£ä¸»è¦æ˜¯ç»™ç¼–è¯‘å™¨å¼€å‘è€…å’Œ Rust ç ”ç©¶è€…çœ‹çš„ï¼Œå› æ­¤å°±ä¸è¿›è¡Œè®²è§£äº†ã€‚

è€Œè¿™é‡Œï¼Œæˆ‘ä»¬å°†ä»ä¸€ä¸ªæ›´é«˜å±‚æ¬¡çš„è§’åº¦æ¥çœ‹çœ‹ä½•ä¸ºæ ˆå€Ÿç”¨ã€‚

> ç›®å‰æ ˆå€Ÿç”¨åœ¨ Rust è¯­ä¹‰æ¨¡å‹ä¸­è¿˜æ˜¯è¯•éªŒé˜¶æ®µï¼Œå› æ­¤ç ´åè¿™äº›è§„åˆ™ä¸ä¸€å®šè¯´æ˜ä½ çš„ç¨‹åºé”™äº†ã€‚ä½†æ˜¯é™¤éä½ åœ¨åšç¼–è¯‘å™¨å¼€å‘ï¼Œå¦åˆ™æœ€å¥½è¿˜æ˜¯ä¿®å¤è¿™äº›é”™è¯¯ã€‚äº‹å‰çš„éº»çƒ¦æ€»æ¯”äº‹åçš„ä¸å®‰å…¨è¦å¥½ï¼Œç‰¹åˆ«æ˜¯å½“æ¶‰åŠåˆ° UB æœªå®šä¹‰è¡Œä¸ºæ—¶

## æŒ‡é’ˆæ··å ( Pointer Aliasing )
åœ¨å¼€å§‹äº†è§£æˆ‘ä»¬ç ´åçš„è§„åˆ™ä¹‹å‰ï¼Œé¦–å…ˆåº”è¯¥äº†è§£ä¸ºä½•ä¼šæœ‰è¿™äº›è§„åˆ™çš„å­˜åœ¨ã€‚è¿™é‡Œæœ‰å¤šä¸ªåŠ¨æœºï¼Œä½†æ˜¯æˆ‘è®¤ä¸ºæœ€é‡è¦çš„åŠ¨æœºæ˜¯ï¼š æŒ‡é’ˆæ··å .

å½“ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜åŒºåŸŸå­˜åœ¨é‡å æ—¶ï¼Œå°±è¯´è¿™ä¸¤ä¸ªæŒ‡é’ˆå‘ç”Ÿäº†æ··å ï¼Œè¿™ç§æƒ…å†µä¼šé€ æˆä¸€äº›é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œç¼–è¯‘å™¨ä½¿ç”¨æŒ‡é’ˆæ··å çš„ä¿¡æ¯æ¥ä¼˜åŒ–å†…å­˜çš„è®¿é—®ï¼Œå½“è¿™äº›ä¿¡æ¯å‡ºé”™æ—¶ï¼Œé‚£ç¨‹åºå°±ä¼šè¢«ä¸æ­£ç¡®åœ°ç¼–è¯‘ï¼Œç„¶åäº§ç”Ÿä¸€äº›å¥‡æ€ªçš„ç»“æœã€‚

> å®é™…ä¸Šï¼Œæ··å æ›´å¤šå…³å¿ƒçš„æ˜¯å†…å­˜è®¿é—®è€Œä¸æ˜¯æŒ‡é’ˆæœ¬èº«ï¼Œè€Œä¸”åªæœ‰åœ¨å…¶ä¸­ä¸€ä¸ªè®¿é—®æ˜¯å¯å˜çš„æ—¶ï¼Œæ‰å¯èƒ½å‡ºé—®é¢˜ã€‚ä¹‹æ‰€ä»¥è¯´æŒ‡é’ˆï¼Œæ˜¯å› ä¸ºæŒ‡é’ˆè¿™ä¸ªæ¦‚å¿µæ›´æ–¹ä¾¿è·Ÿä¸€äº›è§„åˆ™è¿›è¡Œå…³è”ã€‚

å†æ¯”å¦‚ï¼Œç¼–è¯‘å™¨éœ€è¦è·å–ä¸€ä¸ªå€¼æ—¶ï¼Œæ˜¯è¯¥å»ç¼“å­˜ä¸­æŸ¥è¯¢è¿˜æ˜¯æ¯æ¬¡éƒ½å»å†…å­˜ä¸­åŠ è½½å‘¢ï¼Ÿå…³äºè¿™ä¸ªé€‰æ‹©ï¼Œç¼–è¯‘å™¨éœ€è¦æ¸…æ™°åœ°çŸ¥é“æ˜¯å¦æœ‰ä¸€ä¸ªæŒ‡é’ˆåœ¨èƒŒåä¿®æ”¹å†…å­˜ï¼Œå¦‚æœå†…å­˜å€¼è¢«ä¿®æ”¹äº†ï¼Œé‚£ç¼“å­˜æ˜¾ç„¶å°±å¤±æ•ˆäº†ã€‚

## å®‰å…¨åœ°æ ˆå€Ÿç”¨
æœ‰äº†ä¹‹å‰çš„é“ºå«ï¼Œå¤§å®¶è‚¯å®šå¸Œæœ›ç¼–è¯‘å™¨èƒ½å¯¹æŒ‡é’ˆæ··å çš„ä¿¡æ¯äº†è‹¥æŒ‡æŒï¼Œä½†æ˜¯å¯ä»¥å—ï¼Ÿå¯¹äº Rust æ­£å¸¸ä»£ç è€Œè¨€ï¼Œè¿™ç§æƒ…å†µæ˜¯å¯ä»¥é¿å…çš„ï¼Œå› ä¸ºä¸¥æ ¼çš„å€Ÿç”¨è§„åˆ™æ˜¯æˆ‘ä»¬çš„åç›¾ï¼šè¦ä¹ˆåŒæ—¶å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆåŒæ—¶å­˜åœ¨å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼Œè¿™ç§è§„åˆ™ç®€ç›´å®Œç¾é¿å…äº†ï¼šä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€å—å„¿é‡å å†…å­˜åŒºåŸŸï¼Œè€Œå…¶ä¸­ä¸€ä¸ªæ˜¯å¯å˜æŒ‡é’ˆã€‚

ç„¶è€Œå®é™…ä½¿ç”¨ä¸­ï¼Œæœ‰ä¸€äº›æƒ…å†µä¼šè¾ƒä¸ºå¤æ‚ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç ä¸­å‘ç”Ÿäº†å¯å˜å¼•ç”¨çš„å†å€Ÿç”¨( reborrow )ï¼š
```rust
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

*ref2 += 2;
*ref1 += 1;

println!("{}", data);
```

çœ‹ä¸Šå»åƒæ˜¯è¿åäº†å€Ÿç”¨è§„åˆ™ï¼Œä½†æ˜¯è¿™æ®µä»£ç ç¡®å®å¯ä»¥æ­£å¸¸ç¼–è¯‘è¿è¡Œï¼Œå¦‚æœäº¤æ¢ä¸‹å¼•ç”¨ä½¿ç”¨çš„é¡ºåºå‘¢ï¼Ÿ
```rust
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;

println!("{}", data);
```

```shell
error[E0503]: cannot use `*ref1` because it was mutably borrowed
 --> src/main.rs:6:5
  |
4 |     let ref2 = &mut *ref1;
  |                ---------- borrow of `*ref1` occurs here
5 |     
6 |     *ref1 += 1;
  |     ^^^^^^^^^^ use of borrowed `*ref1`
7 |     *ref2 += 2;
  |     ---------- borrow later used here

For more information about this error, try `rustc --explain E0503`.
error: could not compile `playground` due to previous error
```

æœä¸å…¶ç„¶ï¼Œç¼–è¯‘å™¨æŠ›å‡ºäº†é”™è¯¯ï¼Œå½“æˆ‘ä»¬å†å€Ÿç”¨äº†ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œé‚£åŸå§‹çš„å¼•ç”¨å°±ä¸èƒ½å†è¢«ä½¿ç”¨ï¼Œç›´åˆ°å€Ÿç”¨è€…å®Œæˆäº†ä»»åŠ¡ï¼šå€Ÿç”¨è€…çš„å€Ÿç”¨æœ‰æ•ˆèŒƒå›´å¹¶ä¸æ˜¯çœ‹ä½œç”¨åŸŸï¼Œè€Œæ˜¯çœ‹æœ€åä¸€æ¬¡ä½¿ç”¨çš„ä½ç½®ï¼Œæ­£å› ä¸ºå¦‚æ­¤ï¼Œç¬¬ä¸€æ®µä»£ç å¯ä»¥ç¼–è¯‘é€šè¿‡ï¼Œè€Œç¬¬äºŒæ®µä¸è¡Œï¼Œè¿™æ˜¯è‘—åçš„ç”Ÿå‘½å‘¨æœŸ [NLL è§„åˆ™](https://course.rs/advance/lifetime/advance.html#nll-non-lexical-lifetime)ã€‚

ä»¥ä¸Šå°±æ˜¯æˆ‘ä»¬æ‹¥æœ‰å†å€Ÿç”¨ä½†æ˜¯è¿˜æ‹¥æœ‰æ··å ä¿¡æ¯çš„åŸå› ï¼šæ‰€æœ‰çš„å†å€Ÿç”¨éƒ½åœ¨æ¸…æ™°åœ°è¿›è¡ŒåµŒå¥—ï¼Œå› æ­¤æ¯ä¸ªå†å€Ÿç”¨éƒ½ä¸ä¼šä¸å…¶å®ƒçš„å†²çªã€‚é‚£å¤§å®¶çŸ¥é“ä»€ä¹ˆæ–¹æ³•å¯ä»¥å¾ˆå¥½çš„å±•ç°åµŒå¥—çš„äº‹ç‰©å—ï¼Ÿç­”æ¡ˆå°±æ˜¯ä½¿ç”¨æ ˆæ¥å­˜æ”¾è¿™äº›åµŒå¥—çš„å€Ÿç”¨ã€‚

å˜¿ï¼Œè¿™ä¸å°±æ˜¯æ ˆå€Ÿç”¨å—ï¼Ÿ

è¿™ä¸ªæ ˆçš„é¡¶éƒ¨å€Ÿç”¨å°±æ˜¯å½“å‰æ­£åœ¨ä½¿ç”¨( live )çš„å€Ÿç”¨ï¼Œè€Œå®ƒæ¸…æ™°çš„çŸ¥é“åœ¨å®ƒä½¿ç”¨çš„æœŸé—´ä¸ä¼šå‘ç”Ÿæ··å ã€‚å½“å¯¹ä¸€ä¸ªæŒ‡é’ˆè¿›è¡Œå†å€Ÿç”¨æ—¶ï¼Œæ–°çš„å€Ÿç”¨ä¼šè¢«æ’å…¥åˆ°æ ˆçš„é¡¶éƒ¨ï¼Œå¹¶å˜æˆ live çŠ¶æ€ã€‚å¦‚æœè¦å°†ä¸€ä¸ªæ—§çš„æŒ‡é’ˆå˜æˆ liveï¼Œå°±éœ€è¦å°†å€Ÿç”¨æ ˆä¸Šåœ¨å®ƒä¹‹å‰çš„å€Ÿç”¨å…¨éƒ¨å¼¹å‡º( pop )ã€‚

é€šè¿‡æ ˆå€Ÿç”¨çš„æ–¹å¼ï¼Œæˆ‘ä»¬ä¿è¯äº†å°½ç®¡å­˜åœ¨å¤šä¸ªå†å€Ÿç”¨ï¼Œä½†æ˜¯åœ¨åŒä¸€ä¸ªæ—¶é—´ï¼Œåªä¼šæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨è®¿é—®ç›®æ ‡å†…å­˜ï¼Œå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæŒ‡é’ˆæ··å çš„é—®é¢˜äº†ã€‚åªè¦ä¸å»è®¿é—®ä¸€ä¸ªå·²ç»è¢«å¼¹å‡ºå€Ÿç”¨æ ˆçš„æŒ‡é’ˆï¼Œå°±ä¼šéå¸¸å®‰å…¨ï¼

ä»è¡¨è¿°æ–¹å¼æ¥è¯´ï¼Œä¸å…¶è¯´ä½¿ç”¨ `ref1` ä¼šè®© `ref2` ä¸åˆæ³•ï¼Œä¸å¦‚è¯´ `ref2` å¿…é¡»è¦åœ¨æ‰€æœ‰ä½¿ç”¨æƒ…å†µä¸‹åˆæ³•ï¼Œ`ref1` æ°æ°æ˜¯å…¶ä¸­ä¸€ç§æƒ…å†µï¼Œä¼šç ´å `ref2` çš„åˆæ³•æ€§ã€‚è€Œç¼–è¯‘å™¨çš„æŠ¥é”™ä¹Ÿæ˜¯é€‰æ‹©äº†ç¬¬äºŒç§è¡¨è¿°æ–¹å¼ï¼šæ— æ³•ä½¿ç”¨ `*ref1`ï¼ŒåŸå› æ˜¯å®ƒå·²ç»è¢«å¯å˜å€Ÿç”¨äº†ï¼Œå¯ä»¥çœ‹å‡ºï¼Œç¬¬äºŒç§è¡¨è¿°æ–¹å¼æ¯”ç¬¬ä¸€ç§è¦æ›´åŠ ç¬¦åˆç›´è§‰ã€‚

**ä½†æ˜¯ï¼Œå½“ä½¿ç”¨ `unsafe` æŒ‡é’ˆæ—¶ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨å°±æ— æ³•å†å¸®åŠ©æˆ‘ä»¬äº†ï¼**

## ä¸å®‰å…¨åœ°æ ˆå€Ÿç”¨
æ‰€ä»¥ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦ä¸€ä¸ªæ–¹å¼è®© unsafe æŒ‡é’ˆä¹Ÿå¯ä»¥å‚ä¸åˆ°æ ˆå€Ÿç”¨ç³»ç»Ÿä¸­æ¥ï¼Œå³ä½¿ç¼–è¯‘å™¨æ— æ³•æ­£ç¡®åœ°è·Ÿè¸ªå®ƒä»¬ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿå¸Œæœ›è¿™ä¸ªç³»ç»Ÿèƒ½å®½æ¾ä¸€äº›ï¼Œä¸è¦å¾ˆå®¹æ˜“å°±äº§ç”Ÿ UBã€‚

è¿™æ˜¯ä¸€ä¸ªå›°éš¾çš„é—®é¢˜ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“è¯¥å¦‚ä½•è§£å†³ï¼Œä½†æ˜¯ç›®å‰åœ¨ç¼–å†™æ ˆå€Ÿç”¨ç³»ç»Ÿçš„å¼€å‘è€…æ˜¾ç„¶æ˜¯æœ‰æƒ³æ³•çš„ï¼Œä¾‹å¦‚ miri å°±æ˜¯å…¶ä¸­ä¸€ä¸ªäº§ç‰©ã€‚

ä»ä¸€ä¸ªé«˜æŠ½è±¡å±‚æ¬¡æ¥çœ‹ï¼Œå½“æˆ‘ä»¬å°†ä¸€ä¸ªå¼•ç”¨è½¬æ¢æˆè£¸æŒ‡é’ˆæ—¶ï¼Œå°±æ˜¯ä¸€ç§å†å€Ÿç”¨ã€‚é‚£ä¹ˆéšåï¼Œè£¸æŒ‡é’ˆå°±å¯ä»¥å¯¹ç›®æ ‡å†…å­˜è¿›è¡Œæ“ä½œï¼Œå½“å†å€Ÿç”¨ç»“æŸæ—¶ï¼Œå‘ç”Ÿçš„äº‹æƒ…è·Ÿæ­£å¸¸çš„å†å€Ÿç”¨ç»“æŸä¹Ÿæ²¡æœ‰åŒºåˆ«ã€‚

ä½†æ˜¯é—®é¢˜æ˜¯ï¼Œä½ è¿˜å¯ä»¥å°†ä¸€ä¸ªè£¸æŒ‡é’ˆè½¬å˜æˆå¼•ç”¨ï¼Œæœ€é‡è¦çš„æ˜¯ï¼Œè¿˜å¯ä»¥å¯¹è£¸æŒ‡é’ˆè¿›è¡Œæ‹·è´ï¼å¦‚æœå‘ç”Ÿäº†ä»¥ä¸‹è½¬æ¢ `&mut -> *mut -> &mut -> *mut`ï¼Œç„¶åå»è®¿é—®ç¬¬ä¸€ä¸ª `*mut`ï¼Œè¿™ç§è§é¬¼çš„æƒ…å†µä¸‹ï¼Œæ ˆå€Ÿç”¨è¯¥å¦‚ä½•å‘æŒ¥ä½œç”¨ï¼Ÿ

åæ­£æˆ‘ä¸çŸ¥é“ï¼Œåªèƒ½æ±‚åŠ©äº miri äº†ã€‚äº‹å®ä¸Šï¼Œæ­£å› ä¸ºè¿™ç§æƒ…å†µï¼Œmiri è¿˜æä¾›äº†è¯•éªŒæ€§çš„æ¨¡å¼: `-Zmiri-tag-raw-pointers`ã€‚å¯ä»¥é€šè¿‡ç¯å¢ƒçš„æ–¹å¼æ¥å¼€å¯è¯¥æ¨¡å¼ï¼š
```shell
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test
```

å¦‚æœæ˜¯ Windowsï¼Œä½ éœ€è¦è®¾ç½®å…¨å±€å˜é‡:
```shell
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo +nightly-2022-01-21 miri test
```

## ç®¡ç†æ ˆå€Ÿç”¨
å› ä¸ºä¹‹å‰çš„é—®é¢˜ï¼Œä½¿ç”¨è£¸æŒ‡é’ˆï¼Œåº”è¯¥éµå®ˆä¸€ä¸ªåŸåˆ™ï¼š**ä¸€æ—¦å¼€å§‹ä½¿ç”¨è£¸æŒ‡é’ˆï¼Œå°±è¦å°è¯•ç€åªä½¿ç”¨å®ƒ**ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬ä¾ç„¶å¸Œæœ›åœ¨æ¥å£ä¸­ä½¿ç”¨å®‰å…¨çš„å¼•ç”¨å»æ„å»ºä¸€ä¸ªå®‰å…¨çš„æŠ½è±¡ï¼Œä¾‹å¦‚åœ¨å‡½æ•°å‚æ•°ä¸­ä½¿ç”¨å¼•ç”¨è€Œä¸æ˜¯è£¸æŒ‡é’ˆï¼Œè¿™æ ·æˆ‘ä»¬çš„ç”¨æˆ·å°±æ— éœ€æ“å¿ƒ unsafe çš„é—®é¢˜ã€‚

ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åšä»¥ä¸‹äº‹æƒ…ï¼š

1. åœ¨å¼€å§‹æ—¶ï¼Œå°†è¾“å…¥å‚æ•°ä¸­çš„å¼•ç”¨è½¬æ¢æˆè£¸æŒ‡é’ˆ
2. åœ¨å‡½æ•°ä½“ä¸­åªä½¿ç”¨è£¸æŒ‡é’ˆ
3. è¿”å›ä¹‹å‰ï¼Œå°†è£¸æŒ‡é’ˆè½¬æ¢æˆå®‰å…¨çš„æŒ‡é’ˆ

ä½†æ˜¯ç”±äºæ•°æ®ç»“æ„ä¸­çš„å­—æ®µéƒ½æ˜¯ç§æœ‰çš„ï¼Œæ— éœ€æš´éœ²ç»™ç”¨æˆ·ï¼Œå› æ­¤æ— éœ€è¿™ä¹ˆéº»çƒ¦ï¼Œç›´æ¥ä½¿ç”¨è£¸æŒ‡é’ˆå³å¯ã€‚

äº‹å®ä¸Šï¼Œä¸€ä¸ªä¾ç„¶å­˜åœ¨çš„é—®é¢˜å°±æ˜¯è¿˜åœ¨ç»§ç»­ä½¿ç”¨ `Box`, å®ƒä¼šå‘Šè¯‰ç¼–è¯‘å™¨ï¼šheyï¼Œè¿™ä¸ªçœ‹ä¸Šå»å¾ˆåƒæ˜¯ `&mut` ï¼Œå› ä¸ºå®ƒå”¯ä¸€çš„æŒæœ‰é‚£ä¸ªæŒ‡é’ˆã€‚

ä½†æ˜¯æˆ‘ä»¬åœ¨é“¾è¡¨ä¸­ä¸€ç›´ä½¿ç”¨çš„è£¸æŒ‡é’ˆæ˜¯æŒ‡å‘ Box çš„å†…éƒ¨ï¼Œæ‰€ä»¥æ— è®ºä½•æ—¶æˆ‘ä»¬é€šè¿‡æ­£å¸¸çš„æ–¹å¼è®¿é—® Boxï¼Œæˆ‘ä»¬éƒ½æœ‰å¯èƒ½è®©è¯¥è£¸æŒ‡é’ˆçš„å†å€Ÿç”¨å˜å¾—ä¸åˆæ³•ã€‚




================================================
FILE: src/too-many-lists/unsafe-queue/testing-stacked-borrow.md
================================================
[Binary file]


================================================
FILE: src/usecases/aws-rust.md
================================================
[Binary file]


================================================
FILE: src/usecases/intro.md
================================================
# Rustçš„ä½¿ç”¨æ¡ˆä¾‹
è‡ªä» Rust åŸºé‡‘ä¼šæˆç«‹åï¼Œä¸€äº›ä¼˜ç§€çš„è½åœ°æ¡ˆä¾‹å¦‚é›¨åæ˜¥ç¬‹èˆ¬å†’äº†å‡ºæ¥ï¼Œè¿™äº›å……åˆ†è¯´æ˜äº† Rust è¯­è¨€åœ¨å…¨çƒèŒƒå›´çš„æµè¡Œã€‚

è¿™é‡Œæˆ‘ä»¬å°†é€šè¿‡å‡ ä¸ªç²¾å¿ƒæŒ‘é€‰çš„ä½¿ç”¨æ¡ˆä¾‹ï¼Œæ¥å¸®åŠ©å¤§å®¶çœ‹çœ‹ Rust èƒ½ä¸ºä¼ä¸šè§£å†³å“ªäº›ç—›ç‚¹ï¼Œä»¥åŠè¯¥å¦‚ä½•åœ¨ä¼ä¸šå†…è½åœ°ã€‚


================================================
FILE: theme/index1.hbs
================================================
<!DOCTYPE HTML>
<html lang="{{ language }}" class="{{ default_theme }}" dir="{{ text_direction }}">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>{{ title }}</title>
        {{#if is_print }}
        <meta name="robots" content="noindex">
        {{/if}}
        {{#if base_url}}
        <base href="{{ base_url }}">
        {{/if}}


        <!-- Custom HTML head -->
        {{> head}}

        <meta name="description" content="{{ description }}">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        {{#if favicon_svg}}
        <link rel="icon" href="{{ path_to_root }}favicon.svg">
        {{/if}}
        {{#if favicon_png}}
        <link rel="shortcut icon" href="{{ path_to_root }}favicon.png">
        {{/if}}
        <link rel="stylesheet" href="{{ path_to_root }}css/variables.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/general.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/chrome.css">
        {{#if print_enable}}
        <link rel="stylesheet" href="{{ path_to_root }}css/print.css" media="print">
        {{/if}}

        <!-- Fonts -->
        <link rel="stylesheet" href="{{ path_to_root }}FontAwesome/css/font-awesome.css">
        {{#if copy_fonts}}
        <link rel="stylesheet" href="{{ path_to_root }}fonts/fonts.css">
        {{/if}}

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="{{ path_to_root }}highlight.css">
        <link rel="stylesheet" href="{{ path_to_root }}tomorrow-night.css">
        <link rel="stylesheet" href="{{ path_to_root }}ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        {{#each additional_css}}
        <link rel="stylesheet" href="{{ ../path_to_root }}{{ this }}">
        {{/each}}

        {{#if mathjax_support}}
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        {{/if}}
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "{{ path_to_root }}";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "{{ preferred_dark_theme }}" : "{{ default_theme }}";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('{{ default_theme }}')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                {{#toc}}{{/toc}}
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                {{> header}}
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        {{#if search_enabled}}
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        {{/if}}
                    </div>

                    <h1 class="menu-title">{{ book_title }}</h1>

                    <div class="right-buttons">
                        {{#if print_enable}}
                        <a href="{{ path_to_root }}print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_url}}
                        <a href="{{git_repository_url}}" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa {{git_repository_icon}}"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_edit_url}}
                        <a href="{{git_repository_edit_url}}" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        {{/if}}

                    </div>
                </div>

                {{#if search_enabled}}
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                {{/if}}

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        {{{ content }}}
                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        {{#previous}}
                            <a rel="prev" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        {{/previous}}

                        {{#next}}
                            <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        {{/next}}

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                {{#previous}}
                    <a rel="prev" href="{{ path_to_root }}{{link}}" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                {{/previous}}

                {{#next}}
                    <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                {{/next}}
            </nav>

        </div>

        {{#if live_reload_endpoint}}
        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "{{{live_reload_endpoint}}}";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        {{/if}}

        {{#if google_analytics}}
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', '{{google_analytics}}', 'auto');
                ga('send', 'pageview');
            }
        </script>
        {{/if}}

        {{#if playground_line_numbers}}
        <script>
            window.playground_line_numbers = true;
        </script>
        {{/if}}

        {{#if playground_copyable}}
        <script>
            window.playground_copyable = true;
        </script>
        {{/if}}

        {{#if playground_js}}
        <script src="{{ path_to_root }}ace.js"></script>
        <script src="{{ path_to_root }}editor.js"></script>
        <script src="{{ path_to_root }}mode-rust.js"></script>
        <script src="{{ path_to_root }}theme-dawn.js"></script>
        <script src="{{ path_to_root }}theme-tomorrow_night.js"></script>
        {{/if}}

        {{#if search_js}}
        <script src="{{ path_to_root }}elasticlunr.min.js"></script>
        <script src="{{ path_to_root }}mark.min.js"></script>
        <script src="{{ path_to_root }}searcher.js"></script>
        {{/if}}

        <script src="{{ path_to_root }}clipboard.min.js"></script>
        <script src="{{ path_to_root }}highlight.js"></script>
        <script src="{{ path_to_root }}book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "{{ path }}"
        </script>


        <!-- Custom JS scripts -->
        {{#each additional_js}}
        <script src="{{ ../path_to_root }}{{this}}"></script>
        {{/each}}

        {{#if is_print}}
        {{#if mathjax_support}}
        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        {{else}}
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        {{/if}}
        {{/if}}

    </div>
    </body>
</html>


================================================
FILE: theme/style.css
================================================
@media only screen and (max-width:1080px) {
    .sidetoc {
        display: none !important;
    }
}

@media only screen and (min-width:1080px) {
    main {
        position: relative;
        padding-right: 170px;
    }
    .sidetoc {
        margin-left: auto;
        margin-right: auto;
        /*left: calc(100% + (var(--content-max-width))/4 - 180px);*/
        left: calc(100% - 200px);
        position: absolute;
    }
    .pagetoc {
        position: fixed;
        width: 200px;
        height: calc(100vh - var(--menu-bar-height) - 10rem);
        overflow: auto;
        z-index: 1000;
    }
    .pagetoc a {
        border-left: 1px solid var(--sidebar-bg);
        color: var(--fg) !important;
        display: block;
        padding-bottom: 5px;
        padding-top: 5px;
        padding-left: 10px;
        text-align: left;
        text-decoration: none;
        font-size: 1.2rem;
    }
    .pagetoc a:hover,
    .pagetoc a.active {
        background: var(--sidebar-bg);
        color: var(--sidebar-fg) !important;
    }
    .pagetoc .active {
        background: var(--sidebar-bg);
        color: var(--sidebar-fg);
    }
}

.page-footer {
    margin-top: 50px;
    border-top: 1px solid #ccc;
    overflow: hidden;
    padding: 10px 0;
    color: gray;
}

/* ä¿®æ”¹ç« èŠ‚ç›®å½•çš„é—´è· */
.chapter li.chapter-item {
    /* æ²¡æœ‰æ–‡ä»¶æ—¶çš„æ–‡å­—é¢œè‰² */
    color: #939da3;
    margin-top: 1.5rem;
}

/* ä¿®æ”¹æ»šåŠ¨æ¡å®½åº¦ */
::-webkit-scrollbar {
    width: 5px;
    height: 5px;
}
::-webkit-scrollbar-thumb {
    background: #99ccff;
    border-radius: 3px;
}

/* è¡¨æ ¼é å·¦å¯¹é½ */
table {
    margin-left: 0 !important;
}

/* åªä½¿ç”¨åº•éƒ¨çš„é¡µé¢è·³è½¬ï¼Œå› ä¸ºå·¦å³ä¸¤è¾¹çš„å®½è·³è½¬ä¼šè¢« page-toc é®ç›– */
@media only screen and (max-width: 2560px) {
    .nav-wide-wrapper { display: none; }
    .nav-wrapper { 
        display: block;
        position: fixed;
        bottom: 50px;
        left: var(--page-padding);
        right: var(--page-padding); 
    }
}
@media only screen and (max-width: 2560px) {
    .sidebar-visible .nav-wide-wrapper { display: none; }
    .sidebar-visible .nav-wrapper { 
        display: block;
        left: calc(var(--sidebar-width) + var(--page-padding));
    }
}

.mobile-nav-chapters {
    width: 40px;
    font-size: 2.5rem
}

/* ä¿®æ”¹é¡¶éƒ¨å›¾æ ‡å¤§å° */
/* #menu-bar {
    font-size: 17px;
} */
/* ä¿®æ”¹ github æ ·å¼ */
.fa-github {
    font-weight: 550;
}
.fa-github:after{
    content: "ç¹æ˜Ÿç‚¹ç‚¹å°½åœ¨ä½ çš„æŒ‡å°– ğŸŒŸ";
    margin-left: 4px;
}

/* Fix on mobile device */
code {
    word-break: break-word;
}

/* ä¿®å¤å¯ç¼–è¾‘ä»£ç æ¡†é¡¶éƒ¨è¿‡çª„çš„é—®é¢˜ */
code.editable, .ace_scroller {
    top: 10px;
}

/* ä¿®æ”¹ä¹¦ä¾§è¾¹ç›®å½•çš„åŒºåŸŸåˆ†éš”è¡Œæ ·å¼ */

.chapter .spacer {
    background-color: #99CCFF;
    height: 2px;
    margin-top: 8px;
}

.chapter li .md-viewed {
    color: #777;
}



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches:
      - main

  pull_request:
    branches:
      - main

jobs:
  test:
    name: test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        run: |
          rustup set profile minimal
          rustup toolchain install stable
          rustup default stable
      - name: Setup mdBook
        uses: peaceiris/actions-mdbook@v2
        with:
          mdbook-version: "latest"
      - name: Run tests
        run: mdbook test



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy

on:
  push:
    branches:
      - main

  pull_request:
    branches:
      - main

defaults:
  run:
    shell: bash

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        run: |
          rustup set profile minimal
          rustup toolchain install stable
          rustup default stable
      - name: Setup mdBook
        uses: peaceiris/actions-mdbook@v2
        with:
          mdbook-version: "latest"
      - run: mdbook build
      - name: Copy Assets
        run: |
          chmod +x ci/copy-assets.sh
          ci/copy-assets.sh ${{ matrix.os }}
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        if: ${{ github.ref == 'refs/heads/main' }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./book


