What is a DTO in Java? What is the parallel in Rust?

"Hey, ever ordered a pizza online? The form you fill out with your name, address, and pizza toppings is basically a DTO!"

DTOs (Data Transfer Objects) are like delivery forms - they package up data to be sent between different parts of your program.

Structure of a DTO:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     PizzaOrderDTO       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Properties    â”‚    â”‚
â”‚  â”‚ name: String    â”‚    â”‚
â”‚  â”‚ address: String â”‚    â”‚
â”‚  â”‚ toppings: List  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Getters/Setters â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key Characteristics:
ğŸ”„ Plain objects with no business logic
ğŸ“¦ Just data containers
ğŸš¢ Used to transfer data between layers
ğŸ”’ Often immutable (especially in modern Java)


    // Start of Selection
    Why are DTOs important, why did we think of them from a language perspective?
    
    "Think of DTOs like a translator between two people speaking different languages - they help different parts of your code communicate!"
    
    Example:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Database Layer â”‚    â†’    â”‚     DTO      â”‚    â†’    â”‚     UI Layer    â”‚
    â”‚ (Speaks SQL)    â”‚         â”‚(Translator!) â”‚         â”‚(Speaks JSON)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Java DTO Example:
    ```java
    // PizzaOrderDTO.java
    public class PizzaOrderDTO {
        private String name;               // Customer name
        private String address;            // Delivery address
        private List<String> toppings;     // Selected toppings
    
        // Constructors
        public PizzaOrderDTO() {}
    
        public PizzaOrderDTO(String name, String address, List<String> toppings) {
            this.name = name;
            this.address = address;
            this.toppings = toppings;
        }
    
        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
    
        public String getAddress() { return address; }
        public void setAddress(String address) { this.address = address; }
    
        public List<String> getToppings() { return toppings; }
        public void setToppings(List<String> toppings) { this.toppings = toppings; }
    }
    ```
    
    Memory Layout:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     PizzaOrderDTO       â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
    â”‚  â”‚   Properties    â”‚    â”‚
    â”‚  â”‚ name: String    â”‚    â”‚
    â”‚  â”‚ address: String â”‚    â”‚
    â”‚  â”‚ toppings: List  â”‚    â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
    â”‚  â”‚ Getters/Setters â”‚    â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Key Points:
    ğŸ”„ Simplifies data transfer between layers
    ğŸ“¦ Encapsulates data without business logic
    ğŸš€ Enhances maintainability and scalability
    
    ğŸ’¡ Insight: DTOs decouple the internal data structures from external interfaces, promoting a cleaner architecture.
    
    Java to Rust Parallel:
    In Rust, the parallel to a DTO would be a struct used to serialize and deserialize data between layers, often using Serde.
    
    Rust DTO Example:
    ```rust
    // pizza_order_dto.rs
    use serde::{Serialize, Deserialize};
    
    #[derive(Serialize, Deserialize, Debug)]
    pub struct PizzaOrderDTO {
        pub name: String,
        pub address: String,
        pub toppings: Vec<String>,
    }
    
    fn main() {
        let order = PizzaOrderDTO {
            name: String::from("Alice"),
            address: String::from("123 Rust Lane"),
            toppings: vec![String::from("Pepperoni"), String::from("Mushrooms")],
        };
        
        // Serialize to JSON
        let json = serde_json::to_string(&order).unwrap();
        println!("Serialized DTO: {}", json);
        
        // Deserialize back to struct
        let deserialized: PizzaOrderDTO = serde_json::from_str(&json).unwrap();
        println!("Deserialized DTO: {:?}", deserialized);
    }
    ```
    
    Memory Layout:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   PizzaOrderDTO       â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚     Fields      â”‚  â”‚
    â”‚  â”‚ name: String    â”‚  â”‚
    â”‚  â”‚ address: String â”‚  â”‚
    â”‚  â”‚ toppings: Vec   â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    ğŸ’¡ Insight: Both Java and Rust use DTOs to facilitate data transfer, but Rust leverages its ownership system for memory safety and efficient data handling.
    
    ğŸ” Design Choice: Using DTOs enforces separation of concerns, ensuring that changes in one layer don't directly impact others.


Do we have special libraries for DTOs in Java and Rust?

// Start of Selection
Ever felt like you need a universal translator for your data? That's what specialized DTO libraries do!

### Java DTO Libraries

Ever felt like you need a universal translator for your data? That's what specialized DTO libraries do!

### Java DTO Libraries

**1. Lombok: Minimal Boilerplate**

```java
// Lombok reduces repetitive code
import lombok.Data;

@Data
public class UserDTO {
    private String name;  // ğŸ“ Customer name
    private int age;      // ğŸ“… Customer age
}

// Usage
UserDTO user = new UserDTO();
user.setName("Alice");   // ğŸ”„ Set name to Alice
user.setAge(30);         // ğŸ”„ Set age to 30
System.out.println(user); // ğŸ–¨ï¸ Print UserDTO{name='Alice', age=30}
```

- `@Data` annotation automatically generates getters, setters, `toString()`, `equals()`, and `hashCode()` methods.

**ELI15: Advanced Lombok with Builder Pattern**

```java
// Lombok's @Builder simplifies complex object creation
import lombok.Builder;
import lombok.ToString;

@Builder
@ToString
public class OrderDTO {
    private String orderId;     // ğŸ†” Unique Order ID
    private String product;     // ğŸ“¦ Product name
    private int quantity;       // ğŸ”¢ Quantity ordered
    private double price;       // ğŸ’² Price per unit
}

// Usage with Builder
public class Main {
    public static void main(String[] args) {
        OrderDTO order = OrderDTO.builder()
                                 .orderId("ORD123")
                                 .product("Laptop")
                                 .quantity(2)
                                 .price(1500.00)
                                 .build();
        System.out.println(order); // ğŸ–¨ï¸ OrderDTO(orderId=ORD123, product=Laptop, quantity=2, price=1500.0)
    }
}
```

- `@Builder` annotation enables the builder pattern, making it easier to create instances of classes with multiple fields.
- `@ToString` provides a readable `toString()` implementation for easy debugging and logging.

ğŸ’¡ **Insight:** Using Lombok's builder pattern enhances code readability and maintainability, especially when dealing with classes that have numerous fields or optional parameters.

ğŸ” **Design Choice:** The builder pattern separates the construction of an object from its representation, allowing for more flexible and readable object creation without boilerplate code.

**2. MapStruct: Type-Safe Mappers**

```java
// MapStruct generates mapper implementations
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

@Mapper
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);
    
    UserDTO toDTO(User user);
    User toEntity(UserDTO dto);
}

// Usage
User user = new User("Alice", 30);
UserDTO dto = UserMapper.INSTANCE.toDTO(user);
System.out.println(dto);
```

- Automatically maps between entity and DTO classes with type safety.

### Rust DTO Libraries

**1. Serde: Serialization & Deserialization**

```rust
// Serde enables easy serialization
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct UserDTO {
    pub name: String,
    pub age: u32,
}

fn main() {
    let user = UserDTO {
        name: String::from("Alice"),
        age: 30,
    };
    
    // Serialize to JSON
    let json = serde_json::to_string(&user).unwrap();
    println!("Serialized DTO: {}", json);
    
    // Deserialize back to struct
    let deserialized: UserDTO = serde_json::from_str(&json).unwrap();
    println!("Deserialized DTO: {:?}", deserialized);
}
```

**2. Diesel: ORM with DTO Support**

```rust
// Diesel integrates ORM with DTOs
use diesel::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Queryable, Serialize, Deserialize)]
pub struct UserDTO {
    pub id: i32,
    pub name: String,
    pub age: i32,
}

// Assuming a users table exists
fn get_user(connection: &PgConnection, user_id: i32) -> UserDTO {
    use crate::schema::users::dsl::*;
    
    users.filter(id.eq(user_id))
         .first::<UserDTO>(connection)
         .expect("Error loading user")
}
```

ğŸ’¡ **Insight:** Java and Rust utilize these libraries to simplify data transfer between different layers, ensuring data consistency and reducing boilerplate code.

ğŸ” **Design Choice:** These libraries enforce a clear separation of concerns, allowing developers to focus on business logic while handling data serialization and mapping efficiently.
